<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>渡口一艘船</title>
  
  <subtitle>不积跬步，无以至千里；不积小流，无以成江海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xsfelvis.github.io/"/>
  <updated>2018-10-14T06:08:06.035Z</updated>
  <id>https://xsfelvis.github.io/</id>
  
  <author>
    <name>云来</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>上传Jcenter</title>
    <link href="https://xsfelvis.github.io/2018/10/11/Jcenter/"/>
    <id>https://xsfelvis.github.io/2018/10/11/Jcenter/</id>
    <published>2018-10-10T16:00:00.000Z</published>
    <updated>2018-10-14T06:08:06.035Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>Jcenter提供了一个方便使用自己开源库的一个平台 在Android中使用 complie引用即可，目前很多文章都是通过<code>gradle-bintray-plugin</code>这个插件，不过<code>bintray-release</code>这个插件更加人性化，本篇将记录使用这个插件如何上传到Jcenter上</p><h1 id="0x01-注册bintray-com账号"><a href="#0x01-注册bintray-com账号" class="headerlink" title="0x01 注册bintray.com账号"></a>0x01 注册bintray.com账号</h1><ul><li>Step 1</li></ul><p>官网注册账号 <a href="https://bintray.com，切记点击右边的For" target="_blank" rel="noopener">https://bintray.com，切记点击右边的For</a> an Open Source Account，个人版本<br>(企业版 加入或者创建组织才可以建立自己的仓库，比较麻烦)</p><p><img src="https://upload-images.jianshu.io/upload_images/6968064-d2afdefd754a26a2.png" alt="注册"></p><ul><li>Step 2</li></ul><p>注册完之后 进入 Edit profile 查看自己的APIKey，这是上传时候需要用到</p><h1 id="0x02-项目配置"><a href="#0x02-项目配置" class="headerlink" title="0x02 项目配置"></a>0x02 项目配置</h1><ul><li>根gradle</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &apos;com.android.tools.build:gradle:2.3.1&apos;</span><br><span class="line"></span><br><span class="line">        classpath &apos;com.novoda:bintray-release:0.8.0&apos;//添加</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        maven&#123;url &quot;https://jitpack.io&quot;&#125;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    tasks.withType(Javadoc) &#123;</span><br><span class="line">        options.addStringOption(&apos;Xdoclint:none&apos;, &apos;-quiet&apos;)</span><br><span class="line">        options.addStringOption(&apos;encoding&apos;, &apos;UTF-8&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">task clean(type: Delete) &#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//统一声明配置</span><br><span class="line">ext &#123;</span><br><span class="line">    userOrg = &apos;androidxsf&apos; //bintray.com用户名 </span><br><span class="line">    groupId = &apos;com.xsfdev&apos; //jcenter上的路径</span><br><span class="line">    uploadName = &apos;android-basiclib-apifactory&apos;</span><br><span class="line">    publishVersion = &apos;1.0.0&apos; //版本号</span><br><span class="line">    desc = &apos;Request code can be generated automatically&apos; //描述</span><br><span class="line">    website = &apos;https://github.com/HouXiaohu/androidbasiclib&apos; //网站，不重要；尽量模拟github上的地址</span><br><span class="line">    licences = [&apos;Apache-2.0&apos;] //开源协议</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需要上传的各个Module中引入</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apply plugin: &apos;com.novoda.bintray-release&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//添加</span><br><span class="line">publish &#123;</span><br><span class="line">    artifactId = &apos;complexcriptdsl&apos;</span><br><span class="line">    userOrg = rootProject.userOrg</span><br><span class="line">    groupId = rootProject.groupId</span><br><span class="line">    uploadName = rootProject.uploadName</span><br><span class="line">    publishVersion = rootProject.publishVersion</span><br><span class="line">    desc = rootProject.description</span><br><span class="line">    website = rootProject.website</span><br><span class="line">    licences = rootProject.licences</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x03-执行上传"><a href="#0x03-执行上传" class="headerlink" title="0x03 执行上传"></a>0x03 执行上传</h1><p><code>./gradlew bintrayUpload -PbintrayUser = androidxsf(你的用户名) -PbintrayKey = 1f8b6d3da641fe0f34d531c1811774c***(你的APIKey) -PdryRun = false</code></p><p>此时可以看到我们上传的项目了,你可以点击进去看该库的一些信息，但是注意此时还不能够直接被引用。</p><p>点击进去该库，按照下图，点击Add To jcenter</p><h1 id="0x04-其他"><a href="#0x04-其他" class="headerlink" title="0x04 其他"></a>0x04 其他</h1><p>你需要等待bintray的工作人员审核，审核通过会给你发送站内Message，并且Add to Jcenter那个按钮就小时了，此外你还可以根据你上传的groupId,访问该网站<code>https://jcenter.bintray.com/</code>你的groupId例如<code>https://jcenter.bintray.com/com/com.xsfdev/</code></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后总结下整个过程，其实非常简单：</p><ul><li>申请账号</li><li>引入bintray-release，在需要上传的module里面填写相关publish的信息</li><li>调用上传的命令</li><li>Add to Jcenter提交审核</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="工具" scheme="https://xsfelvis.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Jcenter" scheme="https://xsfelvis.github.io/tags/Jcenter/"/>
    
  </entry>
  
  <entry>
    <title>Spi的基本使用</title>
    <link href="https://xsfelvis.github.io/2018/06/11/spi/"/>
    <id>https://xsfelvis.github.io/2018/06/11/spi/</id>
    <published>2018-06-10T16:00:00.000Z</published>
    <updated>2018-06-11T11:20:15.907Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>什么是spi</li></ul><p>SPI （Service Provider Interface）属于<code>动态加载接口实现类</code>的的一项技术，是JDK内置的一种服务提供发现机制，使用ServiceLoader去加载接口对应的实现，这样我们就不用关注实现类，ServiceLoader会告诉我们。<a href="https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html" target="_blank" rel="noopener">官方文档</a>描述为：<code>为某个接口寻找服务的机制,类似IOC思想，将装配的控制权交给ServiceLoader。</code></p><ul><li>解决问题</li></ul><p>只提供服务接口，具体服务由其他组件实现，接口和具体实现分离（类似桥接），同时能够<code>通过系统的ServiceLoader</code>拿到这些实现类的集合，统一处理，这样在组件化中往往会带来很多便利，SPI机制可以实现不同模块之间方便的面向接口编程，拒绝了硬编码的方式，解耦效果很好</p><blockquote><p>即相当于制定标准，然后不同实现方用不同的方式实现标准供使用方使用,并且可以动态加载</p></blockquote><h1 id="在Android中如何使用"><a href="#在Android中如何使用" class="headerlink" title="在Android中如何使用"></a>在Android中如何使用</h1><p>上面说的可能比较抽象，下面将结合例子说明下在Android中的运用。</p><p>这种机制在使用起来也比较简单,使用步骤如下：</p><ul><li><p>定义接口和接口的实现类</p></li><li><p>创建resources/META-INF/services目录</p></li><li><p>在上述Service目录下，创建一个以接口名(类的全名) 命名的文件, 其内容是实现类的类名 (类的全名)。</p></li></ul><blockquote><p>在services目录下创建的文件是com.binglumeng.spidemo.IService 文件中的内容为Animal接口的实现类, 可能是com.binglumeng.spidemo.AService</p></blockquote><ul><li>在java代码中使用ServcieLoader来动态加载并调用内部方法.</li></ul><p>主工程和组件之间一些“服务”的配置</p><p><img src="http://p927u2n0k.bkt.clouddn.com/spiblog-%20%E6%A8%A1%E5%9D%97%E4%BE%9D%E8%B5%96.png" alt="示意图"></p><h2 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDisplay</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主工程和bdisplay 模块中的实现该接口</p><h2 id="创建spi描述文件"><a href="#创建spi描述文件" class="headerlink" title="创建spi描述文件"></a>创建spi描述文件</h2><p>在工程的main目录下新建目录resources/META-INF/services，<code>以服务接口名为文件名新建spi描述文件，内容为具体的服务实现类权限定名，可以有多个</code></p><p>文件结构如下</p><p><img src="http://p927u2n0k.bkt.clouddn.com/1528702141671.jpg" alt="文件结构"></p><h2 id="加载不同服务"><a href="#加载不同服务" class="headerlink" title="加载不同服务"></a>加载不同服务</h2><p>通过ServiceLoader来加载接口的不同实现类，然后会得到迭代器，在迭代器中可以拿到不同实现类全限定名，然后通过反射动态加载实例就可以调用display方法了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;Display&gt; loader = ServiceLoader.load(IDisplay.class);</span><br><span class="line">mIterator =loader.iterator(); </span><br><span class="line"><span class="keyword">while</span>(mIterator.hasNext())&#123;</span><br><span class="line">    mIterator.next().display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>感觉有点很神奇</p><blockquote><p>ServiceLoader<display> loader = ServiceLoader.load(Display.class);</display></p></blockquote><p>就可以拿到<code>Display.class</code>接口的所有实现类了, amazing！(感觉这里跟Retrift使用有点类似)下面来分析一下这个背后到底隐藏了什么</p><p>核心类 <code>ServiceLoader.java</code></p><p><img src="http://p927u2n0k.bkt.clouddn.com/Blog-ServiceLoader.png" alt="ServiceLoader"></p><p>先看下几个重要的成员变量</p><ul><li>PREFIX就是配置文件所在的包目录路径；</li><li>service就是接口名称，在我们这个例子中就是Display；</li><li>loader就是类加载器，其实最终都是通过反射加载实例；</li><li>providers就是不同实现类的缓存，key就是实现类的全限定名，value就是实现类的实例</li><li>lookupIterator就是内部类LazyIterator的实例。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">"META-INF/services/"</span>; </span><br><span class="line"><span class="comment">// The class or interface representing the service being loaded </span></span><br><span class="line"><span class="keyword">private</span> Class&lt;S&gt; service; </span><br><span class="line"><span class="comment">// The class loader used to locate, load, and instantiate providers </span></span><br><span class="line"><span class="keyword">private</span> ClassLoader loader; </span><br><span class="line"><span class="comment">// Cached providers, in instantiation order </span></span><br><span class="line"><span class="keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(); </span><br><span class="line"><span class="comment">// The current lazy-lookup iterator </span></span><br><span class="line"><span class="keyword">private</span> LazyIterator lookupIterator;</span><br></pre></td></tr></table></figure><p>之前spi加载的三个关键步骤</p><ul><li>ServiceLoader<display> loader = ServiceLoader.load(IDisplay.class);</display></li><li>mIterator =loader.iterator(); </li><li>while(mIterator.hasNext()){<br>  mIterator.next().display();<br>}</li></ul><h2 id="获取实现接口集合"><a href="#获取实现接口集合" class="headerlink" title="获取实现接口集合"></a>获取实现接口集合</h2><p>ServiceLoader提供了两个静态的load方法,如果我们没有传入类加载器，ServiceLoader会自动为我们获得一个当前线程的类加载器，最终都是调用构造函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">    ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            ClassLoader loader)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceLoader&lt;&gt;(service, loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数中有一个重要的函数<code>reload</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    providers.clear();</span><br><span class="line">    lookupIterator = <span class="keyword">new</span> LazyIterator(service, loader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LazyIterator</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.service = service;</span><br><span class="line">    <span class="keyword">this</span>.loader = loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以看到当我们load class之后并没有得到什么实现类，那么在何时加载的呢？</p><h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>那么service provider在什么地方进行加载？我们接着看第二个步骤loader.iterator(),</p><ul><li>首先会到providers中去查找有没有存在的实例，有就直接返回，没有再到LazyIterator中查找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;S&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;S&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders</span><br><span class="line">            = providers.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> lookupIterator.hasNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                <span class="keyword">return</span> knownProviders.next().getValue();</span><br><span class="line">            <span class="keyword">return</span> lookupIterator.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是返回一个迭代器。我们看下官方文档的解释,这个就是懒加载实现的地方，<br>焦点聚焦在<code>LazyIterator</code>上</p><ul><li>hasNext()</li></ul><ol><li>首先拿到配置文件名fullName,我们这个例子中是com.example.Display</li><li>通过类加载器获得所有模块的配置文件Enumeration<url> configs configs</url></li><li>依次扫描每个配置文件的内容，返回配置文件内容Iterator<string> pending，每个配置文件中可能有多个实现类的全限定名，所以pending也是个迭代器。</string></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//首先拿到配置文件名fullName</span></span><br><span class="line">            String fullName = PREFIX + service.getName();</span><br><span class="line">            <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">            configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                configs = loader.getResources(fullName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        fail(service, <span class="string">"Error locating configuration files"</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依次扫描每个配置文件的内容，返回配置文件内容Iterator&lt;String&gt; pending</span></span><br><span class="line">        pending = parse(service, configs.nextElement());</span><br><span class="line">    &#125;</span><br><span class="line">    nextName = pending.next();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips</p></blockquote><p>关于 ClassLoader.getSystemResources(fullName)可以查阅</p><ul><li><a href="http://zyjustin9.iteye.com/blog/2022654" target="_blank" rel="noopener">Java目录总结（七.路径的获取二——ClassLoader的使用）</a></li><li><a href="https://blog.csdn.net/walkerjong/article/details/13019671" target="_blank" rel="noopener">Class.getResource() 和 ClassLoader.getResource() 的区别</a></li></ul><ul><li>next()</li></ul><p>在上面hasNext()方法中拿到的nextName就是实现类的全限定名，接下来我们去看看具体实例化工作的地方next():</p><ul><li>1.首先根据nextName，Class.forName加载拿到具体实现类的class对象</li><li>2.Class.newInstance()实例化拿到具体实现类的实例对象</li><li>3.将实例对象转换service.cast为接口</li><li>4.将实例对象放到缓存中，providers.put(cn, p)，key就是实现类的全限定名，value是实例对象。</li><li>5.返回实例对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasNext()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    String cn = nextName;</span><br><span class="line">    nextName = <span class="keyword">null</span>;</span><br><span class="line">    Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//首先根据nextName，Class.forName加载拿到具体实现类的class对象</span></span><br><span class="line">        c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">"Provider "</span> + cn + <span class="string">" not found"</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">        ClassCastException cce = <span class="keyword">new</span> ClassCastException(</span><br><span class="line">                service.getCanonicalName() + <span class="string">" is not assignable from "</span> + c.getCanonicalName());</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">"Provider "</span> + cn  + <span class="string">" not a subtype"</span>, cce);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//将实例对象转换service.cast为接口</span></span><br><span class="line">        S p = service.cast(c.newInstance());</span><br><span class="line">        <span class="comment">//将实例对象放到缓存中，providers.put(cn, p)，key就是实现类的全限定名，value是实例对象</span></span><br><span class="line">        providers.put(cn, p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">        <span class="string">"Provider "</span> + cn + <span class="string">" could not be instantiated: "</span> + x, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error();          <span class="comment">// This cannot happen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Spi的优缺点</p><ul><li>优点</li></ul><p>只提供服务接口，具体服务由其他组件实现，接口和具体实现分离，同时能够通过系统的ServiceLoader拿到这些实现类的集合，统一处理。</p><ul><li>缺点</li></ul><ol><li>Java中SPI是随jar发布的，每个不同的jar都可以包含一系列的SPI配置，而Android平台上，应用在构建的时候最终会将所有的jar合并，这样很容易造成相同的SPI冲突，常见的问题是DuplicatedZipEntryException异常</li><li>读取SPI配置信息是在运行时从jar包中读取，由于apk是签过名的，在从jar中读取的时候，签名校验的耗时问题会造成性能损失</li></ol><h1 id="后续可以改进的点"><a href="#后续可以改进的点" class="headerlink" title="后续可以改进的点"></a>后续可以改进的点</h1><p>Java中使用ServiceLoader去读取SPI配置信息是在程序运行时，我们可以将这个读取配置信息提前，在编译时候就搞定，通过gradle插件，去扫描class文件，找到具体的服务类（可以通过标注来确定），然后生成新的java文件，这个文件中包含了具体的实现类。这样程序在运行时，就已经知道了所有的具体服务类，缺点就是编译时间会加长，自己需要重新写一套读取SPI信息、生成java文件等逻辑。</p><p>经过优化后，SPI已经偏离了原本的初衷，但是可以做更多的事，可以将业务服务分离，通过SPI找到业务服务入口，业务组件化，抽成单独的aar，独立成工程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;什么是spi&lt;/li&gt;
&lt;/
      
    
    </summary>
    
      <category term="spi" scheme="https://xsfelvis.github.io/categories/spi/"/>
    
    
      <category term="spi" scheme="https://xsfelvis.github.io/tags/spi/"/>
    
  </entry>
  
  <entry>
    <title>Gradle学习之基本原理</title>
    <link href="https://xsfelvis.github.io/2018/06/10/Gradle%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>https://xsfelvis.github.io/2018/06/10/Gradle基本原理/</id>
    <published>2018-06-09T16:00:00.000Z</published>
    <updated>2018-06-10T12:18:25.403Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Gradle是一个基于JVM的构建工具，目前Android Studio中建立的工程都是基于gradle进行构建的，Gradle框架是使用Groovy语言实现的，关于Groovy语言的学习将不再赘述可以参考(<a href="https://www.ibm.com/developerworks/cn/education/java/j-groovy/j-groovy.html" target="_blank" rel="noopener">精通Groovy</a>),目前很多技术领域开始使用Gradle的plugin，比如模块化、热修复、SPI的优化等等。</p><h1 id="两个最重要的概念-Projetc和Tasks"><a href="#两个最重要的概念-Projetc和Tasks" class="headerlink" title="两个最重要的概念 Projetc和Tasks"></a>两个最重要的概念 Projetc和Tasks</h1><p>这是Gradle中最重要的两个概念,每次构建至少由一个project构成，一个project由一到多个task构成。<code>项目结构中的每个build.gradle文件代表一个project</code>，在这编译脚本文件中可以定义一系列的task；task 本质上又是由一组被顺序执行的<code>Action</code>对象构成，Action其实是一段代码块，类似于Java中的方法。</p><h1 id="Gradle-构建生命周期"><a href="#Gradle-构建生命周期" class="headerlink" title="Gradle 构建生命周期"></a>Gradle 构建生命周期</h1><h2 id="三个阶段"><a href="#三个阶段" class="headerlink" title="三个阶段"></a>三个阶段</h2><p>每次构建的执行本质上是执行一系列的task，并且某些task还需要依赖其他task，这些task的依赖关系都是在构建阶段确定的。每次构建分为3个阶段(<a href="https://docs.gradle.org/current/userguide/build_lifecycle.html#sec:build_phases" target="_blank" rel="noopener">Build phases 文档 </a>)</p><ul><li>Initialization: 初始化阶段</li></ul><p>这是创建Project阶段，构建工具根据每个build.gradle文件创建出一个Project实例。初始化阶段会执行项目根目录下的settings.gradle文件，来分析哪些项目参与构建。</p><ul><li>Configuration:配置阶段</li></ul><p>这个阶段，通过执行构建脚本来为每个project创建并配置Task。配置阶段会去加载所有参与构建的项目的build.gradle文件，会将每个build.gradle文件实例化为一个Gradle的project对象。然后分析project之间的依赖关系，下载依赖文件，分析project下的task之间的依赖关系。</p><ul><li>Execution:执行阶段</li></ul><p>这是Task真正被执行的阶段，Gradle会根据依赖关系决定哪些Task需要被执行，以及执行的先后顺序。task是Gradle中的最小执行单元，我们所有的构建，编译，打包，debug，test等都是执行了某一个task，一个project可以有多个task，task之间可以互相依赖。例如我有两个task，taskA和taskB，指定taskA依赖taskB，然后执行taskA，这时会先去执行taskB，taskB执行完毕后在执行taskA。在AS右侧的Gradle按钮中可以看到这一些列的task</p><h2 id="监听生命周期"><a href="#监听生命周期" class="headerlink" title="监听生命周期"></a>监听生命周期</h2><p>在gradle的构建过程中，gradle为我们提供了钩子，帮助我们针对项目的需求定制构建的逻辑，如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/19/163781a2edc24703?imageslim" alt="监听生命周期"></p><p>要监听这些生命周期，主要有两种方式：</p><ul><li>添加监听器</li><li>使用钩子的配置块</li></ul><p>关于可用的钩子可以参考Gradle和Project中的定义，常用的钩子包括：</p><blockquote><p>Gradle</p></blockquote><ul><li>beforeProject()/afterProject()<br>等同于Project中的beforeEvaluate和afterEvaluate</li></ul><ul><li>settingsEvaluated()<br>settings脚本被执行完毕，Settings对象配置完毕</li></ul><ul><li>projectsLoaded()<br>所有参与构建的项目都从settings中创建完毕</li></ul><ul><li>projectsEvaluated()<br>所有参与构建的项目都已经被评估完</li></ul><blockquote><p>TaskExecutionGraph</p></blockquote><ul><li>whenReady（）<br>task图生成。所有需要被执行的task已经task之间的依赖关系都已经确立</li></ul><blockquote><p>Project</p></blockquote><ul><li>beforeEvaluate（）</li><li>afterEvaluate（）</li></ul><h1 id="三个重要的gradle文件"><a href="#三个重要的gradle文件" class="headerlink" title="三个重要的gradle文件"></a>三个重要的gradle文件</h1><p>Gradle项目有3个重要的文件需要深入理解：</p><ul><li>项目根目录的 build.gradle </li></ul><p>项目根目录的 build.gradle 文件用来配置针对所有模块的一些属性。它默认包含2个代码块：buildscript{…}和allprojects{…}。前者用于配置构建脚本所用到的代码库和依赖关系，后者用于定义所有模块需要用到的一些公共属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:2.3.2'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">clean</span><span class="params">(type: Delete)</span> </span>&#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>settings.gradle </li></ul><p>settings.gradle 文件会在构建的 initialization 阶段被执行，它用于告诉构建系统哪些模块需要包含到构建过程中。对于单模块项目， settings.gradle 文件不是必需的。对于多模块项目，如果没有该文件，构建系统就不能知道该用到哪些模块。</p><ul><li>模块目录的 build.gradle</li></ul><p>模块级配置文件 build.gradle 针对每个moudle 的配置，如果这里的定义的选项和顶层 build.gradle定义的相同。它有3个重要的代码块：plugin，android 和 dependencies。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.csdn.net/zhaoyanjun6/article/details/77678577#android-gradle-%E7%9A%84-project-%E5%92%8C-tasks" target="_blank" rel="noopener">https://blog.csdn.net/zhaoyanjun6/article/details/77678577#android-gradle-%E7%9A%84-project-%E5%92%8C-tasks</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Gradle是一个基于JVM的构建工具，
      
    
    </summary>
    
      <category term="Gradle" scheme="https://xsfelvis.github.io/categories/Gradle/"/>
    
    
      <category term="Gradle" scheme="https://xsfelvis.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Gradle在Android中的常用点</title>
    <link href="https://xsfelvis.github.io/2018/06/10/Gradle%E5%9C%A8Android%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%82%B9/"/>
    <id>https://xsfelvis.github.io/2018/06/10/Gradle在Android中常用点/</id>
    <published>2018-06-09T16:00:00.000Z</published>
    <updated>2018-06-10T14:25:59.220Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本篇主要介绍Gradle在Android开发中的一些常用的技巧</p><h1 id="设置编译类型"><a href="#设置编译类型" class="headerlink" title="设置编译类型"></a>设置编译类型</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android&#123;</span><br><span class="line"></span><br><span class="line">  buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">true</span>  <span class="comment">//打开混淆</span></span><br><span class="line">            <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        debug </span>&#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span> <span class="comment">//关闭混淆</span></span><br><span class="line">            <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"> &#125;</span></span><br></pre></td></tr></table></figure><p>通常我们需要给QA打出一个带调试功能的release包，这时就可以在这个里面加上新的type</p><h1 id="productFlavors-多渠道打包"><a href="#productFlavors-多渠道打包" class="headerlink" title="productFlavors 多渠道打包"></a>productFlavors 多渠道打包</h1><p>AndroidManifest.xml 里设置动态渠道变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;meta-data</span><br><span class="line">android:name=<span class="string">"UMENG_CHANNEL"</span></span><br><span class="line">android:value=<span class="string">"$&#123;UMENG_CHANNEL_VALUE&#125;"</span>/&gt;</span><br></pre></td></tr></table></figure><p>在 build.gradle 设置 productFlavors , 这里假定我们需要打包的渠道为酷安市场、360、小米、百度、豌豆荚。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">android &#123;  </span><br><span class="line"></span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        kuan &#123;</span><br><span class="line">            manifestPlaceholders = [UMENG_CHANNEL_VALUE: <span class="string">"kuan"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        xiaomi &#123;</span><br><span class="line">            manifestPlaceholders = [UMENG_CHANNEL_VALUE: <span class="string">"xiaomi"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        qh360 &#123;</span><br><span class="line">            manifestPlaceholders = [UMENG_CHANNEL_VALUE: <span class="string">"qh360"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        baidu &#123;</span><br><span class="line">            manifestPlaceholders = [UMENG_CHANNEL_VALUE: <span class="string">"baidu"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        wandoujia &#123;</span><br><span class="line">            manifestPlaceholders = [UMENG_CHANNEL_VALUE: <span class="string">"wandoujia"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者批量修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android &#123;  </span><br><span class="line"></span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        kuan &#123;&#125;</span><br><span class="line">        xiaomi &#123;&#125;</span><br><span class="line">        qh360 &#123;&#125;</span><br><span class="line">        baidu &#123;&#125;</span><br><span class="line">        wandoujia &#123;&#125;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    productFlavors.all &#123; </span><br><span class="line">        flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name] </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多渠道设置包名"><a href="#多渠道设置包名" class="headerlink" title="多渠道设置包名"></a>多渠道设置包名</h1><p>有时候我们需要分渠道设置 applicationId 、友盟的 appkey 、友盟渠道号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">productFlavors &#123;</span><br><span class="line">        google &#123;</span><br><span class="line">            applicationId <span class="string">"com.wifi.cool"</span></span><br><span class="line">            manifestPlaceholders = [                </span><br><span class="line">                    UMENG_APPKEY_VALUE : <span class="string">"456789456789"</span>,</span><br><span class="line">                    UMENG_CHANNEL_VALUE: <span class="string">"google"</span>,            </span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        baidu&#123;</span><br><span class="line">            applicationId <span class="string">'com.wifi.hacker'</span></span><br><span class="line">            manifestPlaceholders = [</span><br><span class="line">                    UMENG_APPKEY_VALUE     : <span class="string">"123456789789"</span>,</span><br><span class="line">                    UMENG_CHANNEL_VALUE    : <span class="string">"baidu"</span>,          </span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="Signing-签名"><a href="#Signing-签名" class="headerlink" title="Signing 签名"></a>Signing 签名</h1><p>在 android 标签下添加 signingConfigs 标签，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        config &#123;</span><br><span class="line">            keyAlias <span class="string">'yiba'</span></span><br><span class="line">            keyPassword <span class="string">'123456'</span></span><br><span class="line">            <span class="function">storeFile <span class="title">file</span><span class="params">(<span class="string">'C:/work/Key.jks'</span>)</span></span></span><br><span class="line"><span class="function">            storePassword '1234567'</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"> &#125;</span></span><br></pre></td></tr></table></figure><p>可以在release 和 debug包中定义签名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        config &#123;</span><br><span class="line">            keyAlias <span class="string">'yiba'</span></span><br><span class="line">            keyPassword <span class="string">'123456'</span></span><br><span class="line">            <span class="function">storeFile <span class="title">file</span><span class="params">(<span class="string">'C:/work/Key.jks'</span>)</span></span></span><br><span class="line"><span class="function">            storePassword '1234567'</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    buildTypes </span>&#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class="line"><span class="function">            signingConfig signingConfigs.config</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        debug </span>&#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class="line"><span class="function">            signingConfig signingConfigs.config</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h1><h2 id="依赖jar包"><a href="#依赖jar包" class="headerlink" title="依赖jar包"></a>依赖jar包</h2><ul><li>1、把 jar 包放在 libs 目录下</li><li>2、在 build.gradle 中添加依赖</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">   <span class="function">compile <span class="title">files</span><span class="params">(<span class="string">'libs/xxx.jar'</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="依赖aar"><a href="#依赖aar" class="headerlink" title="依赖aar"></a>依赖aar</h2><ul><li>1、把 aar 包放到 libs 目录下</li><li>2、在 build.gradle 中添加依赖</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    flatDir &#123;</span><br><span class="line">        dirs <span class="string">'libs'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile(name:<span class="string">'YibaAnalytics-release'</span>, ext:<span class="string">'aar'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要是aar需要被多个module依赖时候，我们可以在项目的根目录创建一个目录，比如叫 aar 目录，然后把我们的 aar 包放进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> flatDir &#123;</span><br><span class="line">     dirs <span class="string">'../aar'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排除依赖兼容包"><a href="#排除依赖兼容包" class="headerlink" title="排除依赖兼容包"></a>排除依赖兼容包</h2><p>有的时候，我们所依赖的项目/模块会引入多个传递性依赖。而其中部分的传递性依赖我们是不需要的，这时候可以使用exclude排除部分的传递性依赖，如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compile(<span class="string">'com.google.firebase:firebase-ads:11.0.4'</span>, &#123;</span><br><span class="line">      exclude group: <span class="string">'com.android.support'</span>   <span class="comment">//排除v7 , v4 包</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="强制使用指定的依赖版本"><a href="#强制使用指定的依赖版本" class="headerlink" title="强制使用指定的依赖版本"></a>强制使用指定的依赖版本</h2><p>Gradle通过选择依赖关系图中找到的最新版本来解决任何依赖版本冲突。 可是有的时候，某些项目会需要使用一个较老的版本号作为依赖。这时候我们可以强制指定某一个版本。例如：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">'org.apache.httpcomponents:httpclient:4.5.4'</span></span><br><span class="line">    <span class="comment">// 假设commons-codec的最新版本是1.10</span></span><br><span class="line">    implementation(<span class="string">'commons-codec:commons-codec:1.9'</span>) &#123;</span><br><span class="line">        force = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="禁止传递性依赖"><a href="#禁止传递性依赖" class="headerlink" title="禁止传递性依赖"></a>禁止传递性依赖</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation(<span class="string">'com.google.guava:guava:23.0'</span>) &#123;</span><br><span class="line">        transitive = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码依赖"><a href="#源码依赖" class="headerlink" title="源码依赖"></a>源码依赖</h2><p>要是我们自己工程下的module直接依赖进来即可，有时候需要从别的路径下依赖module源码</p><ul><li>1、将对应的库的源码down下来，记录下放置的路径</li><li>2、在setting.gradle文件中，进行库的源码引入 (这里以项目外同级目录)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//新增依赖</span></span><br><span class="line">include <span class="string">':outmodule'</span></span><br><span class="line">project(<span class="string">':outmodule'</span>).projectDir = <span class="keyword">new</span> File(settingsDir, <span class="string">'../Sdk/Sdk-Android/product/outmodule'</span>)</span><br></pre></td></tr></table></figure><p>Tips：</p><p>若是主工程使用了Flavor这里也要使用对应的Flavor</p><h2 id="全局统一信息配置"><a href="#全局统一信息配置" class="headerlink" title="全局统一信息配置"></a>全局统一信息配置</h2><p>有时候多个moudle需要依赖不同的版本，有时候就会出现一些编译异常，而且零散的版本号也是不好管理的，如：compileSdkVersion、buildToolsVersion、androidTestCompile 等。</p><h3 id="分类属性配置"><a href="#分类属性配置" class="headerlink" title="分类属性配置"></a>分类属性配置</h3><ul><li>在项目的根目录创建一个gradle配置文件config.gradle，项目中所有的依赖只要在这个文件中统一配置即可。格式如下(内容根据需要进行修改)：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">    </span><br><span class="line">    compileSdkVersion: <span class="number">24</span>,</span><br><span class="line">    buildToolsVersion: <span class="string">"24.0.2"</span>,</span><br><span class="line">    applicationId    : <span class="string">"com.carme.carmerchant"</span>,</span><br><span class="line">    minSdkVersion    : <span class="number">15</span>,</span><br><span class="line">    targetSdkVersion : <span class="number">22</span>,</span><br><span class="line">    versionCode      : <span class="number">3</span>,</span><br><span class="line">    versionName      : <span class="string">"1.0.3"</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    dependencies = [</span><br><span class="line">            <span class="string">"test"</span>                  : <span class="string">"junit:junit:4.12"</span>,</span><br><span class="line">            <span class="string">"appcompat-v7"</span>          : <span class="string">"com.android.support:appcompat-v7:25.0.0"</span>,</span><br><span class="line">            <span class="string">"support-v4"</span>            : <span class="string">"com.android.support:support-v4:25.0.0"</span>,</span><br><span class="line">            <span class="string">"support_design"</span>        : <span class="string">"com.android.support:design:25.0.0"</span>,</span><br><span class="line">            <span class="string">"rxjava"</span>                : <span class="string">"io.reactivex:rxjava:1.2.0"</span>,</span><br><span class="line">            <span class="string">"rxandroid"</span>             : <span class="string">"io.reactivex:rxandroid:1.2.1"</span>,</span><br><span class="line">            <span class="string">"retrofit"</span>              : <span class="string">"com.squareup.retrofit2:retrofit:2.1.0"</span>,</span><br><span class="line">            <span class="string">"converter-gson"</span>        : <span class="string">"com.squareup.retrofit2:converter-gson:2.1.0"</span>,</span><br><span class="line">            <span class="string">"adapter-rxjava"</span>        : <span class="string">"com.squareup.retrofit2:adapter-rxjava:2.1.0"</span>,</span><br><span class="line">            <span class="string">"multidex"</span>              : <span class="string">"com.android.support:multidex:1.0.1"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其次在根目录的build.gradle文件中添加内容（apply from:”config.gradle”），所有的module都可以从这个（config.gradle）配置文件里读取公共参数。</li><li>在各个module目录下的build.gradle文件中使用如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android &#123;  </span><br><span class="line">      compileSdkVersion rootProject .ext.android.compileSdkVersion</span><br><span class="line">      buildToolsVersion rootProject .ext.android.buildToolsVersion</span><br><span class="line">      defaultConfig &#123;</span><br><span class="line">          applicationId rootProject .ext.android.applicationId</span><br><span class="line">          minSdkVersion rootProject .ext.android.minSdkVersion</span><br><span class="line">          targetSdkVersion rootProject .ext.android.targetSdkVersion</span><br><span class="line">          versionCode rootProject .ext.android.versionCode</span><br><span class="line">          versionName rootProject .ext.android.versionName</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      &#125;  </span><br><span class="line">      dependencies &#123;</span><br><span class="line">          ...</span><br><span class="line">          compile rootProject .ext.dependencies[ <span class="string">"design"</span>]</span><br><span class="line">          compile rootProject .ext.dependencies[ <span class="string">"appcompat-v7"</span>]</span><br><span class="line">          compile rootProject .ext.dependencies[ <span class="string">"recyclerview-v7"</span>]</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h1 id="依赖关系解析"><a href="#依赖关系解析" class="headerlink" title="依赖关系解析"></a>依赖关系解析</h1><h2 id="使用依赖关系解析规则"><a href="#使用依赖关系解析规则" class="headerlink" title="使用依赖关系解析规则"></a>使用依赖关系解析规则</h2><p>依赖关系解析规则提供了一种非常强大的方法来控制依赖关系解析过程，并可用于实现依赖管理中的各种高级模式。比如：</p><ul><li>统一构件组的版本</li></ul><p>很多时候我们依赖一个公司的库会包含多个module，这些module一般都是统一构建、打包和发布的，具备相同的版本号。这个时候我们可以通过控制依赖关系的解析过程做到版本号统一。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy.eachDependency &#123; DependencyResolveDetails details -&gt;</span><br><span class="line">    <span class="keyword">if</span> (details.requested.group == <span class="string">'org.gradle'</span>) &#123;</span><br><span class="line">        details.useVersion <span class="string">'1.4'</span></span><br><span class="line">        details.because <span class="string">'API breakage in higher versions'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>处理自定义的版本scheme</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy.eachDependency &#123; DependencyResolveDetails details -&gt;</span><br><span class="line">        <span class="keyword">if</span> (details.requested.version == <span class="string">'default'</span>) &#123;</span><br><span class="line">            <span class="keyword">def</span> version = findDefaultVersionInCatalog(details.requested.group, details.requested.name)</span><br><span class="line">            details.useVersion version.version</span><br><span class="line">            details.because version.because</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> findDefaultVersionInCatalog(String group, String name) &#123;</span><br><span class="line">    <span class="comment">//some custom logic that resolves the default version into a specific version</span></span><br><span class="line">    [<span class="string">version:</span> <span class="string">"1.0"</span>, <span class="string">because:</span> <span class="string">'tested by QA'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于更多依赖关系解析规则的使用实例可以参考gradle的API中的 <a href="https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_blank" rel="noopener">ResolutionStrategy</a></p><ul><li>使用依赖关系的替代规则</li></ul><p>依赖关系的替换规则和上面的依赖关系解析规则有点相似。实际上，依赖关系解析规则的许多功能可以通过依赖关系替换规则来实现。依赖关系的替换规则允许项目依赖（Project Dependency）和模块依赖（Module Dependency）被指定的替换规则透明地替换。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 使用项目依赖替换模块依赖</span></span><br><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy.dependencySubstitution &#123;</span><br><span class="line">        substitute module(<span class="string">"org.utils:api"</span>) with project(<span class="string">":api"</span>) because <span class="string">"we work with the unreleased development version"</span></span><br><span class="line">        substitute module(<span class="string">"org.utils:util:2.5"</span>) with project(<span class="string">":util"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用模块依赖替换项目依赖</span></span><br><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy.dependencySubstitution &#123;</span><br><span class="line">        substitute project(<span class="string">":api"</span>) with module(<span class="string">"org.utils:api:1.3"</span>) because <span class="string">"we use a stable version of utils"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多可以查看官方的文档<a href="https://docs.gradle.org/current/userguide/customizing_dependency_resolution_behavior.html#sec:dependency_substitution_rules" target="_blank" rel="noopener">Customizing Dependency Resolution Behavior</a></p><h1 id="SourceSet"><a href="#SourceSet" class="headerlink" title="SourceSet"></a>SourceSet</h1><p>SourceSet 可以定义项目结构，也可以修改项目结构。Java插件默认实现了两个SourceSet，main 和 test。每个 SourceSet 都提供了一系列的属性，通过这些属性，可以定义该 SourceSet 所包含的源文件。比如，java.srcDirs，resources.srcDirs 。Java 插件中定义的其他任务，就根据 main 和 test 的这两个 SourceSet 的定义来寻找产品代码和测试代码等。</p><h2 id="SourceSet-定义源码目录"><a href="#SourceSet-定义源码目录" class="headerlink" title="SourceSet 定义源码目录"></a>SourceSet 定义源码目录</h2><p>在 Android 项目中，我们可以在 src/main/java 目录新建 Java 文件，现在我们在src目录下，新建一个test目录，发现不能在该目录下新建java文件，这是由于在 Gradle 中 SourceSet 默认定义的源码文件路径是src/main/java , 其他的文件下下面的源码我们自然无法访问。解决这个问题也很简单，我们需要在 SourceSet 中增加一个源码路径即可。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            java &#123;</span><br><span class="line">                srcDir <span class="string">'src/test1'</span> <span class="comment">//指定源码目</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 或者按照如下的方式写也可以</span></span><br><span class="line">            <span class="comment">//java.srcDirs( 'src/test1' , 'src/test2' ,'src/test3' )</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SourceSet-定义资源目录"><a href="#SourceSet-定义资源目录" class="headerlink" title="SourceSet 定义资源目录"></a>SourceSet 定义资源目录</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            java.srcDirs(<span class="string">'src/test1/java'</span>)  <span class="comment">//定义java 源代码</span></span><br><span class="line">            res.srcDirs(<span class="string">'src/test1/res'</span>)    <span class="comment">//定义资源目录（layout , drawable,values）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SourceSet-实现-layout-分包"><a href="#SourceSet-实现-layout-分包" class="headerlink" title="SourceSet 实现 layout 分包"></a>SourceSet 实现 layout 分包</h2><p>对于一个大项目来说，页面太多，布局文件就很多，有时在众多布局文件中找某个模块的布局文件，很是痛苦，为了解决这个问题，我们可以在创建多个 layout 目录，不同模块的布局文件放在不同的 layout 目录中，这样查找起来，就容易很多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            res.srcDirs <span class="string">'src/main/res/layouts/login'</span>  <span class="comment">//定义登录布局目录</span></span><br><span class="line">            res.srcDirs <span class="string">'src/main/res/layouts/register'</span>  <span class="comment">//定义注册布局目录</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SourceSet-定义-AndroidManifest-文件"><a href="#SourceSet-定义-AndroidManifest-文件" class="headerlink" title="SourceSet 定义 AndroidManifest 文件"></a>SourceSet 定义 AndroidManifest 文件</h2><p>在组件化开发中, 我们需要针对 debug 与 release 模式下, 指定不同的 Manifest 文件, 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    def appDebug = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class="line"><span class="function">            appDebug </span>= <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        debug &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class="line"><span class="function">            appDebug </span>= <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            <span class="keyword">if</span> (appDebug) &#123;</span><br><span class="line">                manifest.srcFile <span class="string">'src/test1/AndroidManifest.xml'</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                manifest.srcFile <span class="string">'src/main/AndroidManifest.xml'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="buildConfigField自定义配置"><a href="#buildConfigField自定义配置" class="headerlink" title="buildConfigField自定义配置"></a>buildConfigField自定义配置</h1><p>实际开发中服务器可能有正式环境和测试环境，gradle可以通过buildConfigField来配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sdkA &#123;</span><br><span class="line">            buildConfigField ‘String’, ‘API_HOST’, <span class="string">"\"http:api.test.com\""</span><span class="comment">//API Host</span></span><br><span class="line">            buildConfigField <span class="string">'String'</span>,   <span class="string">'LANG'</span>, <span class="string">'"en-US"'</span></span><br><span class="line">            buildConfigField <span class="string">'String'</span>,   <span class="string">'MAP'</span>, <span class="string">'"google"'</span></span><br><span class="line">            buildConfigField <span class="string">'String'</span>,   <span class="string">'COORDINATE_SYSTEM'</span>, <span class="string">'"WGS_84"'</span></span><br><span class="line">            buildConfigField <span class="string">'int'</span>,      <span class="string">'COORDINATE_TYPE'</span>, <span class="string">'4'</span></span><br><span class="line">            buildConfigField <span class="string">'String[]'</span>, <span class="string">'SUPPORTED_LANGS'</span>, <span class="string">'&#123;LANG&#125;'</span></span><br><span class="line">            buildConfigField <span class="string">'String'</span>,   <span class="string">'CONSUMER_HOTLINE'</span>, </span><br><span class="line">            dimension <span class="string">"lang"</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>然后通过BuildConfig可以获取这些属性，从而做些差异化的配置等等</p><h1 id="打包更改包名"><a href="#打包更改包名" class="headerlink" title="打包更改包名"></a>打包更改包名</h1><p>项目的build.gradle</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line"> ……</span><br><span class="line"><span class="comment">//打包命名</span></span><br><span class="line">    applicationVariants.all &#123;</span><br><span class="line">        variant -&gt;</span><br><span class="line">            variant.outputs.each &#123;</span><br><span class="line">                output -&gt;</span><br><span class="line">                    <span class="keyword">if</span> (variant.buildType.name == <span class="string">'release'</span>) &#123;</span><br><span class="line">                        variant.mergedFlavor.versionCode = getVersionCode(<span class="keyword">false</span>)</span><br><span class="line">                        variant.mergedFlavor.versionName = getVersionName(<span class="keyword">false</span>)</span><br><span class="line">                        <span class="comment">// release</span></span><br><span class="line">                        def apkName = <span class="string">"$&#123;project.getName()&#125;_$&#123;variant.flavorName&#125;_$&#123;buildType.name&#125;_v$&#123;variant.versionCode&#125;.apk"</span>;</span><br><span class="line">                        output.outputFile = <span class="keyword">new</span> File(output.outputFile.parent, apkName);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        variant.mergedFlavor.versionCode = getVersionCode(<span class="keyword">true</span>)</span><br><span class="line">                        variant.mergedFlavor.versionName = getVersionName(<span class="keyword">true</span>)</span><br><span class="line">                        <span class="comment">// debug</span></span><br><span class="line">                        def apkName = <span class="string">"$&#123;project.getName()&#125;_$&#123;buildType.name&#125;.apk"</span>;</span><br><span class="line">                        output.outputFile = <span class="keyword">new</span> File(output.outputFile.parent, apkName);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 version code</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> def <span class="title">getVersionCode</span><span class="params">(<span class="keyword">boolean</span> isDebug)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isDebug) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(<span class="keyword">new</span> Date().format(<span class="string">"yyMMddHHmm"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getRevisionNumber()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 version name</span></span><br><span class="line"><span class="function">def <span class="title">getVersionName</span><span class="params">(<span class="keyword">boolean</span> isDebug)</span> </span>&#123;</span><br><span class="line">    String version = appConfig.appmajor +</span><br><span class="line">            <span class="string">'.'</span> + appConfig.appminor +</span><br><span class="line">            <span class="string">'.'</span> + getRevisionNumber()</span><br><span class="line">    String today = <span class="keyword">new</span> Date().format(<span class="string">'yyMMdd'</span>)</span><br><span class="line">    String time = <span class="keyword">new</span> Date().format(<span class="string">'HHmmss'</span>)</span><br><span class="line">    <span class="keyword">if</span> (isDebug) &#123;</span><br><span class="line">        <span class="keyword">return</span> version + <span class="string">".$today.$time."</span> + getRevisionDescription()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> version + <span class="string">".$today."</span> + getRevisionDescription()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.csdn.net/zhaoyanjun6/article/details/77678577#buildtypes-%E5%AE%9A%E4%B9%89%E4%BA%86%E7%BC%96%E8%AF%91%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener">https://blog.csdn.net/zhaoyanjun6/article/details/77678577#buildtypes-%E5%AE%9A%E4%B9%89%E4%BA%86%E7%BC%96%E8%AF%91%E7%B1%BB%E5%9E%8B</a></li><li><a href="https://juejin.im/post/5b000522f265da0b7f44d1c7" target="_blank" rel="noopener">https://juejin.im/post/5b000522f265da0b7f44d1c7</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;本篇主要介绍Gradle在Android
      
    
    </summary>
    
      <category term="Gradle" scheme="https://xsfelvis.github.io/categories/Gradle/"/>
    
    
      <category term="Gradle" scheme="https://xsfelvis.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Writing Custom Plugins[译]</title>
    <link href="https://xsfelvis.github.io/2018/06/09/%E8%AF%91%E6%96%87_Writing%20Custom%20Plugins/"/>
    <id>https://xsfelvis.github.io/2018/06/09/译文_Writing Custom Plugins/</id>
    <published>2018-06-08T16:00:00.000Z</published>
    <updated>2018-06-09T13:28:47.469Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h1><p>Packaging a plugin<br>Writing a simple plugin<br>Making the plugin configurable<br>Working with files in custom tasks and plugins<br>Mapping extension properties to task properties<br>A standalone project<br>Providing a configuration DSL for the plugin</p><p>一个Gradle 插件可以将build逻辑的复用片段打包在一起，我们可以将他们应用在不同的项目之中。Gradle 允许我们实现我们自定义的插件，因此你可可以复用你的build逻辑并且分享给其他人</p><p>理论上你可以使用你喜欢的任何语言实现一个Gradle 插件，前提它们可以最后编译为字节码。在我们的例子中，我们使用Groovy作为实现语言。Groovy，Java或者Kotlin都是实现插件语言的好的选择，Gradle API 已经被设计的可以很好地兼容这些语言的。总的来说，一个由Java或者Kotlin实现的插件，将比Groovy实现的更加通俗易懂,</p><h1 id="Packaging-a-plugin"><a href="#Packaging-a-plugin" class="headerlink" title="Packaging a plugin"></a>Packaging a plugin</h1><p>以下的一些地方可以防止插件的代码</p><h2 id="Build-script"><a href="#Build-script" class="headerlink" title="Build script"></a>Build script</h2><p>你可以直接在build script中直接包含插件源码，这种做法有个优势就是可以自动的编译，并且添加到build script的classpath中。然后，这个插件在外部不可见，因此你不能在该build之外复用这个插件</p><h2 id="buildSrc-project"><a href="#buildSrc-project" class="headerlink" title="buildSrc project"></a>buildSrc project</h2><p>你可以把插件代码放在<code>rootProjectDir/buildSrc/src/main/groovy</code>目录下,Gradle将处理好编译和测试插件，并且让它在build script的路径下可用。这个插件在当前项目build内的build script中都是可见的，然而在其他项目中build中还是不可见的，因此你还是不能在本项目之外的复用该插件</p><p>你可在参考 <a href="https://docs.gradle.org/current/userguide/organizing_gradle_projects.html" target="_blank" rel="noopener">Organizing Gradle Project</a>了解更多 buildSrc 项目使用的细节</p><h2 id="Standalone-project"><a href="#Standalone-project" class="headerlink" title="Standalone project"></a>Standalone project</h2><p>你可以为你的插件创建一个独立的工程。这个工程可以创建和发布JAR文件，这个jia文件可以在多个项目的build中被使用，总而言之，这个jar文件可以包含一些插件，或者绑定一些相关的task</p><p>在我们的例子中,为了使得事情比较简单，我们将在build script使用插件，，然后我们将学习如何创建一个standalone project的插件</p><h1 id="Writing-a-simple-plugin"><a href="#Writing-a-simple-plugin" class="headerlink" title="Writing a simple plugin"></a>Writing a simple plugin</h1><p>创建一个Gradle插件，首先需要实现<code>Plugin</code>接口，实现<code>Plugin.apply(T)</code>方法。其中project对象作为一个参数，这样插件就可以配置它。下面的飞马包含了一个hello world插件，给project添加了一个<code>hello</code>task</p><p><strong>Example: A custom plugin</strong><br><em>build.gradle</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">        project.task(<span class="string">'hello'</span>) &#123;</span><br><span class="line">            doLast &#123;</span><br><span class="line">                println <span class="string">'Hello from the GreetingPlugin'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the plugin</span></span><br><span class="line">apply plugin: GreetingPlugin</span><br></pre></td></tr></table></figure><p><strong>Output of gradle -q hello</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; gradle -q hello</span><br><span class="line">Hello from the GreetingPlugin</span><br></pre></td></tr></table></figure><p>我们需要明白的是一个插件是在被应用进的projetc来创建插件的实例，也需要明白插件是一个泛型。在上面例子里，接受一个Project类型作为一个参数。一个插件也可一件接受<code>Setting</code>类型的参数，这种插件我们可以把它应用到settin script脚本中;或者接受<code>Gradle</code>类型的插件参数,这种插件我们可以应用到script脚本初始化中</p><h1 id="Making-the-plugin-configurable"><a href="#Making-the-plugin-configurable" class="headerlink" title="Making the plugin configurable"></a>Making the plugin configurable</h1><p>大多数插件需要从build script中获取一些配置，一种方案就是使用<code>extension objects</code>. Gradle <code>Project</code>和<code>ExtensionContainer</code>对象具有联系，这个对象包含了这个插件应用到project的setting和属性。你可以通过添加扩展对象到这个容器来给你的插件提供配置。一个扩展对象就是一个简单的Java Bean兼容类。Groovy是一个很好的语言选择，是实现来扩展对象，这是由于普通老的Groovy对象包含了所有的setter和getter方法，当然Java和Kotlin也是其他好的选择.</p><p>让我们给project添加一个简单的扩展对象，在这里我们给project添加一个<code>greeting</code>扩展对象。</p><p><strong>Example: A custom plugin extension</strong></p><p><em>build.gradle</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPluginExtension</span> </span>&#123;</span><br><span class="line">    String message = <span class="string">'Hello from GreetingPlugin'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Add the 'greeting' extension object</span></span><br><span class="line">        def extension = project.extensions.create(<span class="string">'greeting'</span>, GreetingPluginExtension)</span><br><span class="line">        <span class="comment">// Add a task that uses configuration from the extension object</span></span><br><span class="line">        project.task(<span class="string">'hello'</span>) &#123;</span><br><span class="line">            doLast &#123;</span><br><span class="line">                println extension.message</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: GreetingPlugin</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the extension</span></span><br><span class="line">greeting.message = <span class="string">'Hi from Gradle'</span></span><br></pre></td></tr></table></figure><p><em>Output of gradle -q hello</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; gradle -q hello</span><br><span class="line">Hi from Gradle</span><br></pre></td></tr></table></figure><p>在这个例子中,<code>GreetingPluginExtension</code>是一个普通的旧Groovy对象，它带有一个名为message的属性，这个扩展以<code>greeting</code>的名字加载到插件列表中。这个对象然后在Project中就变得可用</p><p>通常情况下，你需要在一个插件里面配置对个相关属性，Gradle为每个扩展对象添加了闭环配置对象，因而你可以将这些设置分组在一起，下面的例子将要向你展示运作的方式</p><p><strong>Example: A custom plugin with configuration closure</strong><br><em>build.gradle</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPluginExtension</span> </span>&#123;</span><br><span class="line">    String message</span><br><span class="line">    String greeter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">        def extension = project.extensions.create(<span class="string">'greeting'</span>, GreetingPluginExtension)</span><br><span class="line">        project.task(<span class="string">'hello'</span>) &#123;</span><br><span class="line">            doLast &#123;</span><br><span class="line">                println <span class="string">"$&#123;extension.message&#125; from $&#123;extension.greeter&#125;"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: GreetingPlugin</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the extension using a DSL block</span></span><br><span class="line">greeting &#123;</span><br><span class="line">    message = <span class="string">'Hi'</span></span><br><span class="line">    greeter = <span class="string">'Gradle'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Output of gradle -q hello</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; gradle -q hello</span><br><span class="line">Hi from Gradle</span><br></pre></td></tr></table></figure><p>在这个例子中，一些设置可以通过<code>greeting</code>闭包归为一类，在build script中的闭包块name需要和扩展对象名称保持一致。然后当闭包被执行，在扩展对象里面的属性将通过Groovy闭包代理的特性被映射为变量</p><h1 id="Working-with-files-in-custom-tasks-and-plugins"><a href="#Working-with-files-in-custom-tasks-and-plugins" class="headerlink" title="Working with files in custom tasks and plugins"></a>Working with files in custom tasks and plugins</h1><p>当我们开发自定义task和插件的时候，当接受文件位置的输入配置时候需要十分的灵活，要到这个点，您可以利用Project.file（java.lang.Object）方法尽可能晚地解析文件的值。</p><p><strong>Example: Evaluating file properties lazily</strong></p><p><em>build.gradle</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingToFileTask</span> <span class="keyword">extends</span> <span class="title">DefaultTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    def destination</span><br><span class="line"></span><br><span class="line">    <span class="function">File <span class="title">getDestination</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        project.file(destination)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TaskAction</span></span><br><span class="line">    <span class="function">def <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        def file = getDestination()</span><br><span class="line">        file.parentFile.mkdirs()</span><br><span class="line">        file.write <span class="string">'Hello!'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">greet</span><span class="params">(type: GreetingToFileTask)</span> </span>&#123;</span><br><span class="line">    destination = &#123; project.greetingFile &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">sayGreeting</span><span class="params">(dependsOn: greet)</span> </span>&#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        <span class="function">println <span class="title">file</span><span class="params">(greetingFile)</span>.text</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">ext.greetingFile </span>= <span class="string">"$buildDir/hello.txt"</span></span><br></pre></td></tr></table></figure><p><em>Output of gradle -q sayGreeting</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; gradle -q sayGreeting</span><br><span class="line">Hello!</span><br></pre></td></tr></table></figure><p>在这个例子中，我们配置了<code>greet</code> Task的<code>destination</code>属性作为了闭环，并在最后转换为File对象进行评通过Project.file（java.lang.Object）方法对闭包的返回值估。在这个例子中你可以看到，我们设置<code>greetingFile</code>属性，在我们已经为task配置属性之后。这种evaluation的懒加载是文件设置属性可以接受任何值的一个关键的好处,然后在读取属性时解析该值。</p><h1 id="Mapping-extension-properties-to-task-properties"><a href="#Mapping-extension-properties-to-task-properties" class="headerlink" title="Mapping extension properties to task properties"></a>Mapping extension properties to task properties</h1><p>build script通过扩展获取用户的输入，并且将它映射到输入输出属性是自定义task的最佳实践。最终用户只需要通过扩展定义的暴露出来的DSL进行交互即可。命令逻辑隐藏在插件实现中。</p><p>在build script中申明的扩展以及扩展属性和自定义任务属性之间的映射发生在构建生命周期的Gradle配置阶段。为了避免evaluation顺序的问题，必须在excution阶段解决映射属性的实际值。（更多信息请参看 <a href="https://docs.gradle.org/current/userguide/build_lifecycle.html#sec:build_phases" target="_blank" rel="noopener">the section called “Build phases”</a>）.Gradle的API提供了用于表示应该进行延迟evaluate的属性的类型，例如在执行期（参阅<a href="https://docs.gradle.org/current/userguide/lazy_configuration.html" target="_blank" rel="noopener">延迟配置</a>），下面的例子演示了将扩展属性映射到任务属性类型的用法</p><p><strong>Example: Mapping extension properties to task properties</strong><br><em>build.gradle</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">        def extension = project.extensions.create(<span class="string">'greeting'</span>, GreetingPluginExtension, project)</span><br><span class="line">        project.tasks.create(<span class="string">'hello'</span>, Greeting) &#123;</span><br><span class="line">            message = extension.message</span><br><span class="line">            outputFiles = extension.outputFiles</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPluginExtension</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Property&lt;String&gt; message</span><br><span class="line">    <span class="keyword">final</span> ConfigurableFileCollection outputFiles</span><br><span class="line"></span><br><span class="line">    GreetingPluginExtension(Project project) &#123;</span><br><span class="line">        message = project.objects.property(String)</span><br><span class="line">        message.set(<span class="string">'Hello from GreetingPlugin'</span>)</span><br><span class="line">        outputFiles = project.layout.configurableFiles()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setOutputFiles</span><span class="params">(FileCollection outputFiles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.outputFiles.setFrom(outputFiles)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">DefaultTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Property&lt;String&gt; message = project.objects.property(String)</span><br><span class="line">    <span class="keyword">final</span> ConfigurableFileCollection outputFiles = project.layout.configurableFiles()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setOutputFiles</span><span class="params">(FileCollection outputFiles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.outputFiles.setFrom(outputFiles)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TaskAction</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        outputFiles.each &#123;</span><br><span class="line">            logger.quiet <span class="string">"Writing message 'Hi from Gradle' to file"</span></span><br><span class="line">            it.text = message.get()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: GreetingPlugin</span><br><span class="line"></span><br><span class="line">greeting &#123;</span><br><span class="line">    message = <span class="string">'Hi from Gradle'</span></span><br><span class="line">    outputFiles = layout.files(<span class="string">'a.txt'</span>, <span class="string">'b.txt'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Note: The code for this example can be found at samples/userguide/tasks/mapExtensionPropertiesToTaskProperties in the ‘-all’ distribution of Gradle.</p></blockquote><p><em>Output of gradle -q hello</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; gradle -q hello</span><br><span class="line">Writing message <span class="string">'Hi from Gradle'</span> to file</span><br><span class="line">Writing message <span class="string">'Hi from Gradle'</span> to file</span><br></pre></td></tr></table></figure><h1 id="A-standalone-project"><a href="#A-standalone-project" class="headerlink" title="A standalone project"></a>A standalone project</h1><p>现在，我们将把插件移到一个独立的project中，这样我们就可以发布并公用这个插件。这个project是个可以生成包含插件class的Jar文件的简单Groovy Project。下面这个project的简单build script，apply了Groovy插件，并且添加了gradle api的依赖</p><p><strong>Example: A build for a custom plugin</strong></p><p><em>build.gradle</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pply plugin: <span class="string">'groovy'</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="function">compile <span class="title">gradleApi</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    compile <span class="title">localGroovy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>Note: The code for this example can be found at samples/customPlugin/plugin in the ‘-all’ distribution of Gradle.</p></blockquote><p>因此Gradle如何发现实现的插件呢？答案是你需要在<code>META-INF/gradle-plugins</code>目录下提供一个匹配你插件id的属性<br><strong>Example: Wiring for a custom plugin</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- src/main/resources/META-INF/gradle-plugins/org.samples.greeting.properties</span><br><span class="line">  |</span><br><span class="line">  -  implementation-<span class="class"><span class="keyword">class</span></span>=org.gradle.GreetingPlugin</span><br></pre></td></tr></table></figure></p><p>需要注意的是，属性文件名与插件标识匹配，并放置在资源文件夹中，而实现类属性标识插件实现类。</p><h2 id="Creating-a-plugin-id"><a href="#Creating-a-plugin-id" class="headerlink" title="Creating a plugin id"></a>Creating a plugin id</h2><p>插件ID以类似于Java软件包的方式被完全限定（即反向域名）。这有助于避免冲突，并提供了一种将类似所有权的插件分组的方法。</p><p>您的插件ID应该是反映名称空间的组件的组合（指向您或您的组织的合理指针）以及它提供的插件的名称。例如，如果您有一个名为“foo”的Github帐户，并且您的插件名为“bar”，则合适的插件ID可能是com.github.foo.bar。同样，如果插件是在baz组织开发的，插件ID可能是org.baz.bar。</p><p>插件id应该按照以下规则：</p><ul><li>可以包含任何字母数字字符，’.’和’ - ‘。</li><li>必须包含至少一个’.’将名称空间与插件名称分开的字符。</li><li>通常对名称空间使用小写反向域名约定。</li><li>通常在名称中只使用小写字符</li><li>不要使用 org.gradle和com.gradleware命名空间</li><li>无法以’.’开始或结束</li><li>不能包含连续的’.’字符（即’..’）</li></ul><p>尽管插件ID和包名称之间存在传统的相似性，但包名通常比插件ID所需的更详细。例如，将“gradle”添加为插件ID的组件似乎是合理的，但由于插件ID仅用于Gradle插件，这将是多余的。一般而言，标识所有权和名称的名称空间都是良好的插件标识所需的</p><h2 id="Publishing-your-plugin"><a href="#Publishing-your-plugin" class="headerlink" title="Publishing your plugin"></a>Publishing your plugin</h2><p>如果您在公司内部发布您的插件以供您的组织使用，可以像发布其他任何代码工件一样发布它。关于发布工件，请参阅<a href="https://docs.gradle.org/current/userguide/publishing_ivy.html" target="_blank" rel="noopener">lvy</a>和<a href="https://docs.gradle.org/current/userguide/publishing_maven.html" target="_blank" rel="noopener">maven</a>章节。</p><p>如果您有兴趣发布您的插件以供更广泛的Gradle社区使用，您可以将其发布到<a href="https://plugins.gradle.org/docs/submit?_ga=2.115105858.438770069.1528507228-204910210.1513922382" target="_blank" rel="noopener">Gradle plugin portal. </a>。该网站提供搜索和收集Gradle社区贡献插件的信息的能力。请参阅<a href="https://plugins.gradle.org/?_ga=2.115105858.438770069.1528507228-204910210.1513922382" target="_blank" rel="noopener">此处</a>的说明，了解如何使您的插件在本网站上可用。</p><h2 id="Using-your-plugin-in-another-project"><a href="#Using-your-plugin-in-another-project" class="headerlink" title="Using your plugin in another project"></a>Using your plugin in another project</h2><p>要在构建脚本中使用插件，需要将插件类添加到构建脚本的类路径中。为此，请使用“buildscript {}”块，如<a href="https://docs.gradle.org/current/userguide/plugins.html#sec:applying_plugins_buildscript" target="_blank" rel="noopener">“Applying plugins with the buildscript block”</a>. 一节中所述。以下示例显示了当包含该插件的JAR已发布到本地存储库时，您需要这样做：</p><p><strong>Example: Using a custom plugin in another project</strong><br><em>build.gradle</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            <span class="function">url <span class="title">uri</span><span class="params">(<span class="string">'../repo'</span>)</span></span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    dependencies </span>&#123;</span><br><span class="line">        classpath group: <span class="string">'org.gradle'</span>, name: <span class="string">'customPlugin'</span>,</span><br><span class="line">                  version: <span class="string">'1.0-SNAPSHOT'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">apply plugin: <span class="string">'org.samples.greeting'</span></span><br></pre></td></tr></table></figure><p>或者，如果您的插件已发布到插件门户，则可以使用孵化插件DSL（请参阅“<a href="https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block" target="_blank" rel="noopener">使用插件DSL应用插件</a>”一节）来应用该插件：</p><p><strong>Example: Applying a community plugin with the plugins DSL</strong><br><em>build.gradle</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'com.jfrog.bintray'</span> version <span class="string">'0.4.1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Providing-a-configuration-DSL-for-the-plugin"><a href="#Providing-a-configuration-DSL-for-the-plugin" class="headerlink" title="Providing a configuration DSL for the plugin"></a>Providing a configuration DSL for the plugin</h1><p>正如我们上面看到的，您可以使用扩展对象为您的插件提供配置。使用扩展对象还扩展了Gradle DSL以为该插件添加项目属性和DSL块。扩展对象只是一个常规对象，因此您可以通过向扩展对象添加属性和方法来提供嵌套在此块中的DSL元素。Gradle提供了一些便利来帮助为插件创建一个行为良好的DSL。</p><h2 id="Nested-DSL-elements"><a href="#Nested-DSL-elements" class="headerlink" title="Nested DSL elements"></a>Nested DSL elements</h2><p>当Gradle创建任务或扩展对象时，Gradle修饰实现类以混合DSL支持。要创建一个嵌套的DSL元素，可以使用ObjectFactory类型来创建具有类似修饰的对象。然后，可以通过插件扩展的属性和方法使这些修饰对象可见。</p><p><strong>Example: Nested DSL elements</strong></p><p><em>build.gradle</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPluginExtension</span> </span>&#123;</span><br><span class="line">    String message</span><br><span class="line">    <span class="keyword">final</span> Person greeter</span><br><span class="line"></span><br><span class="line">    <span class="meta">@javax</span>.inject.Inject</span><br><span class="line">    GreetingPluginExtension(ObjectFactory objectFactory) &#123;</span><br><span class="line">        <span class="comment">// Create a Person instance</span></span><br><span class="line">        greeter = objectFactory.newInstance(Person)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">greeter</span><span class="params">(Action&lt;? <span class="keyword">super</span> Person&gt; action)</span> </span>&#123;</span><br><span class="line">        action.execute(greeter)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create the extension, passing in an ObjectFactory for it to use</span></span><br><span class="line">        def extension = project.extensions.create(<span class="string">'greeting'</span>, GreetingPluginExtension, project.objects)</span><br><span class="line">        project.task(<span class="string">'hello'</span>) &#123;</span><br><span class="line">            doLast &#123;</span><br><span class="line">                println <span class="string">"$&#123;extension.message&#125; from $&#123;extension.greeter.name&#125;"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: GreetingPlugin</span><br><span class="line"></span><br><span class="line">greeting &#123;</span><br><span class="line">    message = <span class="string">'Hi'</span></span><br><span class="line">    greeter &#123;</span><br><span class="line">        name = <span class="string">'Gradle'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Output of gradle -q hello</span><br><span class="line"></span><br><span class="line">&gt; gradle -q hello</span><br><span class="line">Hi from Gradle</span><br></pre></td></tr></table></figure><p>在这个例子中，插件通过其构造函数将项目的ObjectFactory传递给扩展对象。构造函数使用它创建一个嵌套对象，并通过greeter属性使该对象可供DSL使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Table-of-Contents&quot;&gt;&lt;a href=&quot;#Table-of-Contents&quot; class=&quot;headerlink&quot; title=&quot;Table of
      
    
    </summary>
    
      <category term="Gradle" scheme="https://xsfelvis.github.io/categories/Gradle/"/>
    
    
      <category term="Gradle" scheme="https://xsfelvis.github.io/tags/Gradle/"/>
    
      <category term="翻译" scheme="https://xsfelvis.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>谈谈APT和JavaPoet的一些使用技巧和要点</title>
    <link href="https://xsfelvis.github.io/2018/06/06/%E8%B0%88%E8%B0%88APT%E5%92%8CJavaPoet%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/"/>
    <id>https://xsfelvis.github.io/2018/06/06/谈谈APT和JavaPoet的一些技巧/</id>
    <published>2018-06-05T16:00:00.000Z</published>
    <updated>2018-06-06T15:28:38.868Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>APT+JavaPoet 是一把利剑，可以将很多模板代码在编译期间直接生成，即通过注解收集信息，然后将这些信息形成一些固定代码；特别是在写框架的时候，可以将一些“脏活、累活”通过这种方式处理掉，然后提供给用户一个干净的API接口使用，目前常用在</p><ul><li>路由 如<a href="https://github.com/alibaba/ARouter" target="_blank" rel="noopener">ARouter</a></li><li>ButterKnife、Dagger等</li><li>JsBridge (Hanlder或者Actioon)</li><li><p>权限<br>如 <a href="https://github.com/hongyangAndroid/MPermissions" target="_blank" rel="noopener">MPermissions</a>、<a href="https://github.com/permissions-dispatcher/PermissionsDispatcher" target="_blank" rel="noopener">PermissionsDispatcher</a></p></li><li><p>工厂模式相关 <a href="https://race604.com/annotation-processing/" target="_blank" rel="noopener">工厂模式简化</a> </p></li></ul><p>一些复杂类型的Adapter 等等，这些都可以找到相关的开源库</p><p>关于APT+JavePoet要是不熟悉的话建议先看看我之前的注解系列</p><p>注解系列</p><ul><li><a href="https://xsfelvis.github.io/2017/01/06/%E6%B3%A8%E8%A7%A3%E5%9F%BA%E7%A1%80/">注解基础</a></li><li><a href="https://xsfelvis.github.io/2017/04/07/%E7%BC%96%E8%AF%91%E6%9C%9F%E6%B3%A8%E8%A7%A3%E4%B9%8BAPT/">编译期注解处理之APT</a></li><li><a href="https://xsfelvis.github.io/2017/03/12/%E7%BC%96%E8%AF%91%E6%9C%9F%E6%B3%A8%E8%A7%A3%E4%B9%8BJavaPoet/">JavaPoet</a></li></ul><p><a href="https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%A6%82%E8%BF%B0/#more">ARouter解析</a></p><h1 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h1><h2 id="老生常谈的面向接口编程"><a href="#老生常谈的面向接口编程" class="headerlink" title="老生常谈的面向接口编程"></a>老生常谈的面向接口编程</h2><p>比如在<a href="https://github.com/hongyangAndroid/MPermissions" target="_blank" rel="noopener">MPermissions</a>中，提供了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PermissionProxy</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">grant</span><span class="params">(T source, <span class="keyword">int</span> requestCode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">denied</span><span class="params">(T source, <span class="keyword">int</span> requestCode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rationale</span><span class="params">(T source, <span class="keyword">int</span> requestCode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">needShowRationale</span><span class="params">(<span class="keyword">int</span> requestCode)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后APT生成的代码实现该接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span>$$<span class="title">PermissionProxy</span> <span class="keyword">implements</span> <span class="title">PermissionProxy</span>&lt;<span class="title">MainActivity</span>&gt; </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际逻辑操作中直接使用该接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldShowRequestPermissionRationale</span><span class="params">(Activity activity, String permission, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//核心逻辑只关注接口</span></span><br><span class="line">        PermissionProxy proxy = findPermissionProxy(activity);</span><br><span class="line">        <span class="keyword">if</span> (!proxy.needShowRationale(requestCode)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (ActivityCompat.shouldShowRequestPermissionRationale(activity,</span><br><span class="line">                permission)) &#123;</span><br><span class="line">            proxy.rationale(activity, requestCode);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ARouter(<a href="https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%A6%82%E8%BF%B0/#more">Arouter解析</a>)中也有这种处理的方式，比如IRouteGroup<br>LogisticsCenter#completion</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();</span><br><span class="line">iGroupInstance.loadInto(Warehouse.routes);</span><br><span class="line">Warehouse.groupsIndex.remove(postcard.getGroup());</span><br></pre></td></tr></table></figure><p>思想一样这里就不展开赘述了</p><h2 id="信息注入分离"><a href="#信息注入分离" class="headerlink" title="信息注入分离"></a>信息注入分离</h2><p>比如在ARouter中有一个<code>仓库</code>WearHouse类里面就是一些空壳容器，用来盛放路由的元信息，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Warehouse</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Cache route and metas</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; groupsIndex = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, RouteMeta&gt; routes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache provider</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Class, IProvider&gt; providers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, RouteMeta&gt; providersIndex = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache interceptor</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; interceptorsIndex = <span class="keyword">new</span> UniqueKeyTreeMap&lt;&gt;(<span class="string">"More than one interceptors use same priority [%s]"</span>);</span><br><span class="line">    <span class="keyword">static</span> List&lt;IInterceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道具体的信息是在注解之中，APT+JavaPoet负责将信息收集，在ARouter中体现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ARouter</span>$$<span class="title">Group</span>$$<span class="title">service</span> <span class="keyword">implements</span> <span class="title">IRouteGroup</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadInto</span><span class="params">(Map&lt;String, RouteMeta&gt; atlas)</span> </span>&#123;</span><br><span class="line">    atlas.put(<span class="string">"/service/hello"</span>, RouteMeta.build(RouteType.PROVIDER, HelloServiceImpl.class, <span class="string">"/service/hello"</span>, <span class="string">"service"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">"/service/json"</span>, RouteMeta.build(RouteType.PROVIDER, JsonServiceImpl.class, <span class="string">"/service/json"</span>, <span class="string">"service"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">"/service/single"</span>, RouteMeta.build(RouteType.PROVIDER, SingleService.class, <span class="string">"/service/single"</span>, <span class="string">"service"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出只有一个接受注入的信息的函数,然后在实际逻辑处理中,将此处的信息load到WareHouse中对应map</p><p>LogisticsCenter#completion</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();</span><br><span class="line">iGroupInstance.loadInto(Warehouse.routes);</span><br><span class="line">Warehouse.groupsIndex.remove(postcard.getGroup());</span><br></pre></td></tr></table></figure><p>干净清爽</p><h2 id="常用的JavaPoet"><a href="#常用的JavaPoet" class="headerlink" title="常用的JavaPoet"></a>常用的JavaPoet</h2><p>基本操作可以查看官方文档<a href="https://github.com/square/javapoet" target="_blank" rel="noopener">JavaPoet</a> 这里讲一下一些难点所在不过一般都是纠结在 获取类、接口、Map、带泛型的Map，下面将一一说明</p><h3 id="获取类"><a href="#获取类" class="headerlink" title="获取类"></a>获取类</h3><p>有两种方式</p><ul><li><p>ClassName.bestGuess(“类全名称”) 返回ClassName对象，这里的类全名称表示的类必须要存在，会自动导入相应的包</p></li><li><p>ClassName.get(“包名”，”类名”) 返回ClassName对象，不检查该类是否存在</p></li></ul><p>因此需要注意获取类全名的类在以后重构时候<code>改名类名</code>或者<code>移动了位置</code>需要对应修改这里</p><h3 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h3><ul><li>$L 字面常量（Literals）</li><li>$S 字符串常量（String）</li><li>$T 类型(Types)<br>该占位符最大特点就是会自动导包</li><li>$N 命名(Names),通常指我们自己生成的方法名或者变量名等等</li></ul><h3 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a>复杂类型</h3><p>稍微复杂点的类型 比如泛型 、Map之类的，需要了解下JavaPoet定义的几种专门描述类型的类</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/26/1639c8621da268bc?imageView2/0/w/1280/h/960/ignore-error/1" alt="复杂类型"></p><p>常见的有</p><table><thead><tr><th>分类</th><th>生成的类型</th><th>JavaPoet 写法</th><th>也可以这么写 （等效的 Java 写法）</th></tr></thead><tbody><tr><td>内置类型</td><td>int</td><td>TypeName.INT</td><td>int.class</td></tr><tr><td>数组类型</td><td>int[]</td><td>ArrayTypeName.of(int.class)</td><td>int[].class</td></tr><tr><td>需要引入包名的类型</td><td>java.io.File</td><td>ClassName.get(“java.io”, “File”)</td><td>java.io.File.class</td></tr><tr><td>参数化类型 （ParameterizedType</td><td>List</td><td>ParameterizedTypeName.get(List.class, String.class)</td><td>-</td></tr><tr><td>类型变量  （WildcardType） 用于声明泛型</td><td>T</td><td>TypeVariableName.get(“T”)</td><td>-</td></tr><tr><td>通配符类型</td><td>? extends String</td><td>WildcardTypeName.subtypeOf(String.class)</td><td>-</td></tr></tbody></table><p>通过ARouter中的一段代码，就可以解释的很清楚</p><p>RouterProcessor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数化类型 Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt;</span></span><br><span class="line">ParameterizedTypeName inputMapTypeOfRoot = ParameterizedTypeName.get(</span><br><span class="line">            ClassName.get(Map.class),</span><br><span class="line">            ClassName.get(String.class),</span><br><span class="line">            ParameterizedTypeName.get(</span><br><span class="line">                    ClassName.get(Class.class),</span><br><span class="line">                    WildcardTypeName.subtypeOf(ClassName.get(type_IRouteGroup))</span><br><span class="line">            )</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line"><span class="comment">//参数化类型 Map&lt;String, RouteMeta&gt;</span></span><br><span class="line">ParameterizedTypeName inputMapTypeOfGroup = ParameterizedTypeName.get(</span><br><span class="line">            ClassName.get(Map.class),</span><br><span class="line">            ClassName.get(String.class),</span><br><span class="line">            ClassName.get(RouteMeta.class)</span><br><span class="line">    );        </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *Build input param name.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ParameterSpec rootParamSpec = ParameterSpec.builder(inputMapTypeOfRoot, <span class="string">"routes"</span>).build();</span><br><span class="line">    ParameterSpec groupParamSpec = ParameterSpec.builder(inputMapTypeOfGroup, <span class="string">"atlas"</span>).build();</span><br></pre></td></tr></table></figure><p>生成代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ARouter</span>$$<span class="title">Root</span>$$<span class="title">app</span> <span class="keyword">implements</span> <span class="title">IRouteRoot</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadInto</span><span class="params">(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes)</span> </span>&#123;</span><br><span class="line">    routes.put(<span class="string">"service"</span>, ARouter$$Group$$service.class);</span><br><span class="line">    routes.put(<span class="string">"test"</span>, ARouter$$Group$$test.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ARouter</span>$$<span class="title">Group</span>$$<span class="title">service</span> <span class="keyword">implements</span> <span class="title">IRouteGroup</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadInto</span><span class="params">(Map&lt;String, RouteMeta&gt; atlas)</span> </span>&#123;</span><br><span class="line">    atlas.put(<span class="string">"/service/hello"</span>, RouteMeta.build(RouteType.PROVIDER, HelloServiceImpl.class, <span class="string">"/service/hello"</span>, <span class="string">"service"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">"/service/json"</span>, RouteMeta.build(RouteType.PROVIDER, JsonServiceImpl.class, <span class="string">"/service/json"</span>, <span class="string">"service"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">"/service/single"</span>, RouteMeta.build(RouteType.PROVIDER, SingleService.class, <span class="string">"/service/single"</span>, <span class="string">"service"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者直接先把你需要的泛型都写出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ClassName java_lang_Class = ClassName.get(Class.class);</span><br><span class="line">        <span class="keyword">final</span> ClassName java_util_Collections = ClassName.get(<span class="string">"java.util"</span>, <span class="string">"Collections"</span>);</span><br><span class="line">        <span class="keyword">final</span> ClassName java_util_Map = ClassName.get(<span class="string">"java.util"</span>, <span class="string">"Map"</span>);</span><br><span class="line">        <span class="keyword">final</span> ClassName java_util_Set = ClassName.get(<span class="string">"java.util"</span>, <span class="string">"Set"</span>);</span><br><span class="line">        <span class="keyword">final</span> ClassName java_util_LinkedHashMap = ClassName.get(<span class="string">"java.util"</span>, <span class="string">"LinkedHashMap"</span>);</span><br><span class="line">        <span class="keyword">final</span> ClassName java_util_LinkedHashSet = ClassName.get(<span class="string">"java.util"</span>, <span class="string">"LinkedHashSet"</span>);</span><br><span class="line">        <span class="keyword">final</span> ClassName instantiator = ClassName.get(<span class="string">"java.util.concurrent"</span>, <span class="string">"Callable"</span>);</span><br><span class="line">        <span class="keyword">final</span> TypeName classOfAny = ParameterizedTypeName.get(java_lang_Class, any);</span><br><span class="line">        <span class="keyword">final</span> TypeName instantiatorOfAny = ParameterizedTypeName.get(instantiator, any);</span><br><span class="line">        <span class="keyword">final</span> TypeName instantiatorOfP = ParameterizedTypeName.get(instantiator, p);</span><br><span class="line">        <span class="keyword">final</span> TypeName classOfS = ParameterizedTypeName.get(java_lang_Class, s);</span><br><span class="line">        <span class="keyword">final</span> TypeName classOfP = ParameterizedTypeName.get(java_lang_Class, p);</span><br><span class="line">        <span class="keyword">final</span> TypeName classOfSubTypeOfS = ParameterizedTypeName.get(java_lang_Class, subTypeOfS);</span><br><span class="line">        <span class="keyword">final</span> TypeName setOfClass = ParameterizedTypeName.get(java_util_Set, classOfAny);</span><br><span class="line">        <span class="keyword">final</span> TypeName setOfClassOfSubTypeOfS = ParameterizedTypeName.get(java_util_Set, classOfSubTypeOfS);</span><br><span class="line">        <span class="keyword">final</span> TypeName linkedHashSetOfClass = ParameterizedTypeName.get(java_util_LinkedHashSet, classOfAny);</span><br><span class="line">        <span class="keyword">final</span> TypeName mapOfClassToSetOfClass = ParameterizedTypeName.get(java_util_Map, classOfAny, setOfClass);</span><br><span class="line">        <span class="keyword">final</span> TypeName mapOfClassToInstantiator = ParameterizedTypeName.get(java_util_Map, classOfAny, instantiatorOfAny);</span><br><span class="line">        <span class="keyword">final</span> TypeName linkedHashMapOfClassToSetOfClass = ParameterizedTypeName.get(java_util_LinkedHashMap, classOfAny, setOfClass);</span><br><span class="line">        <span class="keyword">final</span> TypeName linkedHashMapOfClassToInstantializer = ParameterizedTypeName.get(java_util_LinkedHashMap, classOfAny, instantiatorOfAny);</span><br></pre></td></tr></table></figure><p>然后在需要时直接拿到即可,这里是作为一个变量(Field使用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.addField(FieldSpec.builder(mapOfClassToSetOfClass, <span class="string">"sServices"</span>)</span><br><span class="line">                        .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)</span><br><span class="line">                        .initializer(<span class="string">"new $T()"</span>, linkedHashMapOfClassToSetOfClass)</span><br><span class="line">                        .build())</span><br><span class="line">                        </span><br><span class="line">.addField(FieldSpec.builder(mapOfClassToInstantiator, <span class="string">"sInstantiators"</span>)</span><br><span class="line">                        .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)</span><br><span class="line">                        .initializer(<span class="string">"new $T()"</span>, linkedHashMapOfClassToInstantializer)</span><br><span class="line">                        .build())</span><br></pre></td></tr></table></figure><h1 id="要点分析"><a href="#要点分析" class="headerlink" title="要点分析"></a>要点分析</h1><h2 id="Element和TypeMirror"><a href="#Element和TypeMirror" class="headerlink" title="Element和TypeMirror"></a>Element和TypeMirror</h2><p>这个点还是非常重要的，我们的java代码在对于APT处理时只不过各种的Element的结构化文本，当我们需要进行细致的逻辑判断时候，比如是否是某个类的子类，就需要操作他们了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.example;    // PackageElement</span><br><span class="line"></span><br><span class="line">public class Test &#123;        // TypeElement</span><br><span class="line"></span><br><span class="line">    private int a;      // VariableElement</span><br><span class="line">    private Test other;  // VariableElement</span><br><span class="line"></span><br><span class="line">    public Test () &#123;&#125;    // ExecuteableElement</span><br><span class="line">    public void setA (  // ExecuteableElement</span><br><span class="line">                     int newA   // TypeElement</span><br><span class="line">                     ) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Element</code>代表java源文件中的程序构建元素，例如包、类、方法等。Element接口有5个子类。</p><table><thead><tr><th>PackageElement</th><th>表示一个包程序元素，可以获取到包名等</th></tr></thead><tbody><tr><td>TypeParameterElement</td><td>表示一般类、接口、方法或构造方法元素的泛型参数</td></tr><tr><td>TypeElement</td><td>表示一个类或接口程序元素</td></tr><tr><td>VariableElement</td><td>表示一个字段、enum 常量、方法或构造方法参数、局部变量或异常参数</td></tr><tr><td>ExecutableElement</td><td>表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注解类型元素</td></tr></tbody></table><p>开发中Element可根据实际情况强转为以上5种中的一种</p><ul><li>当你有一个注解是以@Target(ElementType.METHOD)定义时，表示该注解只能修饰方法。<br>那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、方法名、参数类型、返回值,如何做？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//@Target(ElementType.METHOD)修饰</span></span><br><span class="line"><span class="keyword">for</span> (Element element : roundEnv.getElementsAnnotatedWith(Inject.class)) &#123;</span><br><span class="line">    <span class="comment">//对于Element直接强转</span></span><br><span class="line">    ExecutableElement executableElement = (ExecutableElement) element;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非对应的Element，通过getEnclosingElement转换获取</span></span><br><span class="line">    TypeElement classElement = (TypeElement) element</span><br><span class="line">                .getEnclosingElement();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当(ExecutableElement) element成立时，使用(PackageElement) element</span></span><br><span class="line">    <span class="comment">//            .getEnclosingElement();将报错。</span></span><br><span class="line">    <span class="comment">//需要使用elementUtils来获取</span></span><br><span class="line">    Elements elementUtils = processingEnv.getElementUtils();</span><br><span class="line">    PackageElement packageElement = elementUtils.getPackageOf(classElement);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全类名</span></span><br><span class="line">    String fullClassName = classElement.getQualifiedName().toString();</span><br><span class="line">    <span class="comment">//类名</span></span><br><span class="line">    String className = classElement.getSimpleName().toString();</span><br><span class="line">    <span class="comment">//包名</span></span><br><span class="line">    String packageName = packageElement.getQualifiedName().toString();</span><br><span class="line">    <span class="comment">//方法名</span></span><br><span class="line">    String methodName = executableElement.getSimpleName().toString();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取得方法参数列表</span></span><br><span class="line">    List&lt;? extends VariableElement&gt; methodParameters = executableElement.getParameters();</span><br><span class="line">    <span class="comment">//参数类型列表</span></span><br><span class="line">    List&lt;String&gt; types = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (VariableElement variableElement : methodParameters) &#123;</span><br><span class="line">        TypeMirror methodParameterType = variableElement.asType();</span><br><span class="line">        <span class="keyword">if</span> (methodParameterType <span class="keyword">instanceof</span> TypeVariable) &#123;</span><br><span class="line">            TypeVariable typeVariable = (TypeVariable) methodParameterType;</span><br><span class="line">            methodParameterType = typeVariable.getUpperBound();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//参数名</span></span><br><span class="line">        String parameterName = variableElement.getSimpleName().toString();</span><br><span class="line">        <span class="comment">//参数类型</span></span><br><span class="line">        String parameteKind = methodParameterType.toString();</span><br><span class="line">        types.add(methodParameterType.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当你有一个注解是以@Target(ElementType.FIELD)定义时，表示该注解只能修饰属性、类成员。那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、类成员类型、类成员名,如何获取?</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Element element : roundEnv.getElementsAnnotatedWith(IdProperty.class)) &#123;</span><br><span class="line">    <span class="comment">//ElementType.FIELD注解可以直接强转VariableElement</span></span><br><span class="line">    VariableElement variableElement = (VariableElement) element;</span><br><span class="line">    <span class="comment">//非对应的Element，通过getEnclosingElement转换获取</span></span><br><span class="line">    TypeElement classElement = (TypeElement) element</span><br><span class="line">            .getEnclosingElement();</span><br><span class="line">    PackageElement packageElement = elementUtils.getPackageOf(classElement);</span><br><span class="line">    <span class="comment">//类名</span></span><br><span class="line">    String className = classElement.getSimpleName().toString();</span><br><span class="line">    <span class="comment">//包名</span></span><br><span class="line">    String packageName = packageElement.getQualifiedName().toString();</span><br><span class="line">    <span class="comment">//类成员名</span></span><br><span class="line">    String variableName = variableElement.getSimpleName().toString();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类成员类型</span></span><br><span class="line">    TypeMirror typeMirror = variableElement.asType();</span><br><span class="line">    String type = typeMirror.toString();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当你有一个注解是以@Target(ElementType.TYPE)定义时，表示该注解只能修饰类、接口、枚举。那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、全类名、父类，如何获取？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Element element : roundEnv.getElementsAnnotatedWith(xxx.class)) &#123;</span><br><span class="line">    <span class="comment">//ElementType.TYPE注解可以直接强转TypeElement</span></span><br><span class="line">    TypeElement classElement = (TypeElement) element;</span><br><span class="line">    <span class="comment">//非对应的Element，通过getEnclosingElement转换获取</span></span><br><span class="line">    PackageElement packageElement = (PackageElement) element</span><br><span class="line">                .getEnclosingElement();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全类名</span></span><br><span class="line">    String fullClassName = classElement.getQualifiedName().toString();</span><br><span class="line">    <span class="comment">//类名</span></span><br><span class="line">    String className = classElement.getSimpleName().toString();</span><br><span class="line">    <span class="comment">//包名</span></span><br><span class="line">    String packageName = packageElement.getQualifiedName().toString();</span><br><span class="line">    <span class="comment">//父类名</span></span><br><span class="line">    String superClassName = classElement.getSuperclass().toString();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Element代表的是源代码。TypeElement代表的是源代码中的类型元素，例如类。然而，TypeElement并不包含类本身的信息。你可以从TypeElement中获取类的名字，但是你获取不到类的信息，例如它的父类。这种信息需要通过TypeMirror获取。<code>TypeMirror</code>用与描述Java程序中元素的信息，即Elment的元信息。通过通过<code>Element.asType()</code>接口可以获取Element的TypeMirror，结构比较复杂<br><img src="https://blog-10039692.file.myqcloud.com/1508900053643_8070_1508900092231.png" alt="typemirror"></p><p>常用的TypeMirror，如下</p><table><thead><tr><th>PrimitiveType</th><th>原始数据类型，boolean,byte,short int,long,float,char,double</th></tr></thead><tbody><tr><td>ReferenceType</td><td>引用类型</td></tr><tr><td>ArrayType</td><td>数组类型</td></tr><tr><td>DeclaredType</td><td>声明的类型，例如类、接口、枚举、注解类型</td></tr><tr><td>AnnotationType</td><td>注解类型</td></tr><tr><td>ClassType</td><td>类类型</td></tr><tr><td>EnumType</td><td>枚举类型</td></tr><tr><td>InterfaceType</td><td>接口类型</td></tr><tr><td>TypeVariable</td><td>类型变量类型</td></tr><tr><td>VoidType</td><td>void 类型</td></tr><tr><td>WildcardType</td><td>通配符类型</td></tr></tbody></table><p>当TypeMirror是DeclaredType或者TypeVariable时，TypeMirror可以转化成Element:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element element = processingEviroment.getTypeUtils().asElement(typeMirror);</span><br></pre></td></tr></table></figure><p>在ARouter中 为了区分是否是某个类的子类使用到了TypeMirro</p><p>RouterProcessor # parseRoutes</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> TypeMirror type_Activity = elements.getTypeElement(ACTIVITY).asType();</span><br><span class="line">            TypeMirror type_Service = elements.getTypeElement(SERVICE).asType();</span><br><span class="line">            TypeMirror fragmentTm = elements.getTypeElement(FRAGMENT).asType();</span><br><span class="line">            TypeMirror fragmentTmV4 = elements.getTypeElement(Consts.FRAGMENT_V4).asType();</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> (types.isSubtype(tm, type_Activity)) &#123;                 <span class="comment">// Activity</span></span><br><span class="line">                    ……</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (types.isSubtype(tm, iProvider)) &#123;         <span class="comment">// IProvider</span></span><br><span class="line">                ……</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (types.isSubtype(tm, fragmentTm) || types.isSubtype(tm, fragmentTmV4)) &#123;</span><br><span class="line">                 ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ul><li>使用Messager</li></ul><p><code>Messager</code>提供给注解处理器一个报告错误、警告以及提示信息的途径。它不是注解处理器开发者的日志工具，而是用来写一些信息给使用此注解器的第三方开发者的。<br>在官方文档中描述了消息的不同级别中非常重要的是Kind.ERROR，因为这种类型的信息用来表示我们的注解处理器处理失败了。很有可能是第三方开发者错误的使用了注解。这个概念和传统的Java应用有点不一样，在传统Java应用中我们可能就抛出一个异常Exception。如果你在process()中抛出一个异常，那么运行注解处理器的JVM将会崩溃（就像其他Java应用一样），使用我们注解处理器第三方开发者将会从javac中得到非常难懂的出错信息，因为它包含注解处理器的堆栈跟踪（Stacktace）信息。因此，注解处理器就有一个Messager类，它能够打印非常优美的错误信息。除此之外，你还可以连接到出错的元素。在像现在的IDE（集成开发环境）中，第三方开发者可以直接点击错误信息，IDE将会直接跳转到第三方开发者项目的出错的源文件的相应的行。<br>因此我们通常封装一个Logger去打印关键点，具体可以参考ARouter的<a href="https://github.com/alibaba/ARouter/blob/master/arouter-compiler/src/main/java/com/alibaba/android/arouter/compiler/utils/Logger.java" target="_blank" rel="noopener">Logger</a></p><ul><li>断点调试</li></ul><p>(1) 在项目的根目录下的gradle.properties文件中，新增如下配置：</p><blockquote><p>org.gradle.jvmargs=-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005<br>org.gradle.daemon=true</p></blockquote><p>(2)新建remote debugger</p><p>注意新建remoteDebuger的名称一定要是AnnotationProcessor<br><img src="https://blog-10039692.file.myqcloud.com/1508900731628_7034_1508900770128.png" alt=""></p><p><img src="https://blog-10039692.file.myqcloud.com/1508900743976_6437_1508900782462.png" alt=""><br>(3)Debug AnnotationProcessor<br><img src="https://blog-10039692.file.myqcloud.com/1508900753173_3782_1508900791654.png" alt=""></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>APT + JavaPoet 固然比较强大，但是也有其局限性，比如它无法扫描 AAR、JAR包，在一些大型app上分模块最终以jar包形式提供的话，就不能扫描到注解了，那这时就需要借助于更为强大的技术了，可以通过自定义Gradle Plugin + JavaAssist在dex之前扫描class方式去生成我们想要的代码,这是后话了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.im/entry/58fefebf8d6d810058a610de/" target="_blank" rel="noopener">https://juejin.im/entry/58fefebf8d6d810058a610de/</a></li><li><a href="https://cloud.tencent.com/developer/article/1006210" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1006210</a></li><li><a href="https://race604.com/annotation-processing/" target="_blank" rel="noopener">https://race604.com/annotation-processing/</a></li><li><a href="https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/" target="_blank" rel="noopener">https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;APT+JavaPoet 是一把利剑，可
      
    
    </summary>
    
      <category term="注解" scheme="https://xsfelvis.github.io/categories/%E6%B3%A8%E8%A7%A3/"/>
    
    
      <category term="APT" scheme="https://xsfelvis.github.io/tags/APT/"/>
    
      <category term="JavaPoet" scheme="https://xsfelvis.github.io/tags/JavaPoet/"/>
    
  </entry>
  
  <entry>
    <title>ARouter解析之URL跳转</title>
    <link href="https://xsfelvis.github.io/2018/06/06/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8BURL%E8%B7%B3%E8%BD%AC/"/>
    <id>https://xsfelvis.github.io/2018/06/06/ARouter解析之URL跳转/</id>
    <published>2018-06-05T16:00:00.000Z</published>
    <updated>2018-06-06T08:20:03.342Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>ARouter解析</p><ul><li><p><a href="https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%A6%82%E8%BF%B0/">ARouter概述</a></p></li><li><p><a href="https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8B%E8%B7%AF%E7%94%B1%E7%9A%84%E7%A7%98%E5%AF%86/">路由的秘密</a></p></li><li><a href="https://xsfelvis.github.io/2018/06/06/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8BURL%E8%B7%B3%E8%BD%AC/">URL跳转</a></li></ul><h1 id="ARouter解析之URL跳转"><a href="#ARouter解析之URL跳转" class="headerlink" title="ARouter解析之URL跳转"></a>ARouter解析之URL跳转</h1><p>在ARouter Demo中，点击通过URL跳转，会通过WebView加载html</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance()</span><br><span class="line">        .build(<span class="string">"/test/webview"</span>)</span><br><span class="line">        .withString(<span class="string">"url"</span>, <span class="string">"file:///android_asset/schame-test.html"</span>)</span><br><span class="line">        .navigation();</span><br></pre></td></tr></table></figure><p> <img src="https://upload-images.jianshu.io/upload_images/2608779-5104d9c50fcb0553.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340" alt=""></p><h2 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h2><p>通常webview上的url跳转会给webview设置一个<code>webviewClient</code>，然后通过shouldOverrideUrlLoading方法，在方法中构造intent进行跳转，简单示意如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">webview.setWebViewClient(<span class="keyword">new</span> WebViewClient()&#123;    </span><br><span class="line"><span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span> (url != <span class="keyword">null</span> &amp;&amp; url.contains(<span class="string">"arouter"</span>))&#123;    </span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(TestWebview.<span class="keyword">this</span>, Test1Activity.class);    </span><br><span class="line">        startActivity(intent);    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.shouldOverrideUrlLoading(view, url);    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种做法往往会有很多缺陷</p><ol><li>硬编码，业务复杂时候webview变得很臃肿，耦合严重不利于维护</li><li>当外不应用打开链接需要跳转到我们的App某个Activity中时候，此时就不在自己App的webview环境中，这样就无法满足跳转需求的，因此这种方式也不够强大</li></ol><p>ARouter就是通过<code>注册一个没有UI的界面</code>作为跳板来统一处理,scheme是arouter的跳转请求。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">".SchemeFilterActivity"</span>&gt;</span><br><span class="line">    &lt;!-- Schame --&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;data</span><br><span class="line">            android:host=<span class="string">"m.aliyun.com"</span></span><br><span class="line">            android:scheme=<span class="string">"arouter"</span>/&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">"android.intent.action.VIEW"</span>/&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"android.intent.category.BROWSABLE"</span>/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">    &lt;!-- App Links --&gt;</span><br><span class="line">    &lt;intent-filter android:autoVerify=<span class="string">"true"</span>&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">"android.intent.action.VIEW"</span>/&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"android.intent.category.BROWSABLE"</span>/&gt;</span><br><span class="line">        &lt;data</span><br><span class="line">            android:host=<span class="string">"m.aliyun.com"</span></span><br><span class="line">            android:scheme=<span class="string">"http"</span>/&gt;</span><br><span class="line">        &lt;data</span><br><span class="line">            android:host=<span class="string">"m.aliyun.com"</span></span><br><span class="line">            android:scheme=<span class="string">"https"</span>/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><p>在清单文件中注册了SchemeFilterActivity这个activity</p><ul><li>scheme就是arouter, </li><li>host就是m.aliyun.com，</li><li>其中有个category是 android.intent.category.BROWSABLE，</li></ul><p>其中 <code>android.intent.category.BROWSABLE</code>就是让浏览器可以打这个Actvity，当然要符合host和scheme,这样就可以在WebView中跳转SchemeFilterActivity这个界面了。</p><p>这种方式的优点：</p><ol><li><p>首先是页面跳转的灵活性，<br>比如需要和H5中进行通信，H5需要跳转到App本地的页面，Native和H5只需要统一一个path文档即可，H5可以通过path构造一个url就可以实现跳转到对应页面的功能，很类似浏览器，实现很好的解耦</p></li><li><p>更加的安全<br>相比较于隐式的intent，每一个从外面跳转进来的页面都需要注册上intent-filter，每个页面都需要设置export=true，也就是需要让每一个页面都可以导出，在外部可以访问到。这样做会带来非常严重的安全风险，就像是一个房子有十个门还是只有一个门，看门的成本是不同的。而现在使用的这种场景只需要对外暴露出一个activity，然后在这个activity中注册一个intent-filter，这样之后所有的外部路由请求都会经过这唯一的门，然后在这个activity中获取到URL并将其交给ARouter，剩下的就由路由框架做分发了。</p></li><li><p>携带参数注入<br>另外一个好处就是隐式intent跳转无法将参数自动注入，ARouter可以在url中携带参数然后自动注入</p></li></ol><p>这里也需要H5链接需要按照<code>约定的scheme来</code>，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>跳转测试<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>自定义Scheme[通常来说都是这样的]<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"arouter://m.aliyun.com/test/activity1"</span>&gt;</span>arouter://m.aliyun.com/test/activity1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"arouter://m.aliyun.com/test/activity1?url=https%3a%2f%2fm.abc.com%3fa%3db%26c%3dd"</span>&gt;</span>测试URL Encode情况<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"arouter://m.aliyun.com/test/activity1?name=alex&amp;age=18&amp;boy=true&amp;high=180&amp;obj=%7b%22name%22%3a%22jack%22%2c%22id%22%3a666%7d"</span>&gt;</span>arouter://m.aliyun.com/test/activity1?name=alex&amp;age=18&amp;boy=true&amp;high=180&amp;obj=&#123;"name":"jack","id":"666"&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"arouter://m.aliyun.com/test/activity2"</span>&gt;</span>arouter://m.aliyun.com/test/activity2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"arouter://m.aliyun.com/test/activity2?key1=value1"</span>&gt;</span>arouter://m.aliyun.com/test/activity2?key1=value1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"arouter://m.aliyun.com/test/activity3?name=alex&amp;age=18&amp;boy=true&amp;high=180"</span>&gt;</span>arouter://m.aliyun.com/test/activity3?name=alex&amp;age=18&amp;boy=true&amp;high=180<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>App Links[防止被App屏蔽]<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://m.aliyun.com/test/activity1"</span>&gt;</span>http://m.aliyun.com/test/activity1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://m.aliyun.com/test/activity2"</span>&gt;</span>http://m.aliyun.com/test/activity2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="URL中转SchemeFilterActivity"><a href="#URL中转SchemeFilterActivity" class="headerlink" title="URL中转SchemeFilterActivity"></a>URL中转SchemeFilterActivity</h2><p>点击url之后通过清单文件的匹配intent-filter中的data, action, category的标签，其中category匹配任意一个即可。接着就来到SchemeFilterActivity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchemeFilterActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        直接通过ARouter处理外部Uri</span></span><br><span class="line">        Uri uri = getIntent().getData();</span><br><span class="line">        ARouter.getInstance().build(uri).navigation(<span class="keyword">this</span>, <span class="keyword">new</span> NavCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onArrival</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">                finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续处理就跟之前路由逻辑一致了,这里就不赘述了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;ARouter解析&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%
      
    
    </summary>
    
      <category term="开源学习" scheme="https://xsfelvis.github.io/categories/%E5%BC%80%E6%BA%90%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ARouter" scheme="https://xsfelvis.github.io/tags/ARouter/"/>
    
      <category term="路由" scheme="https://xsfelvis.github.io/tags/%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>ARouter解析之路由的秘密</title>
    <link href="https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8B%E8%B7%AF%E7%94%B1%E7%9A%84%E7%A7%98%E5%AF%86/"/>
    <id>https://xsfelvis.github.io/2018/06/05/ARouter解析之路由的秘密/</id>
    <published>2018-06-04T16:00:00.000Z</published>
    <updated>2018-06-06T15:30:42.105Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>ARouter解析</p><ul><li><p><a href="https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%A6%82%E8%BF%B0/">ARouter概述</a></p></li><li><p><a href="https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8B%E8%B7%AF%E7%94%B1%E7%9A%84%E7%A7%98%E5%AF%86/">路由的秘密</a></p></li><li><a href="https://xsfelvis.github.io/2018/06/06/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8BURL%E8%B7%B3%E8%BD%AC/">URL跳转</a></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本篇主要介绍ARouter如何进行路由的，比如Activity、Fragment、服务等</p><h1 id="路由的秘密"><a href="#路由的秘密" class="headerlink" title="路由的秘密"></a>路由的秘密</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>初始化路由之后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARouter.init(mApplication);</span><br></pre></td></tr></table></figure><p>在需要支持页面路由的页面上添加注解(至少两级)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Route</span>(path = <span class="string">"/test/activity2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2Activity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span></span><br></pre></td></tr></table></figure><p>在路由时候通过建造者模式构建参数，<code>路由页面</code>分为以下几种</p><h3 id="路由页面"><a href="#路由页面" class="headerlink" title="路由页面"></a>路由页面</h3><ul><li>普通跳转</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance()</span><br><span class="line">        .build(<span class="string">"/test/activity2"</span>)</span><br><span class="line">        .navigation();</span><br></pre></td></tr></table></figure><ul><li>带参数跳转</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance()</span><br><span class="line">    .build(<span class="string">"/test/activity2"</span>)</span><br><span class="line">    .withString(<span class="string">"key1"</span>, <span class="string">"value1"</span>)</span><br><span class="line">    .navigation();</span><br></pre></td></tr></table></figure><p>其中ARouter提供了丰富的参数类型主要有基本类型、Object、Parceable等，核心原理也是通过Bundle携带传递</p><ul><li>startActivityForResult</li></ul><p>比如在TestActivity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance().build(<span class="string">"/test/activity2"</span>)</span><br><span class="line">                     .withString(<span class="string">"key1"</span>, <span class="string">"value1"</span>)</span><br><span class="line">                     .navigation(<span class="keyword">this</span>, <span class="number">999</span>);</span><br></pre></td></tr></table></figure><p>然后在TestActivity中 使用onActivityResult得到数据进行处理，这里跟普通过程一样</p><ul><li>带回调路由</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance().build(<span class="string">"/xxx/xxx"</span>).navigation(<span class="keyword">this</span>, <span class="keyword">new</span> NavCallback() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFound</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">                       Log.d(<span class="string">"ARouter"</span>, <span class="string">"找到了"</span>);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLost</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">                       Log.d(<span class="string">"ARouter"</span>, <span class="string">"找不到了"</span>);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onArrival</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">                       Log.d(<span class="string">"ARouter"</span>, <span class="string">"跳转完了"</span>);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInterrupt</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">                       Log.d(<span class="string">"ARouter"</span>, <span class="string">"被拦截了"</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br></pre></td></tr></table></figure><h3 id="路由Fragment"><a href="#路由Fragment" class="headerlink" title="路由Fragment"></a>路由Fragment</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Fragment fragment = (Fragment) ARouter.getInstance()</span><br><span class="line">                    .build(<span class="string">"/test/fragment"</span>)</span><br><span class="line">                    .navigation();</span><br></pre></td></tr></table></figure><h3 id="路由服务"><a href="#路由服务" class="headerlink" title="路由服务"></a>路由服务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance()</span><br><span class="line">        .navigation(SingleService.class)</span><br><span class="line">        .sayHello(<span class="string">"Mike"</span>);</span><br></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>可以看出路由到页面 分为三步</p><ul><li>build 构建 信息邮票(PostCard)</li></ul><p>_ARouter # build</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Build postcard by path and default group</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Postcard <span class="title">build</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(path)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(Consts.TAG + <span class="string">"Parameter is invalid!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != pService) &#123;</span><br><span class="line">            path = pService.forString(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(path, extractGroup(path));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>WithXXX 路由参数</p></li><li><p>navagation 导航</p></li></ul><p>_ARouter # navagation</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">navigation</span><span class="params">(Context mContext, Postcard postcard, <span class="keyword">int</span> requestCode, NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _ARouter.getInstance().navigation(mContext, postcard, requestCode, callback);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面将按照上面的提到三个核心过程进行分析</p><ul><li>通过path构建路由信息</li></ul><p>build是在构建路由信息邮票”PostCard”,从名字看来这就是一张路由邮票，跟网络路由协议传递携带的信息作用一样,通过ARouter这个门面类(Facade)调用实际操控着_ARouter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Build postcard by path and default group</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Postcard <span class="title">build</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">      ……</span><br><span class="line">    <span class="comment">//路径扩展</span></span><br><span class="line">    PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != pService) &#123;</span><br><span class="line">        path = pService.forString(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> build(path, extractGroup(path));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也体现了作者设计这套框架的扩展性能，这个<code>PathReplaceService</code>就是让使用者自己可以给path添加扩展。extractGroup就是根据path(/test/activity2)提取group(test)，这里就是默认第一个/隔断的字符串，通过这些信息<code>初步</code>构造路由信息，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> Postcard <span class="title">build</span><span class="params">(String path, String group)</span> </span>&#123;</span><br><span class="line">       ……</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Postcard(path, group);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一个具有 <code>path</code>和<code>group</code>简单信息的PostCard对象就被构造出来了</p><ul><li>携带参数</li></ul><p>由于是Builder模式，此时构造出postcard之后之后的<code>.WithXXX</code>实际上实在给PostCard对象填充信息，PostCard对象的Bundle来承载这些信息，<br>其中 序列化对象<code>SerializationService</code>转成json存到Bundle中<br>通过这一步PostCard这个<code>邮票</code>信息进一步丰满了</p><ul><li>navigation 导航</li></ul><p>得到PostCard对象之后回去调用postCard对象的navigation对象,调用函数链如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PostCard（Arouter.getInstance.build("test/activity2")）——&gt;PostCard#navigation——&gt;ARouter#navigation</span><br><span class="line">——&gt;_ARouter#navigation`</span><br></pre></td></tr></table></figure><h4 id="ARouter-navigation"><a href="#ARouter-navigation" class="headerlink" title="_ARouter#navigation"></a>_ARouter#navigation</h4><p>来到了核心函数 <code>_ARouter#navigation</code>函数中,这个函数其实是核心路由逻辑的第一道大门,我们越来越接近真相了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">navigation</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="keyword">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//完善postCard 核心信息,主要是跳转路径 后面会详细分析</span></span><br><span class="line">        LogisticsCenter.completion(postcard);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoRouteFoundException ex) &#123;</span><br><span class="line">        <span class="comment">// 未找到页面的降级处理策略</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">            <span class="comment">//自定义回调高于系统</span></span><br><span class="line">            callback.onLost(postcard);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// No callback for this invoke, then we use the global degrade service.</span></span><br><span class="line">            <span class="comment">//没有自定义回调才使用系统onLost</span></span><br><span class="line">            DegradeService degradeService = ARouter.getInstance().navigation(DegradeService.class);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != degradeService) &#123;</span><br><span class="line">                degradeService.onLost(context, postcard);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">        <span class="comment">//onFound回调</span></span><br><span class="line">        callback.onFound(postcard);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!postcard.isGreenChannel()) &#123;   <span class="comment">// It must be run in async thread, maybe interceptor cost too mush time made ANR.</span></span><br><span class="line">        <span class="comment">//非绿色通道检查拦截器</span></span><br><span class="line">        interceptorService.doInterceptions(postcard, <span class="keyword">new</span> InterceptorCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onContinue</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//真正核心导航逻辑</span></span><br><span class="line">            _navigation(context, postcard, requestCode, callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInterrupt</span><span class="params">(Throwable exception)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">                    callback.onInterrupt(postcard);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//真正核心导航逻辑</span></span><br><span class="line">        <span class="keyword">return</span> _navigation(context, postcard, requestCode, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法较长 主要分为以下四步</p><ol><li>首先调用LogisticsCenter.completion完成postcard的补充</li><li>NavigationCallBack的处理</li><li>拦截器Interceptions的处理</li><li>开始路由导航</li></ol><p>路由导航之前如何将之前获取的postcard信息进行完善?<br>ARouter.getInstance() .build(“/test/activity2”)时已经返回了一个postcard对象，那么要完善那些信息呢？其实我们可以看出，postcard中只有path和group的信息，目标页面是什么还不明确，因此需要进一步完善信息，核心函数就是上面的LogisticsCenter.completion，这样就体现了框架的重要性，脏活累活交给框架层面，而跟用户打交道的永远都是那么的简洁。</p><h4 id="ARouter-navigationObject-navigation"><a href="#ARouter-navigationObject-navigation" class="headerlink" title="_ARouter#navigationObject navigation("></a>_ARouter#navigationObject navigation(</h4><p>最后会来到_ARouter#navigationObject navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback)）</p><p>这个函数负责最终的页面跳转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">_navigation</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="keyword">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Context currentContext = <span class="keyword">null</span> == context ? mContext : context;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (postcard.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> ACTIVITY:</span><br><span class="line">                <span class="comment">// Build intent</span></span><br><span class="line">                <span class="keyword">final</span> Intent intent = <span class="keyword">new</span> Intent(currentContext, postcard.getDestination());</span><br><span class="line">                intent.putExtras(postcard.getExtras());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Set flags.</span></span><br><span class="line">                <span class="keyword">int</span> flags = postcard.getFlags();</span><br><span class="line">                <span class="keyword">if</span> (-<span class="number">1</span> != flags) &#123;</span><br><span class="line">                    intent.setFlags(flags);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(currentContext <span class="keyword">instanceof</span> Activity)) &#123;    <span class="comment">// Non activity, need less one flag.</span></span><br><span class="line">                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Navigation in main looper.</span></span><br><span class="line">                <span class="keyword">new</span> Handler(Looper.getMainLooper()).post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (requestCode &gt; <span class="number">0</span>) &#123;  <span class="comment">// Need start for result</span></span><br><span class="line">                            ActivityCompat.startActivityForResult((Activity) currentContext, intent, requestCode, postcard.getOptionsBundle());</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            ActivityCompat.startActivity(currentContext, intent, postcard.getOptionsBundle());</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> ((-<span class="number">1</span> != postcard.getEnterAnim() &amp;&amp; -<span class="number">1</span> != postcard.getExitAnim()) &amp;&amp; currentContext <span class="keyword">instanceof</span> Activity) &#123;    <span class="comment">// Old version.</span></span><br><span class="line">                            ((Activity) currentContext).overridePendingTransition(postcard.getEnterAnim(), postcard.getExitAnim());</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123; <span class="comment">// Navigation over.</span></span><br><span class="line">                            callback.onArrival(postcard);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PROVIDER:</span><br><span class="line">                <span class="keyword">return</span> postcard.getProvider();</span><br><span class="line">            <span class="keyword">case</span> BOARDCAST:</span><br><span class="line">            <span class="keyword">case</span> CONTENT_PROVIDER:</span><br><span class="line">            <span class="keyword">case</span> FRAGMENT:</span><br><span class="line">                Class fragmentMeta = postcard.getDestination();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object instance = fragmentMeta.getConstructor().newInstance();</span><br><span class="line">                    <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> Fragment) &#123;</span><br><span class="line">                        ((Fragment) instance).setArguments(postcard.getExtras());</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> android.support.v4.app.Fragment) &#123;</span><br><span class="line">                        ((android.support.v4.app.Fragment) instance).setArguments(postcard.getExtras());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> instance;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    logger.error(Consts.TAG, <span class="string">"Fetch fragment instance error, "</span> + TextUtils.formatStackTrace(ex.getStackTrace()));</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> METHOD:</span><br><span class="line">            <span class="keyword">case</span> SERVICE:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>Activity</li></ul><p>来到ACTIVITY分支，从postcard中拿到目标页面TestActivity.class然后组成intent，然后putExtras，如果是startActivityForResult,这里面就有参数。如果context不是activity，那么就需要另起一个栈Intent.FLAG_ACTIVITY_NEW_TASK进行activity的展示。接下来通过handler发送启动activity的任务。终于找到了熟悉的ActivityCompat.startActivity和ActivityCompat.startActivityForResult，</p><ul><li>Fragment</li></ul><p>通过postcard拿到目标页面的Fragment Class，然后实例化这个，还需要兼容fragment，设置Arguments参数之后返回这个Fragment实例</p><ul><li>Provider</li></ul><p>这个是用来提供服务的，由于在 完善postCard 核心信息,<code>LogisticsCenter.completion(postcard);</code>中已经将provider实例化了，这里直接直接get出来就好。后面将会分析<code>LogisticsCenter.completion(postcard)</code>具体做了哪些工作</p><h4 id="LogisticsCenter-completion-postcard"><a href="#LogisticsCenter-completion-postcard" class="headerlink" title="LogisticsCenter.completion(postcard)"></a>LogisticsCenter.completion(postcard)</h4><p>这个函数就是完善PostCard信息的，postcard是路由信息的容器，到这个函数时候postcard中只有path和group的信息，目标页面是什么还不知道，LogisticsCenter.completion就是填充剩余的关键信息的，b并且是通过<code>按需加载的</code>,十分重要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">completion</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="comment">//从仓库WareHouse中获取路由元数据，即一些路由基本的数据</span></span><br><span class="line">    RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == routeMeta) &#123;    <span class="comment">// Maybe its does't exist, or didn't load.</span></span><br><span class="line">        Class&lt;? extends IRouteGroup&gt; groupMeta = Warehouse.groupsIndex.get(postcard.getGroup());  <span class="comment">// Load route meta.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == groupMeta) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoRouteFoundException(TAG + <span class="string">"There is no route match the path ["</span> + postcard.getPath() + <span class="string">"], in group ["</span> + postcard.getGroup() + <span class="string">"]"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Load route and cache it into memory, then delete from metas.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ……</span><br><span class="line">                <span class="comment">//将信息加载进Warehouse.routes中</span></span><br><span class="line">                IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();</span><br><span class="line">                iGroupInstance.loadInto(Warehouse.routes);</span><br><span class="line">                Warehouse.groupsIndex.remove(postcard.getGroup());</span><br><span class="line">                ……</span><br><span class="line">            &#125; </span><br><span class="line">            ……</span><br><span class="line">            <span class="comment">//经过上面的处理后，此时可以获取到对应path下的routeMeta，调用本身</span></span><br><span class="line">            completion(postcard);   <span class="comment">// Reload</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//正常获取到routeMeta填充postCard信息</span></span><br><span class="line">        postcard.setDestination(routeMeta.getDestination());</span><br><span class="line">        postcard.setType(routeMeta.getType());</span><br><span class="line">        postcard.setPriority(routeMeta.getPriority());</span><br><span class="line">        postcard.setExtra(routeMeta.getExtra());</span><br><span class="line"></span><br><span class="line">        Uri rawUri = postcard.getUri();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != rawUri) &#123;   <span class="comment">// Try to set params into bundle.</span></span><br><span class="line">            Map&lt;String, String&gt; resultMap = TextUtils.splitQueryParameters(rawUri);</span><br><span class="line">            Map&lt;String, Integer&gt; paramsType = routeMeta.getParamsType();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (MapUtils.isNotEmpty(paramsType)) &#123;</span><br><span class="line">                <span class="comment">// Set value by its type, just for params which annotation by @Param</span></span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; params : paramsType.entrySet()) &#123;</span><br><span class="line">                    setValue(postcard,</span><br><span class="line">                            params.getValue(),</span><br><span class="line">                            params.getKey(),</span><br><span class="line">                            resultMap.get(params.getKey()));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Save params name which need auto inject.</span></span><br><span class="line">                postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(<span class="keyword">new</span> String[]&#123;&#125;));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Save raw uri</span></span><br><span class="line">            postcard.withString(ARouter.RAW_URI, rawUri.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (routeMeta.getType()) &#123;</span><br><span class="line">            <span class="comment">//完成信息的同时顺便把"服务实例化"，fragment置为无须过滤的绿色通道</span></span><br><span class="line">            <span class="keyword">case</span> PROVIDER:  <span class="comment">// if the route is provider, should find its instance</span></span><br><span class="line">                <span class="comment">// Its provider, so it must implement IProvider</span></span><br><span class="line">                Class&lt;? extends IProvider&gt; providerMeta = (Class&lt;? extends IProvider&gt;) routeMeta.getDestination();</span><br><span class="line">                IProvider instance = Warehouse.providers.get(providerMeta);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123; <span class="comment">// There's no instance of this provider</span></span><br><span class="line">                    IProvider provider;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        provider = providerMeta.getConstructor().newInstance();</span><br><span class="line">                        provider.init(mContext);</span><br><span class="line">                        Warehouse.providers.put(providerMeta, provider);</span><br><span class="line">                        instance = provider;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(<span class="string">"Init provider failed! "</span> + e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                postcard.setProvider(instance);</span><br><span class="line">                postcard.greenChannel();    <span class="comment">// Provider should skip all of interceptors</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FRAGMENT:</span><br><span class="line">                postcard.greenChannel();    <span class="comment">// Fragment needn't interceptors</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程图如下<br><img src="http://p927u2n0k.bkt.clouddn.com/arouter-complete.png" alt="arouter-complete"></p><p>这个有一个关键点 WearHouse</p><ul><li>仓库查找页面节点</li></ul><p>首先根据路径信息到WareHouse仓库中查找路由节点信息，其实就是几个map，包含节点、拦截器和组别等信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());</span><br></pre></td></tr></table></figure><p>一开始是没有这个节点信息的，所以需要到WareHouse.groupsIndex中找到组别的信息，这里体现了之前提到的<code>分组加载的策略</code>，这里对应的是test这一组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;? extends IRouteGroup&gt; groupMeta = Warehouse.groupsIndex.get(postcard.getGroup());  <span class="comment">// Load route meta</span></span><br></pre></td></tr></table></figure><p>然后通过反射的方式加载这一组类别的映射关系，就是前面提到的按需加载，然后从仓库中删除这个组别信息节点，防止重复加载</p><pre><code class="java">IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();        iGroupInstance.loadInto(Warehouse.routes);    Warehouse.groupsIndex.remove(postcard.getGroup());</code></pre><p>其中编译期间已经组成了RouteMeta这个节点信息，包含有目标页面、类型、路径、组别、参数、优先级等信息。可以看到生成之后的信息表并没有直接加载到内存中，而是在第一次访问该组内一个页面时才去加载该组的信息，然后该groupindex移除，防止重复加载</p><p>生成的<code>ARouter$$Group$$test</code></p><p><img src="https://upload-images.jianshu.io/upload_images/2608779-20192e96ae6f869f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="test组"></p><ul><li>填充信息</li></ul><p>当第一次没有查找到路由节点之后，要到组别中找到路由信息 load到warehouse中，再次调用本身<code>completion(postcard)</code>函数.然后执行到else中填充路由信息</p><ul><li>一些初始化</li></ul><p>填充玩信息后，将”服务”实例化，方便后面直接获取，并且将“服务”和fragment设置为绿色通道无需检查，感觉是由于二者本身需要返回一个实例，回调接口NavCallBack只能回调PostCard信息，而且二者近似服务性质，因而不如直接给个绿色通道来的直接。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>路由之间跳转到的分析到此基本上告一段落了，其中众多信息都在PostCard中不断完善，然后在LogisticsCenter.completion进行完全填充，更重要的是整体架构关注点分离的设计是非常棒的，编译期间映射信息都下沉到LogisticsCenter与用户层打交道的API都通过ARouter这个门面友好的暴露给用户，我们平时在开发设计中也可以这样学习一下</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;ARouter解析&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%
      
    
    </summary>
    
      <category term="开源学习" scheme="https://xsfelvis.github.io/categories/%E5%BC%80%E6%BA%90%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ARouter" scheme="https://xsfelvis.github.io/tags/ARouter/"/>
    
      <category term="路由" scheme="https://xsfelvis.github.io/tags/%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>ARouter解析</title>
    <link href="https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%A3%E6%9E%90/"/>
    <id>https://xsfelvis.github.io/2018/06/05/ARouter解析/</id>
    <published>2018-06-04T16:00:00.000Z</published>
    <updated>2018-06-08T07:34:40.410Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>ARouter解析</p><ul><li><p><a href="https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%A6%82%E8%BF%B0/">ARouter概述</a></p></li><li><p><a href="https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8B%E8%B7%AF%E7%94%B1%E7%9A%84%E7%A7%98%E5%AF%86/">路由的秘密</a></p></li><li><a href="https://xsfelvis.github.io/2018/06/06/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8BURL%E8%B7%B3%E8%BD%AC/">URL跳转</a></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这个库非常值得学习，里面涉及到的技术和编程思想都是不错的</p><ol><li>APT 编译器注解处理技术</li><li>URL的统一管理跳转的方案</li><li>‘服务’的解耦（接口设计）与获取(反射)</li><li>多线程处理技术 (CountDownLatch的使用) </li><li>拦截器思想、降级策略(（AOP的设计思想）)、分组加载策略</li><li>友好的api设计</li></ol><h1 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h1><p><img src="http://p927u2n0k.bkt.clouddn.com/ARouter.png" alt="ARoute"></p><p>再进一步抽象就是<code>“邮票”PostCard信息的完善过程</code>，当信息完全填充就可以具体往哪里跳，携带什么参数</p><p><img src="http://p927u2n0k.bkt.clouddn.com/Arouter核心抽象.png" alt="Arouter核心抽象"></p><p>使用原作者的抽象图，整个ARouter架构如下:</p><p><img src="http://p927u2n0k.bkt.clouddn.com/37b723fb660fdfcf7cdc09c194c88a8073d8272d.png" alt="37b723fb660fdfcf7cdc09c194c88a8073d8272d"></p><p><img src="http://p927u2n0k.bkt.clouddn.com/e4d3ec6020479ef2043cfd7e10cfaf33254ac309-1.png" alt="e4d3ec6020479ef2043cfd7e10cfaf33254ac309"></p><p>其实在Android原生跳转主要是通过intent，主要分为显式和隐式跳转，显示跳转直接导致类之间的耦合，而隐式跳转需要在清单文件中申明，在多模块协作中比较困难,而且二者最终都会调用startActivity，这个环节我们就无法控制了，而ARouter路由可以在跳转中进行如同拦截,跳转失败进行降级的操作。</p><p>把握好了整体，下面将分几篇介绍这个开源库,见开篇链接。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;ARouter解析&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%
      
    
    </summary>
    
      <category term="开源学习" scheme="https://xsfelvis.github.io/categories/%E5%BC%80%E6%BA%90%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ARouter" scheme="https://xsfelvis.github.io/tags/ARouter/"/>
    
      <category term="路由" scheme="https://xsfelvis.github.io/tags/%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>clean架构</title>
    <link href="https://xsfelvis.github.io/2018/05/18/%E5%85%B3%E4%BA%8Eclean%E6%9E%B6%E6%9E%84%E5%9C%A8android%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://xsfelvis.github.io/2018/05/18/关于clean架构在android中的应用/</id>
    <published>2018-05-17T16:00:00.000Z</published>
    <updated>2018-06-06T06:13:38.572Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="1、clean架构简介"><a href="#1、clean架构简介" class="headerlink" title="1、clean架构简介"></a>1、clean架构简介</h2><p>clean架构相信大家早有耳闻，毕竟是Bob大叔的心血之作，最近又把<a href="http://five.agency/blog/android/" target="_blank" rel="noopener">http://five.agency/blog/android/</a> 几篇关于clean 架构的文章拿出来读读加深了对该架构的一些理解。clean架构又称“洋葱架构”，这个是由于它的架构示意图得名的<br><img src="https://user-gold-cdn.xitu.io/2018/5/15/16364599d2727324?w=896&amp;h=472&amp;f=png&amp;s=104636" alt="" title="image.png"><br>删除一些android项目中使用不到的东西加上我们使用的东西看起来如下图</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/15/16364599d36a65e7?w=892&amp;h=467&amp;f=png&amp;s=96377" alt="" title="image.png"></p><h2 id="2、核心概念"><a href="#2、核心概念" class="headerlink" title="2、核心概念"></a>2、核心概念</h2><p>从最抽象的核心到细节的边缘</p><h3 id="Entities"><a href="#Entities" class="headerlink" title="Entities"></a>Entities</h3><ul><li><p>Entities，<br>即<strong>Domain 对象</strong>或业务对象，是App的核心。 它们代表了APP的主要功能， 它们包含业务逻辑， 他们不会与外在世界的细节进行互动。</p></li><li><p>Use case，<br>又名interactors（交互器），又名business services，是Entities的扩展，是业务逻辑的延伸，也就是说。 它们包含的逻辑不仅限于一个实体，而是处理更多的实体。</p></li></ul><h3 id="Repositories"><a href="#Repositories" class="headerlink" title="Repositories"></a>Repositories</h3><p>Repositories用于持久化Entities。 就这么简单。 它们被定义为接口并用作想要对Entities执行CRUD操作的用例的输出端口。</p><h3 id="Presenters"><a href="#Presenters" class="headerlink" title="Presenters"></a>Presenters</h3><p>如果你熟悉MVP模式，Presenters就会做你期望他们做的事情。 他们处理用户交互，调用适当的业务逻辑，并将数据发送到UI进行渲染。 这里通常有不同类型之间的映射<br>大概这几个概念可以帮助我们更好的理解clean 架构，但是核心一点就是越在洋葱里面越是抽象。</p><h2 id="3、clean-架构的核心规则"><a href="#3、clean-架构的核心规则" class="headerlink" title="3、clean 架构的核心规则"></a>3、clean 架构的核心规则</h2><p>首先需要掌握涉及的领域，原文称作“Master of your domain”，就是说当你打开你的工程，除去技术相关，你就应该从宏观上知晓你的app是做什么的，而不要沉浸到细节之中” 为啥需要我们站在这个高度去看待自己的项目呢，因为这也是clean核心所在，该架构越往洋葱里面抽象度越来越高，都是业务逻辑的高度抽象，即”内层包含业务逻辑、外层包含实现细节”</p><p>继而给出了设计出这样特性的clean架构需要具备的技术点</p><p>（1）Dependency rule（依赖原则）</p><p>（2）Abstraction（抽象）</p><p>（3）Communication between layers（层之间的通信）</p><p>下面将一一介绍</p><h3 id="3-1-Dependency-rule（依赖原则）"><a href="#3-1-Dependency-rule（依赖原则）" class="headerlink" title="3.1 Dependency rule（依赖原则）"></a>3.1 Dependency rule（依赖原则）</h3><p>从最开始的第一幅我们就可以看出箭头是”依赖”,即 外层看到并了解内层，但是内层既看不到也不知道外层，结合前面所强调的 内层包含业务逻辑（抽象），外层包含实现细节。 结合依赖关系规则，业务逻辑既看不到，也不知道实现细节。 通常我们可以通过放在不同的module中去来调整它们之间的依赖关系<br><img src="https://user-gold-cdn.xitu.io/2018/5/15/16364599d4727672?w=456&amp;h=405&amp;f=png&amp;s=64878" alt="" title="image.png"></p><h3 id="3-2-Abstraction（抽象）"><a href="#3-2-Abstraction（抽象）" class="headerlink" title="3.2 Abstraction（抽象）"></a>3.2 Abstraction（抽象）</h3><p>之前也说过当你走向图的中间时，东西变得更加抽象。 这是有道理的：抽象往往比细节更加稳定，就像搭积木一样根基越稳越好。</p><p>举个例子比如我们可以将抽象接口定义为“加载网络图片”并将其放入内层，业务逻辑就可以使用它来显示图片。 另一方面，我们可以通过实现改接口调用具体的图片加载库glide或者Picasso，然后将该实现放入外层。业务逻辑可以使用加载图片功能而无需知道实现细节的任何内容。这样抵御了变化的风险，日后换成什么方式加载图片，洋葱内部的抽象业务逻辑是不会感知到的</p><h3 id="3-3-Communication-between-layers（层之间的通信）"><a href="#3-3-Communication-between-layers（层之间的通信）" class="headerlink" title="3.3 Communication between layers（层之间的通信）"></a>3.3 Communication between layers（层之间的通信）</h3><p>既然已经划分好了层，分离了内容，将业务逻辑放在应用程序的架构中心和架构边缘的实现细节中，一切看起来都很棒。 但是你可能很快遇到了一个有趣的问题。<br>如果你的UI是一个实现细节，那么internet也是一个实现细节，业务逻辑介于两者之间，<strong>我们如何从internet获取数据，通过业务逻辑传递它，然后将其发送到屏幕？</strong><br>组合和继承的就要发挥功效了</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/15/16364599d7039681?w=665&amp;h=447&amp;f=png&amp;s=107878" alt="" title="image.png"></p><h2 id="4、实践"><a href="#4、实践" class="headerlink" title="4、实践"></a>4、实践</h2><p>下面用代码示意一下，以RSS Reader 为例我们的用户应该能够管理他们的RSS提要订阅，从提要中获取文章并阅读它们。这里是数据流问题，用例介于表示层和数据层之间。 我们如何建立层之间的沟通？ 记住那些输入和输出端口？<br><img src="https://user-gold-cdn.xitu.io/2018/5/15/16364599d7eca624?w=888&amp;h=466&amp;f=png&amp;s=49877" alt="" title="image.png"></p><p>从上图可以看出我们的 Use Case必须实现输入端口（接口）。 Presenter在 Use Case上调用方法，数据流向 Use Case（feedId）。 Use Case映射feedId提供文章并希望将它们发送回表示层。 它有一个对输出端口（回调）的引用，因为输出端口是在同一层定义的，因此它调用了一个方法。 因此，数据发送到输出端口 - Presenter。</p><p>让我们从domain层开始，创建我们的核心业务模型和逻辑。</p><p>我们的商业模式非常简单：</p><ul><li>Feed - 持有RSS提要相关数据，如网址，缩略图网址，标题和说明</li><li>Article -保存文章相关数据，如文章标题，网址和发布日期</li></ul><p>我们的逻辑，我们将使用UseCases。 他们在简洁的类中封装了小部分业务逻辑。 他们都将实施通用的UseCase 契约接口：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UseCase</span>&lt;<span class="title">P</span>, <span class="title">R</span>&gt;</span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span>&lt;<span class="title">R</span>&gt;</span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(R return)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span></span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(P parameter, Callback&lt;R&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"> callback)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CompletableUseCase</span>&lt;<span class="title">P</span>&gt;</span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span></span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(P parameter, Callback callback)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UseCase接口是输入端口，Callback接口是输出端口，GetFeedArticlesUseCase实现如下  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetFeedArticlesUseCase</span> <span class="keyword">implements</span> <span class="title">UseCase</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">Integer</span>, <span class="title">List</span>&lt;<span class="title">Article</span>&gt;&gt;</span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> FeedRepository feedRepository;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Integer feedId, <span class="keyword">final</span> Callback&lt;List&lt;Article&gt;&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"> callback)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> callback.onSuccess(feedRepository.getFeedArticles(feedId));</span><br><span class="line"> &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable throwable) &#123;</span><br><span class="line"> callback.onError(throwable);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>然后到洋葱外面的UI实现，View有一个简单的契约类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">showArticles</span><span class="params">(List&lt;ArticleViewModel&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"> feedArticles)</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">showErrorMessage</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">showLoadingIndicator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该视图的Presenter具有非常简单的显示逻辑。 它获取文章，将它们映射到view odels并传递到View，再看下FeedArticlesPresenter：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeedArticlesPresenter</span> <span class="keyword">implements</span> <span class="title">UseCase</span>.<span class="title">Callback</span>&lt;<span class="title">List</span>&lt;<span class="title">Article</span>&gt;&gt;</span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> GetFeedArticlesUseCase getFeedArticlesUseCase;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> ViewModeMapper viewModelMapper;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fetchFeedItems</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> feedId)</span> </span>&#123;</span><br><span class="line"> getFeedArticlesUseCase.execute(feedId, <span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">final</span> List&lt;Article&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"> articles)</span> </span>&#123;</span><br><span class="line"> getView().showArticles(viewModelMapper.mapArticlesToViewModels(articles));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="keyword">final</span> Throwable throwable)</span> </span>&#123;</span><br><span class="line"> getView().showErrorMessage();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>到这里可以看出FeedArticlesPresenter实现了Callback接口，并将其自身传递给use case，它实际上是use case的输出端口，并以这种方式关闭了数据流</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/15/16364599d8d3d3ff?w=892&amp;h=472&amp;f=png&amp;s=76180" alt="" title="image.png"></p><p>谷歌架构项目上也有个 <a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean/" target="_blank" rel="noopener">todo-mvp-clean</a>分支可以看下具体玩法。</p><h2 id="5、小结"><a href="#5、小结" class="headerlink" title="5、小结"></a>5、小结</h2><p>这个跟设计模式中依赖倒置和接口隔离有着密不可分的关系，通过依赖倒置，只依赖于抽象而不是细节，将细节的实现倒置到实现类中，这样洋葱的核心就是清清爽爽的业务逻辑（抽象）；</p><p>通常一个良好的架构一般需要满足以下几点：</p><ol><li>Satisfy a multitude of stakeholders.（满足各方利益者）</li><li>Encourage separation of concerns.（鼓励的关注点分离）</li><li>Run away from the real world (Android, DB, Internet…).即高度的抽象</li><li>Enable your components to be testable.（使您的组件成为可测试的）</li></ol><p>但是一个架构往往针对特定的场景，架构也是需要慢慢演进的，比如后面的模块化、插件化等等都是业务发展到一定程度，当前架构的弊端慢慢的凸显需要更新。但不管如何变化，一些核心基本点还是相伴相随，比如依赖翻转、面向接口编程、关注点分离等都是我们需要点亮的技能点之一。</p><p>##参考</p><p>1、<a href="http://five.agency/blog/android/" target="_blank" rel="noopener">http://five.agency/blog/android/</a><br>2、<a href="http://five.agency/android-architecture-part-1-every-new-beginning-is-hard/" target="_blank" rel="noopener">http://five.agency/android-architecture-part-1-every-new-beginning-is-hard/</a><br>3、<a href="http://five.agency/android-architecture-part-2-clean-architecture/" target="_blank" rel="noopener">http://five.agency/android-architecture-part-2-clean-architecture/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;1、clean架构简介&quot;&gt;&lt;a href=&quot;#1、clean架构简介&quot; class=&quot;headerlink&quot; title=&quot;1、clean架构简介&quot;&gt;&lt;/a&gt;1、c
      
    
    </summary>
    
      <category term="架构" scheme="https://xsfelvis.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="clean" scheme="https://xsfelvis.github.io/tags/clean/"/>
    
  </entry>
  
  <entry>
    <title>几个权限库分析</title>
    <link href="https://xsfelvis.github.io/2018/04/21/%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%902%20%E5%87%A0%E4%B8%AA%E6%9D%83%E9%99%90%E5%BA%93%E5%88%86%E6%9E%90/"/>
    <id>https://xsfelvis.github.io/2018/04/21/动态权限2 几个权限库分析/</id>
    <published>2018-04-20T16:00:00.000Z</published>
    <updated>2018-06-06T07:33:00.094Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>权限系列</p><ul><li><a href="https://xsfelvis.github.io/2018/04/06/%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%901/">动态权限基础</a></li><li><a href="https://xsfelvis.github.io/2018/04/21/%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%902%20%E5%87%A0%E4%B8%AA%E6%9D%83%E9%99%90%E5%BA%93%E5%88%86%E6%9E%90/">几个权限库分析</a></li></ul><p>有比较多的权限库,由浅入深先看简单的开开胃</p><h2 id="PermissionGen"><a href="#PermissionGen" class="headerlink" title="PermissionGen"></a>PermissionGen</h2><h3 id="核心源码分析"><a href="#核心源码分析" class="headerlink" title="核心源码分析"></a>核心源码分析</h3><p><a href="https://github.com/lovedise/PermissionGen" target="_blank" rel="noopener">PermissionGen</a>  </p><p>该库比较早 看提交是3年前了 通过看该库的readme可以了解这个库的使用方式，通过链式调用比较易于配置</p><p>核心类图如下：<br><img src="https://user-gold-cdn.xitu.io/2018/5/15/16364446c046e010" alt="" title="image.png"></p><p>将权限涉及到核心api封装到框架之中，干掉冗余函数，使用者只关心功能函数即可。</p><p>涉及到的比较核心的一个点就是，<code>通过注解的方式直接回调权限成功、失败的函数</code></p><p>When it succeeded in obtaining permission</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PermissionSuccess</span>(requestCode = <span class="number">100</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">Toast.makeText(<span class="keyword">this</span>, <span class="string">"Contact permission is granted"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When it failed in obtaining permission</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PermissionFail</span>(requestCode = <span class="number">100</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFailSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">Toast.makeText(<span class="keyword">this</span>, <span class="string">"Contact permission is not granted"</span>, t.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心的处理逻辑在<code>PermissionGen\#requestPermissions\(Object object, int requestCode, String\[\] permissions\)</code>中，最终通过反射调取 PermissionFail和PermissionSucess注解的函数</p><p>通过这种方式干掉了冗余代码，让用户专注于业务的开发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">requestPermissions</span><span class="params">(Object object, <span class="keyword">int</span> requestCode, String[] permissions)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!Utils.isOverMarshmallow()) &#123;</span><br><span class="line">      doExecuteSuccess(object, requestCode);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; deniedPermissions = Utils.findDeniedPermissions(getActivity(object), permissions);</span><br><span class="line">    <span class="keyword">if</span>(deniedPermissions.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(object <span class="keyword">instanceof</span> Activity)&#123;</span><br><span class="line">        ((Activity)object).requestPermissions(deniedPermissions.toArray(<span class="keyword">new</span> String[deniedPermissions.size()]), requestCode);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(object <span class="keyword">instanceof</span> Fragment)&#123;</span><br><span class="line">        ((Fragment)object).requestPermissions(deniedPermissions.toArray(<span class="keyword">new</span> String[deniedPermissions.size()]), requestCode);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(object.getClass().getName() + <span class="string">" is not supported"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      doExecuteSuccess(object, requestCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executeMethod</span><span class="params">(Object activity, Method executeMethod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(executeMethod != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!executeMethod.isAccessible()) executeMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        executeMethod.invoke(activity, <span class="keyword">null</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出反射函数只能无参函数 其中拿到activity或者fragment的注解方法在Utils的方法中，这里可以学习一下反射的一些用法，比如查找对应注解的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;A extends Annotation&gt; <span class="function">Method <span class="title">findMethodWithRequestCode</span><span class="params">(Class clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;A&gt; annotation, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Method method : clazz.getDeclaredMethods())&#123;</span><br><span class="line">      <span class="keyword">if</span>(method.isAnnotationPresent(annotation))&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEqualRequestCodeFromAnntation(method, annotation, requestCode))&#123;</span><br><span class="line">          <span class="keyword">return</span> method;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>这个库比较简单有一些优缺点：<br>优点：初步封装了权限的核心函数的，省去了冗余代码；可以学习反射的一些用法</p><p>缺点：</p><p>（1）大量使用反射（可以使用apt），</p><p>（2）api设计不是很合理</p><p> 链式调用往往是平级调用方法，但是现在这个明显是有先后顺序的，一不留神容易写错</p><h2 id="MPermissions"><a href="#MPermissions" class="headerlink" title="MPermissions"></a>MPermissions</h2><p><a href="https://github.com/hongyangAndroid/MPermissions" target="_blank" rel="noopener">MPermissions</a></p><p>这个是鸿洋在PermissionGen基础上做了一些优化，作者说是使用apt解决了运行时反射的问题，优化了对外提供的api，因为申请只需要三个参数，抛弃了使用原本类库的单例的方式，直接一个几个静态方法，简单整洁暴力。</p><p>看了一下代码，主要是核心类MPermissions操作接口，间接操作实现该接口的APT生成类(依赖翻转，面向接口编程)</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/15/16364446c11d972d" alt="" title="image.png"></p><p>可以学习的一些点：</p><h4 id="2-1-APT-编译前找不到类"><a href="#2-1-APT-编译前找不到类" class="headerlink" title="2.1 APT 编译前找不到类"></a>2.1 APT 编译前找不到类</h4><p>面向接口编程，APT代码生成代码实现这个接口就可以，</p><p>权限类的核心能力通过接口提供</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PermissionProxy</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">grant</span><span class="params">(T source, <span class="keyword">int</span> requestCode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">denied</span><span class="params">(T source, <span class="keyword">int</span> requestCode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rationale</span><span class="params">(T source, <span class="keyword">int</span> requestCode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">needShowRationale</span><span class="params">(<span class="keyword">int</span> requestCode)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>功能类跟接口层交互即可</p><h4 id="2-2-APT技术"><a href="#2-2-APT技术" class="headerlink" title="2.2 APT技术"></a>2.2 APT技术</h4><p>通过APT生成一些重复的模板代码非常有用，关于APT技术在之前的博客多有提及就不再赘述了。<br>不过APT也有它的弊端就是APT 的工作原理是在编译 class 时，通过 Annotation 生成源代码，而在 Android 构建的过程中，像 滴滴出行乘客端 这样的集成方式，所有的模块都是 AAR 的方式来集成构建的，没有机会去同时编译所有的 class，这时候就需要新的手段来生成代码了，比如构建gradle的task在编译前扫描全局结合javapoet生成代码，在这个库里可以学习一下apt processor的异常处理有助于我们定位代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void error(Element element, String message, Object... args) &#123;</span><br><span class="line">    if (args.length &gt; 0) &#123;</span><br><span class="line">        message = String.format(message, args);</span><br><span class="line">    &#125;</span><br><span class="line">    processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, message, element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>作者仅仅是通过APT生成了模板代码，但是还是使用到反射生成实现代理接口的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> PermissionProxy <span class="title">findPermissionProxy</span><span class="params">(Object activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class clazz = activity.getClass();</span><br><span class="line">        Class injectorClazz = Class.forName(clazz.getName() + SUFFIX);</span><br><span class="line">        <span class="keyword">return</span> (PermissionProxy) injectorClazz.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(String.format(<span class="string">"can not find %s , something when compiler."</span>, activity.getClass().getSimpleName() + SUFFIX));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个APT代理的思想还是值得我们去借鉴的</p><h2 id="PermissionsDispatcher"><a href="#PermissionsDispatcher" class="headerlink" title="PermissionsDispatcher"></a>PermissionsDispatcher</h2><p>这个库目前有7726个start，而且有自己的<a href="https://permissions-dispatcher.github.io/PermissionsDispatcher/" target="_blank" rel="noopener">网站</a>指导说明，俨然是动态权限三方库的一哥，看来这个库需要好好分析一下</p><p>从官方这个库使用起来也非常简单，仔细看了下代码发现大同小异，跟前面两个库使用的方式很像，通过注解的方式标记 权限申请成功、权限事情失败、权限弹窗说明等函数调用，唯一多的是：</p><p>1、需要使用动态权的 <code>Activity</code> or <code>Fragment</code>(we support both) to handle permissions加上RuntimePermissions注解</p><p>这个库更多是将所有的逻辑处理放在了权限生成类 xxxPermissionDispatcher类，（生成代码承担了很多的逻辑处理）而不像MPermission库中仅仅将用户使用的功能代码，比如权限成功、失败之类的函数规整到生成类中，核心逻辑还是通过开发者自己代码处理，这样更容易写这个库，用户阅读代码也比较方便</p><p>个人更加倾向于 MPermission</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;权限系列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://xsfelvis.github.io/2018/04/06/%E5%8A%A8%E6%80%81%E6%
      
    
    </summary>
    
      <category term="开源学习" scheme="https://xsfelvis.github.io/categories/%E5%BC%80%E6%BA%90%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="权限" scheme="https://xsfelvis.github.io/tags/%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>动态权限</title>
    <link href="https://xsfelvis.github.io/2018/04/06/%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%901/"/>
    <id>https://xsfelvis.github.io/2018/04/06/动态权限1/</id>
    <published>2018-04-05T16:00:00.000Z</published>
    <updated>2018-06-05T09:53:56.166Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>权限系列</p><ul><li><a href="https://xsfelvis.github.io/2018/04/06/%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%901/">动态权限基础</a></li><li><a href="https://xsfelvis.github.io/2018/04/21/%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%902%20%E5%87%A0%E4%B8%AA%E6%9D%83%E9%99%90%E5%BA%93%E5%88%86%E6%9E%90/">几个权限库分析</a></li></ul><h2 id="1、在给app升级动态权限之前需要注意搞清楚一下几个概念"><a href="#1、在给app升级动态权限之前需要注意搞清楚一下几个概念" class="headerlink" title="1、在给app升级动态权限之前需要注意搞清楚一下几个概念"></a>1、在给app升级动态权限之前需要注意搞清楚一下几个概念</h2><h3 id="1-1、版本号对应的api等级"><a href="#1-1、版本号对应的api等级" class="headerlink" title="1.1、版本号对应的api等级"></a>1.1、版本号对应的api等级</h3><p>查阅官网可以看出</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/15/16364387f6eeb9fc?w=1714&amp;h=1262&amp;f=png&amp;s=192923" alt=""></p><h3 id="1-2、minSdkVersion、targetSdkVersion和-compileSdkVersion"><a href="#1-2、minSdkVersion、targetSdkVersion和-compileSdkVersion" class="headerlink" title="1.2、minSdkVersion、targetSdkVersion和 compileSdkVersion"></a>1.2、minSdkVersion、targetSdkVersion和 compileSdkVersion</h3><p>这几个属性通常在gradle defaultConfig中去配置，作用如下</p><p>（1）minSdkVersion<br>指明应用程序运行所需的最小API level，如果系统的API level低于minSdkVersion设定的值，那么android系统会阻止用户安装这个应用，如果不指明的话，默认是1，如果指明这个属性，并在项目中使用了改与这个API level的API的话，那么将会在编译时报错。<br>可见该属性不仅在程序安装时起作用，而且会在项目构建时起作用</p><p>（2）targetSdkVersion</p><p>指明应用程序目标API level的一个整数，如果不设置就默认和minSdkVersion相同。这个属性通知系统，已经针对这个目标版本测试过程序，系统不必使用兼容模式来让你的应用程序向前兼容这个目标版本。<br>如果targetSdkVersion为19（对应为Android4.4），应用运行时，最高只能使用API 19的新特性。即使代码中使用了API 23的新特性，实际运行时，也不会使用该新特性；<br>可见targetSdkVersion这个属性是在程序运行时期起作用的，系统根据这个属性决定要不要以兼容模式运行这个程序<br>例如，Android6.0系统增加了动态权限机制，如果为了追时髦，盲目把你的targetSDKVersion设置为23(6.0)，那么在需要使用权限的地方将会出现异常。为此，在你做好动态权限申请之前，为保障APP正常运行，你需要将目标版本设置低于23。</p><p>（3）complieSdkVersion</p><p>compileSdkVersion仅仅是告诉Gradle使用哪个版本的SDK编译应用，不会被包含到apk中，完全不影响应用的运行结果；虽然没有影响但是</p><p>即 ：compileSDKVersion是和编译器打交道的，而minSDKVersion和targetSDKVersion是和系统打交道的。</p><h2 id="2、如何升级app的动态权限"><a href="#2、如何升级app的动态权限" class="headerlink" title="2、如何升级app的动态权限"></a>2、如何升级app的动态权限</h2><p>首先需要了解动态权限这个概念</p><h3 id="2-1-动态权限"><a href="#2-1-动态权限" class="headerlink" title="2.1 动态权限"></a>2.1 动态权限</h3><p>这个是在android 6.0提出的，从该版本开始，用户实在运行时而不是应用安装时授予或者撤销应用权限，对应API23,这个版本最重要的变化就是权限动态管理，任何未被授予权限的逻辑都可能引起后续运行的崩溃，可以通过adb 工具从命令行获取权限</p><p>按组列出权限和状态： </p><blockquote><p>$ adb shell pm list permissions -d -g</p></blockquote><p>授予或撤销一项或多项权限：</p><blockquote><p>$ adb shell pm [grant|revoke] <permission-name> …</permission-name></p></blockquote><p>6.0之前的权限在AndroidMenifest声明之后即可获取所有权限，这样会造成用户会默默忍受一些不必要的权限，特别是通讯录，位置短信之类的比较敏感的权限，在6.0之后我们只有在需要权限的时候才会向用户请求，用户可以选择拒绝，新的机制较好的保护的用户的隐私。<br>谷歌将权限分为两大类<br>Normal Permissions<br>这类权限一般不涉及用户隐私是不需要用户进行授权的，比如网络访问、蓝牙（详细权限见附录）<br>Dangenerous Permission<br>这类涉及到用户隐私，需要用户进行授权，比如读取sdcard、开启照相机、访问通讯录等，其中危险权限是分组的，用户之前如果已经选择通过该组某个危险权限，主要有以下几组（详细权限见附录）</p><ol><li>身体传感器</li><li>日历 摄像头</li><li>通讯录</li><li>地理位置</li><li>麦克风</li><li>电话</li><li>短信</li><li>存储空间  </li></ol><h3 id="2-2-权限相关API"><a href="#2-2-权限相关API" class="headerlink" title="2.2 权限相关API"></a>2.2 权限相关API</h3><p>为了方便开发者实现权限管理，谷歌给出下面4个API</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/15/1636438febbcbeb9?w=894&amp;h=494&amp;f=png&amp;s=66186" alt=""></p><p>一般权限检查需要以下三个步骤配合</p><p>1、检查权限是否授予</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Activity.java</span><br><span class="line">&gt; public int checkSelfPermission(permission)</span><br></pre></td></tr></table></figure><p>这个是在ContextCompat类中用来判断是否app已经获取到某一个权限的使用权。如果返回android.content.pm.PackageManager#PERMISSION_GRANTED，则说明app被授予权限，如果返回android.content.pm.PackageManager#PERMISSION_DENIED 则说明权限被禁止授予</p><p>2、申请权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Activity.java</span><br><span class="line">public final void requestPermissions( new String[permission1,permission2,...], requestCode)</span><br></pre></td></tr></table></figure><p>这个是在ActivityCompat类以及FragmentCompat类中用来申请权限的方法</p><p>3、权限回调<br>用户在系统弹窗里面选择以后结果会通过Activity的onRequestPermissionsResult<br>方法回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults)</span><br><span class="line">&#123;</span><br><span class="line">    //继续执行逻辑或者提示权限获取失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些方法可以封装在BaseActvity中</p><p>4、是否显示权限对话框<br>这个是作为辅助类</p><blockquote><p>public static boolean shouldShowRequestPermissionRationale(@NonNull Activity activity, @NonNull String permission)<br>这个是在ActivityCompat类以及FragmentCompat类中用来判断是否显示权限询问对话框。在权限申请的过程中，如果用户选择允许权限使用或者在拒绝的同时又勾选了不再询问对话框，这2种情况下该api就会返回false，表示不再弹出权限询问对话框，其中授权弹窗是不支持自定义的</p></blockquote><p>这个辅助函数十分重要，当动态权限申请时候如果用户如果用户勾选了“不再询问”，那么在执行requestPermissions( )后，onRequestPermissionsResult( )会永远返回PERMISSION_DENIED，这样应用原本的操作将永远无法执行，这是我们不希望看到的</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/15/163643a25ce67cd9?w=1010&amp;h=766&amp;f=png&amp;s=122723" alt=""><br>谷歌还是给我们留了一手，就是<br>shouldShowRequestPermissionRationale，如果返回true，应用应该弹出dialog说明申请权限的缘由比如下面这种</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/15/163643a66ad3eb69?w=1100&amp;h=522&amp;f=png&amp;s=49564" alt=""></p><p>其中第一次申请权限时候该函数默认返回false，无需告知用户申请该权限的理由;当第一次申请被拒绝，再次申请时该函数会返回true，并且弹出的系统dialog上会有一个选择“不再询问”，要是用户勾选了该选项，则以后该函数一直会返回false。</p><h3 id="2-3-如何适配"><a href="#2-3-如何适配" class="headerlink" title="2.3 如何适配"></a>2.3 如何适配</h3><p>如果项目的targetSdkVersion &lt; 23 运行在android 6.0及以上的系统上，会默认给与AndroidManifest.xml中申请的权限，是不是这样就万事大吉了呢？显然是想多了，如果用户在应用的权限页面手动回收权限，将会导致应用crash</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/15/163643b31c161434?w=1064&amp;h=1200&amp;f=png&amp;s=235446" alt=""></p><p>虽然系统提醒了用户，但是还是要取决用户心情，因此稳妥的适配动态还是有必要的事情。</p><p>首先targetSdkVersion小于23的应用默认授予了所申请的所有权限，所以如果你以前的APP设置的targetSdkVersion低于23，也能正常使用。等于或者大于23，则必须 request permission,否则会崩溃闪退。<br>下面将大致阐述一下升级动态权限步骤</p><p>（1）声明目标版本sdk<br>修改build.gradle中targetSdkVersion为23以上</p><p>（2）检查权限申请地方并request权限<br>在我们需要使用到权限的地方，检查是否已经拥有权限，比如读写外置SD卡权限，我们在写入之前检车是否有权限，没有权限则申请权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void requestContactPermission() &#123;</span><br><span class="line">        if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_CONTACTS)</span><br><span class="line">                != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            //申请 WRITE_CONTACTS 权限</span><br><span class="line">            ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.WRITE_CONTACTS&#125;,</span><br><span class="line">                    REQUEST_CODE_WRITE_CONTACTS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"> ```  </span><br><span class="line"></span><br><span class="line">（3）响应用户权限回调</span><br><span class="line"></span><br><span class="line">用户可以选择allow或者deny，可能deny。回调onRequestPermissionsResult方法, 该方法类似于onActivityResult。如果是fragment，最好是使用父fragment，但不是使用ActivityCompat。建议使用getParentFragment().requestPermissions方法。  </span><br><span class="line"></span><br><span class="line">（4）根据requestCode和grandResult（授权结果）做相应处理</span><br></pre></td></tr></table></figure><p>private void handleGrantResults(int requestCode, int[] grantResults) {<br>      if (requestCode == WRITE_EXTERNAL_STORAGE_REQUEST_CODE) {<br>          if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {<br>              // Permission Granted 获得权限后执行xxx<br>          } else {<br>              // Permission Denied 拒绝后xx的操作。<br>          }<br>      }<br>  }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 3、后话</span><br><span class="line"></span><br><span class="line">### 3.1、权限申请如果用户拒绝怎么处理</span><br><span class="line">如果用户拒绝了核心权限一次，下次再次申请会出现不再提醒的选项，要是选择不再提醒，核心权限不给获取一些功能就无法使用，你可以选择直接退出应用，或者可以优雅点，我们自己检测一下是否拒绝了两次或者以上，自己给个提示向用户做一个交互</span><br></pre></td></tr></table></figure></p><p>private void handleContactPermission() {<br>        if (Integer.parseInt(Build.VERSION.SDK)&gt;=23) {<br>            int hasWriteContactsPermission = checkSelfPermission(Manifest.permission.WRITE_CONTACTS);<br>            if (hasWriteContactsPermission != PackageManager.PERMISSION_GRANTED) {<br>                if (!shouldShowRequestPermissionRationale(Manifest.permission.WRITE_CONTACTS)) {<br>                    showMessageOKCancel(“You need to allow access to Contacts”,<br>                            new DialogInterface.OnClickListener() {<br>                                @Override<br>                                public void onClick(DialogInterface dialog, int which) {<br>                                    requestContactPermission();//确定后申请权限。<br>                                }<br>                            });<br>                    return;<br>                }<br>                requestContactPermission();//没有权限的话，申请。<br>            }<br>        }<br>```<br>或者记录用户勾选了不再询问<br>Google提供了一个非常好的思路，详见EasyPermissions .<br>EasyPermissions并没有存储上一次shouldShowRequestPermissionRationale( )的返回值，而是在申请权限被拒后调用shouldShowRequestPermissionRationale( )方法，如果此时返回false则说明用户勾选了“不再询问”。</p><p>两种方式都可以作为参考方式。</p><h3 id="3-2-取消支持Apache-http-客户端"><a href="#3-2-取消支持Apache-http-客户端" class="headerlink" title="3.2 取消支持Apache http 客户端"></a>3.2 取消支持Apache http 客户端</h3><p>Android 6.0 版移除了对 Apache HTTP 客户端的支持。如果您的应用使用该客户端，并以 Android 2.3（API 级别 9）或更高版本为目标平台，请改用HttpURLConnection 类。此 API 效率更高，因为它可以通过透明压缩和响应缓存减少网络使用，并可最大限度降低耗电量。要继续使用 Apache HTTP API，您必须先在 build.gradle 文件中声明以下编译时依赖项：<br>  android {<br>      useLibrary ‘org.apache.http.legacy’<br>  }</p><h3 id="3-3-升级到7-0-api-24及以上"><a href="#3-3-升级到7-0-api-24及以上" class="headerlink" title="3.3 升级到7.0 api 24及以上"></a>3.3 升级到7.0 api 24及以上</h3><p>对于面向 Android 7.0 的应用，Android 框架执行的 StrictMode API 政策禁止在您的应用外部公开 file:// URI。如果一项包含文件 URI 的 intent 离开您的应用，则应用出现故障，并出现 FileUriExposedException 异常，常见的是访问升级下载到内部sd卡，访问手机相册等。<br>网上有很多解决方案</p><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote><p>Normal Permissions</p></blockquote><p>ACCESS_LOCATION_EXTRA_COMMANDS</p><p>ACCESS_NETWORK_STATE</p><p>ACCESS_NOTIFICATION_POLICY</p><p>ACCESS_WIFI_STATE</p><p>BLUETOOTH</p><p>BLUETOOTH_ADMIN</p><p>BROADCAST_STICKY</p><p>CHANGE_NETWORK_STATE</p><p>CHANGE_WIFI_MULTICAST_STATE</p><p>CHANGE_WIFI_STATE</p><p>DISABLE_KEYGUARD</p><p>EXPAND_STATUS_BAR</p><p>GET_PACKAGE_SIZE</p><p>INSTALL_SHORTCUT</p><p>INTERNET</p><p>KILL_BACKGROUND_PROCESSES</p><p>MODIFY_AUDIO_SETTINGS</p><p>NFC</p><p>READ_SYNC_SETTINGS</p><p>READ_SYNC_STATS</p><p>RECEIVE_BOOT_COMPLETED</p><p>REORDER_TASKS</p><p>REQUEST_INSTALL_PACKAGES</p><p>SET_ALARM</p><p>SET_TIME_ZONE</p><p>SET_WALLPAPER</p><p>SET_WALLPAPER_HINTS</p><p>TRANSMIT_IR</p><p>UNINSTALL_SHORTCUT</p><p>USE_FINGERPRINT</p><p>VIBRATE</p><p>WAKE_LOCK</p><p>WRITE_SYNC_SETTINGS</p><blockquote><p>Dangenerous Permission</p></blockquote><p>group:android.permission-group.CONTACTS<br>  permission:android.permission.WRITE_CONTACTS<br>  permission:android.permission.GET_ACCOUNTS<br>  permission:android.permission.READ_CONTACTS</p><p>group:android.permission-group.PHONE<br>  permission:android.permission.READ_CALL_LOG<br>  permission:android.permission.READ_PHONE_STATE<br>  permission:android.permission.CALL_PHONE<br>  permission:android.permission.WRITE_CALL_LOG<br>  permission:android.permission.USE_SIP<br>  permission:android.permission.PROCESS_OUTGOING_CALLS<br>  permission:com.android.voicemail.permission.ADD_VOICEMAIL</p><p>group:android.permission-group.CALENDAR<br>  permission:android.permission.READ_CALENDAR<br>  permission:android.permission.WRITE_CALENDAR</p><p>group:android.permission-group.CAMERA<br>  permission:android.permission.CAMERA</p><p>group:android.permission-group.SENSORS<br>  permission:android.permission.BODY_SENSORS</p><p>group:android.permission-group.LOCATION<br>  permission:android.permission.ACCESS_FINE_LOCATION<br>  permission:android.permission.ACCESS_COARSE_LOCATION</p><p>group:android.permission-group.STORAGE<br>  permission:android.permission.READ_EXTERNAL_STORAGE<br>  permission:android.permission.WRITE_EXTERNAL_STORAGE</p><p>group:android.permission-group.MICROPHONE<br>  permission:android.permission.RECORD_AUDIO</p><p>group:android.permission-group.SMS<br>  permission:android.permission.READ_SMS<br>  permission:android.permission.RECEIVE_WAP_PUSH<br>  permission:android.permission.RECEIVE_MMS<br>  permission:android.permission.RECEIVE_SMS<br>  permission:android.permission.SEND_SMS<br>  permission:android.permission.READ_CELL_BROADCASTS</p><p>###参考链接</p><ul><li>1、<a href="https://source.android.com/source/build-numbers" target="_blank" rel="noopener">https://source.android.com/source/build-numbers</a> </li><li>2、<a href="https://www.jianshu.com/p/06e55a322f6f" target="_blank" rel="noopener">https://www.jianshu.com/p/06e55a322f6f</a></li><li>3、<a href="https://developer.android.com/about/versions/marshmallow/android-6.0-changes?hl=zh-cn" target="_blank" rel="noopener">Android 6.0变更</a></li><li>4、<a href="https://developer.android.com/about/versions/marshmallow/android-6.0-changes?hl=zh-cn#behavior-runtime-permissions" target="_blank" rel="noopener">运行时权限</a> </li><li>5、<a href="developer.android.com/intl/zh-cn/training/permissions/best-practices.html#testing">Permissions Best Practices</a></li><li>6、<a href="developer.android.com/intl/zh-cn/training/permissions/index.html">Working with System Permissions</a></li><li>7、<a href="https://blog.csdn.net/andrexpert/article/details/53331836" target="_blank" rel="noopener">探讨Android 6.0及以上新权限系统的检测与处理</a></li><li>8、<a href="https://mp.weixin.qq.com/s/ye7RTgPuIbBS4RCH-jDWAA" target="_blank" rel="noopener">Android 权限机制与适配经验</a></li><li>9、<a href="https://blog.csdn.net/dzsw0117/article/details/51212612" target="_blank" rel="noopener">Android 6.0权限管理，sdk&gt;=23请求权限</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;权限系列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://xsfelvis.github.io/2018/04/06/%E5%8A%A8%E6%80%81%E6%
      
    
    </summary>
    
      <category term="Android" scheme="https://xsfelvis.github.io/categories/Android/"/>
    
    
      <category term="权限" scheme="https://xsfelvis.github.io/tags/%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>Service</title>
    <link href="https://xsfelvis.github.io/2017/10/31/Service/"/>
    <id>https://xsfelvis.github.io/2017/10/31/Service/</id>
    <published>2017-10-30T16:00:00.000Z</published>
    <updated>2018-06-06T07:26:16.774Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="service"><a href="#service" class="headerlink" title="service"></a>service</h1><p>本篇博文主要介绍Service相关知识，具体目录如下</p><p><img src="https://i.imgur.com/RjNWNs2.png" alt=""></p><h2 id="0x00-什么是Service"><a href="#0x00-什么是Service" class="headerlink" title="0x00 什么是Service"></a>0x00 什么是Service</h2><ul><li>Service是一个应用程序组件，可以在后台长时间运行的操作，不提供用户界面；</li><li>一个应用程序可以启动一个服务，它将继续在后台运行，即使用户切换到另外一个应用</li><li>一个组件可以绑定到一个服务与它交互，甚至执行进程间通信(IPC)，如处理网络传输、音乐播放、执行文件I/O，与content provider进行交互等。</li></ul><h2 id="0x01-服务的分类"><a href="#0x01-服务的分类" class="headerlink" title="0x01 服务的分类"></a>0x01 服务的分类</h2><ul><li><p>按照运行地点分类</p><p>|           类别           |         区别         |                                                                                                        优点                                                                                                       | 缺点                                                                  | 应用                                             |<br>|:————————:|:——————–:|:—————————————————————————————————————————————————————————————————————–:|———————————————————————–|————————————————–|<br>| 本地服务(Local Service)  | 该服务依附在主进程上 | 服务依附在主进程上而不是独立的进程，这样在一定程度上节约了资源，另外Local服务因为是在同一进程因此不需要IPC，也不需要AIDL。相应bindService会方便很多。                                                             | 主进程被Kill后，服务便会终止。                                        | 如：音乐播放器播放等不需要常驻的服务。           |<br>| 远程服务(Remote Service) | 该服务是独立的进程   | 服务为独立的进程，对应进程名格式为所在包名加上你指定的android:process字符串。由于是独立的进程，因此在Activity所在进程被Kill的时候，该服务依然在运行，不受其他进程影响，有利于为多个进程提供服务具有较高的灵活性。 | 该服务是独立的进程，会占用一定资源，并且使用AIDL进行IPC稍微麻烦一点。 | 一些提供系统服务的Service，这种Service是常驻的。 |</p></li></ul><ul><li>按运行类型分类</li></ul><table><thead><tr><th style="text-align:center">类别</th><th style="text-align:center">区别</th><th>应用</th></tr></thead><tbody><tr><td style="text-align:center">前台服务</td><td style="text-align:center">会在通知栏显示onGoing的 Notification</td><td>当服务被终止的时候，通知一栏的 Notification 也会消失，这样对于用户有一定的通知作用。常见的如音乐播放服务。</td></tr><tr><td style="text-align:center">后台服务</td><td style="text-align:center">默认的服务即为后台服务，即不会在通知一栏显示 onGoing的 Notification。</td><td>当服务被终止的时候，用户是看不到效果的。某些不需要运行或终止提示的服务，如天气更新，日期同步，邮件同步等。</td></tr></tbody></table><ul><li>按使用方式分类</li></ul><table><thead><tr><th style="text-align:center">类别</th><th style="text-align:center">区别</th></tr></thead><tbody><tr><td style="text-align:center">startService启动的服务</td><td style="text-align:center">主要用于启动一个服务执行后台任务，不进行通信。停止服务使用stopService。</td></tr><tr><td style="text-align:center">bindService启动的服务</td><td style="text-align:center">方法启动的服务要进行通信。停止服务使用unbindService。</td></tr><tr><td style="text-align:center">同时使用startService、bindService 启动的服务</td><td style="text-align:center">停止服务应同时使用stopService与unbindService。</td></tr></tbody></table><h2 id="0x02-生命周期"><a href="#0x02-生命周期" class="headerlink" title="0x02 生命周期"></a>0x02 生命周期</h2><p>如使用方式分类所提，service使用常分为两大类，start、bind</p><ul><li><p>如果一个应用程序组件（比如一个activity）通过调用startService()来启动服务，则该服务就是被“started”了。一旦被启动，服务就能在后台一直运行下去，即使启动它的组件已经被销毁了。<br>通常，started的服务执行单一的操作并且不会向调用者返回结果。比如，它可以通过网络下载或上传文件。当操作完成后，服务应该自行终止。</p></li><li><p>如果一个应用程序组件通过调用bindService()绑定到服务上，则该服务就是被“bound”了。bound服务提供了一个客户端/服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至可以利用进程间通信（IPC）跨进程执行这些操作。绑定服务的生存期和被绑定的应用程序组件一致。<br>多个组件可以同时与一个服务绑定，不过所有的组件解除绑定后，服务也就会被销毁。</p></li></ul><p>二者的生命周期如下：</p><p><img src="https://i.imgur.com/36H22oh.png" alt=""></p><p>对应的方法解释如下：</p><ul><li>4个手动调用的方法</li></ul><table><thead><tr><th style="text-align:center">手动调用方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">startService()</td><td style="text-align:center">启动服务</td></tr><tr><td style="text-align:center">stopService()</td><td style="text-align:center">关闭服务</td></tr><tr><td style="text-align:center">stopSelf()</td><td style="text-align:center">关闭服务</td></tr><tr><td style="text-align:center">bindService()</td><td style="text-align:center">绑定服务</td></tr><tr><td style="text-align:center">unbindService()</td><td style="text-align:center">解绑服务</td></tr></tbody></table><ul><li>5个内部调用的方法</li></ul><table><thead><tr><th style="text-align:center">内部调用的方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">onCreat()</td><td style="text-align:center">创建服务</td></tr><tr><td style="text-align:center">onStartCommand()</td><td style="text-align:center">开始服务</td></tr><tr><td style="text-align:center">onDestroy()</td><td style="text-align:center">销毁服务</td></tr><tr><td style="text-align:center">onBind()</td><td style="text-align:center">绑定服务</td></tr><tr><td style="text-align:center">onUnbind()</td><td style="text-align:center">解绑服务</td></tr></tbody></table><p>其中需要注意以下几点：</p><ul><li>startService()和stopService()只能开启和关闭Service，无法操作Service；bindService()和unbindService()可以操作Service</li><li>startService开启的Service，调用者退出后Service仍然存在；BindService开启的Service，调用者退出后，Service随着调用者销毁。</li></ul><h2 id="0x03-如何使用"><a href="#0x03-如何使用" class="headerlink" title="0x03 如何使用"></a>0x03 如何使用</h2><p>建议参照demo学习<a href="https://github.com/xsfelvis/ServiceAIDLStudyDemo.git" target="_blank" rel="noopener">https://github.com/xsfelvis/ServiceAIDLStudyDemo.git</a></p><p><img src="https://i.imgur.com/YrN3X1w.png" alt=""></p><p><strong>本地Service(startService)</strong></p><p>通过start启动的service一旦被启动，服务一般会在后台一直运行即使启动它的的组件已经销毁了，而且<code>不会像调用者返回结果</code>，如可以通过它进行网络下载或者上传文件，当操作完成后，该服务自行终止。</p><blockquote><p>Step 1 在AndroidManifest中注册Service</p></blockquote><p>其中一些相关属性需要重点说明下：</p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">说明</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:center">android:name</td><td style="text-align:center">Service的类名</td><td></td></tr><tr><td style="text-align:center">android:label</td><td style="text-align:center">Service的名字</td><td>若不设置默认为Service类名</td></tr><tr><td style="text-align:center">android:icon</td><td style="text-align:center">Service的图标</td><td></td></tr><tr><td style="text-align:center">android:permission</td><td style="text-align:center">申明此Service的权限</td><td>有提供了该权限的应用才能控制或连接此服务</td></tr><tr><td style="text-align:center">android:process</td><td style="text-align:center">表示该服务是否在另一个进程中运行（远程服务)</td><td>不设置默认为本地服务；remote则设置成远程服务</td></tr><tr><td style="text-align:center">android:enabled</td><td style="text-align:center">系统默认启动</td><td>true：Service 将会默认被系统启动；不设置则默认为false</td></tr><tr><td style="text-align:center">android:exported</td><td style="text-align:center">该服务是否能够被其他应用程序所控制或连接</td><td>不设置默认此项为 false</td></tr></tbody></table><blockquote><p>step 2 新建子类继承自Service类</p></blockquote><p>需要重写onCreate()、onStartCommand()、onDestroy()和onBind()方法</p><blockquote><p>step 3 构建用于启动Service的intent对象</p><p>step 4 调用startService启动，调用stopService/stopSelf停止服务</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里配置一些信息</span></span><br><span class="line">    <span class="comment">//启动运行服务的线程。</span></span><br><span class="line">    <span class="comment">//请记住我们要创建一个单独的线程，因为服务通常运行于进程的主线程中，可我们不想阻塞主线程。</span></span><br><span class="line">    <span class="comment">//我们还要赋予它后台运行的优先级，以便计算密集的工作不会干扰我们的UI。</span></span><br><span class="line">    HandlerThread handlerThread = <span class="keyword">new</span> HandlerThread(TAG);</span><br><span class="line">    handlerThread.start();</span><br><span class="line">    <span class="comment">//获取handlerThread的loop队列并用于Handler</span></span><br><span class="line">    mServiceLooper = handlerThread.getLooper();</span><br><span class="line">    mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</span><br><span class="line">    Log.d(TAG, <span class="string">"onCreate"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    msgStr = intent.getStringExtra(<span class="string">"startService"</span>);</span><br><span class="line">    Log.d(TAG, <span class="string">"onStartCommand getExtraString = "</span> + msgStr);</span><br><span class="line">    <span class="comment">//对于每一个启动请求，都发送一个消息来启动一个处理</span></span><br><span class="line">    <span class="comment">//同时传入启动ID，以便任务完成后我们知道该终止哪一个请求。</span></span><br><span class="line">    Message message = mServiceHandler.obtainMessage();</span><br><span class="line">    message.arg1 = <span class="number">1</span>;</span><br><span class="line">    mServiceHandler.sendMessage(message);</span><br><span class="line">    <span class="comment">//如果我们被杀死了，那从这里返回之后被重启</span></span><br><span class="line">    <span class="keyword">return</span> START_STICKY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Service也是运行在主线程中，如果需要执行一些耗时操作需要放到相应的子线程中处理，谷歌内置了一个<code>IntentService(异步处理服务)</code>，</p><p>它会新开一个线程：handlerThread在线程中发消息，然后接受处理完成后，会清理线程，并且关掉服务。</p><p>IntentService有以下特点：</p><p>（1） 它创建了一个独立的工作线程来处理所有的通过onStartCommand()传递给服务的intents。</p><p>（2） 创建了一个工作队列，来逐个发送intent给onHandleIntent()。</p><p>（3） 不需要主动调用stopSelft()来结束服务。因为，在所有的intent被处理完后，系统会自动关闭服务。</p><p>（4） 默认实现的onBind()返回null</p><p>（5） 默认实现的onStartCommand()的目的是将intent插入到工作队列中</p><p>其中intentService在5.0系统中需要显示启动</p><p>在之前的例子中我们自己手动维护了一个handleThread去处理耗时操作，intentService已经自带了，然后用户只要是实现onHandleIntent去处理新的业务即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IntentService从缺省的工作线程中调用本方法，并用启动服务的intent作为参数。</span></span><br><span class="line"><span class="comment"> * 本方法返回后，IntentService将适时终止这个服务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(@Nullable Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据Intent的不同进行不同的事务处理</span></span><br><span class="line">    String taskName = intent.getExtras().getString(<span class="string">"taskName"</span>);</span><br><span class="line">    <span class="keyword">switch</span> (taskName) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"task1"</span>:</span><br><span class="line">            Log.d(TAG, <span class="string">"do task1"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"task2"</span>:</span><br><span class="line">            Log.d(TAG, <span class="string">"do task2"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两种均在demo中有所实现</p><p><strong>可通信Service(bind) </strong></p><blockquote><p>如果一个应用程序组件通过调用bindService()绑定到服务上，bound服务提供了一个客户端/服务器接口，<code>允许组件与服务进行交互、发送请求、获取结果，甚至可以利用进程间通信（IPC）跨进程执行这些操作</code>。绑定服务的生存期和被绑定的应用程序组件一致。多个组件可以同时与一个服务绑定，不过所有的组件解除绑定后，服务也就会被销毁。</p></blockquote><ul><li><p>使用场景<br>当客户端和服务位于同一个应用程序的进程中，(如一个音乐应用需要把Activity绑定到它自己的后台音乐播放上)</p></li><li><p>使用步骤</p></li></ul><ol><li><p>在你的服务中创建一个Binder的实例，通常需要实现以下3点之一</p><ul><li>包含了可供客户端调用的公共方法，如demo中的 <code>getHelloBoundService()</code>方法</li><li>返回当前Service实例，其中包含了可供客户端调用的公共方法，如demo中的<code>getRandomNumber</code></li><li>或者，返回内含服务类的其它类的一个实例，服务中包含了可供客户端调用的公共方法，</li></ul></li><li><p>从回调方法onBinder()返回Binder的实例</p></li><li>在客户端中，在回调方法onServiceConnected()中接收Binder并用所提供的方法对绑定的服务进行调用，不过服务和客户端之所以必须位于同一个应用程序中，是为了让客户端能够正确转换（cast）返回的对象并调用对象的API。<br>服务和客户端也必须位于同一个进程中，因为这种方式不能执行任何跨进程的序列化（marshalling）操作。</li></ol><ul><li>Tips</li></ul><ol><li>在没有bind时执行unbind，会报Service not registered crash，可以增加标志位控制bind、unbind可以参看demo中的unbind操作</li><li>ServiceConnection中重写2个方法<code>onServiceConnected</code>、<code>onServiceDisconnected</code>，其中bindService会触发onServiceConnected，而unbinderService不会触发onServiceDisconnected；<code>onServiceDisconnected</code>在系统在内存不足的时候可以优先杀死这个服务</li></ol><p><strong>前台service</strong></p><p>前台service和后台service最大的区别在于</p><ul><li>前台service在下来通知栏有显示通知，但是后台service没有</li><li>前台service优先级较高，不会由于系统内存不足而被回收，而后台service优先级比较低，当系统出现内存不足情况时有可能被回收</li></ul><p>与普通service使用类似，核心是增加构建通知部分的处理，具体可以查看demo中代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//API11之后构建Notification的方式</span></span><br><span class="line">    Notification.Builder builder = <span class="keyword">new</span> Notification.Builder(<span class="keyword">this</span>);</span><br><span class="line">    Intent frontServiceIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MainActivity.class);</span><br><span class="line">    PendingIntent frontServicePeningIntent = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">0</span>, frontServiceIntent, <span class="number">0</span>);</span><br><span class="line">    builder.setContentIntent(frontServicePeningIntent)</span><br><span class="line">            .setContentTitle(<span class="string">"下拉列表中的Title"</span>)</span><br><span class="line">            .setContentText(<span class="string">"要显示的内容"</span>)</span><br><span class="line">            .setSmallIcon(R.mipmap.ic_front_small)</span><br><span class="line">            .setLargeIcon(BitmapFactory.decodeResource(<span class="keyword">this</span>.getResources(), R.mipmap.ic_front_big))</span><br><span class="line">            .setWhen(System.currentTimeMillis());</span><br><span class="line">    Notification notification = builder.getNotification();</span><br><span class="line">    notification.defaults = Notification.DEFAULT_SOUND;</span><br><span class="line">    <span class="comment">// 参数一：唯一的通知标识；参数二：通知消息。</span></span><br><span class="line">    startForeground(<span class="number">110</span>, notification);<span class="comment">// 开始前台服务</span></span><br><span class="line">    <span class="keyword">return</span> START_STICKY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>远程service</strong></p><p>主要是为了让Service与多个应用程序的组件进行跨进程通信(IPC)，这里涉及到两个概念</p><ul><li>IPC：Inter-Process Communication，即跨进程通信</li><li>AIDL：Android Interface Definition Language，即Android接口定义语言；用于让某个Service与多个应用程序组件之间进行跨进程通信，从而可以实现多个应用程序共享同一个Service的功能。</li></ul><p>AIDL（Android 接口定义语言）与您可能使用过的其他 IDL 类似。 您可以利用它定义客户端与服务使用进程间通信 (IPC) 进行相互通信时都认可的编程接口。 在 Android 上，一个进程通常无法访问另一个进程的内存。 尽管如此，进程需要将其对象分解成操作系统能够识别的原语，并将对象编组成跨越边界的对象。 编写执行这一编组操作的代码是一项繁琐的工作，因此 Android 会使用 AIDL 来处理。</p><p>并且谷歌特意注明了AIDL使用的场景</p><blockquote><p>注：只有允许不同应用的客户端用 IPC 方式访问服务，并且想要在服务中处理多线程时，才有必要使用 AIDL。 如果您不需要执行跨越不同应用的并发 IPC，就应该通过实现一个 Binder 创建接口；或者，如果您想执行 IPC，但根本不需要处理多线程，则使用 Messenger 类来实现接口。无论如何，在实现 AIDL 之前，请您务必理解绑定服务。</p></blockquote><p>首先新建一个aidl文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IAidlService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">aidlService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后make一下，在build/generated/source/aidl文件下生成一个接口文件</p><p>在使用到通信的地方使用这个接口文件中的api，AIDLService1.Stub.asInterface()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mAidlServiceConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写onServiceConnected()方法和onServiceDisconnected()方法</span></span><br><span class="line">    <span class="comment">//在Activity与Service建立关联和解除关联的时候调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在Activity与Service建立关联时调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用AIDLService1.Stub.asInterface()方法将传入的IBinder对象传换成了mServerAidlService对象</span></span><br><span class="line">        mServerAidlService = IAidlService.Stub.asInterface(service);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过该对象调用在MyAIDLService.aidl文件中定义的接口方法,从而实现跨进程通信</span></span><br><span class="line">            mServerAidlService.aidlService();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>可以看出二者不在一个线程中</p><p><img src="https://i.imgur.com/u6dBylu.png" alt=""><br><img src="https://i.imgur.com/cbwBY5P.png" alt=""></p><p>具体代码在demo中~</p><h2 id="0x04-一些容易混淆的点"><a href="#0x04-一些容易混淆的点" class="headerlink" title="0x04 一些容易混淆的点"></a>0x04 一些容易混淆的点</h2><p><strong>Service和Thread的区别</strong></p><p>官方有两点描述</p><ul><li>1.A Service is not a separate process. The Service object itself does<br>not imply it is running in its own process; unless otherwise specified,<br>it runs in the same process as the application it is part of.</li><li>2.A Service is not a thread. It is not a means itself to do work off<br>of the main thread (to avoid Application Not Responding errors).</li></ul><p>第二点清楚提到不是一个thread，只是有些时候二者均工作在后台而已。</p><p>service和调用者之间的通讯都是同步的（不论是远程service还是本地service），它跟线程一点关系都没有！</p><p><strong>service和intentService之间区别</strong></p><ul><li>1.Service：依赖于应用程序的主线程不要误以为是独立的进程 or 线程，因此不能处理耗时操作,否则就会报ANR(Activity—–&gt;5秒<br>Broadcast—–&gt;10秒,Service—–&gt;20秒)，而intentService内部启动一个HandleThread工作线程来去处理耗时任务</li><li><ol><li>Service需要主动调用stopSelf()来结束服务，而IntentService不需要（在所有intent被处理完后，系统会自动关闭服务，内部调用了stopself()方法）</li></ol></li></ul><p><strong>IntentService与线程的区别</strong></p><ul><li>intentService内部采用了HandlerThread实现，作用类似于后台线程；与后台线程相比，IntentService是一种后台服务，优势是：优先级高（不容易被系统杀死），从而保证任务的执行</li><li>在应用中，如果是长时间的在后台运行，而且不需要交互的情况下，使用服务。</li><li>同样是在后台运行，不需要交互的情况下，如果只是完成某个任务，之后就不需要运行，而且可能是多个任务，需要长时间运行的情况下使用线程。</li><li>如果任务占用CPU时间多，资源大的情况下，要使用线程。</li></ul><h2 id="0x05-小结"><a href="#0x05-小结" class="headerlink" title="0x05 小结"></a>0x05 小结</h2><p>service是Android 四大组件之一，掌握好它对平时的开发有着莫大益处，本文只是介绍了service的常见用法和一些容易混淆的点，还有一些深入的点比如aidl数据传递、自定义notification定制化和在不同android版本的坑，这些都需要在实际开发中遇到再去针对性处理了~</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://developer.android.com/guide/components/services.html?hl=zh-cn" target="_blank" rel="noopener">https://developer.android.com/guide/components/services.html?hl=zh-cn</a></li><li><a href="https://developer.android.com/guide/components/bound-services.html?hl=zh-cn" target="_blank" rel="noopener">https://developer.android.com/guide/components/bound-services.html?hl=zh-cn</a></li><li><a href="https://developer.android.com/guide/components/aidl.html?hl=zh-cn" target="_blank" rel="noopener">https://developer.android.com/guide/components/aidl.html?hl=zh-cn</a></li><li><a href="http://www.jianshu.com/p/1e49e93c3ec8" target="_blank" rel="noopener">http://www.jianshu.com/p/1e49e93c3ec8</a></li><li><a href="http://www.jianshu.com/p/8d0cde35eb10" target="_blank" rel="noopener">http://www.jianshu.com/p/8d0cde35eb10</a></li><li><a href="http://blog.csdn.net/luoyanglizi/article/details/51980630" target="_blank" rel="noopener">http://blog.csdn.net/luoyanglizi/article/details/51980630</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;service&quot;&gt;&lt;a href=&quot;#service&quot; class=&quot;headerlink&quot; title=&quot;service&quot;&gt;&lt;/a&gt;service&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="Android" scheme="https://xsfelvis.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://xsfelvis.github.io/tags/Android/"/>
    
      <category term="Service" scheme="https://xsfelvis.github.io/tags/Service/"/>
    
  </entry>
  
  <entry>
    <title>仿知乎创新广告</title>
    <link href="https://xsfelvis.github.io/2017/05/22/%E4%BB%BF%E7%9F%A5%E4%B9%8E%E5%88%9B%E6%96%B0%E5%B9%BF%E5%91%8A/"/>
    <id>https://xsfelvis.github.io/2017/05/22/仿知乎创新广告/</id>
    <published>2017-05-21T16:00:00.000Z</published>
    <updated>2018-06-06T06:38:54.760Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="1、效果描述"><a href="#1、效果描述" class="headerlink" title="1、效果描述"></a>1、效果描述</h3><p>知乎看到的一种非常有特色的广告展现方式，即在列表页，某一个Item显示背后部分广告图，随着列表滚动，会逐渐展示全部图片。  </p><p><img src="https://rishiqing-file.oss-cn-beijing.aliyuncs.com/1513259506589GIF.gif?Expires=1526540309&amp;OSSAccessKeyId=JZJNf7zIXqCHwLpT&amp;Signature=ygBAc9kD0a1kMYiqKL2fEAMtals%3D" alt="" title="GIF.gif"></p><h3 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h3><ul><li>2.1 实现思路</li></ul><p>在需要列表滚动时候，改变图片的显示部分</p><p>有两个核心点</p><ol><li><p>捕获列表滚动变化的dy，不管是ListView还是RecyclerView都可以做到</p></li><li><p>图片显示部分变化，可以利用canvas.translate</p></li></ol><p>方案一：</p><p>自定义view，自己去绘制bitmap，对外暴露setDy（dy），然后根据dy做canvas.translate偏移重绘即可</p><p>方案二：(更优)</p><p>利用Drawable本身就是可以绘制的，直接利用drawable去完成，当然还是要结合canvas.translate</p><p>注意super.onDrawer的调用时机</p><h3 id="3、涉及到的技术点"><a href="#3、涉及到的技术点" class="headerlink" title="3、涉及到的技术点"></a>3、涉及到的技术点</h3><ul><li>3.1 ImageView:ScaleType</li></ul><blockquote><p>不进行缩放:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATRIX </span><br><span class="line">CENTER : 不改变原图大小从ImageView的左上角开始绘制，超过ImageView部分不再显示。</span><br></pre></td></tr></table></figure><blockquote><p>等比例缩放</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CENTER_CROP: 对原图居中显示后进行等比放缩处理，使原图最小边等于ImageView的相应边。</span><br><span class="line"></span><br><span class="line">CENTER_INSIDE: 若原图宽高小于ImageView宽高，这原图不做处理居中显示，否则按比例放缩原图宽(高)是之等于ImageView的宽(高)。 </span><br><span class="line"></span><br><span class="line">FIT_START: 对原图按比例放缩使之等于ImageView的宽高，若原图高大于宽则左对齐否则上对齐。 </span><br><span class="line"></span><br><span class="line">FIT_CENTER: 对原图按比例放缩使之等于ImageView的宽高使之居中显示。 </span><br><span class="line"></span><br><span class="line">FIT_END: 对原图按比例放缩使之等于ImageView的宽高，若原图高大于宽则右对齐否则下对齐。</span><br></pre></td></tr></table></figure><blockquote><p>不等比例缩放</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FIT_XY： 对原图宽高进行放缩，该放缩不保持原比例来填充满ImageView。</span><br></pre></td></tr></table></figure><blockquote><p>图片信息可能丢失</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MATRIX </span><br><span class="line">CENTER ： 不缩放就有可能丢失 </span><br><span class="line"></span><br><span class="line">CENTER_CROP</span><br></pre></td></tr></table></figure><blockquote><p>图片过小时不会放大的情况</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">不缩放肯定就不会放大 MATRIX </span><br><span class="line">CENTER</span><br><span class="line"></span><br><span class="line">CENTER_INSIDE</span><br></pre></td></tr></table></figure><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="http://mp.weixin.qq.com/s/BHbmtfUzg3XTaGrGcX5-bg" target="_blank" rel="noopener">http://mp.weixin.qq.com/s/BHbmtfUzg3XTaGrGcX5-bg</a>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;1、效果描述&quot;&gt;&lt;a href=&quot;#1、效果描述&quot; class=&quot;headerlink&quot; title=&quot;1、效果描述&quot;&gt;&lt;/a&gt;1、效果描述&lt;/h3&gt;&lt;p&gt;知乎看到
      
    
    </summary>
    
      <category term="实践" scheme="https://xsfelvis.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Android" scheme="https://xsfelvis.github.io/tags/Android/"/>
    
      <category term="知乎广告" scheme="https://xsfelvis.github.io/tags/%E7%9F%A5%E4%B9%8E%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>编译期注解处理之APT</title>
    <link href="https://xsfelvis.github.io/2017/04/07/%E7%BC%96%E8%AF%91%E6%9C%9F%E6%B3%A8%E8%A7%A3%E4%B9%8BAPT/"/>
    <id>https://xsfelvis.github.io/2017/04/07/编译期注解之APT/</id>
    <published>2017-04-06T16:00:00.000Z</published>
    <updated>2018-06-06T06:08:03.937Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>注解系列</p><ul><li><a href="https://xsfelvis.github.io/2017/01/06/%E6%B3%A8%E8%A7%A3%E5%9F%BA%E7%A1%80/">注解基础</a></li><li><a href="https://xsfelvis.github.io/2017/03/12/%E7%BC%96%E8%AF%91%E6%9C%9F%E6%B3%A8%E8%A7%A3%E4%B9%8BJavaPoet/">JavaPoet</a></li><li><a href="https://xsfelvis.github.io/2017/04/07/%E7%BC%96%E8%AF%91%E6%9C%9F%E6%B3%A8%E8%A7%A3%E4%B9%8BAPT/">编译期注解处理之APT</a></li></ul><h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>前一篇介绍了注解的基本知识以及常见用法，由于运行期(RunTime)利用反射去获取信息还是比较损耗性能的，本篇将介绍一种使用注解更加优雅的方式，编译期(Compile time)注解，以及处理编译期注解的手段APT和Javapoet,限于篇幅，本篇着重介绍APT<br>首先你的注解需要声明为CLASS<br>@Retention(RetentionPolicy.CLASS)  </p><p>编译期解析注解基本原理：<br>在某些代码元素上（如类型、函数、字段等）添加注解，在编译时编译器会检查AbstractProcessor的子类，并且调用该类型的process函数，然后将添加了注解的所有元素都传递到process函数中，使得开发人员可以在编译器进行相应的处理，例如，根据注解生成新的Java类，这也就是ButterKnife等开源库的基本原理。</p><h2 id="0x01-APT"><a href="#0x01-APT" class="headerlink" title="0x01 APT"></a>0x01 APT</h2><p>在处理编译器注解的第一个手段就是APT(Annotation Processor Tool),即注解处理器。在java5的时候已经存在，但是java6开始的时候才有可用的API，最近才随着butterknife这些库流行起来。本章将阐述什么是注解处理器，以及如何使用这个强大的工具。</p><blockquote><p>什么是APT</p></blockquote><p>APT是一种处理注解的工具，确切的说它是javac的一个工具，它用来在编译时扫描和处理注解，一个注解的注解处理器，以java代码(或者编译过的字节码)作为输入，生成.java文件作为输出，核心是交给自己定义的处理器去处理，</p><blockquote><p>如何使用</p></blockquote><p>每个自定义的处理器都要继承虚处理器，实现其关键的几个方法</p><ul><li>继承虚处理器 AbstractProcessor</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment env)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment env)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面重点介绍下这几个函数：</p><ol><li><code>init(ProcessingEnvironment env)</code>: 每一个注解处理器类都必须有一个空的构造函数。然而，这里有一个特殊的init()方法，它会被注解处理工具调用，并输入ProcessingEnviroment参数。ProcessingEnviroment提供很多有用的工具类Elements, Types和Filer</li><li><code>process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</code>: 这相当于每个处理器的主函数main()。你在这里写你的扫描、评估和处理注解的代码，以及生成Java文件。输入参数RoundEnviroment，可以让你查询出包含特定注解的被注解元素。这是一个布尔值，表明注解是否已经被处理器处理完成，官方原文<code>whether or not the set of annotations are claimed by this processor</code>，通常在处理出现异常直接返回false、处理完成返回true。</li><li><code>getSupportedAnnotationTypes()</code>: 必须要实现；用来表示这个注解处理器是注册给哪个注解的。返回值是一个字符串的集合，包含本处理器想要处理的注解类型的合法全称。</li><li><code>getSupportedSourceVersion()</code>: 用来指定你使用的Java版本。通常这里返回SourceVersion.latestSupported()，你也可以使用SourceVersion_RELEASE_6、7、8</li></ol><ul><li>注册 处理器</li></ul><p>由于处理器是javac的工具，因此我们必须将我们自己的处理器注册到javac中，在以前我们需要提供一个.jar文件，打包你的注解处理器到此文件中，并在在你的jar中，需要打包一个特定的文件 <code>javax.annotation.processing.Processor到META-INF/services路径下</code><br>把MyProcessor.jar放到你的builpath中，javac会自动检查和读取javax.annotation.processing.Processor中的内容，并且注册MyProcessor作为注解处理器。</p><p>超级麻烦有木有，不过不要慌，谷歌baba给我们开发了AutoService注解，你只需要引入这个依赖，然后在你的解释器第一行加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@AutoService(Processor.class)</span><br></pre></td></tr></table></figure><p>然后就可以自动生成META-INF/services/javax.annotation.processing.Processor文件的。省去了打jar包这些繁琐的步骤。</p><blockquote><p>APT中的Elements和TypeMirrors</p></blockquote><p>在前面的init()中我们可以获取如下引用</p><ul><li>Elements：一个用来处理Element的工具类</li><li>Types：一个用来处理TypeMirror的工具类</li><li>Filer：正如这个名字所示，使用Filer你可以创建文件(通常与javapoet结合)</li></ul><p>在注解处理过程中，我们扫面所有的Java源文件。源文件的每一个部分都是一个特定类型的Element</p><p>先来看一下Element</p><p>对于编译器来说 代码中的元素结构是基本不变的，如，组成代码的基本元素包括包、类、函数、字段、变量的等，JDK为这些元素定义了一个基类也就是<code>Element</code>类</p><p>Element有五个直接子类，分别代表一种特定类型</p><table><thead><tr><th>PackageElement</th><th>表示一个包程序元素，可以获取到包名等</th></tr></thead><tbody><tr><td>TypeElement</td><td>表示一个类或接口程序元素</td></tr><tr><td>VariableElement</td><td>表示一个字段、enum 常量、方法或构造方法参数、局部变量或异常参数</td></tr><tr><td>ExecutableElement</td><td>表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注解类型元素</td></tr><tr><td>TypeParameterElement</td><td>表示一般类、接口、方法或构造方法元素的泛型参数</td></tr></tbody></table><p>开发中Element可根据实际情况强转为以上5种中的一种，它们都带有各自独有的方法，如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;    <span class="comment">// PackageElement</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;        <span class="comment">// TypeElement</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;      <span class="comment">// VariableElement</span></span><br><span class="line">    <span class="keyword">private</span> Test other;  <span class="comment">// VariableElement</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span> <span class="params">()</span> </span>&#123;&#125;    <span class="comment">// ExecuteableElement</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span> <span class="params">(  // ExecuteableElement</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> newA   // TypeElement</span></span></span><br><span class="line"><span class="function"><span class="params">                     )</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再举个栗子🌰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解因为只能作用于函数类型，因此，它对应的元素类型就是ExecutableElement当我们想通过APT处理这个注解的时候就可以获取目标对象上的Test注解，并且将所有这些元素转换为ExecutableElement元素，以便获取到他们对应的信息。</p><p>查看其代码定义</p><p>定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">** </span><br><span class="line"> * 表示一个程序元素，比如包、类或者方法，有如下几种子接口： </span><br><span class="line"> * ExecutableElement：表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注解类型元素 ； </span><br><span class="line"> * PackageElement：表示一个包程序元素； </span><br><span class="line"> * TypeElement：表示一个类或接口程序元素； </span><br><span class="line"> * TypeParameterElement：表示一般类、接口、方法或构造方法元素的形式类型参数； </span><br><span class="line"> * VariableElement：表示一个字段、<span class="keyword">enum</span> 常量、方法或构造方法参数、局部变量或异常参数 </span><br><span class="line"> */  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> <span class="keyword">extends</span> <span class="title">AnnotatedConstruct</span> </span>&#123;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 返回此元素定义的类型 </span></span><br><span class="line"><span class="comment">     * 例如，对于一般类元素 C&lt;N extends Number&gt;，返回参数化类型 C&lt;N&gt; </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function">TypeMirror <span class="title">asType</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 返回此元素的种类：包、类、接口、方法、字段...,如下枚举值 </span></span><br><span class="line"><span class="comment">     * PACKAGE, ENUM, CLASS, ANNOTATION_TYPE, INTERFACE, ENUM_CONSTANT, FIELD, PARAMETER, LOCAL_VARIABLE, EXCEPTION_PARAMETER, </span></span><br><span class="line"><span class="comment">     * METHOD, CONSTRUCTOR, STATIC_INIT, INSTANCE_INIT, TYPE_PARAMETER, OTHER, RESOURCE_VARIABLE; </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function">ElementKind <span class="title">getKind</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 返回此元素的修饰符,如下枚举值 </span></span><br><span class="line"><span class="comment">     * PUBLIC, PROTECTED, PRIVATE, ABSTRACT, DEFAULT, STATIC, FINAL, </span></span><br><span class="line"><span class="comment">     * TRANSIENT, VOLATILE, SYNCHRONIZED, NATIVE, STRICTFP; </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function">Set&lt;Modifier&gt; <span class="title">getModifiers</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 返回此元素的简单名称,例如 </span></span><br><span class="line"><span class="comment">     * 类型元素 java.util.Set&lt;E&gt; 的简单名称是 "Set"； </span></span><br><span class="line"><span class="comment">     * 如果此元素表示一个未指定的包，则返回一个空名称； </span></span><br><span class="line"><span class="comment">     * 如果它表示一个构造方法，则返回名称 "&lt;init&gt;"； </span></span><br><span class="line"><span class="comment">     * 如果它表示一个静态初始化程序，则返回名称 "&lt;clinit&gt;"； </span></span><br><span class="line"><span class="comment">     * 如果它表示一个匿名类或者实例初始化程序，则返回一个空名称 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function">Name <span class="title">getSimpleName</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 返回封装此元素的最里层元素。 </span></span><br><span class="line"><span class="comment">     * 如果此元素的声明在词法上直接封装在另一个元素的声明中，则返回那个封装元素； </span></span><br><span class="line"><span class="comment">     * 如果此元素是顶层类型，则返回它的包； </span></span><br><span class="line"><span class="comment">     * 如果此元素是一个包，则返回 null； </span></span><br><span class="line"><span class="comment">     * 如果此元素是一个泛型参数，则返回 null. </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function">Element <span class="title">getEnclosingElement</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 返回此元素直接封装的子元素 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    List&lt;? extends Element&gt; getEnclosedElements();  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 返回直接存在于此元素上的注解 </span></span><br><span class="line"><span class="comment">     * 要获得继承的注解，可使用 getAllAnnotationMirrors </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    List&lt;? extends AnnotationMirror&gt; getAnnotationMirrors();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 返回此元素针对指定类型的注解（如果存在这样的注解），否则返回 null。注解可以是继承的，也可以是直接存在于此元素上的 </span></span><br><span class="line"><span class="comment">     */</span>   </span><br><span class="line">    &lt;A extends Annotation&gt; <span class="function">A <span class="title">getAnnotation</span><span class="params">(Class&lt;A&gt; annotationType)</span></span>; </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//接受访问者的访问 （？？）</span></span><br><span class="line">     &lt;R, P&gt; <span class="function">R <span class="title">accept</span><span class="params">(ElementVisitor&lt;R, P&gt; var1, P var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一个，并没有使用到，感觉不太好理解，查了资料这个函数接受一个ElementVisitor和类型为P的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ElementVisitor</span>&lt;<span class="title">R</span>, <span class="title">P</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//访问元素</span></span><br><span class="line">    <span class="function">R <span class="title">visit</span><span class="params">(Element e, P p)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">R <span class="title">visit</span><span class="params">(Element e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问包元素</span></span><br><span class="line">    <span class="function">R <span class="title">visitPackage</span><span class="params">(PackageElement e, P p)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问类型元素</span></span><br><span class="line">    <span class="function">R <span class="title">visitType</span><span class="params">(TypeElement e, P p)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//访问变量元素</span></span><br><span class="line">    <span class="function">R <span class="title">visitVariable</span><span class="params">(VariableElement e, P p)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问克而执行元素</span></span><br><span class="line">    <span class="function">R <span class="title">visitExecutable</span><span class="params">(ExecutableElement e, P p)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问参数元素</span></span><br><span class="line">    <span class="function">R <span class="title">visitTypeParameter</span><span class="params">(TypeParameterElement e, P p)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理位置的元素类型，这是为了应对后续Java语言的扩折而预留的接口，例如后续元素类型添加了，那么通过这个接口就可以处理上述没有声明的类型</span></span><br><span class="line">    <span class="function">R <span class="title">visitUnknown</span><span class="params">(Element e, P p)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ElementgVisitor中定义了多个visit接口，每个接口处理一种元素类型，这就是典型的访问者模式。我们制定，一个类元素和函数元素是完全不一样的，他们的结构不一样，因此，在编译器对他们的操作肯定是不一样，通过访问者模式正好可以解决数据结构与数据操作分离的问题，避免某些操作污染数据对象类。</p><p>因此，代码在APT眼中只是一个结构化的文本而已。Element代表的是源代码。TypeElement代表的是源代码中的类型元素，例如类。然而，TypeElement并不包含类本身的信息。你可以从TypeElement中获取类的名字，但是你获取不到类的信息，例如它的父类。这种信息需要通过TypeMirror获取。你可以通过调用elements.asType()获取元素的TypeMirror。</p><h2 id="0x02-辅助接口"><a href="#0x02-辅助接口" class="headerlink" title="0x02 辅助接口"></a>0x02 辅助接口</h2><p>在自定义注解器的初始化时候，可以获取以下4个辅助接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;  </span><br><span class="line">    </span><br><span class="line">      <span class="keyword">private</span> Types typeUtils;  </span><br><span class="line">      <span class="keyword">private</span> Elements elementUtils;  </span><br><span class="line">      <span class="keyword">private</span> Filer filer;  </span><br><span class="line">      <span class="keyword">private</span> Messager messager;  </span><br><span class="line">    </span><br><span class="line">      <span class="meta">@Override</span>  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;  </span><br><span class="line">          <span class="keyword">super</span>.init(processingEnv);  </span><br><span class="line">          typeUtils = processingEnv.getTypeUtils();  </span><br><span class="line">          elementUtils = processingEnv.getElementUtils();  </span><br><span class="line">          filer = processingEnv.getFiler();  </span><br><span class="line">          messager = processingEnv.getMessager();  </span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>Filer </li></ul><p>一般配合JavaPoet来生成需要的java文件（下一篇将详细介绍javaPoet）</p><ul><li>Messager</li></ul><p>Messager提供给注解处理器一个报告错误、警告以及提示信息的途径。它不是注解处理器开发者的日志工具，而是用来写一些信息给使用此注解器的第三方开发者的。在官方文档中描述了消息的不同级别中非常重要的是Kind.ERROR，因为这种类型的信息用来表示我们的注解处理器处理失败了。很有可能是第三方开发者错误的使用了注解。这个概念和传统的Java应用有点不一样，在传统Java应用中我们可能就抛出一个异常Exception。如果你在process()中抛出一个异常，那么运行注解处理器的JVM将会崩溃（就像其他Java应用一样），使用我们注解处理器第三方开发者将会从javac中得到非常难懂的出错信息，因为它包含注解处理器的堆栈跟踪（Stacktace）信息。因此，注解处理器就有一个Messager类，它能够打印非常优美的错误信息。除此之外，你还可以连接到出错的元素。在像现在的IDE（集成开发环境）中，第三方开发者可以直接点击错误信息，IDE将会直接跳转到第三方开发者项目的出错的源文件的相应的行。</p><ul><li>Types</li></ul><p>Types是一个用来处理TypeMirror的工具</p><ul><li>Elements</li></ul><p>Elements是一个用来处理Element的工具</p><h2 id="0x03-优缺点"><a href="#0x03-优缺点" class="headerlink" title="0x03 优缺点"></a>0x03 优缺点</h2><blockquote><p>优点(结合javapoet)</p></blockquote><ul><li>对代码进行标记、在编译时收集信息并做处理</li><li>生成一套独立代码，辅助代码运行</li></ul><blockquote><p>缺点</p></blockquote><ul><li>可以自动生成代码，但在运行时需要主动调用</li><li>如果要生成代码需要编写模板函数</li></ul><h2 id="0x04-其他"><a href="#0x04-其他" class="headerlink" title="0x04 其他"></a>0x04 其他</h2><ol><li><p>通常我们需要分离处理器和注解<br>这样做的原因是，在发布程序时注解及生成的代码会被打包到用户程序中，而注解处理器则不会（注解处理器是在编译期在JVM上运行跟运行时无关）。要是不分离的话，假如注解处理器中使用到了其他第三方库，那就会占用系统资源，特别是方法数，</p></li><li><p>该技术可以让我们在设计自己框架时候多了一种技术选择，更加的优雅</p></li><li><p>反射优化</p></li></ol><p>运行时注解的使用可以减少很多代码的编写，但是谁都知道这是有性能损耗的，不过权衡利弊，我们选择了妥协，这个技术手段可以处理这个问题</p><h2 id="0x05-参考文献"><a href="#0x05-参考文献" class="headerlink" title="0x05 参考文献"></a>0x05 参考文献</h2><ul><li><a href="http://hannesdorfmann.com/annotation-processing/annotationprocessing101" target="_blank" rel="noopener">http://hannesdorfmann.com/annotation-processing/annotationprocessing101</a></li><li><a href="http://blog.csdn.net/github_35180164/article/details/52121038" target="_blank" rel="noopener">http://blog.csdn.net/github_35180164/article/details/52121038</a></li><li><a href="https://www.zhangningning.com.cn/blog/Android/android_rentention.html" target="_blank" rel="noopener">https://www.zhangningning.com.cn/blog/Android/android_rentention.html</a></li><li><a href="https://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/AbstractProcessor.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/AbstractProcessor.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;注解系列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://xsfelvis.github.io/2017/01/06/%E6%B3%A8%E8%A7%A3%E5%
      
    
    </summary>
    
      <category term="注解" scheme="https://xsfelvis.github.io/categories/%E6%B3%A8%E8%A7%A3/"/>
    
    
      <category term="注解" scheme="https://xsfelvis.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
      <category term="APT" scheme="https://xsfelvis.github.io/tags/APT/"/>
    
  </entry>
  
  <entry>
    <title>JavaPoet</title>
    <link href="https://xsfelvis.github.io/2017/03/12/%E7%BC%96%E8%AF%91%E6%9C%9F%E6%B3%A8%E8%A7%A3%E4%B9%8BJavaPoet/"/>
    <id>https://xsfelvis.github.io/2017/03/12/编译期注解之JavaPoet/</id>
    <published>2017-03-11T16:00:00.000Z</published>
    <updated>2018-06-06T08:48:10.908Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>注解系列</p><ul><li><a href="https://xsfelvis.github.io/2017/01/06/%E6%B3%A8%E8%A7%A3%E5%9F%BA%E7%A1%80/">注解基础</a></li><li><a href="https://xsfelvis.github.io/2017/03/12/%E7%BC%96%E8%AF%91%E6%9C%9F%E6%B3%A8%E8%A7%A3%E4%B9%8BJavaPoet/">JavaPoet</a></li><li><a href="https://xsfelvis.github.io/2017/04/07/%E7%BC%96%E8%AF%91%E6%9C%9F%E6%B3%A8%E8%A7%A3%E4%B9%8BAPT/">编译期注解处理之APT</a></li></ul><h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>上一篇限于篇幅只介绍了APT，这篇来继续介绍<a href="https://github.com/square/javapoet" target="_blank" rel="noopener">javapoet</a>，是square公司的开源库。正如其名，java诗人，通过注解来生成java源文件，通常要使用javapoet这个库与Filer配合使用。主要和注解配合用来干掉那些重复的模板代码(如butterknife<br>和databinding所做的事情)，当然你也可以使用这个技术让你的代码更加的炫酷。</p><h2 id="0x01-简单使用"><a href="#0x01-简单使用" class="headerlink" title="0x01 简单使用"></a>0x01 简单使用</h2><p>使用之前要先引入这个库 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.squareup:javapoet:1.7.0&apos;</span><br></pre></td></tr></table></figure><p>javapoet是用来生成代码的，需要借助</p><h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><p>使用javapoet前需要了解4个常用类</p><h4 id="MethodSpec-代表一个构造函数或方法声明。"><a href="#MethodSpec-代表一个构造函数或方法声明。" class="headerlink" title="MethodSpec 代表一个构造函数或方法声明。"></a>MethodSpec 代表一个构造函数或方法声明。</h4><h4 id="TypeSpec-代表一个类，接口，或者枚举声明。"><a href="#TypeSpec-代表一个类，接口，或者枚举声明。" class="headerlink" title="TypeSpec 代表一个类，接口，或者枚举声明。"></a>TypeSpec 代表一个类，接口，或者枚举声明。</h4><h4 id="FieldSpec-代表一个成员变量，一个字段声明。"><a href="#FieldSpec-代表一个成员变量，一个字段声明。" class="headerlink" title="FieldSpec 代表一个成员变量，一个字段声明。"></a>FieldSpec 代表一个成员变量，一个字段声明。</h4><h4 id="JavaFile包含一个顶级类的Java文件。"><a href="#JavaFile包含一个顶级类的Java文件。" class="headerlink" title="JavaFile包含一个顶级类的Java文件。"></a>JavaFile包含一个顶级类的Java文件。</h4><p>国际惯例先自动生成一个helloWorld类<br>定义一个编译期注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> clazz_hello &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后看下helloworld的注解处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoService</span>(Processor.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldProcess</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Filer filer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(processingEnv);</span><br><span class="line">        filer = processingEnv.getFiler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (TypeElement element : annotations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (element.getQualifiedName().toString().equals(clazz_hello.class.getCanonicalName())) &#123;</span><br><span class="line">                MethodSpec main = MethodSpec.methodBuilder(<span class="string">"main"</span>)</span><br><span class="line">                        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">                        .returns(<span class="keyword">void</span>.class)</span><br><span class="line">                        .addParameter(String[].class, <span class="string">"args"</span>)</span><br><span class="line">                        .addStatement(<span class="string">"$T.out.println($S)"</span>, System.class, <span class="string">"Hello, JavaPoet!"</span>)</span><br><span class="line">                        .build();</span><br><span class="line">                TypeSpec helloWorld = TypeSpec.classBuilder(<span class="string">"HelloWorld"</span>)</span><br><span class="line">                        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">                        .addMethod(main)</span><br><span class="line">                        .build();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    JavaFile javaFile = JavaFile.builder(<span class="string">"com.xsf"</span>, helloWorld)</span><br><span class="line">                            .addFileComment(<span class="string">" This codes are generated automatically. Do not modify!"</span>)</span><br><span class="line">                            .build();</span><br><span class="line">                    javaFile.writeTo(filer);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; annotations = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        annotations.add(clazz_hello.class.getCanonicalName());</span><br><span class="line">        <span class="keyword">return</span> annotations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SourceVersion.latestSupported();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就会在app-build-source-apt-debug-com.xsf文件夹下生成这个文件</p><h2 id="0x02-使用进阶"><a href="#0x02-使用进阶" class="headerlink" title="0x02 使用进阶"></a>0x02 使用进阶</h2><h3 id="方法-amp-控制流："><a href="#方法-amp-控制流：" class="headerlink" title="方法&amp;控制流："></a>方法&amp;控制流：</h3><h4 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h4><p><code>addcode</code> 和 <code>addstatement</code>,对与无需类引入的极简代码可以直接使用<code>addCode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec main = MethodSpec.methodBuilder(<span class="string">"main"</span>)</span><br><span class="line">    .addCode(<span class="string">""</span></span><br><span class="line">        + <span class="string">"int total = 0;\n"</span></span><br><span class="line">        + <span class="string">"for (int i = 0; i &lt; 10; i++) &#123;\n"</span></span><br><span class="line">        + <span class="string">"  total += i;\n"</span></span><br><span class="line">        + <span class="string">"&#125;\n"</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成的是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    total += i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要是需要import的方法，如上面的<code>.addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;Hello, JavaPoet!&quot;)</code> 就需要使用<code>.addStatement</code>来声明</p><h5 id="更优雅的流控制"><a href="#更优雅的流控制" class="headerlink" title="更优雅的流控制"></a>更优雅的流控制</h5><p><code>beginControlFlow</code> 流开启<br><code>addStatement</code> 处理语句<br><code>endControlFlow()</code>流结束</p><p>如上面的用流改写就是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec main = MethodSpec.methodBuilder(<span class="string">"main"</span>)</span><br><span class="line">    .addStatement(<span class="string">"int total = 0"</span>)</span><br><span class="line">    .beginControlFlow(<span class="string">"for (int i = 0; i &lt; 10; i++)"</span>)</span><br><span class="line">    .addStatement(<span class="string">"total += i"</span>)</span><br><span class="line">    .endControlFlow()</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure></p><h3 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h3><p>javapoet里面提供了占位符来帮助我们更好地生成代码</p><h4 id="L-字面常量（Literals）"><a href="#L-字面常量（Literals）" class="headerlink" title="$L 字面常量（Literals）"></a>$L 字面常量（Literals）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MethodSpec <span class="title">computeRange</span><span class="params">(String name, <span class="keyword">int</span> from, <span class="keyword">int</span> to, String op)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> MethodSpec.methodBuilder(name)</span><br><span class="line">      .returns(<span class="keyword">int</span>.class)</span><br><span class="line">      .addStatement(<span class="string">"int result = 0"</span>)</span><br><span class="line">      .beginControlFlow(<span class="string">"for (int i = $L; i &lt; $L; i++)"</span>, from, to)</span><br><span class="line">      .addStatement(<span class="string">"result = result $L i"</span>, op)</span><br><span class="line">      .endControlFlow()</span><br><span class="line">      .addStatement(<span class="string">"return result"</span>)</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是一个for循环，op负责加减乘除等符号</p><h4 id="S-字符串常量（String）"><a href="#S-字符串常量（String）" class="headerlink" title="$S 字符串常量（String）"></a>$S 字符串常量（String）</h4><h4 id="T-类型-Types"><a href="#T-类型-Types" class="headerlink" title="$T 类型(Types)"></a>$T 类型(Types)</h4><p>最大的特点是自动导入包，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec today = MethodSpec.methodBuilder(<span class="string">"today"</span>)</span><br><span class="line">    .returns(Date.class)</span><br><span class="line">    .addStatement(<span class="string">"return new $T()"</span>, Date.class)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">TypeSpec helloWorld = TypeSpec.classBuilder(<span class="string">"HelloWorld"</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">    .addMethod(today)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">JavaFile javaFile = JavaFile.builder(<span class="string">"com.example.helloworld"</span>, helloWorld)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">javaFile.writeTo(System.out);</span><br></pre></td></tr></table></figure><p>生成的代码如下，而且会自动导包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function">Date <span class="title">today</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想要导入自己写的类怎么办？上面的例子是传入系统的class，这里也提供一种方式，通过ClassName.get（”类的路径”，”类名“），结合$T可以生成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ClassName hoverboard = ClassName.get(<span class="string">"com.mattel"</span>, <span class="string">"Hoverboard"</span>);</span><br><span class="line">ClassName list = ClassName.get(<span class="string">"java.util"</span>, <span class="string">"List"</span>);</span><br><span class="line">ClassName arrayList = ClassName.get(<span class="string">"java.util"</span>, <span class="string">"ArrayList"</span>);</span><br><span class="line">TypeName listOfHoverboards = ParameterizedTypeName.get(list, hoverboard);</span><br><span class="line"></span><br><span class="line">MethodSpec beyond = MethodSpec.methodBuilder(<span class="string">"beyond"</span>)</span><br><span class="line">    .returns(listOfHoverboards)</span><br><span class="line">    .addStatement(<span class="string">"$T result = new $T&lt;&gt;()"</span>, listOfHoverboards, arrayList)</span><br><span class="line">    .addStatement(<span class="string">"result.add(new $T())"</span>, hoverboard)</span><br><span class="line">    .addStatement(<span class="string">"result.add(new $T())"</span>, hoverboard)</span><br><span class="line">    .addStatement(<span class="string">"result.add(new $T())"</span>, hoverboard)</span><br><span class="line">    .addStatement(<span class="string">"return result"</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>然后生成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mattel.Hoverboard;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function">List&lt;Hoverboard&gt; <span class="title">beyond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Hoverboard&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    result.add(<span class="keyword">new</span> Hoverboard());</span><br><span class="line">    result.add(<span class="keyword">new</span> Hoverboard());</span><br><span class="line">    result.add(<span class="keyword">new</span> Hoverboard());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在导入包这里，javapoet 同样支持import static,通过<code>addStaticImport</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ClassName hoverboard = ClassName.get(<span class="string">"com.mattel"</span>, <span class="string">"Hoverboard"</span>);</span><br><span class="line"></span><br><span class="line">ClassName namedBoards = ClassName.get(<span class="string">"com.mattel"</span>, <span class="string">"Hoverboard"</span>, <span class="string">"Boards"</span>);</span><br><span class="line"></span><br><span class="line">MethodSpec beyond = MethodSpec.methodBuilder(<span class="string">"beyond"</span>)</span><br><span class="line">    .returns(listOfHoverboards)</span><br><span class="line">    .addStatement(<span class="string">"$T result = new $T&lt;&gt;()"</span>, listOfHoverboards, arrayList)</span><br><span class="line">    .addStatement(<span class="string">"result.add($T.createNimbus(2000))"</span>, hoverboard)</span><br><span class="line">    .addStatement(<span class="string">"result.add($T.createNimbus(\"2001\"))"</span>, hoverboard)</span><br><span class="line">    .addStatement(<span class="string">"result.add($T.createNimbus($T.THUNDERBOLT))"</span>, hoverboard, namedBoards)</span><br><span class="line">    .addStatement(<span class="string">"$T.sort(result)"</span>, Collections.class)</span><br><span class="line">    .addStatement(<span class="string">"return result.isEmpty() $T.emptyList() : result"</span>, Collections.class)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">TypeSpec hello = TypeSpec.classBuilder(<span class="string">"HelloWorld"</span>)</span><br><span class="line">    .addMethod(beyond)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">JavaFile.builder(<span class="string">"com.example.helloworld"</span>, hello)</span><br><span class="line">    .addStaticImport(hoverboard, <span class="string">"createNimbus"</span>)</span><br><span class="line">    .addStaticImport(namedBoards, <span class="string">"*"</span>)</span><br><span class="line">    .addStaticImport(Collections.class, <span class="string">"*"</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h4 id="N-命名-Names"><a href="#N-命名-Names" class="headerlink" title="$N 命名(Names)"></a>$N 命名(Names)</h4><p>通常指我们自己生成的方法名或者变量名等等比如这样的代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">byteToHex</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span>[] result = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span>];</span><br><span class="line">  result[<span class="number">0</span>] = hexDigit((b &gt;&gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xf</span>);</span><br><span class="line">  result[<span class="number">1</span>] = hexDigit(b &amp; <span class="number">0xf</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> String(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">hexDigit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">char</span>) (i &lt; <span class="number">10</span> ? i + <span class="string">'0'</span> : i - <span class="number">10</span> + <span class="string">'a'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以传递<code>hexDigit()</code>来代替。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec hexDigit = MethodSpec.methodBuilder(<span class="string">"hexDigit"</span>)</span><br><span class="line">    .addParameter(<span class="keyword">int</span>.class, <span class="string">"i"</span>)</span><br><span class="line">    .returns(<span class="keyword">char</span>.class)</span><br><span class="line">    .addStatement(<span class="string">"return (char) (i &lt; 10 ? i + '0' : i - 10 + 'a')"</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">MethodSpec byteToHex = MethodSpec.methodBuilder(<span class="string">"byteToHex"</span>)</span><br><span class="line">    .addParameter(<span class="keyword">int</span>.class, <span class="string">"b"</span>)</span><br><span class="line">    .returns(String.class)</span><br><span class="line">    .addStatement(<span class="string">"char[] result = new char[2]"</span>)</span><br><span class="line">    .addStatement(<span class="string">"result[0] = $N((b &gt;&gt;&gt; 4) &amp; 0xf)"</span>, hexDigit)</span><br><span class="line">    .addStatement(<span class="string">"result[1] = $N(b &amp; 0xf)"</span>, hexDigit)</span><br><span class="line">    .addStatement(<span class="string">"return new String(result)"</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h3 id="构建类的元素"><a href="#构建类的元素" class="headerlink" title="构建类的元素"></a>构建类的元素</h3><h4 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h4><p>方法的修饰，如<code>Modifiers.ABSTRACT</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec flux = MethodSpec.methodBuilder(<span class="string">"flux"</span>)</span><br><span class="line">    .addModifiers(Modifier.ABSTRACT, Modifier.PROTECTED)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">TypeSpec helloWorld = TypeSpec.classBuilder(<span class="string">"HelloWorld"</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)</span><br><span class="line">    .addMethod(flux)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>这将会生成如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">flux</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然Methods需要和<code>MethodSpec.Builder</code>配置来增加方法参数、异常、javadoc、注解等。</p><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>这个其实也是个函数方法而已，因此可以使用MethodSpec来生成构造器方法。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec flux = MethodSpec.constructorBuilder()</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addParameter(String.class, <span class="string">"greeting"</span>)</span><br><span class="line">    .addStatement(<span class="string">"this.$N = $N"</span>, <span class="string">"greeting"</span>, <span class="string">"greeting"</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">TypeSpec helloWorld = TypeSpec.classBuilder(<span class="string">"HelloWorld"</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addField(String.class, <span class="string">"greeting"</span>, Modifier.PRIVATE, Modifier.FINAL)</span><br><span class="line">    .addMethod(flux)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>将会生成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String greeting;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HelloWorld</span><span class="params">(String greeting)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.greeting = greeting;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>之前我们是通过<code>addstatement</code>直接设置参数，其实参数也有自己的一个专用类<code>ParameterSpec</code>，我们可以使用<code>ParameterSpec.builder()</code>来生成参数，然后MethodSpec的addParameter去使用，这样更加优雅。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ParameterSpec android = ParameterSpec.builder(String.class, <span class="string">"android"</span>)</span><br><span class="line">    .addModifiers(Modifier.FINAL)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">MethodSpec welcomeOverlords = MethodSpec.methodBuilder(<span class="string">"welcomeOverlords"</span>)</span><br><span class="line">    .addParameter(android)</span><br><span class="line">    .addParameter(String.class, <span class="string">"robot"</span>, Modifier.FINAL)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">welcomeOverlords</span><span class="params">(<span class="keyword">final</span> String android, <span class="keyword">final</span> String robot)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4><p>可以使用FieldSpec去声明字段，然后加到Method中处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FieldSpec android = FieldSpec.builder(String.class, <span class="string">"android"</span>)</span><br><span class="line">    .addModifiers(Modifier.PRIVATE, Modifier.FINAL)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">TypeSpec helloWorld = TypeSpec.classBuilder(<span class="string">"HelloWorld"</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addField(android)</span><br><span class="line">    .addField(String.class, <span class="string">"robot"</span>, Modifier.PRIVATE, Modifier.FINAL)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>然后生成代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String android;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String robot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常Builder可以更加详细的创建字段的内容，比如javadoc、annotations或者初始化字段参数等，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FieldSpec android = FieldSpec.builder(String.class, <span class="string">"android"</span>)</span><br><span class="line">    .addModifiers(Modifier.PRIVATE, Modifier.FINAL)</span><br><span class="line">    .initializer(<span class="string">"$S + $L"</span>, <span class="string">"Lollipop v."</span>, <span class="number">5.0</span>d)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>对应生成的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String android = <span class="string">"Lollipop v."</span> + <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口方法必须是PUBLIC ABSTRACT并且接口字段必须是PUBLIC STATIC FINAL ，使用<code>TypeSpec.interfaceBuilder</code></p><p>如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TypeSpec helloWorld = TypeSpec.interfaceBuilder(<span class="string">"HelloWorld"</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addField(FieldSpec.builder(String.class, <span class="string">"ONLY_THING_THAT_IS_CONSTANT"</span>)</span><br><span class="line">        .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)</span><br><span class="line">        .initializer(<span class="string">"$S"</span>, <span class="string">"change"</span>)</span><br><span class="line">        .build())</span><br><span class="line">    .addMethod(MethodSpec.methodBuilder(<span class="string">"beep"</span>)</span><br><span class="line">        .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)</span><br><span class="line">        .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  String ONLY_THING_THAT_IS_CONSTANT = <span class="string">"change"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">beep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>枚举类型</li></ul><p>使用<code>TypeSpec.enumBuilder</code>来创建，使用<code>addEnumConstant</code>来添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TypeSpec helloWorld = TypeSpec.enumBuilder(<span class="string">"Roshambo"</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addEnumConstant(<span class="string">"ROCK"</span>)</span><br><span class="line">    .addEnumConstant(<span class="string">"SCISSORS"</span>)</span><br><span class="line">    .addEnumConstant(<span class="string">"PAPER"</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Roshambo &#123;</span><br><span class="line">  ROCK,</span><br><span class="line"></span><br><span class="line">  SCISSORS,</span><br><span class="line"></span><br><span class="line">  PAPER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更复杂的类型也可以支持，如重写、注解等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">TypeSpec helloWorld = TypeSpec.enumBuilder(<span class="string">"Roshambo"</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addEnumConstant(<span class="string">"ROCK"</span>, TypeSpec.anonymousClassBuilder(<span class="string">"$S"</span>, <span class="string">"fist"</span>)</span><br><span class="line">        .addMethod(MethodSpec.methodBuilder(<span class="string">"toString"</span>)</span><br><span class="line">            .addAnnotation(Override.class)</span><br><span class="line">            .addModifiers(Modifier.PUBLIC)</span><br><span class="line">            .addStatement(<span class="string">"return $S"</span>, <span class="string">"avalanche!"</span>)</span><br><span class="line">            .build())</span><br><span class="line">        .build())</span><br><span class="line">    .addEnumConstant(<span class="string">"SCISSORS"</span>, TypeSpec.anonymousClassBuilder(<span class="string">"$S"</span>, <span class="string">"peace"</span>)</span><br><span class="line">        .build())</span><br><span class="line">    .addEnumConstant(<span class="string">"PAPER"</span>, TypeSpec.anonymousClassBuilder(<span class="string">"$S"</span>, <span class="string">"flat"</span>)</span><br><span class="line">        .build())</span><br><span class="line">    .addField(String.class, <span class="string">"handsign"</span>, Modifier.PRIVATE, Modifier.FINAL)</span><br><span class="line">    .addMethod(MethodSpec.constructorBuilder()</span><br><span class="line">        .addParameter(String.class, <span class="string">"handsign"</span>)</span><br><span class="line">        .addStatement(<span class="string">"this.$N = $N"</span>, <span class="string">"handsign"</span>, <span class="string">"handsign"</span>)</span><br><span class="line">        .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Roshambo &#123;</span><br><span class="line">  ROCK(<span class="string">"fist"</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"avalanche!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  SCISSORS(<span class="string">"peace"</span>),</span><br><span class="line"></span><br><span class="line">  PAPER(<span class="string">"flat"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String handsign;</span><br><span class="line"></span><br><span class="line">  Roshambo(String handsign) &#123;</span><br><span class="line">    <span class="keyword">this</span>.handsign = handsign;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>需要使用<code>Type.anonymousInnerClass(&quot;&quot;)</code>,通常可以使用$L占位符来指代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TypeSpec comparator = TypeSpec.anonymousClassBuilder(<span class="string">""</span>)</span><br><span class="line">    .addSuperinterface(ParameterizedTypeName.get(Comparator.class, String.class))</span><br><span class="line">    .addMethod(MethodSpec.methodBuilder(<span class="string">"compare"</span>)</span><br><span class="line">        .addAnnotation(Override.class)</span><br><span class="line">        .addModifiers(Modifier.PUBLIC)</span><br><span class="line">        .addParameter(String.class, <span class="string">"a"</span>)</span><br><span class="line">        .addParameter(String.class, <span class="string">"b"</span>)</span><br><span class="line">        .returns(<span class="keyword">int</span>.class)</span><br><span class="line">        .addStatement(<span class="string">"return $N.length() - $N.length()"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>)</span><br><span class="line">        .build())</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">TypeSpec helloWorld = TypeSpec.classBuilder(<span class="string">"HelloWorld"</span>)</span><br><span class="line">    .addMethod(MethodSpec.methodBuilder(<span class="string">"sortByLength"</span>)</span><br><span class="line">        .addParameter(ParameterizedTypeName.get(List.class, String.class), <span class="string">"strings"</span>)</span><br><span class="line">        .addStatement(<span class="string">"$T.sort($N, $L)"</span>, Collections.class, <span class="string">"strings"</span>, comparator)</span><br><span class="line">        .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortByLength</span><span class="params">(List&lt;String&gt; strings)</span> </span>&#123;</span><br><span class="line">  Collections.sort(strings, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a.length() - b.length();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义匿名内部类的一个特别棘手的问题是参数的构造。在上面的代码中我们传递了不带参数的空字符串。TypeSpec.anonymousClassBuilder(“”)。</p><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>注解使用起来比较简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec toString = MethodSpec.methodBuilder(<span class="string">"toString"</span>)</span><br><span class="line">    .addAnnotation(Override.class)</span><br><span class="line">    .returns(String.class)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addStatement(<span class="string">"return $S"</span>, <span class="string">"Hoverboard"</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hoverboard"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>AnnotationSpec.builder()</code> 可以对注解设置属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec logRecord = MethodSpec.methodBuilder(<span class="string">"recordEvent"</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)</span><br><span class="line">    .addAnnotation(AnnotationSpec.builder(Headers.class)</span><br><span class="line">        .addMember(<span class="string">"accept"</span>, <span class="string">"$S"</span>, <span class="string">"application/json; charset=utf-8"</span>)</span><br><span class="line">        .addMember(<span class="string">"userAgent"</span>, <span class="string">"$S"</span>, <span class="string">"Square Cash"</span>)</span><br><span class="line">        .build())</span><br><span class="line">    .addParameter(LogRecord.class, <span class="string">"logRecord"</span>)</span><br><span class="line">    .returns(LogReceipt.class)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>代码生成如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Headers</span>(</span><br><span class="line">    accept = <span class="string">"application/json; charset=utf-8"</span>,</span><br><span class="line">    userAgent = <span class="string">"Square Cash"</span></span><br><span class="line">)</span><br><span class="line"><span class="function">LogReceipt <span class="title">recordEvent</span><span class="params">(LogRecord logRecord)</span></span>;</span><br></pre></td></tr></table></figure><p>注解同样可以注解其他注解，通过$L引用如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec logRecord = MethodSpec.methodBuilder(<span class="string">"recordEvent"</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)</span><br><span class="line">    .addAnnotation(AnnotationSpec.builder(HeaderList.class)</span><br><span class="line">        .addMember(<span class="string">"value"</span>, <span class="string">"$L"</span>, AnnotationSpec.builder(Header.class)</span><br><span class="line">            .addMember(<span class="string">"name"</span>, <span class="string">"$S"</span>, <span class="string">"Accept"</span>)</span><br><span class="line">            .addMember(<span class="string">"value"</span>, <span class="string">"$S"</span>, <span class="string">"application/json; charset=utf-8"</span>)</span><br><span class="line">            .build())</span><br><span class="line">        .addMember(<span class="string">"value"</span>, <span class="string">"$L"</span>, AnnotationSpec.builder(Header.class)</span><br><span class="line">            .addMember(<span class="string">"name"</span>, <span class="string">"$S"</span>, <span class="string">"User-Agent"</span>)</span><br><span class="line">            .addMember(<span class="string">"value"</span>, <span class="string">"$S"</span>, <span class="string">"Square Cash"</span>)</span><br><span class="line">            .build())</span><br><span class="line">        .build())</span><br><span class="line">    .addParameter(LogRecord.class, <span class="string">"logRecord"</span>)</span><br><span class="line">    .returns(LogReceipt.class)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HeaderList</span>(&#123;</span><br><span class="line">    <span class="meta">@Header</span>(name = <span class="string">"Accept"</span>, value = <span class="string">"application/json; charset=utf-8"</span>),</span><br><span class="line">    <span class="meta">@Header</span>(name = <span class="string">"User-Agent"</span>, value = <span class="string">"Square Cash"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function">LogReceipt <span class="title">recordEvent</span><span class="params">(LogRecord logRecord)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="0x03-后续"><a href="#0x03-后续" class="headerlink" title="0x03 后续"></a>0x03 后续</h2><p>在javapoet之前有javawriter，但javapoet有着更强大的代码模型，并且对类的理解更加到位，因此推荐使用javapoet </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;注解系列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://xsfelvis.github.io/2017/01/06/%E6%B3%A8%E8%A7%A3%E5%
      
    
    </summary>
    
      <category term="注解" scheme="https://xsfelvis.github.io/categories/%E6%B3%A8%E8%A7%A3/"/>
    
    
      <category term="注解" scheme="https://xsfelvis.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
      <category term="JavaPoet" scheme="https://xsfelvis.github.io/tags/JavaPoet/"/>
    
  </entry>
  
  <entry>
    <title>Andfix学习</title>
    <link href="https://xsfelvis.github.io/2017/01/11/Andfix%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>https://xsfelvis.github.io/2017/01/11/Andfix学习记录/</id>
    <published>2017-01-10T16:00:00.000Z</published>
    <updated>2018-06-04T08:39:01.573Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="概述篇"><a href="#概述篇" class="headerlink" title="概述篇"></a>概述篇</h1><p>AndFix，全称是Android hot-fix。是阿里开源的一个热补丁框架，允许APP在不重新发布版本的情况下修复线上的bug。支持Android 2.3 到 7.0，并且支持arm 与 X86系统架构的设备。完美支持Dalvik与ART的Runtime，补丁文件是以 .apatch 结尾的文件，并且是立即生效的</p><p>项目地址<a href="https://github.com/alibaba/AndFix" target="_blank" rel="noopener">https://github.com/alibaba/AndFix</a></p><p>官方ReadMe</p><blockquote><p>大致修复图</p></blockquote><p><img src="https://github.com/alibaba/AndFix/raw/master/images/principle.png" alt=""></p><blockquote><p>How to Use(官方)</p></blockquote><p>Initialize PatchManager,</p><pre><code>`patchManager = new PatchManager(context); patchManager.init(appversion);//current version`</code></pre><p>Load patch,</p><pre><code>`patchManager.loadPatch();`</code></pre><p>You should load patch as early as possible, generally, in the initialization phase of your application(such as Application.onCreate()).</p><p>Add patch,</p><pre><code>`patchManager.addPatch(path);//path of the patch file that was downloaded`</code></pre><p>When a new patch file has been downloaded, it will become <code>effective immediately</code> by addPatch</p><p>还有一点就是混淆需要注意</p><pre><code>`-keep class * extends java.lang.annotation.Annotation -keepclasseswithmembernames class * {  native &lt;methods&gt;;  } -keep class com.alipay.euler.andfix.** { *; } `</code></pre><p>如何制作一个apatch呢，阿里在这个开源项目中提供了一个工具<a href="https://github.com/alibaba/AndFix/blob/master/tools/apkpatch-1.0.3.zip" target="_blank" rel="noopener">https://github.com/alibaba/AndFix/blob/master/tools/apkpatch-1.0.3.zip</a><br>，这里先大致介绍一下原理：通过diff增量比对两个apk改变的地方，在其上通过加上注解标记，生成一个apatch</p><p><img src="http://images2015.cnblogs.com/blog/886182/201603/886182-20160311145621210-104524703.png" alt=""></p><p>例如旧的apk为1.apk，新的apk为2.apk, -o表示补丁的输出目录，-k表示keystore, -p表示keystore的密码，-a表示alias, -e表示entry password。</p><p><img src="http://images2015.cnblogs.com/blog/886182/201603/886182-20160311192720366-164535579.png" alt=""></p><p>命令输入有点麻烦，可以自己写一个win的脚本</p><blockquote><p>apkpatch -f 2.apk -t 1.apk -o . -k finance.keystore  -p finance.tech.netease.com -a android.finance.163.com -e finance.tech.netease.com</p></blockquote><p>这样基本可以照猫画虎折腾热更新了,当然不要忘记添加读写权限</p><pre><code>`&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;`</code></pre><h1 id="原理篇"><a href="#原理篇" class="headerlink" title="原理篇"></a>原理篇</h1><ul><li><p>andfix 深入</p></li><li><p>补丁深入</p></li></ul><h2 id="andfix-原理"><a href="#andfix-原理" class="headerlink" title="andfix 原理"></a>andfix 原理</h2><p>andfix的核心原理就是方法替换 在通过其apath工具给需要替换的方法加上注解@repleaceMethod，这样在执行时把有bug的方法替换成补丁文件中执行的方法。（在Native 层使用指针替换的方式替换bug的方法，从而达到修复bug的目的），具体过程如下图：</p><p><img src="http://i.imgur.com/ErUHzr9.jpg" alt=""></p><ul><li>加载补丁</li></ul><p>使用虚拟机的JarFile加载的补丁文件，读取PATCH.MF文件得到补丁类名称</p><ul><li>获取补丁方法</li></ul><p>使用DexFile读取patch文件的dex文件，获取后根据注解获取补丁方法</p><ul><li><p>获取bug所在的方法</p><p>根据注解中获取到的类名和方法，使用ClassLaoder获取到class，然后根据反射得到bug Method，并将其访问属性修改为public<br>—————————————–java 层————————————————————-</p></li><li><p>Native 层替换方法</p></li></ul><p>使用JNI来替换bug所在方法对象的属性来修复bug</p><p>简要类之间关系图<br><img src="http://i.imgur.com/hXtSBHF.png" alt=""></p><p>修复的具体过程为：</p><p>1）我们及时修复好bug之后，我们可以apkpatch工具将两个apk做一次对比，然后找出不同的部分。生成的apatch了文件。若果这个时候，我们把后缀改成zip再解压开，里面有一个dex文件。反编译之后查看一下源码，里面就是被修复的代码所在的类文件,这些更改过的类都加上了一个_CF的后缀，并且变动的方法都被加上了一个叫@MethodReplace的annotation，通过clazz和method指定了需要替换的方法。(后面补丁原理会说到)</p><p>2）客户端得到补丁文件后就会根据annotation来寻找需要替换的方法。从AndFixManager.fix方法开始，客户端找到对应的需要替换的方法，然后在fix方法的具体实现中调用fixClass方法进行方法替换过程。</p><p>3）由JNI层完成方法的替换。fixClass方法遍历补丁class里的方法，在jni层对所需要替换的方法进行一一替换。(AndfixManager#replaceMethod)</p><blockquote><p>源码解析</p></blockquote><p>遵循使用时四步走：</p><blockquote><p>Step1：初始化PatchManger</p></blockquote><pre><code>`PatchManager patchManager = new PatchManager();`</code></pre><p>参阅 patchManager类源码——&gt;AndfixManager 其中包含了Compat兼容性检测类、SecurityChecker安全性检查类</p><pre><code>`public AndFixManager(Context context) {    mContext = context;    //判断机型是否支持Andfix 阿里的YunOs不支持    mSupport = Compat.isSupport();    if (mSupport) {        //初始化签名判断类        mSecurityChecker = new SecurityChecker(mContext);        mOptDir = new File(mContext.getFilesDir(), DIR);        // make directory fail        if (!mOptDir.exists() &amp;&amp; !mOptDir.mkdirs()) {            mSupport = false;            Log.e(TAG, &quot;opt dir create error.&quot;);        } else if (!mOptDir.isDirectory()) {// not directory            //如果不是目录则删除            mOptDir.delete();            mSupport = false;        }    }}`</code></pre><blockquote><p>Step2:使用PatchManger检查版本</p></blockquote><pre><code>`patchManager.init(apk版本)`</code></pre><p>参阅patchManager#init ——&gt;Patch 构造函数初始化 init<br>主要是版本比对，记录版本号；根据版本号将patch清除或者加载到缓存中</p><p>参阅Patch#init</p><pre><code>`    public void init(String appVersion) {    if (!mPatchDir.exists() &amp;&amp; !mPatchDir.mkdirs()) {// make directory fail        Log.e(TAG, &quot;patch dir create error.&quot;);        return;    } else if (!mPatchDir.isDirectory()) {// not directory        mPatchDir.delete();        return;    }    SharedPreferences sp = mContext.getSharedPreferences(SP_NAME,            Context.MODE_PRIVATE);//缓存版本号    String ver = sp.getString(SP_VERSION, null);    if (ver == null || !ver.equalsIgnoreCase(appVersion)) {        //根据传入版本号作对比，若不同，则删除本地的补丁文件        cleanPatch();        sp.edit().putString(SP_VERSION, appVersion).commit();//传入新的版本号    } else {        initPatchs();//初始化patch列表，把本地的patch加载到内存中    }}private void initPatchs() {    File[] files = mPatchDir.listFiles();    for (File file : files) {        addPatch(file);    }}`</code></pre><p>Patch文件的加载 使用JarFile读取Patch文件，读取一些属性如patchname，createtime，其中如果本地保存了多个补丁，那么AndFix会按照补丁生成的时间顺序加载补丁。具体是根据.apatch文件中的PATCH.MF的字段Created-Time。</p><blockquote><p>step3:loadPatch</p></blockquote><pre><code>`patchManager.loadPatch();`</code></pre><p>参阅patchManager#loadPatch</p><p>提供了3个重载方法</p><pre><code>`public void loadPatch()//andfix 初始化之后调用 private void loadPatch(Patch patch)//下载补丁完成后调用，addPatch(path) public void loadPatch(String patchName, ClassLoader classLoader)//提供了自定义类加载器的实现 `</code></pre><p>这三个核心都是调用了public synchronized void fix(File file, ClassLoader classLoader, List<string> classes)</string></p><p>参看AndfixManager#fix</p><pre><code>`public synchronized void fix(File file, ClassLoader classLoader,        List&lt;String&gt; classes) {    if (!mSupport) {        return;    }    //判断补丁的签名    if (!mSecurityChecker.verifyApk(file)) {// security check fail        return;    }    try {        File optfile = new File(mOptDir, file.getName());        boolean saveFingerprint = true;        if (optfile.exists()) {            // need to verify fingerprint when the optimize file exist,            // prevent someone attack on jailbreak device with            // Vulnerability-Parasyte.            // btw:exaggerated android Vulnerability-Parasyte            // http://secauo.com/Exaggerated-Android-Vulnerability-Parasyte.html            //如果本地已经存在补丁文件，则校验指纹信息            if (mSecurityChecker.verifyOpt(optfile)) {                saveFingerprint = false;            } else if (!optfile.delete()) {                return;            }        }        //加载patch文件中的dex        final DexFile dexFile = DexFile.loadDex(file.getAbsolutePath(),                optfile.getAbsolutePath(), Context.MODE_PRIVATE);        if (saveFingerprint) {            mSecurityChecker.saveOptSig(optfile);        }        ClassLoader patchClassLoader = new ClassLoader(classLoader) {            //重写了ClassLoader的findClass方法            @Override            protected Class&lt;?&gt; findClass(String className)                    throws ClassNotFoundException {                Class&lt;?&gt; clazz = dexFile.loadClass(className, this);                if (clazz == null                        &amp;&amp; className.startsWith(&quot;com.alipay.euler.andfix&quot;)) {                    return Class.forName(className);// annotation注解class                                                    // not found                }                if (clazz == null) {                    throw new ClassNotFoundException(className);                }                return clazz;            }        };        Enumeration&lt;String&gt; entrys = dexFile.entries();        Class&lt;?&gt; clazz = null;        while (entrys.hasMoreElements()) {            String entry = entrys.nextElement();            if (classes != null &amp;&amp; !classes.contains(entry)) {                continue;// skip, not need fix            }            clazz = dexFile.loadClass(entry, patchClassLoader);//获取有bug的类文件            if (clazz != null) {                fixClass(clazz, classLoader);//核心-            }        }    } catch (IOException e) {        Log.e(TAG, &quot;pacth&quot;, e);    }}`</code></pre><p>fix——&gt;fixclass——&gt;replaceMethod——&gt;Andfix#replaceMethod(Method dest,Method src) Native方法</p><pre><code>`private void fixClass(Class&lt;?&gt; clazz, ClassLoader classLoader) {    //反射找到clazz中的所有方法    Method[] methods = clazz.getDeclaredMethods();    //MethodReplace的注解    MethodReplace methodReplace;    String clz;    String meth;    for (Method method : methods) {        //遍历所有方法，找到有MethodReplace注解的方法，即需要替换的方法        methodReplace = method.getAnnotation(MethodReplace.class);//获取此方法的注解，有bug的方法生成patch的类中的方法都是有注解的        if (methodReplace == null)            continue;        clz = methodReplace.clazz(); //获取注解中的clazz的值        meth = methodReplace.method(); //获取注解中method的值        if (!isEmpty(clz) &amp;&amp; !isEmpty(meth)) {            //找到需要替换的方法后调用replaceMethod替换方法            replaceMethod(classLoader, clz, meth, method);        }    }}</code></pre><p>`</p><pre><code>`private void replaceMethod(ClassLoader classLoader, String clz,        String meth, Method method) {    try {        String key = clz + &quot;@&quot; + classLoader.toString();        //根据key查找缓存中的数据，该缓存记录了已经被修复过得class        Class&lt;?&gt; clazz = mFixedClass.get(key);        if (clazz == null) {// class not load            //找不到说明该class没有被修复过，则通过类加载器去加载            Class&lt;?&gt; clzz = classLoader.loadClass(clz);            // initialize target class            //通过C层改写accessFlag，把需要替换的类的所有方法(Field)改成了public            clazz = AndFix.initTargetClass(clzz);//初始化target class        }        if (clazz != null) {// initialize class OK            mFixedClass.put(key, clazz);            Method src = clazz.getDeclaredMethod(meth,                    method.getParameterTypes());  //根据反射拿到有bug的类的方法            //这里是调用了jni，art和dalvik分别执行不同的替换逻辑，在cpp进行实现            AndFix.addReplaceMethod(src, method);//替换方法 src是有bug的方法，method是补丁方法        }    } catch (Exception e) {        Log.e(TAG, &quot;replaceMethod&quot;, e);    }}`</code></pre><p> <code>Natvie方法的分析</code>见下面</p><p>前三步都是一开始初始化时候要做的，而最后一步第四步则是补丁下载好之后再做的</p><blockquote><p>step4: 添加Patch</p></blockquote><pre><code>`patchManager.addPatch(path)`</code></pre><p>参阅PatchManager#addPatch，最终还是执行loadpatch</p><p>appPatch——&gt;copy到andfix默认的文件夹下——&gt;执行loadPatch(补丁立即生效)</p><pre><code>`    public void addPatch(String path) throws IOException {    File src = new File(path);    File dest = new File(mPatchDir, src.getName());    if(!src.exists()){        throw new FileNotFoundException(path);    }    if (dest.exists()) {        Log.d(TAG, &quot;patch [&quot; + path + &quot;] has be loaded.&quot;);        return;    }    //这一步很重要，通过这一步将你所下载保存的patch文件，copy到andfix自己默认的文件夹内存的data/data/apatch    FileUtil.copyFile(src, dest);// copy to patch&apos;s directory    Patch patch = addPatch(dest);    if (patch != null) {        //加载patch 补丁立即生效        loadPatch(patch);    }}`</code></pre><p>小结一下：<br>可以看出andfix的核心就是两大步</p><ul><li>java层 实现加载补丁文件，安全验证等操作，然后根据补丁汇总的注解找到将要替换的方法，交给Native层去处理替换方法</li><li>native层：利用java hook的技术来替换要修复的方法</li></ul><h2 id="附-Native-分析"><a href="#附-Native-分析" class="headerlink" title="附 Native 分析"></a>附 Native 分析</h2><p>在JNI目录下 art和darvik文件中</p><p>andfix.cpp#replaceMethod——&gt;art_method_replace.cpp(根据版本)——art_method_replace_5_0.cpp</p><ul><li><p>Dalvik</p><p>Dalvik是Google公司自己设计用于Android平台的Java虚拟机。Dalvik虚拟机是Google等厂商合作开发的Android移动设备平台的核心组成部分之一。它可以支持已转换为 .dex（即Dalvik Executable）格式的Java应用程序的运行，.dex格式是专为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。Dalvik 经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik 应用作为一个独立的Linux 进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。</p></li><li><p>ART</p></li></ul><p>Android操作系统已经成熟，Google的Android团队开始将注意力转向一些底层组件，其中之一是负责应用程序运行的Dalvik运行时。Google开发者已经花了两年时间开发更快执行效率更高更省电的替代ART运行时。 ART代表Android Runtime，其处理应用程序执行的方式完全不同于Dalvik，Dalvik是依靠一个Just-In-Time (JIT)编译器去解释字节码。开发者编译后的应用代码需要通过一个解释器在用户的设备上运行，这一机制并不高效，但让应用能更容易在不同硬件和架构上运 行。ART则完全改变了这套做法，在应用安装时就预编译字节码到机器语言，这一机制叫Ahead-Of-Time (AOT）编译。在移除解释代码这一过程后，应用程序执行将更有效率，启动更快。</p><p>-优缺点</p><p>ART优点：</p><p>1、系统性能的显著提升。</p><p>2、应用启动更快、运行更快、体验更流畅、触感反馈更及时。</p><p>3、更长的电池续航能力。</p><p>4、支持更低的硬件。</p><p>ART缺点：</p><p>1、更大的存储空间占用，可能会增加10%-20%。</p><p>2、更长的应用安装时间。</p><p>总的来说ART的功效就是“空间换时间”。</p><blockquote><p>其他重要函数</p></blockquote><p>PatchManage#removeAllPatch()</p><p>这个函数是在PatchManage#init(viersin) verision不同时调用的方法一样，清空补丁目录文件，这在做保护的时候十分重要。</p><pre><code>`    public void removeAllPatch() {    cleanPatch();    SharedPreferences sp = mContext.getSharedPreferences(SP_NAME,            Context.MODE_PRIVATE);    sp.edit().clear().commit();}`</code></pre><p>比如在laodPatch,包括初始化的时候patchManager.loadPatch()和patchManager.addPatch(其实也是调用loadpath)</p><pre><code>`public void loadPatch() {    mLoaders.put(&quot;*&quot;, mContext.getClassLoader());// wildcard    Set&lt;String&gt; patchNames;    List&lt;String&gt; classes;    for (Patch patch : mPatchs) {        patchNames = patch.getPatchNames();        for (String patchName : patchNames) {            classes = patch.getClasses(patchName);//获取patch对用的class类集合            mAndFixManager.fix(patch.getFile(), mContext.getClassLoader(),                    classes);//核心-修复bug方法        }    }}`</code></pre><p>   因此需要在以下两处做好保护</p><pre><code>`public void starAndfix() {    try {        mPatchManager = new PatchManager(context);        mPatchManager.init(BuildConfig.VERSION_NAME);//更换版本号，补丁会被清除        AppLog.d(TAG, &quot;inited.&quot;);        mPatchManager.loadPatch();                  ……        requestHotFixServer(lastSign);    } catch (Throwable throwable) {        mPatchManager.removeAllPatch();        AppLog.d(TAG, &quot;outer catch error remove apatch&quot;);    }}`` try{                mPatchManager.addPatch(context.getFilesDir() + &quot;/&quot; + DIR + APATCH_PATH);            }catch (Throwable throwable){                mPatchManager.removeAllPatch();                AppLog.d(TAG, &quot;inner catch error remove apatch&quot;);            }`</code></pre><h2 id="补丁原理"><a href="#补丁原理" class="headerlink" title="补丁原理"></a>补丁原理</h2><h3 id="apkPatch工具解析"><a href="#apkPatch工具解析" class="headerlink" title="apkPatch工具解析"></a>apkPatch工具解析</h3><p>apkpatch是一个jar包，并没有开源出来，我们可以使用JD-GUI来查看其源码。首先找到Main.class 位于com.euler.patch包下，找到main方法 Main#97</p><pre><code>`public static void main(final String[] args) {    .....    //根据上面命令输入拿到参数           ApkPatch apkPatch = new ApkPatch(from, to, name, out, keystore, password, alias, entry);   apkPatch.doPatch();}`</code></pre><p>——&gt;ApkPatch#doPatch</p><pre><code>` public void doPatch() {try {  //生成smail文件夹  File smaliDir = new File(this.out, &quot;smali&quot;);  if (!smaliDir.exists())    smaliDir.mkdir();  try  {    FileUtils.cleanDirectory(smaliDir);  } catch (IOException e) {    throw new RuntimeException(e);  }  //新建diff.dex文件  File dexFile = new File(this.out, &quot;diff.dex&quot;);  if ((dexFile.exists()) &amp;&amp; (!dexFile.delete())) {    throw new RuntimeException(&quot;diff.dex can&apos;t be removed.&quot;);  }  //新建diff.apatch文件  File outFile = new File(this.out, &quot;diff.apatch&quot;);  if ((outFile.exists()) &amp;&amp; (!outFile.delete())) {    throw new RuntimeException(&quot;diff.apatch can&apos;t be removed.&quot;);  }  //第一步：拿到两个apk文件对比，对比信息写入DiffInfo  DiffInfo info = new DexDiffer().diff(this.from, this.to);  //第二步：将对比结果info写入.smail文件中，然后打包成dex文件  this.classes = buildCode(smaliDir, dexFile, info);  //第三步：将生成的dex文件写入jar包，并根据输入的签名信息进行签名生成diff.apatch文件  build(outFile, dexFile);  //第四步：将diff.apatch文件重命名  release(this.out, dexFile, outFile);} catch (Exception e) {  e.printStackTrace();}}`</code></pre><p>代码翻译一下：</p><ul><li>对比apk文件，得到所需信息</li><li>将结果打包为apatch文件</li></ul><p>主要的就是对比文件信息的DexDiffer().diff(this.from, this.to)方法</p><p>——&gt;diff#DexDiffer#diff</p><pre><code>`public DiffInfo diff(File newFile, File oldFile)throws IOException{//提取新apk的dex文件DexBackedDexFile newDexFile = DexFileFactory.loadDexFile(newFile, 19,   true);//提取旧apk的dex文件DexBackedDexFile oldDexFile = DexFileFactory.loadDexFile(oldFile, 19,   true);DiffInfo info = DiffInfo.getInstance();boolean contains = false;for (DexBackedClassDef newClazz : newDexFile.getClasses()) {  Set oldclasses = oldDexFile    .getClasses();  for (DexBackedClassDef oldClazz : oldclasses) {    //对比相同的方法，存储为修改的方法    if (newClazz.equals(oldClazz)) {      //对比class文件的变量      compareField(newClazz, oldClazz, info);      //对比class的方法，如果同一个类中没有相同的方法，则判断为新增方法(后面方法)      compareMethod(newClazz, oldClazz, info);      contains = true;      break;    }  }  if (!contains)  {    info.addAddedClasses(newClazz);  }}return info;}`</code></pre><p>从这段代码可以看出dex diff得到两个apk文件的差别信息，变量和方法</p><blockquote><p>变量</p></blockquote><pre><code>`public void addAddedFields(DexBackedField field) {this.addedFields.add(field);throw new RuntimeException(&quot;can,t add new Field:&quot; +   field.getName() + &quot;(&quot; + field.getType() + &quot;), &quot; + &quot;in class :&quot; +   field.getDefiningClass()); } public void addModifiedFields(DexBackedField field) { this.modifiedFields.add(field); throw new RuntimeException(&quot;can,t modified Field:&quot; +   field.getName() + &quot;(&quot; + field.getType() + &quot;), &quot; + &quot;in class :&quot; +   field.getDefiningClass());}`</code></pre><p>可以看出不支持增加成员变量，也不支持修改成员变量。</p><blockquote><p>方法</p></blockquote><pre><code>`public void addAddedMethods(DexBackedMethod method) {System.out.println(&quot;add new Method:&quot; + method.getReturnType() +   &quot;  &quot; + method.getName() + &quot;(&quot; +   Formater.formatStringList(method.getParameterTypes()) +   &quot;)  in Class:&quot; + method.getDefiningClass());this.addedMethods.add(method);if (!this.modifiedClasses.contains(method.classDef))  this.modifiedClasses.add(method.classDef);}public void addModifiedMethods(DexBackedMethod method) {System.out.println(&quot;add modified Method:&quot; + method.getReturnType() +   &quot;  &quot; + method.getName() + &quot;(&quot; +   Formater.formatStringList(method.getParameterTypes()) +   &quot;)  in Class:&quot; + method.getDefiningClass());this.modifiedMethods.add(method);if (!this.modifiedClasses.contains(method.classDef))  this.modifiedClasses.add(method.classDef);}}`</code></pre><p>可以看出对比方法过程中对比两个dex文件中同时存在的方法，如果方法实现不同则存储为修改过的方法；如果方法名不同，存储为新增的方法，也就是说AndFix支持增加新的方法</p><p>最后还有一点需要注意下：<br>在diff#DexDiffer#diff中<br>    //提取新apk的dex文件<br>    DexBackedDexFile newDexFile = DexFileFactory.loadDexFile(newFile, 19, true);</p><p>——&gt;org#jf#dexlib2#DexFileFactory</p><pre><code>`public static DexBackedDexFile loadDexFile(String path, int api, boolean experimental)throws IOException{return loadDexFile(new File(path), &quot;classes.dex&quot;, new Opcodes(api, experimental));}`</code></pre><p>可以看出只提取出了classes.dex这个文件，所以并不支持multidex，如果使用了multidex方案，并且修复的类不在同一个dex文件中，那么补丁就不会生效。</p><h3 id="生成补丁解析"><a href="#生成补丁解析" class="headerlink" title="生成补丁解析"></a>生成补丁解析</h3><p>当时在研究热更新时出现了使用release包加壳后的补丁不能使，为了更好地研究生成的补丁的使用，需要进一步研究一下生成的补丁具体是什么。</p><blockquote><p>工具： jadx</p></blockquote><p>使用参考：<a href="https://liuzhichao.com/2016/jadx-decompiler.html" target="_blank" rel="noopener">https://liuzhichao.com/2016/jadx-decompiler.html</a></p><blockquote><p>将加壳前和加壳后生成的补丁，后缀改为zip，得到noshell.out.zip和shell.out.zip，解压后二者都是由两部分组成</p></blockquote><p><img src="http://i.imgur.com/6TLvmKO.png" alt=""></p><p>通过jadx查看 未加壳生成的补丁dex文件<br><img src="http://i.imgur.com/3QTF5Es.png" alt=""><br>可以清楚看到加注解的方法，注解之中写了clazz和method的值，对应着apk包中的类名和方法名称；然后就是前后替换的地方</p><p>而当用jadx查看加壳后引起一场的补丁时候，<br><img src="http://i.imgur.com/Zi75LwY.png" alt=""></p><p>可以看出，加壳之后两个apk根本无法通过diff正确生成补丁，初步推断应该是加壳引入更大的混淆，是的前后两个apk根本无法通过增量比对判断变化，这种error补丁后补丁加入之后会引起 java.lang.VerifyError<br><img src="http://i.imgur.com/8Mcue65.png" alt=""></p><p>因此做好异常保护十分重要</p><h1 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h1><blockquote><p>优点</p></blockquote><p>1）可以多次打补丁。如果本地保存了多个补丁，那么AndFix会按照补丁生成的时间顺序加载补丁。具体是根据.apatch文件中的PATCH.MF的字段Created-Time。</p><p>2）安全性</p><p>readme提示开发者需要验证下载过来的apatch文件的签名是否就是在使用apkpatch工具时使用的签名，如果不验证那么任何人都可以制作自己的apatch文件来对你的APP进行修改。 但是我看到AndFix已经做了验证，如果补丁文件的证书和当前apk的证书不是同一个的话，就不能加载补丁。 官网还有一条，提示需要验证optimize file的指纹，应该是为了防止有人替换掉本地保存的补丁文件，所以要验证MD5码，然而SecurityChecker类里面也已经做了这个工作。。但是这个MD5码是保存在sharedpreference里面，如果手机已经root那么还是可以被访问的。</p><p>3）不需要重启APP即可应用补丁。</p><blockquote><p>缺点</p></blockquote><p>1）不支持YunOS </p><p>2）无法添加新类和新的字段 </p><p>3）需要使用加固前的apk制作补丁，但是补丁文件很容易被反编译，也就是修改过的类源码容易泄露 </p><p>4）使用加固平台可能会使热补丁功能失效 </p><p>5）无法添加类和字段</p><p>6)如果使用了multidex方案，并且修复的类不在同一个dex文件中，那么补丁就不会生效。</p><h1 id="再次总结"><a href="#再次总结" class="headerlink" title="再次总结"></a>再次总结</h1><p>andfix热补丁的原理就是，通过加载差分补丁，把需要替换的方法注入到native层，然后通过替换新老方法的函数指针，从而达到bug修复的目的，但是由于Andfix是动态的跳过了类的初始化，所以对于静态方法，静态成员变量，构造方法，是不能处理的，而且也不支持新增成员变量和修改成员变量。</p><h1 id="其他一些坑"><a href="#其他一些坑" class="headerlink" title="其他一些坑"></a>其他一些坑</h1><ul><li>自己下载文件的位置不要跟andfix默认的位置一致，否则源码执行addpatch先会在默认位置检查，如果存在直接return而不会去执行loadpatch</li><li>含有loadpatch的地方要做好保护</li><li>需要提供未加壳apk生成的补丁文件，而不是加壳后的补丁</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;概述篇&quot;&gt;&lt;a href=&quot;#概述篇&quot; class=&quot;headerlink&quot; title=&quot;概述篇&quot;&gt;&lt;/a&gt;概述篇&lt;/h1&gt;&lt;p&gt;AndFix，全称是Androi
      
    
    </summary>
    
      <category term="开源学习" scheme="https://xsfelvis.github.io/categories/%E5%BC%80%E6%BA%90%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Andfix" scheme="https://xsfelvis.github.io/tags/Andfix/"/>
    
  </entry>
  
  <entry>
    <title>注解基础</title>
    <link href="https://xsfelvis.github.io/2017/01/06/%E6%B3%A8%E8%A7%A3%E5%9F%BA%E7%A1%80/"/>
    <id>https://xsfelvis.github.io/2017/01/06/注解基础/</id>
    <published>2017-01-05T16:00:00.000Z</published>
    <updated>2018-06-06T06:44:36.329Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>注解系列</p><ul><li><a href="https://xsfelvis.github.io/2017/01/06/%E6%B3%A8%E8%A7%A3%E5%9F%BA%E7%A1%80/">注解基础</a></li><li><a href="https://xsfelvis.github.io/2017/03/12/%E7%BC%96%E8%AF%91%E6%9C%9F%E6%B3%A8%E8%A7%A3%E4%B9%8BJavaPoet/">JavaPoet</a></li><li><a href="https://xsfelvis.github.io/2017/04/07/%E7%BC%96%E8%AF%91%E6%9C%9F%E6%B3%A8%E8%A7%A3%E4%B9%8BAPT/">编译期注解处理之APT</a></li></ul><h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>本文主要是介绍注解的基础知识，为后面的APT和JavaPoet打下基础</p><h2 id="0x01-什么是注解"><a href="#0x01-什么是注解" class="headerlink" title="0x01 什么是注解"></a>0x01 什么是注解</h2><p>注解（Annotation）是Java5的一个新特性,是插入在代码中的一种注释或者说是一种元数据（meta data），这些注释信息可以在编译期使用预编译工具进行获取处理，也可以在运行期使用Java反射机制来获取，这取决于你的注解类型。</p><h2 id="0x02-注解的语法及其定义"><a href="#0x02-注解的语法及其定义" class="headerlink" title="0x02 注解的语法及其定义"></a>0x02 注解的语法及其定义</h2><p>在Android中注解经常存在我们代码中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main4);</span><br><span class="line">    getIntentData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的<code>@Override</code>就是系统的注解，表明这是个重写方法，点击源码可以看到长成下面的样子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际中会带有一些参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> run_methodInfo &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> "<span class="keyword">long</span>"</span>;</span><br><span class="line">    <span class="function">String <span class="title">data</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> 365</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Retention @Target @Document @Inherited四种 是元注解即 “注解的注解”</p><blockquote><p>@Target 表示该注解目标,可能的 ElemenetType 参数包括:</p></blockquote><ul><li>ElemenetType.CONSTRUCTOR 构造器声明</li><li>ElemenetType.FIELD 域声明(包括 enum 实例) </li><li>ElemenetType.LOCAL_VARIABLE 局部变量声明 </li><li>ElemenetType.METHOD 方法声明 </li><li>ElemenetType.PACKAGE 包声明 </li><li>ElemenetType.PARAMETER 参数声明 </li><li>ElemenetType.TYPE 类，接口(包括注解类型)或enum声明</li></ul><blockquote><p>@Retention 表示该注解的生命周期,可选的 RetentionPolicy 参数包括</p></blockquote><ul><li>RetentionPolicy.SOURCE 注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃注解将被编译器丢弃 </li><li>RetentionPolicy.CLASS 注解被保留到class文件，但jvm加载class文件时候被遗弃</li><li>RetentionPolicy.RUNTIME 注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在；，因此可以通过反射机制读取注解的信息</li></ul><blockquote><p>@Documented 指示将此注解包含在 javadoc 中<br>@Inherited 指示允许子类继承父类中的注解</p></blockquote><p>使用注解需要遵守它的规则：</p><ul><li>Annotation型定义为@interface, 所有的Annotation会自动继承java.lang.Annotation这一接口,并且不能再去继承别的类或是接口.</li><li>参数成员只能用public或默认(default)这两个访问权修饰</li><li>参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和String、Enum、Class、annotations等数据类型,以及这一些类型的数组.</li><li>要获取类方法和字段的注解信息，必须通过Java的反射技术来获取 Annotation对象,因为你除此之外没有别的获取注解对象的方法（分为编译期还是运行期）</li></ul><h2 id="0x03-使用"><a href="#0x03-使用" class="headerlink" title="0x03 使用"></a>0x03 使用</h2><p>（这里仅介绍最常见的运行期的注解，编译期注解涉及到apt、javapoet会单独再开一篇介绍）</p><blockquote><p>Step One 定义注解</p></blockquote><p>先看三个Runtime注解，包括类、方法、字段，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> run_classInfo &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> run_methodInfo &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> "<span class="keyword">long</span>"</span>;</span><br><span class="line">    <span class="function">String <span class="title">data</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> 365</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> run_fieldInfo &#123;</span><br><span class="line">    <span class="keyword">int</span>[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Step two 使用这些注解，</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@run</span>_classInfo(<span class="string">"类注解RunTime Class"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunTimeTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@run</span>_fieldInfo(value = &#123;<span class="number">77</span>, <span class="number">88</span>&#125;)</span><br><span class="line">    <span class="keyword">public</span> String fieldInfo = <span class="string">"filedInfo"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@run</span>_fieldInfo(value = &#123;<span class="number">163</span>&#125;)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@run</span>_methodInfo(name = <span class="string">"彩笔学长"</span>, data = <span class="string">"finance"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RunTimeTest.class.getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用反射解析注解</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析运行时注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showRunTimeInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="comment">//获取Class 注解</span></span><br><span class="line">    Class&lt;?&gt; clazz = RunTimeTest.class;</span><br><span class="line">    Constructor&lt;?&gt;[] constructors = clazz.getConstructors();</span><br><span class="line">    <span class="comment">//获取包含的注解类信息</span></span><br><span class="line">    run_classInfo runClassInfo = clazz.getAnnotation(run_classInfo.class);</span><br><span class="line">    <span class="keyword">if</span> (runClassInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取class注解</span></span><br><span class="line">        sb.append(<span class="string">"Class注解: "</span>).append(<span class="string">"\n"</span>);</span><br><span class="line">        sb.append(Modifier.toString(clazz.getModifiers())).append(<span class="string">" "</span>)</span><br><span class="line">                .append(clazz.getSimpleName()).append(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        sb.append(<span class="string">"注解值："</span>).append(<span class="string">"\n"</span>)</span><br><span class="line">                .append(runClassInfo.value()).append(<span class="string">"\n\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Field注解</span></span><br><span class="line">    sb.append(<span class="string">"Field注解："</span>).append(<span class="string">"\n"</span>);</span><br><span class="line">    Field[] fields = clazz.getDeclaredFields(); <span class="comment">//获取自身的不包括继承类</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">        <span class="comment">//获取field注解类信息</span></span><br><span class="line">        run_fieldInfo fieldInfo = field.getAnnotation(run_fieldInfo.class);</span><br><span class="line">        <span class="keyword">if</span> (fieldInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sb.append(Modifier.toString(field.getModifiers())).append(<span class="string">" "</span>)</span><br><span class="line">                    .append(field.getType().getSimpleName()).append(<span class="string">" "</span>)</span><br><span class="line">                    .append(field.getName()).append(<span class="string">"\n"</span>);</span><br><span class="line">            sb.append(<span class="string">"注解值： "</span>).append(<span class="string">"\n"</span>)</span><br><span class="line">                    .append(Arrays.toString(fieldInfo.value())).append(<span class="string">"\n\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Method 注解</span></span><br><span class="line">    sb.append(<span class="string">"Method注解： "</span>).append(<span class="string">"\n"</span>);</span><br><span class="line">    Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        run_methodInfo methodInfo = method.getAnnotation(run_methodInfo.class);</span><br><span class="line">        <span class="keyword">if</span> (methodInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sb.append(Modifier.toString(method.getModifiers())).append(<span class="string">" "</span>)</span><br><span class="line">                    .append(method.getReturnType().getSimpleName()).append(<span class="string">" "</span>)</span><br><span class="line">                    .append(method.getName()).append(<span class="string">"\n"</span>);</span><br><span class="line">            sb.append(<span class="string">"注解值："</span>).append(<span class="string">"\n"</span>);</span><br><span class="line">            sb.append(<span class="string">"name: "</span>).append(methodInfo.name()).append(<span class="string">"\n"</span>);</span><br><span class="line">            sb.append(<span class="string">"data: "</span>).append(methodInfo.data()).append(<span class="string">"\n"</span>);</span><br><span class="line">            sb.append(<span class="string">"id: "</span>).append(methodInfo.id()).append(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    tvDes.setText(sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##0x04 参考文献</p><ul><li><a href="http://www.cnblogs.com/lbangel/p/3523741.html" target="_blank" rel="noopener">http://www.cnblogs.com/lbangel/p/3523741.html</a></li><li><a href="http://blog.csdn.net/github_35180164/article/details/52107204" target="_blank" rel="noopener">http://blog.csdn.net/github_35180164/article/details/52107204</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;注解系列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://xsfelvis.github.io/2017/01/06/%E6%B3%A8%E8%A7%A3%E5%
      
    
    </summary>
    
      <category term="注解" scheme="https://xsfelvis.github.io/categories/%E6%B3%A8%E8%A7%A3/"/>
    
    
      <category term="注解" scheme="https://xsfelvis.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>自定义Lint</title>
    <link href="https://xsfelvis.github.io/2016/12/16/%E8%87%AA%E5%AE%9A%E4%B9%89Lint/"/>
    <id>https://xsfelvis.github.io/2016/12/16/自定义Lint/</id>
    <published>2016-12-15T16:00:00.000Z</published>
    <updated>2018-06-04T15:26:13.043Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Lint"><a href="#Lint" class="headerlink" title="Lint"></a>Lint</h1><p>在android studio中内置了大概200个左右的lint检查，比如定义变量未使用，直接Handler报内存泄漏提醒，时时刻刻在监督着我们的代码。自己定制了一些Lint规则，项目开源在GitHub上<br><a href="https://github.com/xsfelvis/LintDemo" title="项目地址" target="_blank" rel="noopener">https://github.com/xsfelvis/LintDemo</a></p><h3 id="为什么需要自定义Lint"><a href="#为什么需要自定义Lint" class="headerlink" title="为什么需要自定义Lint"></a>为什么需要自定义Lint</h3><ul><li><p>原生Lint无法满足团队特有的需求，如：编码规范</p></li><li><p>原生Lint存在一些检测缺陷或者缺少一些我们认为有必要的检测,如new Message等</p></li></ul><h3 id="自定义Lint-主要完成了以下功能"><a href="#自定义Lint-主要完成了以下功能" class="headerlink" title="自定义Lint,主要完成了以下功能"></a>自定义Lint,主要完成了以下功能</h3><ul><li>Actvity、Fragment布局文件名称前缀为<code>actvity_</code>、<code>fragment_</code>的检查</li><li>Log、System.out.pritln打印必须为工程中自定义的<code>AppLog</code>检查(这个因项目而异)</li><li>检测new Message,提醒使用<code>Message.Obtain()</code>/<code>handler.obtainMessage</code></li><li>xml文件中各种控件命名规范化，如Buttion前缀为btn，适合规范化编程</li></ul><blockquote><p>依赖方式</p></blockquote><p>采用LinkedIn提供了另一种思路 : 将jar放到一个aar中。这样我们就可以针对工程进行自定义Lint，lint.jar只对当前工程有效，使用前记得开启AS的支持自定义Lint检查功能，如下图<br><img src="https://user-gold-cdn.xitu.io/2016/12/16/d99bffe30fec6ddc7eb08c02afecad0f.png" alt=""></p><blockquote><p>部分效果示意图</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2016/12/16/19f5dfe820be8ef2944395f8c2ab72d0.png" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2016/12/16/c90d7bffdc9558febbbeaf6baa5b9cda.png" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2016/12/16/6bd951cd05c7e3b245908b1d6d2dc1aa.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Lint&quot;&gt;&lt;a href=&quot;#Lint&quot; class=&quot;headerlink&quot; title=&quot;Lint&quot;&gt;&lt;/a&gt;Lint&lt;/h1&gt;&lt;p&gt;在android stu
      
    
    </summary>
    
      <category term="工具" scheme="https://xsfelvis.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Lint" scheme="https://xsfelvis.github.io/tags/Lint/"/>
    
  </entry>
  
  <entry>
    <title>粒子动画效果</title>
    <link href="https://xsfelvis.github.io/2016/11/28/%E7%B2%92%E5%AD%90%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0/"/>
    <id>https://xsfelvis.github.io/2016/11/28/粒子动画学习/</id>
    <published>2016-11-27T16:00:00.000Z</published>
    <updated>2018-06-04T04:56:43.869Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="粒子效果动画"><a href="#粒子效果动画" class="headerlink" title="粒子效果动画"></a>粒子效果动画</h1><p>看了几个开源库，自己在学习过程中重构了一个供自己以后使用</p><p>源码地址:<a href="https://github.com/xsfelvis/Explosion" target="_blank" rel="noopener">https://github.com/xsfelvis/Explosion</a></p><p>效果图：</p><p><img src="http://ogopjinry.bkt.clouddn.com/particle.gif" alt="particle"></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>提供了6中粒子动画效果，框架支持扩展，若有新的粒子需求可以继承Particle实现自己的需求，整体框架如下</p><p><img src="http://ogopjinry.bkt.clouddn.com/Particle.jpeg" alt="particleUml"></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>已经单独将粒子动画部分抽成modudle依赖，直接添加依赖即可，或者使用jar包<a href="http://ogopjinry.bkt.clouddn.com/explosion.jar" target="_blank" rel="noopener">jar包下载地址</a>，然后在Actvity中按照如下方式使用即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ExplosionView explosionView;</span><br><span class="line"><span class="comment">//找到对应的控件</span></span><br><span class="line">tvNormal = (TextView) findViewById(R.id.tvNormal);</span><br><span class="line">ivVx = (ImageView) findViewById(R.id.ivVx);</span><br><span class="line"><span class="comment">//设置监听即可</span></span><br><span class="line">explosionView = <span class="keyword">new</span> ExplosionView(<span class="keyword">this</span>, <span class="keyword">new</span> ParticleFactory(ParticleFactory.NORMAL));     explosionView.addExplosionListener(tvNormal);</span><br><span class="line">explosionView.addExplosionListener(ivVx);</span><br></pre></td></tr></table></figure><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>站在巨人的肩膀上会领略到更多的风景，并在他们的基础上做了大量的重构。<br>Thanks </p><ul><li><a href="https://github.com/Xieyupeng520/AZExplosion" target="_blank" rel="noopener">https://github.com/Xieyupeng520/AZExplosion</a></li><li><a href="https://github.com/tyrantgit/ExplosionField" target="_blank" rel="noopener">https://github.com/tyrantgit/ExplosionField</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;粒子效果动画&quot;&gt;&lt;a href=&quot;#粒子效果动画&quot; class=&quot;headerlink&quot; title=&quot;粒子效果动画&quot;&gt;&lt;/a&gt;粒子效果动画&lt;/h1&gt;&lt;p&gt;看了几个
      
    
    </summary>
    
      <category term="开源学习" scheme="https://xsfelvis.github.io/categories/%E5%BC%80%E6%BA%90%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="粒子动画" scheme="https://xsfelvis.github.io/tags/%E7%B2%92%E5%AD%90%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
</feed>
