<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>云来</title>
  
  <subtitle>不积跬步，无以至千里；不积小流，无以成江海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xsfelvis.github.io/"/>
  <updated>2018-06-03T17:42:32.539Z</updated>
  <id>https://xsfelvis.github.io/</id>
  
  <author>
    <name>云来</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《剑指offer》刷题笔记系列综述</title>
    <link href="https://xsfelvis.github.io/2017/12/01/offer-0/"/>
    <id>https://xsfelvis.github.io/2017/12/01/offer-0/</id>
    <published>2017-11-30T16:00:00.000Z</published>
    <updated>2018-06-03T17:42:32.539Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/CodingInterviewChinese2" target="_blank" rel="noopener">https://github.com/WordZzzz/CodingInterviewChinese2</a></strong></li><li><strong>文章地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li><li><strong>题&emsp;&emsp;库：剑指offer</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;WordZzzz原计划按照牛客网上面的《剑指offer》的通过率高低来把66道编程题刷一遍，但是后来发现，相对于牛客网上大神的解答，WordZzzz更倾向于原书作者的详解。所以，从今天开始，本博主打算按照《剑指offer》纪念版上的题目顺序来进行后续的总结，以作者何大大思路为主，以牛客网上各路大声的代码为辅，对每一道题的解法进行详细的记录，方便自己日后查看，也为订阅本专栏的各位可爱的亲人们提供一些参考。</p><ul><li>《剑指offer》何大大的源码（含测试代码）传送门：<a href="https://github.com/zhedahht/CodingInterviewChinese2" target="_blank" rel="noopener">https://github.com/zhedahht/CodingInterviewChinese2</a></li><li>当然我自己也fork了一下：<a href="https://github.com/WordZzzz/CodingInterviewChinese2" target="_blank" rel="noopener">https://github.com/WordZzzz/CodingInterviewChinese2</a></li><li>再来个码云的传送门吧：<a href="https://gitee.com/WordZzzz/CodingInterviewChinese2" target="_blank" rel="noopener">https://gitee.com/WordZzzz/CodingInterviewChinese2</a></li><li>至于《剑指offer》纪念版的电子版当然我也有，网上最清晰的资源，需要的请私信我。有条件的还是建议购买正版书籍，支持何大大，支持正版！</li></ul><p>&emsp;&emsp;另外，下面这道开胃菜牛客上没有，所以先贴出来了。</p><h2 id="赋值运算符函数"><a href="#赋值运算符函数" class="headerlink" title="赋值运算符函数"></a>赋值运算符函数</h2><p>&emsp;&emsp;如下为类型CMyString的生命，请为该类型添加赋值运算符函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CMyString(<span class="keyword">char</span>* pData = <span class="literal">NULL</span>);</span><br><span class="line">    CMyString(<span class="keyword">char</span>* CMyString&amp; str);</span><br><span class="line">    ~CMyString(<span class="keyword">void</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CMyString(<span class="keyword">char</span>* pData = <span class="literal">NULL</span>);</span><br><span class="line">    CMyString(<span class="keyword">char</span>* CMyString&amp; str);</span><br><span class="line">    ~CMyString(<span class="keyword">void</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="考察细节"><a href="#考察细节" class="headerlink" title="考察细节"></a>考察细节</h3><ul><li>是否会把返回值的类型声明为该类型的引用，并在函数结束前返回实例自身的引用（即*this）。只有返回一个引用，才可以允许连续赋值。否则如果函数的返回值是void，应用该赋值运算符将不能做连续赋值。假设有3个CMyString的对象：str1、str2和str3，在程序中语句str1=str2=str3是不能通过编译的。</li><li>是否把传入的参数的类型声明为常量引用。如果传入的参数不是引用而是实例，那么从形参到实参会调用一次复制构造函数，吧参数声明为引用可以避免这样的消耗，能提高代码的效率。同时，我们在赋值运算符函数中不会改变传入的实例的状态，因此应该为传入的引用参数加上const关键字。</li><li>是否释放实例自身已有的内存。如果我们忘记在分配新内存之前释放自身已有的空间，程序将出现内存泄漏。</li><li>是否判断传入的参数和但钱的实例是不是同一个实例。如果是同一个，则不进行赋值操作，直接返回。如果事先不判断就进行赋值，那么在释放自身的内存的时候就会导致严重的问题：当*this和传入的参数是同一个实例时，那么一旦释放了自身的内存，传入的参数的内存也同时被释放了，因此再也找不到需要赋值的内容了。</li></ul><h3 id="经典的解法"><a href="#经典的解法" class="headerlink" title="经典的解法"></a>经典的解法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span> = (<span class="keyword">const</span> CMyString &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> []m_pData;</span><br><span class="line">    m_pData = <span class="literal">NULL</span>;</span><br><span class="line">    m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_pData, str.m_pData);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这是一般教材上提供的参考代码。明眼人可能会发现，上述代码在分配内存之前先用delete释放了实例m_pData的内存。如果此时内存不足导致new char抛出异常，m_pData将是一个空指针，这昂非常容易导致程序的崩溃。</p><h3 id="考虑异常安全性的解法"><a href="#考虑异常安全性的解法" class="headerlink" title="考虑异常安全性的解法"></a>考虑异常安全性的解法</h3><p>&emsp;&emsp;要想在赋值运算符函数中实现异常安全性，一般有两种方法。一个简单的办法是我们先用new分配新内存再用delete释放已有的内容；一个更好的方法是创建临时实例，再交换临时实例和原来的实例。参考代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span> = (<span class="keyword">const</span> CMyString &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;str)</span><br><span class="line">    &#123;</span><br><span class="line">        CMyString strTemp(str);</span><br><span class="line">        </span><br><span class="line">        cahr* pTemp = strTemp.m_pData;</span><br><span class="line">        strTemp.m_pData = m_pData;</span><br><span class="line">        m_pData = pTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;程序比较简单，值得注意的是，strTemp是一个局部变量，程序运行到if的外面的时候，也就出了该变量的作用域，就会自动调用其析构函数，把strTemp.m_pData所指向的内存释放掉。由于strTemp.m_pData指向的内存就是实例之前m_pData的内存，这就相当于自动调用析构函数释放实例的内存。</p><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="AtOffer" scheme="https://xsfelvis.github.io/categories/AtOffer/"/>
    
    
      <category term="AtOffer" scheme="https://xsfelvis.github.io/tags/AtOffer/"/>
    
      <category term="c++" scheme="https://xsfelvis.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>自定义Lint</title>
    <link href="https://xsfelvis.github.io/2016/12/16/%E8%87%AA%E5%AE%9A%E4%B9%89Lint/"/>
    <id>https://xsfelvis.github.io/2016/12/16/自定义Lint/</id>
    <published>2016-12-15T16:00:00.000Z</published>
    <updated>2018-06-04T04:57:34.430Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Lint"><a href="#Lint" class="headerlink" title="Lint"></a>Lint</h1><p>在android studio中内置了大概200个左右的lint检查，比如定义变量未使用，直接Handler报内存泄漏提醒，时时刻刻在监督着我们的代码。自己定制了一些Lint规则，项目开源在GitHub上<br><a href="https://github.com/xsfelvis/LintDemo" title="项目地址" target="_blank" rel="noopener">https://github.com/xsfelvis/LintDemo</a></p><blockquote><p>为什么需要自定义Lint</p></blockquote><ul><li><p>原生Lint无法满足团队特有的需求，如：编码规范</p></li><li><p>原生Lint存在一些检测缺陷或者缺少一些我们认为有必要的检测,如new Message等</p></li></ul><blockquote><p>自定义Lint,主要完成了以下功能</p></blockquote><ul><li>Actvity、Fragment布局文件名称前缀为<code>actvity_</code>、<code>fragment_</code>的检查</li><li>Log、System.out.pritln打印必须为工程中自定义的<code>AppLog</code>检查(这个因项目而异)</li><li>检测new Message,提醒使用<code>Message.Obtain()</code>/<code>handler.obtainMessage</code></li><li>xml文件中各种控件命名规范化，如Buttion前缀为btn，适合规范化编程</li></ul><blockquote><p>依赖方式</p></blockquote><p>采用LinkedIn提供了另一种思路 : 将jar放到一个aar中。这样我们就可以针对工程进行自定义Lint，lint.jar只对当前工程有效，使用前记得开启AS的支持自定义Lint检查功能，如下图<br><img src="https://user-gold-cdn.xitu.io/2016/12/16/d99bffe30fec6ddc7eb08c02afecad0f.png" alt=""></p><blockquote><p>部分效果示意图</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2016/12/16/19f5dfe820be8ef2944395f8c2ab72d0.png" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2016/12/16/c90d7bffdc9558febbbeaf6baa5b9cda.png" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2016/12/16/6bd951cd05c7e3b245908b1d6d2dc1aa.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Lint&quot;&gt;&lt;a href=&quot;#Lint&quot; class=&quot;headerlink&quot; title=&quot;Lint&quot;&gt;&lt;/a&gt;Lint&lt;/h1&gt;&lt;p&gt;在android stu
      
    
    </summary>
    
      <category term="工具" scheme="https://xsfelvis.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Lint" scheme="https://xsfelvis.github.io/tags/Lint/"/>
    
  </entry>
  
  <entry>
    <title>粒子动画效果</title>
    <link href="https://xsfelvis.github.io/2016/11/28/%E7%B2%92%E5%AD%90%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0/"/>
    <id>https://xsfelvis.github.io/2016/11/28/粒子动画学习/</id>
    <published>2016-11-27T16:00:00.000Z</published>
    <updated>2018-06-04T04:56:43.869Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="粒子效果动画"><a href="#粒子效果动画" class="headerlink" title="粒子效果动画"></a>粒子效果动画</h1><p>看了几个开源库，自己在学习过程中重构了一个供自己以后使用</p><p>源码地址:<a href="https://github.com/xsfelvis/Explosion" target="_blank" rel="noopener">https://github.com/xsfelvis/Explosion</a></p><p>效果图：</p><p><img src="http://ogopjinry.bkt.clouddn.com/particle.gif" alt="particle"></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>提供了6中粒子动画效果，框架支持扩展，若有新的粒子需求可以继承Particle实现自己的需求，整体框架如下</p><p><img src="http://ogopjinry.bkt.clouddn.com/Particle.jpeg" alt="particleUml"></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>已经单独将粒子动画部分抽成modudle依赖，直接添加依赖即可，或者使用jar包<a href="http://ogopjinry.bkt.clouddn.com/explosion.jar" target="_blank" rel="noopener">jar包下载地址</a>，然后在Actvity中按照如下方式使用即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ExplosionView explosionView;</span><br><span class="line"><span class="comment">//找到对应的控件</span></span><br><span class="line">tvNormal = (TextView) findViewById(R.id.tvNormal);</span><br><span class="line">ivVx = (ImageView) findViewById(R.id.ivVx);</span><br><span class="line"><span class="comment">//设置监听即可</span></span><br><span class="line">explosionView = <span class="keyword">new</span> ExplosionView(<span class="keyword">this</span>, <span class="keyword">new</span> ParticleFactory(ParticleFactory.NORMAL));     explosionView.addExplosionListener(tvNormal);</span><br><span class="line">explosionView.addExplosionListener(ivVx);</span><br></pre></td></tr></table></figure><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>站在巨人的肩膀上会领略到更多的风景，并在他们的基础上做了大量的重构。<br>Thanks </p><ul><li><a href="https://github.com/Xieyupeng520/AZExplosion" target="_blank" rel="noopener">https://github.com/Xieyupeng520/AZExplosion</a></li><li><a href="https://github.com/tyrantgit/ExplosionField" target="_blank" rel="noopener">https://github.com/tyrantgit/ExplosionField</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;粒子效果动画&quot;&gt;&lt;a href=&quot;#粒子效果动画&quot; class=&quot;headerlink&quot; title=&quot;粒子效果动画&quot;&gt;&lt;/a&gt;粒子效果动画&lt;/h1&gt;&lt;p&gt;看了几个
      
    
    </summary>
    
      <category term="开源学习" scheme="https://xsfelvis.github.io/categories/%E5%BC%80%E6%BA%90%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="粒子动画" scheme="https://xsfelvis.github.io/tags/%E7%B2%92%E5%AD%90%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>常用设计模式</title>
    <link href="https://xsfelvis.github.io/2016/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
    <id>https://xsfelvis.github.io/2016/11/16/设计模式学习/</id>
    <published>2016-11-15T16:00:00.000Z</published>
    <updated>2018-06-04T04:55:24.485Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>学习设计模式是一个漫长的过程，也是一个程序员登堂入室的必经之路。这篇博文就是记录学习设计模式的过程,会持续更新(属于<code>天狼星</code>计划的一部分，严肃脸)，<code>每个模式都有对应的学习代码</code>，学习在<a href="https://github.com/xsfelvis/DesignPattern.git" target="_blank" rel="noopener">https://github.com/xsfelvis/DesignPattern.git</a></p><h2 id="0x01-大纲"><a href="#0x01-大纲" class="headerlink" title="0x01 大纲"></a>0x01 大纲</h2><table><thead><tr><th></th><th style="text-align:center">创建型</th><th>结构型</th><th style="text-align:right">行为型</th></tr></thead><tbody><tr><td>对象</td><td style="text-align:center">Factory Method</td><td>Adapter_Class</td><td style="text-align:right">Interpreter<br>Template Method</td></tr><tr><td>类</td><td style="text-align:center">Abstract Factory <br> Builder <br> Prototype <br> Singleton</td><td>Adapter_Object <br>Bridge<br>Composite<br> Decorator<br>Facade<br> Flyweight<br>Proxy</td><td style="text-align:right">Chain of Responsibility<br>Command<br> Iterator<br>Mediator<br> Memento<br>Observer<br> State<br>Strategy<br> Visitor</td></tr></tbody></table><h2 id="0x02-Factory-Method-简单工厂方法"><a href="#0x02-Factory-Method-简单工厂方法" class="headerlink" title="0x02 Factory Method (简单工厂方法)"></a>0x02 Factory Method (简单工厂方法)</h2><blockquote><p>Factory Method (简单工厂方法)</p></blockquote><p>又称简单工厂模式或者静态工厂模式</p><ul><li>使用动机</li></ul><p>定义一个用于创建对象的接口，让子类决定去实例化哪一个类。Factory Method使用一个类的实例化延迟到其子类。</p><ul><li>通用UML图</li></ul><p><img src="http://ogopjinry.bkt.clouddn.com/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F" alt="工厂模式"></p><p>这个uml基本概括了工厂模式的核心，其他的都是可以根据这个衍生发展。</p><p>主要分为4大模块，</p><p><code>抽象工厂</code>：其为工厂方法模式的核心；</p><p><code>具体工厂</code>：体现实现具体的业务逻辑</p><p><code>抽象产品</code>：是工厂方法模式所创建的产品的父类</p><p><code>具体产品</code>：实现抽象产品的某个具体产品的对象</p><ul><li>适用场景</li></ul><ol><li>当一个类不知道它所必须创建对象类的时候</li><li>当一个类希望由它的子类来指定它所创建的对象的时候</li><li>当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候</li></ol><ul><li>要点分析</li></ul><blockquote><p>工厂根据type生成对应示例</p></blockquote><p>在最简单的工厂中，往往传入产品的type，然后得到具体的产品示例。在我们金融app中分享部分的代码就是按照这个思路来处理的(代码已经脱敏)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShareButtonClick</span><span class="params">(<span class="keyword">int</span> btnType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (btnType)&#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.weixin:</span><br><span class="line">                client = ShareFactory.getClient(<span class="keyword">this</span>, ShareFactory.ClientEnum.wx);</span><br><span class="line">                ((WXClient) client).setType(SendMessageToWX.Req.WXSceneSession);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出通过在工厂中定义一个枚举类型，然后根据传入的type生成对应的示例</p><blockquote><p>传入class 根据反射更加简洁的生产出具体产品</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 抽象工厂方法</span></span><br><span class="line"><span class="comment"> * 具体交由子类实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//public abstract Product createProduct();</span></span><br><span class="line">    <span class="comment">//使用抽象类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends Product&gt; <span class="function">T <span class="title">createProduct</span><span class="params">(Class&lt;T&gt; clz)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 具体工厂实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreateFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="comment">//根据传入的class通过反射取得</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Product&gt; <span class="function">T <span class="title">createProduct</span><span class="params">(Class&lt;T&gt; clz)</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            product = (Product) (Class.forName(clz.getName())).newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) product;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public Product createProduct() &#123;</span></span><br><span class="line"><span class="comment">        return new ProductA();</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Factory factory = <span class="keyword">new</span> ConcreateFactory();</span><br><span class="line">        <span class="comment">//Product product = new ProductA();</span></span><br><span class="line">        Product product = factory.createProduct(ProductA.class);</span><br><span class="line">        product.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>工厂方法模式 降低了对象之间的耦合度，而且依赖于抽象的架构，扩展性比较好</p></blockquote><h2 id="0x03-Abstract-Factory-抽象工厂模式"><a href="#0x03-Abstract-Factory-抽象工厂模式" class="headerlink" title="0x03 Abstract Factory(抽象工厂模式)"></a>0x03 Abstract Factory(抽象工厂模式)</h2><blockquote><p>Abstract Factory(抽象工厂模式)</p></blockquote><ul><li>使用动机</li></ul><p>提供一个创建一些列相关或相互依赖对象的接口,而无需指定它们的具体类</p><p>相比之前的工厂都是生产具体的产品，抽象工厂生产的产品是不确定的。起源于操作系统的图形化结业方案，每个操作系统都是一个产品类，而各自的按钮与文本框也是构成一个产品类，这两种产品都有自己的特性，如android和ios的Button和TextView等。</p><ul><li>通用UML图</li></ul><p><img src="http://ogopjinry.bkt.clouddn.com/abstract%20factory.jpg" alt="abstract factory"></p><p>跟普通工厂一样，主要的类还是4个：</p><p><code>AbstractFactroy</code>：抽象工厂角色，声明了一组用于创建一种产品的方法，每个方法对应一种产品。</p><p><code>ConcreateFactroy</code>：具体工厂角色，实现在抽象工厂中定义的产品的方法，生成一组具体产品，这些产品构成一个产品种类，每个产品都位于某个产品等级结构中，如ConcreateFactroy1和ConcreateFactroy2。</p><p><code>AbstractProduct</code>：抽象产品角色，它为每种产品声明接口，如AbstractProductA和AbstractProductB。</p><p><code>ConcreateProduct</code>：具体产品角色，它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。</p><ul><li><p>适用场景</p><ol><li>一个系统要独立于它的产品的创建、组合和表示</li><li>一个系统要由多个产品系列中的一个来配置时</li><li>当需要强调一系列相关的产品对象的设计以便进行联合使用</li><li>当提供一个产品类库，只想显示它们接口而不是实现</li></ol></li></ul><p>缺点：</p><p>抽象工厂的缺点就是随着工厂类增多而导致类文件非常多，这个在实际开发中要权衡使用</p><h2 id="0x04-Builder-建造者模式"><a href="#0x04-Builder-建造者模式" class="headerlink" title="0x04 Builder(建造者模式)"></a>0x04 Builder(建造者模式)</h2><ul><li>使用动机</li></ul><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p><ul><li>适用场景</li></ul><ol><li>当要实例化的类是在运行时刻指定时，例如，通过动态装载；</li><li>为了避免创建一个与产品类层次平行的工厂类层次时；</li><li>当一个类的实例只能有几个不同状态组合中的一种时，建立相应得原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</li></ol><ul><li>通用UML图</li></ul><p><img src="http://ogopjinry.bkt.clouddn.com/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.jpg" alt="Builder"></p><p>建造者模式通常也是有4大部分组成</p><p>Product产品类: 产品的抽象类</p><p>Builder: 抽象Builder类，规范产品的组建，一般是由子类实现具体的构建过程</p><p>ConcreateBuilder： 具体的Builder类</p><p>Director： 统一组装过程</p><ul><li>要点分析</li></ul><blockquote><p>链式调用</p></blockquote><p>通常在开发中，Director可以当做内部类来处理，直接使用一个Builder来进行对象的组装，这个Buidler通常称为链式调用，它的关键点是每个setter方法都返回自身即<code>return this</code> 这样就使得setter方法可以称为链式调用，套路如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">new</span> TestBuilder().setA(<span class="string">"A"</span>).setB(<span class="string">"B"</span>).create();</span><br></pre></td></tr></table></figure><blockquote><p>Dialog的经典实现</p></blockquote><h2 id="0x05-单例模式"><a href="#0x05-单例模式" class="headerlink" title="0x05 单例模式"></a>0x05 单例模式</h2><ul><li>使用动机</li></ul><p>保证一个类仅有一个实例，而且自行实例化并向整个系统提供这个实例</p><ul><li>使用场景</li></ul><ol><li>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时</li><li>当这个唯一实例应该是通过子类化可以扩展，并且客户应该无需更改代码就可以使用一个扩展的实例时</li></ol><ul><li>核心UML图</li></ul><p><img src="http://ogopjinry.bkt.clouddn.com/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.jpeg" alt=""></p><p>核心角色有2个</p><p><code>Client</code>  高层客户端<br><code>Singleton</code> 单例类</p><ul><li>要点分析</li></ul><ol><li>构造函数不对外开放，一般为Private</li><li>通过一个静态方法或者枚举类返回单例类对象</li><li>确保单例类的对象有且只有一个，尤其是在多线程的环境下</li><li>确保单例类对象在反序列化是不会重新构建对象</li><li>实现方式：</li></ol><p>单例看似简单，其实很有门道的，常见的比如<code>饿汉模式</code>、<code>懒汉模式</code> 、<code>双重检验(valtile)</code>等，下面将一一道来。</p><blockquote><p>饿汉模式&amp;懒汉模式</p></blockquote><p>首先需要介绍下什么是<code>延迟加载</code>，即等到真正使用的时候才去创建实例，不用的时候不去创建实例。</p><p>因此从速度和反应时间角度来看，非延时加载(饿汉模式)好,从资源利用率上看，延时加载(又称懒汉模式)好。<br>先从两个简单的入手：</p><p>第一种：非延时加载(饿汉模式)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种：同步延迟加载(懒汉模式)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>双重检验(valtile) 同步延时加载</p></blockquote><p>第三种：双重检测同步延迟加载(懒汉模式)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DCSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span>  <span class="keyword">static</span>  DCSingleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DCSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DCSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DCSingleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> DCSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种单例方式在java中会行不通的，可以看到上面的代码对instance进行二次检查，第一层判断是为了避免不必要的同步，第二层判断是为了在null情况下创建实例，目的是避开过多的同步，需要声明instance时定义为volatile即可。java中之所以需要双重加锁进行单例，是由于java内存模型允许<code>无序写入</code>，假设未加上关键字volatile时，执行到instance=new Singleton()时，实际上它并不是一个原子操作，会被编译成多条汇编指令，大致做了3件事：</p><p>(1)给DCSingleton 的实例分配内存<br>(2)调用DCSingleton()的构造函数，初始化成员字段<br>(3)将instance对象指向分配的内存空间(此时instance就不是null)</p><p>由于java编译器<code>无序写入</code>，Cache、寄存器到主内存的回写顺序，上面第二第三条顺序是无法保证的，即可以是1-2-3也有可能是1-3-2，如果是后者，并且在3执行完毕、2未执行之前，被切换到线程B上，此时A线程已经执行了第三点，instance已经是非空了，B线程直接取走instance再使用时就会报错，这就是DCL失效的问题。而加上volatile关键字则禁止了指令的重排序从而避免了这个问题。</p><blockquote><p>更加优雅的单例</p></blockquote><p>DLC并不优雅，在《java 并发编程实践》一书中建议使用下面的单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BetterSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BetterSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BetterSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BetterSingleton instance = <span class="keyword">new</span> BetterSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式当第一次加载是不会初始化实例instance，只有第一次调用getInstance方法时才会导致instance被初始化。这样不会能够确保线程安全，也能够保证单例对象的唯一性，同时也延时了单例的实例化，这是推荐的单例模式实现方式</p><blockquote><p>使用容器实现单例模式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; objMap = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SingletonManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String key,Object instance)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!objMap.containsKey(key))&#123;</span><br><span class="line">            objMap.put(key,instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getService</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> objMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在程序的初始将多种单例类型注入到一个统一的管理类中，在使用时根据key获取对象对应类型的对象，这种方式使得我们可以管理多种类型的单例，并且在使用可以通过统一的接口进行获取操作，降低了用户的成本，也对用户隐藏了具体实现，降低了耦合度。</p><h2 id="0x06-策略模式"><a href="#0x06-策略模式" class="headerlink" title="0x06 策略模式"></a>0x06 策略模式</h2><ul><li>使用动机</li></ul><p>策略模式定义了一些列的算法，并将每一个算法封装起来，而且使他们可以相互替换。。策略模式让算法独立于使用它的客户端而独立变化。</p><ul><li>使用场景</li></ul><ol><li>针对同一问题的多种处理方式，仅仅是具体行为有差别时</li><li>需要安全地封装多种同一类型的操作时</li><li>出现同一抽象类有多个子类，而又需要使用if-else或者switch-case来选择具体子类时</li></ol><ul><li>核心UML图</li></ul><p><img src="http://ogopjinry.bkt.clouddn.com/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.jpeg" alt="策略模式"></p><p>策略模式主要有3个核心</p><p><code>Context</code>: 用来操作策略的上下文环境</p><p><code>Stragety</code>:策略的抽象</p><p><code>ConcreateStragetyX</code>:具体策略的实现</p><ul><li>要点分析</li></ul><blockquote><p>通过一个Context(实际中可能称作Manager/Controller)结合注入的方式来管理不同的策略</p><p>干掉了多余的if-else</p><p>可扩展性变得很强</p></blockquote><p>缺点： 随着策略的增加，子类会变得繁多</p><h2 id="0x07责任链模式"><a href="#0x07责任链模式" class="headerlink" title="0x07责任链模式"></a>0x07责任链模式</h2><ul><li>动机</li></ul><p>使很多对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，将这些对象连成一条链，并沿着这条链条传递，直到有一个对象处理它为止。</p><ul><li>使用场景</li></ul><ol><li>有多个的对象可以处理一个请求，哪个对象处理该请求，运行时刻自动确定</li><li>你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求<br>3.可处理一个请求的对象集合应被动态指定</li></ol><ul><li>核心UML</li></ul><p><img src="http://ogopjinry.bkt.clouddn.com/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.png" alt="责任链模式"></p><p>主要抽象成两个角色：</p><p><code>Hanlder</code>: 抽象处理者角色，声明一个请求处理的方法，并在其中保持Handler对象的引用</p><p><code>ConcreateHanlder</code>: 具体处理者角色，对请求进行处理，如果不能处理则将该请求转发给下一个节点上的对象处理</p><ul><li>要点分析</li></ul><blockquote><p>精髓在与保持Handler对象的引用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Handler successor;<span class="comment">//下一节点的处理者</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String condition)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通常，责任链中的请求和处理规则是不尽相同的，在这种请求下可以将请求进行封装，同时对请求的处理规则也进行封装作为一个独立的对象</p></blockquote><p>下面将介绍一下基于核心UML的稍微复杂的扩展，UML图如下：</p><p><img src="http://ogopjinry.bkt.clouddn.com/%E5%A4%8D%E6%9D%82%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.png" alt="复杂责任链"></p><blockquote><p>android源码中最典型就是Touch事件的分发</p><p>可以借鉴责任链的思想来优化 有序广播</p><p>优缺点</p></blockquote><ol><li><p>最大的缺点就是对链中请求的遍历，如果处理者爱多那么遍历必定会影响性能，特别是在一些递归调用中，需要谨慎使用</p></li><li><p>优点显而易见，就是请求者和处理者的关系解耦</p></li></ol><h2 id="0x07-状态模式"><a href="#0x07-状态模式" class="headerlink" title="0x07 状态模式"></a>0x07 状态模式</h2><ul><li>使用动机</li></ul><p>允许一个对象再起内部状态改变时改变它的行为，这个对象看起来像是改变了其类</p><ul><li>使用场景</li></ul><ol><li>一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为</li><li>代码中包含大量与对象状态有关的条件语句，且这些分值依赖于该对象的状态。状态模式将每一个条件分值放入一个独立的类中，使得可以根据对象自身情况将对象的状态作为一个对象，这个对象可以不依赖于其他对象而独立变化，这样通过多态来去除过多的、重复的if-else等分支语句</li></ol><ul><li>核心UML图</li></ul><p><img src="http://ogopjinry.bkt.clouddn.com/state.jpg" alt="state"></p><p>抽象成3和核心角色</p><p><code>Context</code>: 环境类，定义客户感兴趣的接口，维护一个State子类实例，这个子类定义了对象当前的状态</p><p><code>State</code>: 抽象状态类或者状态接口，定义一个或者一组接口，表示该状态下的行为</p><p><code>ConcreateX</code>: 具体状态类，每一个具体的状态类实现抽象State中定义的接口，从而达到不同的行为</p><ul><li>要点分析</li></ul><ol><li>状态模式的关键是在不同的状态下对于同一行为在不同状态下有着不同的响应</li></ol><h2 id="0x08-观察者模式"><a href="#0x08-观察者模式" class="headerlink" title="0x08 观察者模式"></a>0x08 观察者模式</h2><ul><li>使用动机</li></ul><p>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并且被自动更新</p><ul><li>使用场景</li></ul><ol><li>关联行为场景，需要注意的是关联行为是可拆分的，而不是组合关系</li><li>事件多级触发场景</li><li>跨系统的消息交换场景，如消息队列，事件总线的处理机制</li></ol><ul><li>核心UML图</li></ul><p><img src="http://ogopjinry.bkt.clouddn.com/Observer.jpg" alt="Observer"></p><p>核心为2个</p><p><code>Observer</code>:抽象观察者，该角色是观察者的抽象类，它定义了一个更新接口，使得在主题更改时通知更新自己</p><p><code>ConcreateObserver</code>: 具体的观察者，该角色实现抽象观察者角色所定义的更新接口，以便在主题的状态发生改变时更新自己</p><ul><li>要点分析</li></ul><p>1.在java中观察者可以继承Observer,发布者可以继承Observable来迅速实现</p><p>2.观察者模式最经典的就是listview的adapter，当然也有EventBus这种事件总线的库也是采用观察者模式</p><blockquote><p>Note：</p><p><code>Step1</code>在ListView中设置Adapter时会构建一个AdapterDataSetObserver,并且注册到Adapter中，这就是一个<code>观察者</code>。Adapter中包含一个数据集<code>可观察者</code>DataSetObservable。<br><code>Step2</code> 在数据发生变更时，开发者手动调用Adapter.notifyDataSetChanged,而notifyDataSetChanged会去调用notifyChanged函数，该函数会遍历所有观察者的onChanged函数。<br><code>Step3</code> 在AdapterDataSetObserver的onChanged函数中会获取Adapter中数据集的新数据，然后调用ListView的requestLayout()方法重新布局更新用户界面</p></blockquote><h2 id="0x09-代理模式"><a href="#0x09-代理模式" class="headerlink" title="0x09 代理模式"></a>0x09 代理模式</h2><ul><li>使用动机</li></ul><p>为其他对象提供一种代理以控制这个对象的访问。</p><ul><li>适用场景</li></ul><ol><li>当无法或者不想直接访问某个对象或者访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口</li></ol><ul><li>核心UML图</li></ul><p><img src="http://ogopjinry.bkt.clouddn.com/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.jpg" alt="代理模式"></p><p>主要有3个角色组成：<br><code>Subject</code>:抽象主题类,该类主要职责是声明真实主题与代理的共同接口方法，该类既可以是一个接口也可以是一个接口</p><p><code>RealSubject</code>:真实主题类,该类也被称为委托类或被代理类，该类定义了代理表示的真实对象，由其执行具体的业务逻辑方法。</p><p><code>ProxSubject</code>:代理类,该类也称为委托类，该类持有一个对真实主题类的引用,在其所实现的接口方法中调用真实主题类中相应的接口方法执行，以此起到代理的作用</p><p><code>Client</code>: 客户类，即使用代理类的类型</p><ul><li>要点分析</li></ul><ol><li>通常代理模式分为<code>静态代理</code>、<code>动态代理</code>,静态代理即在我们的代码运行前代理类的class编译文件就已经存在，而动态代理则与静态代理相反，通过反射机制动态地生成代理者对象，而java也给我们提供了一个便捷的动态代理接口InvocationHandler实现该接口需要重写其调用方法invoke</li><li>静态代理和动态代理只是从code方面来区分代理模式的两种方法，我们也可以通过适用范围来区分不同类型的代理实现<ul><li>远程代理(Remote Proxy):为某个对象在不同的内存地址空间提供局部代理，使系统可以将Server部分实现隐藏，以便Client可以不考虑Server的存在</li><li>虚拟代理(Virtual Proxy):虚拟代理经常直到我们真正需要一个对象时才创建它，当对象在创建前和创建中时，由虚拟代理来扮演对象的替身，对象创建后，代理就会将请求直接委托给对象</li><li>保护代理（Protection Proxy):使用代理控制对原始对象的访问,该类型的代理常用于原始对象有着不同的访问权限的情况<a href="http://blog.csdn.net/shuangde800/article/details/10381495" target="_blank" rel="noopener">保护模式实例</a></li></ul></li></ol><p>未完待续……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00-概述&quot;&gt;&lt;a href=&quot;#0x00-概述&quot; class=&quot;headerlink&quot; title=&quot;0x00 概述&quot;&gt;&lt;/a&gt;0x00 概述&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="设计模式" scheme="https://xsfelvis.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://xsfelvis.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="常用设计模式" scheme="https://xsfelvis.github.io/tags/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式六大原则</title>
    <link href="https://xsfelvis.github.io/2016/11/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%A5%E9%97%A8/"/>
    <id>https://xsfelvis.github.io/2016/11/13/设计模式入门/</id>
    <published>2016-11-12T16:00:00.000Z</published>
    <updated>2018-06-04T04:56:55.754Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>本文主要介绍设计模式的六大原则，这是学习设计模式的总纲。</p><p>设计模式其实是一套被反复使用、总结出来的代码设计经验的总结，使用设计模式是为了重用代码，让代码更加容易的被他人理解，保证代码的可靠性。在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。</p><p>四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。</p><ul><li>对接口编程而不是对实现编程。</li><li>优先使用对象组合而不是继承。</li></ul><h2 id="0x01-设计模式六大原则"><a href="#0x01-设计模式六大原则" class="headerlink" title="0x01 设计模式六大原则"></a>0x01 设计模式六大原则</h2><blockquote><p> 单一职责</p></blockquote><p>一个类只负责一项职责</p><blockquote><p>里氏替换原则</p></blockquote><p>所有引用基类的地方必须透明的使用其子类的对象。该原则是面向对象设计的基本原则之一，是继承复用的基石。只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正的被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充，实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现</p><blockquote><p>依赖倒转原则</p></blockquote><p>这是开闭原则的基础：针对接口编程，依赖于抽象而不依赖于具体</p><blockquote><p>接口隔离原则</p></blockquote><p>使用多个隔离的接口，比使用单个接口要好。还有就是降低类之间的耦合度。</p><blockquote><p>迪米特法则</p></blockquote><p>又称最少知道原则，即一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立</p><h2 id="0x02-设计模式类型"><a href="#0x02-设计模式类型" class="headerlink" title="0x02 设计模式类型"></a>0x02 设计模式类型</h2><p>通常设计模式分为23种，划分为3大类</p><ul><li>创建型模式</li><li>结构型模式</li><li>行为型模式</li></ul><blockquote><p>创建型模式</p></blockquote><p>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用新的运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p><ul><li>工厂模式（Factory Pattern）</li><li>抽象工厂模式（Abstract Factory Pattern）</li><li>单例模式（Singleton Pattern）</li><li>建造者模式（Builder Pattern）</li><li>原型模式（Prototype Pattern）</li></ul><blockquote><p>结构型模式</p></blockquote><p>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p><ul><li>适配器模式（Adapter Pattern）</li><li>桥接模式（Bridge Pattern）</li><li>过滤器模式（Filter、Criteria Pattern）</li><li>组合模式（Composite Pattern）</li><li>装饰器模式（Decorator Pattern）</li><li>外观模式（Facade Pattern）</li><li>享元模式（Flyweight Pattern）</li><li>代理模式（Proxy Pattern）</li></ul><blockquote><p>行为型模式</p></blockquote><p>这些设计模式特别关注对象之间的通信。</p><ul><li>责任链模式（Chain of Responsibility Pattern）</li><li>命令模式（Command Pattern）</li><li>解释器模式（Interpreter Pattern）</li><li>迭代器模式（Iterator Pattern）</li><li>中介者模式（Mediator Pattern）</li><li>备忘录模式（Memento Pattern）</li><li>观察者模式（Observer Pattern）</li><li>状态模式（State Pattern）</li><li>空对象模式（Null Object Pattern）</li><li>策略模式（Strategy Pattern）</li><li>模板模式（Template Pattern）</li><li>访问者模式（Visitor Pattern）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00-概述&quot;&gt;&lt;a href=&quot;#0x00-概述&quot; class=&quot;headerlink&quot; title=&quot;0x00 概述&quot;&gt;&lt;/a&gt;0x00 概述&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="设计模式" scheme="https://xsfelvis.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://xsfelvis.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="solid" scheme="https://xsfelvis.github.io/tags/solid/"/>
    
  </entry>
  
  <entry>
    <title>JavaPoet</title>
    <link href="https://xsfelvis.github.io/2016/11/07/%E7%BC%96%E8%AF%91%E6%9C%9F%E6%B3%A8%E8%A7%A3%E4%B9%8BJavaPoet/"/>
    <id>https://xsfelvis.github.io/2016/11/07/编译期注解之JavaPoet/</id>
    <published>2016-11-06T16:00:00.000Z</published>
    <updated>2018-06-04T04:53:52.932Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>上一篇限于篇幅只介绍了APT，这篇来继续介绍<a href="https://github.com/square/javapoet" target="_blank" rel="noopener">javapoet</a>，是square公司的开源库。正如其名，java诗人，通过注解来生成java源文件，通常要使用javapoet这个库与Filer配合使用。主要和注解配合用来干掉那些重复的模板代码(如butterknife<br>和databinding所做的事情)，当然你也可以使用这个技术让你的代码更加的炫酷。</p><h2 id="0x01-简单使用"><a href="#0x01-简单使用" class="headerlink" title="0x01 简单使用"></a>0x01 简单使用</h2><p>使用之前要先引入这个库 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.squareup:javapoet:1.7.0&apos;</span><br></pre></td></tr></table></figure><p>javapoet是用来生成代码的，需要借助</p><blockquote><p>常用类</p></blockquote><p>使用javapoet前需要了解4个常用类</p><ul><li>MethodSpec 代表一个构造函数或方法声明。</li><li>TypeSpec 代表一个类，接口，或者枚举声明。</li><li>FieldSpec 代表一个成员变量，一个字段声明。</li><li>JavaFile包含一个顶级类的Java文件。</li></ul><p>国际惯例先自动生成一个helloWorld类<br>定义一个编译期注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.CLASS)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">public @interface clazz_hello &#123;</span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后看下helloworld的注解处理器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">@AutoService(Processor.class)</span><br><span class="line">public class HelloWorldProcess extends AbstractProcessor &#123;</span><br><span class="line"></span><br><span class="line">    private Filer filer;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void init(ProcessingEnvironment processingEnv) &#123;</span><br><span class="line">        super.init(processingEnv);</span><br><span class="line">        filer = processingEnv.getFiler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</span><br><span class="line">        for (TypeElement element : annotations) &#123;</span><br><span class="line">            if (element.getQualifiedName().toString().equals(clazz_hello.class.getCanonicalName())) &#123;</span><br><span class="line">                MethodSpec main = MethodSpec.methodBuilder(&quot;main&quot;)</span><br><span class="line">                        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">                        .returns(void.class)</span><br><span class="line">                        .addParameter(String[].class, &quot;args&quot;)</span><br><span class="line">                        .addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;Hello, JavaPoet!&quot;)</span><br><span class="line">                        .build();</span><br><span class="line">                TypeSpec helloWorld = TypeSpec.classBuilder(&quot;HelloWorld&quot;)</span><br><span class="line">                        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">                        .addMethod(main)</span><br><span class="line">                        .build();</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    JavaFile javaFile = JavaFile.builder(&quot;com.xsf&quot;, helloWorld)</span><br><span class="line">                            .addFileComment(&quot; This codes are generated automatically. Do not modify!&quot;)</span><br><span class="line">                            .build();</span><br><span class="line">                    javaFile.writeTo(filer);</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;String&gt; getSupportedAnnotationTypes() &#123;</span><br><span class="line">        Set&lt;String&gt; annotations = new LinkedHashSet&lt;&gt;();</span><br><span class="line">        annotations.add(clazz_hello.class.getCanonicalName());</span><br><span class="line">        return annotations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public SourceVersion getSupportedSourceVersion() &#123;</span><br><span class="line">        return SourceVersion.latestSupported();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就会在app-build-source-apt-debug-com.xsf文件夹下生成这个文件</p><h2 id="0x02-使用进阶"><a href="#0x02-使用进阶" class="headerlink" title="0x02 使用进阶"></a>0x02 使用进阶</h2><blockquote><p>方法&amp;控制流：</p></blockquote><ul><li>添加方法 <code>addcode</code> 和 <code>addstatement</code><br>对与无需类引入的极简代码可以直接使用<code>addCode</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec main = MethodSpec.methodBuilder(&quot;main&quot;)</span><br><span class="line">    .addCode(&quot;&quot;</span><br><span class="line">        + &quot;int total = 0;\n&quot;</span><br><span class="line">        + &quot;for (int i = 0; i &lt; 10; i++) &#123;\n&quot;</span><br><span class="line">        + &quot;  total += i;\n&quot;</span><br><span class="line">        + &quot;&#125;\n&quot;)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成的是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">  int total = 0;</span><br><span class="line">  for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    total += i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要是需要import的方法，如上面的<code>.addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;Hello, JavaPoet!&quot;)</code> 就需要使用<code>.addStatement</code>来声明</p><ul><li>更优雅的流控制</li></ul><p><code>beginControlFlow</code> 流开启<br><code>addStatement</code> 处理语句<br><code>endControlFlow()</code>流结束</p><p>如上面的用流改写就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec main = MethodSpec.methodBuilder(&quot;main&quot;)</span><br><span class="line">    .addStatement(&quot;int total = 0&quot;)</span><br><span class="line">    .beginControlFlow(&quot;for (int i = 0; i &lt; 10; i++)&quot;)</span><br><span class="line">    .addStatement(&quot;total += i&quot;)</span><br><span class="line">    .endControlFlow()</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure></p><blockquote><p>占位符</p></blockquote><p>javapoet里面提供了占位符来帮助我们更好地生成代码</p><ul><li>$L 字面常量（Literals）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private MethodSpec computeRange(String name, int from, int to, String op) &#123;</span><br><span class="line">  return MethodSpec.methodBuilder(name)</span><br><span class="line">      .returns(int.class)</span><br><span class="line">      .addStatement(&quot;int result = 0&quot;)</span><br><span class="line">      .beginControlFlow(&quot;for (int i = $L; i &lt; $L; i++)&quot;, from, to)</span><br><span class="line">      .addStatement(&quot;result = result $L i&quot;, op)</span><br><span class="line">      .endControlFlow()</span><br><span class="line">      .addStatement(&quot;return result&quot;)</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是一个for循环，op负责加减乘除等符号</p><ul><li>$S 字符串常量（String）</li><li>$T 类型(Types)</li></ul><p>最大的特点是自动导入包，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec today = MethodSpec.methodBuilder(&quot;today&quot;)</span><br><span class="line">    .returns(Date.class)</span><br><span class="line">    .addStatement(&quot;return new $T()&quot;, Date.class)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">TypeSpec helloWorld = TypeSpec.classBuilder(&quot;HelloWorld&quot;)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">    .addMethod(today)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">JavaFile javaFile = JavaFile.builder(&quot;com.example.helloworld&quot;, helloWorld)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">javaFile.writeTo(System.out);</span><br></pre></td></tr></table></figure><p>生成的代码如下，而且会自动导包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.example.helloworld;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public final class HelloWorld &#123;</span><br><span class="line">  Date today() &#123;</span><br><span class="line">    return new Date();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想要导入自己写的类怎么办？上面的例子是传入系统的class，这里也提供一种方式，通过ClassName.get（”类的路径”，”类名“），结合$T可以生成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ClassName hoverboard = ClassName.get(&quot;com.mattel&quot;, &quot;Hoverboard&quot;);</span><br><span class="line">ClassName list = ClassName.get(&quot;java.util&quot;, &quot;List&quot;);</span><br><span class="line">ClassName arrayList = ClassName.get(&quot;java.util&quot;, &quot;ArrayList&quot;);</span><br><span class="line">TypeName listOfHoverboards = ParameterizedTypeName.get(list, hoverboard);</span><br><span class="line"></span><br><span class="line">MethodSpec beyond = MethodSpec.methodBuilder(&quot;beyond&quot;)</span><br><span class="line">    .returns(listOfHoverboards)</span><br><span class="line">    .addStatement(&quot;$T result = new $T&lt;&gt;()&quot;, listOfHoverboards, arrayList)</span><br><span class="line">    .addStatement(&quot;result.add(new $T())&quot;, hoverboard)</span><br><span class="line">    .addStatement(&quot;result.add(new $T())&quot;, hoverboard)</span><br><span class="line">    .addStatement(&quot;result.add(new $T())&quot;, hoverboard)</span><br><span class="line">    .addStatement(&quot;return result&quot;)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>然后生成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.example.helloworld;</span><br><span class="line"></span><br><span class="line">import com.mattel.Hoverboard;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public final class HelloWorld &#123;</span><br><span class="line">  List&lt;Hoverboard&gt; beyond() &#123;</span><br><span class="line">    List&lt;Hoverboard&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    result.add(new Hoverboard());</span><br><span class="line">    result.add(new Hoverboard());</span><br><span class="line">    result.add(new Hoverboard());</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在导入包这里，javapoet 同样支持import static,通过<code>addStaticImport</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ClassName hoverboard = ClassName.get(&quot;com.mattel&quot;, &quot;Hoverboard&quot;);</span><br><span class="line"></span><br><span class="line">ClassName namedBoards = ClassName.get(&quot;com.mattel&quot;, &quot;Hoverboard&quot;, &quot;Boards&quot;);</span><br><span class="line"></span><br><span class="line">MethodSpec beyond = MethodSpec.methodBuilder(&quot;beyond&quot;)</span><br><span class="line">    .returns(listOfHoverboards)</span><br><span class="line">    .addStatement(&quot;$T result = new $T&lt;&gt;()&quot;, listOfHoverboards, arrayList)</span><br><span class="line">    .addStatement(&quot;result.add($T.createNimbus(2000))&quot;, hoverboard)</span><br><span class="line">    .addStatement(&quot;result.add($T.createNimbus(\&quot;2001\&quot;))&quot;, hoverboard)</span><br><span class="line">    .addStatement(&quot;result.add($T.createNimbus($T.THUNDERBOLT))&quot;, hoverboard, namedBoards)</span><br><span class="line">    .addStatement(&quot;$T.sort(result)&quot;, Collections.class)</span><br><span class="line">    .addStatement(&quot;return result.isEmpty() $T.emptyList() : result&quot;, Collections.class)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">TypeSpec hello = TypeSpec.classBuilder(&quot;HelloWorld&quot;)</span><br><span class="line">    .addMethod(beyond)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">JavaFile.builder(&quot;com.example.helloworld&quot;, hello)</span><br><span class="line">    .addStaticImport(hoverboard, &quot;createNimbus&quot;)</span><br><span class="line">    .addStaticImport(namedBoards, &quot;*&quot;)</span><br><span class="line">    .addStaticImport(Collections.class, &quot;*&quot;)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><ul><li>$N 命名(Names),通常指我们自己生成的方法名或者变量名等等</li></ul><p>比如这样的代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public String byteToHex(int b) &#123;</span><br><span class="line">  char[] result = new char[2];</span><br><span class="line">  result[0] = hexDigit((b &gt;&gt;&gt; 4) &amp; 0xf);</span><br><span class="line">  result[1] = hexDigit(b &amp; 0xf);</span><br><span class="line">  return new String(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public char hexDigit(int i) &#123;</span><br><span class="line">  return (char) (i &lt; 10 ? i + &apos;0&apos; : i - 10 + &apos;a&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以传递<code>hexDigit()</code>来代替。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec hexDigit = MethodSpec.methodBuilder(&quot;hexDigit&quot;)</span><br><span class="line">    .addParameter(int.class, &quot;i&quot;)</span><br><span class="line">    .returns(char.class)</span><br><span class="line">    .addStatement(&quot;return (char) (i &lt; 10 ? i + &apos;0&apos; : i - 10 + &apos;a&apos;)&quot;)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">MethodSpec byteToHex = MethodSpec.methodBuilder(&quot;byteToHex&quot;)</span><br><span class="line">    .addParameter(int.class, &quot;b&quot;)</span><br><span class="line">    .returns(String.class)</span><br><span class="line">    .addStatement(&quot;char[] result = new char[2]&quot;)</span><br><span class="line">    .addStatement(&quot;result[0] = $N((b &gt;&gt;&gt; 4) &amp; 0xf)&quot;, hexDigit)</span><br><span class="line">    .addStatement(&quot;result[1] = $N(b &amp; 0xf)&quot;, hexDigit)</span><br><span class="line">    .addStatement(&quot;return new String(result)&quot;)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><blockquote><p>构建类的元素</p></blockquote><ul><li>Methods</li></ul><p>方法的修饰，如<code>Modifiers.ABSTRACT</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec flux = MethodSpec.methodBuilder(&quot;flux&quot;)</span><br><span class="line">    .addModifiers(Modifier.ABSTRACT, Modifier.PROTECTED)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">TypeSpec helloWorld = TypeSpec.classBuilder(&quot;HelloWorld&quot;)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)</span><br><span class="line">    .addMethod(flux)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>这将会生成如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class HelloWorld &#123;</span><br><span class="line">  protected abstract void flux();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然Methods需要和<code>MethodSpec.Builder</code>配置来增加方法参数、异常、javadoc、注解等。</p><ul><li>构造器</li></ul><p>这个其实也是个函数方法而已，因此可以使用MethodSpec来生成构造器方法。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec flux = MethodSpec.constructorBuilder()</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addParameter(String.class, &quot;greeting&quot;)</span><br><span class="line">    .addStatement(&quot;this.$N = $N&quot;, &quot;greeting&quot;, &quot;greeting&quot;)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">TypeSpec helloWorld = TypeSpec.classBuilder(&quot;HelloWorld&quot;)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addField(String.class, &quot;greeting&quot;, Modifier.PRIVATE, Modifier.FINAL)</span><br><span class="line">    .addMethod(flux)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>将会生成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">  private final String greeting;</span><br><span class="line"></span><br><span class="line">  public HelloWorld(String greeting) &#123;</span><br><span class="line">    this.greeting = greeting;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参数</li></ul><p>之前我们是通过<code>addstatement</code>直接设置参数，其实参数也有自己的一个专用类<code>ParameterSpec</code>，我们可以使用<code>ParameterSpec.builder()</code>来生成参数，然后MethodSpec的addParameter去使用，这样更加优雅。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ParameterSpec android = ParameterSpec.builder(String.class, &quot;android&quot;)</span><br><span class="line">    .addModifiers(Modifier.FINAL)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">MethodSpec welcomeOverlords = MethodSpec.methodBuilder(&quot;welcomeOverlords&quot;)</span><br><span class="line">    .addParameter(android)</span><br><span class="line">    .addParameter(String.class, &quot;robot&quot;, Modifier.FINAL)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void welcomeOverlords(final String android, final String robot) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>字段</li></ul><p>可以使用FieldSpec去声明字段，然后加到Method中处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FieldSpec android = FieldSpec.builder(String.class, &quot;android&quot;)</span><br><span class="line">    .addModifiers(Modifier.PRIVATE, Modifier.FINAL)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">TypeSpec helloWorld = TypeSpec.classBuilder(&quot;HelloWorld&quot;)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addField(android)</span><br><span class="line">    .addField(String.class, &quot;robot&quot;, Modifier.PRIVATE, Modifier.FINAL)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>然后生成代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">  private final String android;</span><br><span class="line"></span><br><span class="line">  private final String robot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常Builder可以更加详细的创建字段的内容，比如javadoc、annotations或者初始化字段参数等，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FieldSpec android = FieldSpec.builder(String.class, &quot;android&quot;)</span><br><span class="line">    .addModifiers(Modifier.PRIVATE, Modifier.FINAL)</span><br><span class="line">    .initializer(&quot;$S + $L&quot;, &quot;Lollipop v.&quot;, 5.0d)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>对应生成的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final String android = &quot;Lollipop v.&quot; + 5.0;</span><br></pre></td></tr></table></figure><ul><li>接口</li></ul><p>接口方法必须是PUBLIC ABSTRACT并且接口字段必须是PUBLIC STATIC FINAL ，使用<code>TypeSpec.interfaceBuilder</code></p><p>如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TypeSpec helloWorld = TypeSpec.interfaceBuilder(&quot;HelloWorld&quot;)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addField(FieldSpec.builder(String.class, &quot;ONLY_THING_THAT_IS_CONSTANT&quot;)</span><br><span class="line">        .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)</span><br><span class="line">        .initializer(&quot;$S&quot;, &quot;change&quot;)</span><br><span class="line">        .build())</span><br><span class="line">    .addMethod(MethodSpec.methodBuilder(&quot;beep&quot;)</span><br><span class="line">        .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)</span><br><span class="line">        .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成的代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface HelloWorld &#123;</span><br><span class="line">  String ONLY_THING_THAT_IS_CONSTANT = &quot;change&quot;;</span><br><span class="line"></span><br><span class="line">  void beep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>枚举类型</li></ul><p>使用<code>TypeSpec.enumBuilder</code>来创建，使用<code>addEnumConstant</code>来添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TypeSpec helloWorld = TypeSpec.enumBuilder(&quot;Roshambo&quot;)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addEnumConstant(&quot;ROCK&quot;)</span><br><span class="line">    .addEnumConstant(&quot;SCISSORS&quot;)</span><br><span class="line">    .addEnumConstant(&quot;PAPER&quot;)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public enum Roshambo &#123;</span><br><span class="line">  ROCK,</span><br><span class="line"></span><br><span class="line">  SCISSORS,</span><br><span class="line"></span><br><span class="line">  PAPER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更复杂的类型也可以支持，如重写、注解等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">TypeSpec helloWorld = TypeSpec.enumBuilder(&quot;Roshambo&quot;)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addEnumConstant(&quot;ROCK&quot;, TypeSpec.anonymousClassBuilder(&quot;$S&quot;, &quot;fist&quot;)</span><br><span class="line">        .addMethod(MethodSpec.methodBuilder(&quot;toString&quot;)</span><br><span class="line">            .addAnnotation(Override.class)</span><br><span class="line">            .addModifiers(Modifier.PUBLIC)</span><br><span class="line">            .addStatement(&quot;return $S&quot;, &quot;avalanche!&quot;)</span><br><span class="line">            .build())</span><br><span class="line">        .build())</span><br><span class="line">    .addEnumConstant(&quot;SCISSORS&quot;, TypeSpec.anonymousClassBuilder(&quot;$S&quot;, &quot;peace&quot;)</span><br><span class="line">        .build())</span><br><span class="line">    .addEnumConstant(&quot;PAPER&quot;, TypeSpec.anonymousClassBuilder(&quot;$S&quot;, &quot;flat&quot;)</span><br><span class="line">        .build())</span><br><span class="line">    .addField(String.class, &quot;handsign&quot;, Modifier.PRIVATE, Modifier.FINAL)</span><br><span class="line">    .addMethod(MethodSpec.constructorBuilder()</span><br><span class="line">        .addParameter(String.class, &quot;handsign&quot;)</span><br><span class="line">        .addStatement(&quot;this.$N = $N&quot;, &quot;handsign&quot;, &quot;handsign&quot;)</span><br><span class="line">        .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public enum Roshambo &#123;</span><br><span class="line">  ROCK(&quot;fist&quot;) &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void toString() &#123;</span><br><span class="line">      return &quot;avalanche!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  SCISSORS(&quot;peace&quot;),</span><br><span class="line"></span><br><span class="line">  PAPER(&quot;flat&quot;);</span><br><span class="line"></span><br><span class="line">  private final String handsign;</span><br><span class="line"></span><br><span class="line">  Roshambo(String handsign) &#123;</span><br><span class="line">    this.handsign = handsign;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>匿名内部类</li></ul><p>需要使用<code>Type.anonymousInnerClass(&quot;&quot;)</code>,通常可以使用$L占位符来指代</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TypeSpec comparator = TypeSpec.anonymousClassBuilder(&quot;&quot;)</span><br><span class="line">    .addSuperinterface(ParameterizedTypeName.get(Comparator.class, String.class))</span><br><span class="line">    .addMethod(MethodSpec.methodBuilder(&quot;compare&quot;)</span><br><span class="line">        .addAnnotation(Override.class)</span><br><span class="line">        .addModifiers(Modifier.PUBLIC)</span><br><span class="line">        .addParameter(String.class, &quot;a&quot;)</span><br><span class="line">        .addParameter(String.class, &quot;b&quot;)</span><br><span class="line">        .returns(int.class)</span><br><span class="line">        .addStatement(&quot;return $N.length() - $N.length()&quot;, &quot;a&quot;, &quot;b&quot;)</span><br><span class="line">        .build())</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">TypeSpec helloWorld = TypeSpec.classBuilder(&quot;HelloWorld&quot;)</span><br><span class="line">    .addMethod(MethodSpec.methodBuilder(&quot;sortByLength&quot;)</span><br><span class="line">        .addParameter(ParameterizedTypeName.get(List.class, String.class), &quot;strings&quot;)</span><br><span class="line">        .addStatement(&quot;$T.sort($N, $L)&quot;, Collections.class, &quot;strings&quot;, comparator)</span><br><span class="line">        .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void sortByLength(List&lt;String&gt; strings) &#123;</span><br><span class="line">  Collections.sort(strings, new Comparator&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(String a, String b) &#123;</span><br><span class="line">      return a.length() - b.length();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义匿名内部类的一个特别棘手的问题是参数的构造。在上面的代码中我们传递了不带参数的空字符串。TypeSpec.anonymousClassBuilder(“”)。</p><ul><li>注解</li></ul><p>注解使用起来比较简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec toString = MethodSpec.methodBuilder(&quot;toString&quot;)</span><br><span class="line">    .addAnnotation(Override.class)</span><br><span class="line">    .returns(String.class)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addStatement(&quot;return $S&quot;, &quot;Hoverboard&quot;)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">  return &quot;Hoverboard&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>AnnotationSpec.builder()</code> 可以对注解设置属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec logRecord = MethodSpec.methodBuilder(&quot;recordEvent&quot;)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)</span><br><span class="line">    .addAnnotation(AnnotationSpec.builder(Headers.class)</span><br><span class="line">        .addMember(&quot;accept&quot;, &quot;$S&quot;, &quot;application/json; charset=utf-8&quot;)</span><br><span class="line">        .addMember(&quot;userAgent&quot;, &quot;$S&quot;, &quot;Square Cash&quot;)</span><br><span class="line">        .build())</span><br><span class="line">    .addParameter(LogRecord.class, &quot;logRecord&quot;)</span><br><span class="line">    .returns(LogReceipt.class)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>代码生成如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Headers(</span><br><span class="line">    accept = &quot;application/json; charset=utf-8&quot;,</span><br><span class="line">    userAgent = &quot;Square Cash&quot;</span><br><span class="line">)</span><br><span class="line">LogReceipt recordEvent(LogRecord logRecord);</span><br></pre></td></tr></table></figure><p>注解同样可以注解其他注解，通过$L引用如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec logRecord = MethodSpec.methodBuilder(&quot;recordEvent&quot;)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)</span><br><span class="line">    .addAnnotation(AnnotationSpec.builder(HeaderList.class)</span><br><span class="line">        .addMember(&quot;value&quot;, &quot;$L&quot;, AnnotationSpec.builder(Header.class)</span><br><span class="line">            .addMember(&quot;name&quot;, &quot;$S&quot;, &quot;Accept&quot;)</span><br><span class="line">            .addMember(&quot;value&quot;, &quot;$S&quot;, &quot;application/json; charset=utf-8&quot;)</span><br><span class="line">            .build())</span><br><span class="line">        .addMember(&quot;value&quot;, &quot;$L&quot;, AnnotationSpec.builder(Header.class)</span><br><span class="line">            .addMember(&quot;name&quot;, &quot;$S&quot;, &quot;User-Agent&quot;)</span><br><span class="line">            .addMember(&quot;value&quot;, &quot;$S&quot;, &quot;Square Cash&quot;)</span><br><span class="line">            .build())</span><br><span class="line">        .build())</span><br><span class="line">    .addParameter(LogRecord.class, &quot;logRecord&quot;)</span><br><span class="line">    .returns(LogReceipt.class)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@HeaderList(&#123;</span><br><span class="line">    @Header(name = &quot;Accept&quot;, value = &quot;application/json; charset=utf-8&quot;),</span><br><span class="line">    @Header(name = &quot;User-Agent&quot;, value = &quot;Square Cash&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">LogReceipt recordEvent(LogRecord logRecord);</span><br></pre></td></tr></table></figure><h2 id="0x03-后续"><a href="#0x03-后续" class="headerlink" title="0x03 后续"></a>0x03 后续</h2><p>在javapoet之前有javawriter，但javapoet有着更强大的代码模型，并且对类的理解更加到位，因此推荐使用javapoet </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00-概述&quot;&gt;&lt;a href=&quot;#0x00-概述&quot; class=&quot;headerlink&quot; title=&quot;0x00 概述&quot;&gt;&lt;/a&gt;0x00 概述&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="Annotation" scheme="https://xsfelvis.github.io/categories/Annotation/"/>
    
    
      <category term="Annotation" scheme="https://xsfelvis.github.io/tags/Annotation/"/>
    
      <category term="JavaPoet" scheme="https://xsfelvis.github.io/tags/JavaPoet/"/>
    
  </entry>
  
  <entry>
    <title>编译期注解处理之APT</title>
    <link href="https://xsfelvis.github.io/2016/11/07/%E7%BC%96%E8%AF%91%E6%9C%9F%E6%B3%A8%E8%A7%A3%E4%B9%8BAPT/"/>
    <id>https://xsfelvis.github.io/2016/11/07/编译期注解之APT/</id>
    <published>2016-11-06T16:00:00.000Z</published>
    <updated>2018-06-04T04:53:44.245Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>前一篇介绍了注解的基本知识以及常见用法，由于运行期(RunTime)利用反射去获取信息还是比较损耗性能的，本篇将介绍一种使用注解更加优雅的方式，编译期(Compile time)注解，以及处理编译期注解的手段APT和Javapoet,限于篇幅，本篇着重介绍APT<br>首先你的注解需要声明为CLASS<br>@Retention(RetentionPolicy.CLASS)  </p><p>编译期解析注解基本原理：<br>在某些代码元素上（如类型、函数、字段等）添加注解，在编译时编译器会检查AbstractProcessor的子类，并且调用该类型的process函数，然后将添加了注解的所有元素都传递到process函数中，使得开发人员可以在编译器进行相应的处理，例如，根据注解生成新的Java类，这也就是ButterKnife等开源库的基本原理。</p><h2 id="0x01-APT"><a href="#0x01-APT" class="headerlink" title="0x01 APT"></a>0x01 APT</h2><p>在处理编译器注解的第一个手段就是APT(Annotation Processor Tool),即注解处理器。在java5的时候已经存在，但是java6开始的时候才有可用的API，最近才随着butterknife这些库流行起来。本章将阐述什么是注解处理器，以及如何使用这个强大的工具。</p><blockquote><p>什么是APT</p></blockquote><p>APT是一种处理注解的工具，确切的说它是javac的一个工具，它用来在编译时扫描和处理注解，一个注解的注解处理器，以java代码(或者编译过的字节码)作为输入，生成.java文件作为输出，核心是交给自己定义的处理器去处理，</p><blockquote><p>如何使用</p></blockquote><p>每个自定义的处理器都要继承虚处理器，实现其关键的几个方法</p><ul><li>继承虚处理器 AbstractProcessor</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MyProcessor extends AbstractProcessor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void init(ProcessingEnvironment env)&#123; &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment env) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public SourceVersion getSupportedSourceVersion() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面重点介绍下这几个函数：</p><ol><li><code>init(ProcessingEnvironment env)</code>: 每一个注解处理器类都必须有一个空的构造函数。然而，这里有一个特殊的init()方法，它会被注解处理工具调用，并输入ProcessingEnviroment参数。ProcessingEnviroment提供很多有用的工具类Elements, Types和Filer</li><li><code>process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</code>: 这相当于每个处理器的主函数main()。你在这里写你的扫描、评估和处理注解的代码，以及生成Java文件。输入参数RoundEnviroment，可以让你查询出包含特定注解的被注解元素。这是一个布尔值，表明注解是否已经被处理器处理完成，官方原文<code>whether or not the set of annotations are claimed by this processor</code>，通常在处理出现异常直接返回false、处理完成返回true。</li><li><code>getSupportedAnnotationTypes()</code>: 必须要实现；用来表示这个注解处理器是注册给哪个注解的。返回值是一个字符串的集合，包含本处理器想要处理的注解类型的合法全称。</li><li><code>getSupportedSourceVersion()</code>: 用来指定你使用的Java版本。通常这里返回SourceVersion.latestSupported()，你也可以使用SourceVersion_RELEASE_6、7、8</li></ol><ul><li>注册 处理器</li></ul><p>由于处理器是javac的工具，因此我们必须将我们自己的处理器注册到javac中，在以前我们需要提供一个.jar文件，打包你的注解处理器到此文件中，并在在你的jar中，需要打包一个特定的文件 <code>javax.annotation.processing.Processor到META-INF/services路径下</code><br>把MyProcessor.jar放到你的builpath中，javac会自动检查和读取javax.annotation.processing.Processor中的内容，并且注册MyProcessor作为注解处理器。</p><p>超级麻烦有木有，不过不要慌，谷歌baba给我们开发了AutoService注解，你只需要引入这个依赖，然后在你的解释器第一行加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@AutoService(Processor.class)</span><br></pre></td></tr></table></figure><p>然后就可以自动生成META-INF/services/javax.annotation.processing.Processor文件的。省去了打jar包这些繁琐的步骤。</p><blockquote><p>APT中的Elements和TypeMirrors</p></blockquote><p>在前面的init()中我们可以获取如下引用</p><ul><li>Elements：一个用来处理Element的工具类</li><li>Types：一个用来处理TypeMirror的工具类</li><li>Filer：正如这个名字所示，使用Filer你可以创建文件(通常与javapoet结合)</li></ul><p>在注解处理过程中，我们扫面所有的Java源文件。源文件的每一个部分都是一个特定类型的Element</p><p>先来看一下Element</p><p>对于编译器来说 代码中的元素结构是基本不变的，如，组成代码的基本元素包括包、类、函数、字段、变量的等，JDK为这些元素定义了一个基类也就是<code>Element</code>类</p><p>Element有五个直接子类，分别代表一种特定类型</p><p>==<br>| PackageElement | 表示一个包程序元素，可以获取到包名等 |<br>| — | — |<br>| TypeParameterElement | 表示一般类、接口、方法或构造方法元素的泛型参数 |<br>| TypeElement | 表示一个类或接口程序元素 |<br>| VariableElement | 表示一个字段、enum 常量、方法或构造方法参数、局部变量或异常参数 |</p><h1 id="ExecutableElement-表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注解类型元素"><a href="#ExecutableElement-表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注解类型元素" class="headerlink" title="| ExecutableElement | 表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注解类型元素 |"></a>| ExecutableElement | 表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注解类型元素 |</h1><p>开发中Element可根据实际情况强转为以上5种中的一种，它们都带有各自独有的方法，如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.example;    // PackageElement</span><br><span class="line"></span><br><span class="line">public class Test &#123;        // TypeElement</span><br><span class="line"></span><br><span class="line">    private int a;      // VariableElement</span><br><span class="line">    private Test other;  // VariableElement</span><br><span class="line"></span><br><span class="line">    public Test () &#123;&#125;    // ExecuteableElement</span><br><span class="line">    public void setA (  // ExecuteableElement</span><br><span class="line">                     int newA   // TypeElement</span><br><span class="line">                     ) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再举个栗子🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.CLASS)</span><br><span class="line">public @interface Test &#123;</span><br><span class="line"></span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解因为只能作用于函数类型，因此，它对应的元素类型就是ExecutableElement当我们想通过APT处理这个注解的时候就可以获取目标对象上的Test注解，并且将所有这些元素转换为ExecutableElement元素，以便获取到他们对应的信息。</p><p>查看其代码定义</p><p>定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">** </span><br><span class="line"> * 表示一个程序元素，比如包、类或者方法，有如下几种子接口： </span><br><span class="line"> * ExecutableElement：表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注解类型元素 ； </span><br><span class="line"> * PackageElement：表示一个包程序元素； </span><br><span class="line"> * TypeElement：表示一个类或接口程序元素； </span><br><span class="line"> * TypeParameterElement：表示一般类、接口、方法或构造方法元素的形式类型参数； </span><br><span class="line"> * VariableElement：表示一个字段、enum 常量、方法或构造方法参数、局部变量或异常参数 </span><br><span class="line"> */  </span><br><span class="line">public interface Element extends AnnotatedConstruct &#123;  </span><br><span class="line">    /** </span><br><span class="line">     * 返回此元素定义的类型 </span><br><span class="line">     * 例如，对于一般类元素 C&lt;N extends Number&gt;，返回参数化类型 C&lt;N&gt; </span><br><span class="line">     */  </span><br><span class="line">    TypeMirror asType();  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 返回此元素的种类：包、类、接口、方法、字段...,如下枚举值 </span><br><span class="line">     * PACKAGE, ENUM, CLASS, ANNOTATION_TYPE, INTERFACE, ENUM_CONSTANT, FIELD, PARAMETER, LOCAL_VARIABLE, EXCEPTION_PARAMETER, </span><br><span class="line">     * METHOD, CONSTRUCTOR, STATIC_INIT, INSTANCE_INIT, TYPE_PARAMETER, OTHER, RESOURCE_VARIABLE; </span><br><span class="line">     */  </span><br><span class="line">    ElementKind getKind();  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 返回此元素的修饰符,如下枚举值 </span><br><span class="line">     * PUBLIC, PROTECTED, PRIVATE, ABSTRACT, DEFAULT, STATIC, FINAL, </span><br><span class="line">     * TRANSIENT, VOLATILE, SYNCHRONIZED, NATIVE, STRICTFP; </span><br><span class="line">     */  </span><br><span class="line">    Set&lt;Modifier&gt; getModifiers();  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 返回此元素的简单名称,例如 </span><br><span class="line">     * 类型元素 java.util.Set&lt;E&gt; 的简单名称是 &quot;Set&quot;； </span><br><span class="line">     * 如果此元素表示一个未指定的包，则返回一个空名称； </span><br><span class="line">     * 如果它表示一个构造方法，则返回名称 &quot;&lt;init&gt;&quot;； </span><br><span class="line">     * 如果它表示一个静态初始化程序，则返回名称 &quot;&lt;clinit&gt;&quot;； </span><br><span class="line">     * 如果它表示一个匿名类或者实例初始化程序，则返回一个空名称 </span><br><span class="line">     */  </span><br><span class="line">    Name getSimpleName();  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 返回封装此元素的最里层元素。 </span><br><span class="line">     * 如果此元素的声明在词法上直接封装在另一个元素的声明中，则返回那个封装元素； </span><br><span class="line">     * 如果此元素是顶层类型，则返回它的包； </span><br><span class="line">     * 如果此元素是一个包，则返回 null； </span><br><span class="line">     * 如果此元素是一个泛型参数，则返回 null. </span><br><span class="line">     */  </span><br><span class="line">    Element getEnclosingElement();  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 返回此元素直接封装的子元素 </span><br><span class="line">     */  </span><br><span class="line">    List&lt;? extends Element&gt; getEnclosedElements();  </span><br><span class="line">    </span><br><span class="line">    boolean equals(Object var1);</span><br><span class="line"></span><br><span class="line">    int hashCode();</span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 返回直接存在于此元素上的注解 </span><br><span class="line">     * 要获得继承的注解，可使用 getAllAnnotationMirrors </span><br><span class="line">     */  </span><br><span class="line">    List&lt;? extends AnnotationMirror&gt; getAnnotationMirrors();  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 返回此元素针对指定类型的注解（如果存在这样的注解），否则返回 null。注解可以是继承的，也可以是直接存在于此元素上的 </span><br><span class="line">     */   </span><br><span class="line">    &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationType); </span><br><span class="line">     </span><br><span class="line">    //接受访问者的访问 （？？）</span><br><span class="line">     &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; var1, P var2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一个，并没有使用到，感觉不太好理解，查了资料这个函数接受一个ElementVisitor和类型为P的参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public interface ElementVisitor&lt;R, P&gt; &#123;</span><br><span class="line">    //访问元素</span><br><span class="line">    R visit(Element e, P p);</span><br><span class="line"></span><br><span class="line">    R visit(Element e);</span><br><span class="line"></span><br><span class="line">    //访问包元素</span><br><span class="line">    R visitPackage(PackageElement e, P p);</span><br><span class="line"></span><br><span class="line">    //访问类型元素</span><br><span class="line">    R visitType(TypeElement e, P p);</span><br><span class="line"></span><br><span class="line">   //访问变量元素</span><br><span class="line">    R visitVariable(VariableElement e, P p);</span><br><span class="line"></span><br><span class="line">    //访问克而执行元素</span><br><span class="line">    R visitExecutable(ExecutableElement e, P p);</span><br><span class="line"></span><br><span class="line">    //访问参数元素</span><br><span class="line">    R visitTypeParameter(TypeParameterElement e, P p);</span><br><span class="line"></span><br><span class="line">    //处理位置的元素类型，这是为了应对后续Java语言的扩折而预留的接口，例如后续元素类型添加了，那么通过这个接口就可以处理上述没有声明的类型</span><br><span class="line">    R visitUnknown(Element e, P p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ElementgVisitor中定义了多个visit接口，每个接口处理一种元素类型，这就是典型的访问者模式。我们制定，一个类元素和函数元素是完全不一样的，他们的结构不一样，因此，在编译器对他们的操作肯定是不一样，通过访问者模式正好可以解决数据结构与数据操作分离的问题，避免某些操作污染数据对象类。</p><p>因此，代码在APT眼中只是一个结构化的文本而已。Element代表的是源代码。TypeElement代表的是源代码中的类型元素，例如类。然而，TypeElement并不包含类本身的信息。你可以从TypeElement中获取类的名字，但是你获取不到类的信息，例如它的父类。这种信息需要通过TypeMirror获取。你可以通过调用elements.asType()获取元素的TypeMirror。</p><h2 id="0x02-辅助接口"><a href="#0x02-辅助接口" class="headerlink" title="0x02 辅助接口"></a>0x02 辅助接口</h2><p>在自定义注解器的初始化时候，可以获取以下4个辅助接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MyProcessor extends AbstractProcessor &#123;  </span><br><span class="line">    </span><br><span class="line">      private Types typeUtils;  </span><br><span class="line">      private Elements elementUtils;  </span><br><span class="line">      private Filer filer;  </span><br><span class="line">      private Messager messager;  </span><br><span class="line">    </span><br><span class="line">      @Override  </span><br><span class="line">      public synchronized void init(ProcessingEnvironment processingEnv) &#123;  </span><br><span class="line">          super.init(processingEnv);  </span><br><span class="line">          typeUtils = processingEnv.getTypeUtils();  </span><br><span class="line">          elementUtils = processingEnv.getElementUtils();  </span><br><span class="line">          filer = processingEnv.getFiler();  </span><br><span class="line">          messager = processingEnv.getMessager();  </span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>Filer </li></ul><p>一般配合JavaPoet来生成需要的java文件（下一篇将详细介绍javaPoet）</p><ul><li>Messager</li></ul><p>Messager提供给注解处理器一个报告错误、警告以及提示信息的途径。它不是注解处理器开发者的日志工具，而是用来写一些信息给使用此注解器的第三方开发者的。在官方文档中描述了消息的不同级别中非常重要的是Kind.ERROR，因为这种类型的信息用来表示我们的注解处理器处理失败了。很有可能是第三方开发者错误的使用了注解。这个概念和传统的Java应用有点不一样，在传统Java应用中我们可能就抛出一个异常Exception。如果你在process()中抛出一个异常，那么运行注解处理器的JVM将会崩溃（就像其他Java应用一样），使用我们注解处理器第三方开发者将会从javac中得到非常难懂的出错信息，因为它包含注解处理器的堆栈跟踪（Stacktace）信息。因此，注解处理器就有一个Messager类，它能够打印非常优美的错误信息。除此之外，你还可以连接到出错的元素。在像现在的IDE（集成开发环境）中，第三方开发者可以直接点击错误信息，IDE将会直接跳转到第三方开发者项目的出错的源文件的相应的行。</p><ul><li>Types</li></ul><p>Types是一个用来处理TypeMirror的工具</p><ul><li>Elements</li></ul><p>Elements是一个用来处理Element的工具</p><h2 id="0x03-优缺点"><a href="#0x03-优缺点" class="headerlink" title="0x03 优缺点"></a>0x03 优缺点</h2><blockquote><p>优点(结合javapoet)</p></blockquote><ul><li>对代码进行标记、在编译时收集信息并做处理</li><li>生成一套独立代码，辅助代码运行</li></ul><blockquote><p>缺点</p></blockquote><ul><li>可以自动生成代码，但在运行时需要主动调用</li><li>如果要生成代码需要编写模板函数</li></ul><h2 id="0x04-其他"><a href="#0x04-其他" class="headerlink" title="0x04 其他"></a>0x04 其他</h2><ol><li><p>通常我们需要分离处理器和注解<br>这样做的原因是，在发布程序时注解及生成的代码会被打包到用户程序中，而注解处理器则不会（注解处理器是在编译期在JVM上运行跟运行时无关）。要是不分离的话，假如注解处理器中使用到了其他第三方库，那就会占用系统资源，特别是方法数，</p></li><li><p>该技术可以让我们在设计自己框架时候多了一种技术选择，更加的优雅</p></li><li><p>反射优化</p></li></ol><p>运行时注解的使用可以减少很多代码的编写，但是谁都知道这是有性能损耗的，不过权衡利弊，我们选择了妥协，这个技术手段可以处理这个问题</p><h2 id="0x05-参考文献"><a href="#0x05-参考文献" class="headerlink" title="0x05 参考文献"></a>0x05 参考文献</h2><ul><li><a href="http://hannesdorfmann.com/annotation-processing/annotationprocessing101" target="_blank" rel="noopener">http://hannesdorfmann.com/annotation-processing/annotationprocessing101</a></li><li><a href="http://blog.csdn.net/github_35180164/article/details/52121038" target="_blank" rel="noopener">http://blog.csdn.net/github_35180164/article/details/52121038</a></li><li><a href="https://www.zhangningning.com.cn/blog/Android/android_rentention.html" target="_blank" rel="noopener">https://www.zhangningning.com.cn/blog/Android/android_rentention.html</a></li><li><a href="https://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/AbstractProcessor.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/AbstractProcessor.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00-概述&quot;&gt;&lt;a href=&quot;#0x00-概述&quot; class=&quot;headerlink&quot; title=&quot;0x00 概述&quot;&gt;&lt;/a&gt;0x00 概述&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="Annotation" scheme="https://xsfelvis.github.io/categories/Annotation/"/>
    
    
      <category term="Annotation" scheme="https://xsfelvis.github.io/tags/Annotation/"/>
    
      <category term="APT" scheme="https://xsfelvis.github.io/tags/APT/"/>
    
  </entry>
  
  <entry>
    <title>注解基础</title>
    <link href="https://xsfelvis.github.io/2016/11/06/%E6%B3%A8%E8%A7%A3%E5%9F%BA%E7%A1%80/"/>
    <id>https://xsfelvis.github.io/2016/11/06/注解基础/</id>
    <published>2016-11-05T16:00:00.000Z</published>
    <updated>2018-06-04T04:53:40.142Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>本文主要是介绍注解的基础知识，为后面的APT和JavaPoet打下基础</p><h2 id="0x01-什么是注解"><a href="#0x01-什么是注解" class="headerlink" title="0x01 什么是注解"></a>0x01 什么是注解</h2><p>注解（Annotation）是Java5的一个新特性,是插入在代码中的一种注释或者说是一种元数据（meta data），这些注释信息可以在编译期使用预编译工具进行获取处理，也可以在运行期使用Java反射机制来获取，这取决于你的注解类型。</p><h2 id="0x02-注解的语法及其定义"><a href="#0x02-注解的语法及其定义" class="headerlink" title="0x02 注解的语法及其定义"></a>0x02 注解的语法及其定义</h2><p>在Android中注解经常存在我们代码中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main4);</span><br><span class="line">    getIntentData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的<code>@Override</code>就是系统的注解，表明这是个重写方法，点击源码可以看到长成下面的样子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.SOURCE)</span><br><span class="line">public @interface Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际中会带有一些参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">public @interface run_methodInfo &#123;</span><br><span class="line">    String name() default &quot;long&quot;;</span><br><span class="line">    String data();</span><br><span class="line">    int id() default 365;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Retention @Target @Document @Inherited四种 是元注解即 “注解的注解”</p><blockquote><p>@Target 表示该注解目标,可能的 ElemenetType 参数包括:</p></blockquote><ul><li>ElemenetType.CONSTRUCTOR 构造器声明</li><li>ElemenetType.FIELD 域声明(包括 enum 实例) </li><li>ElemenetType.LOCAL_VARIABLE 局部变量声明 </li><li>ElemenetType.METHOD 方法声明 </li><li>ElemenetType.PACKAGE 包声明 </li><li>ElemenetType.PARAMETER 参数声明 </li><li>ElemenetType.TYPE 类，接口(包括注解类型)或enum声明</li></ul><blockquote><p>@Retention 表示该注解的生命周期,可选的 RetentionPolicy 参数包括</p></blockquote><ul><li>RetentionPolicy.SOURCE 注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃注解将被编译器丢弃 </li><li>RetentionPolicy.CLASS 注解被保留到class文件，但jvm加载class文件时候被遗弃</li><li>RetentionPolicy.RUNTIME 注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在；，因此可以通过反射机制读取注解的信息</li></ul><blockquote><p>@Documented 指示将此注解包含在 javadoc 中<br>@Inherited 指示允许子类继承父类中的注解</p></blockquote><p>使用注解需要遵守它的规则：</p><ul><li>Annotation型定义为@interface, 所有的Annotation会自动继承java.lang.Annotation这一接口,并且不能再去继承别的类或是接口.</li><li>参数成员只能用public或默认(default)这两个访问权修饰</li><li>参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和String、Enum、Class、annotations等数据类型,以及这一些类型的数组.</li><li>要获取类方法和字段的注解信息，必须通过Java的反射技术来获取 Annotation对象,因为你除此之外没有别的获取注解对象的方法（分为编译期还是运行期）</li></ul><h2 id="0x03-使用"><a href="#0x03-使用" class="headerlink" title="0x03 使用"></a>0x03 使用</h2><p>（这里仅介绍最常见的运行期的注解，编译期注解涉及到apt、javapoet会单独再开一篇介绍）</p><blockquote><p>Step One 定义注解</p></blockquote><p>先看三个Runtime注解，包括类、方法、字段，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">public @interface run_classInfo &#123;</span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">public @interface run_methodInfo &#123;</span><br><span class="line">    String name() default &quot;long&quot;;</span><br><span class="line">    String data();</span><br><span class="line">    int id() default 365;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">public @interface run_fieldInfo &#123;</span><br><span class="line">    int[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Step two 使用这些注解，</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@run_classInfo(&quot;类注解RunTime Class&quot;)</span><br><span class="line">public class RunTimeTest &#123;</span><br><span class="line">    @run_fieldInfo(value = &#123;77, 88&#125;)</span><br><span class="line">    public String fieldInfo = &quot;filedInfo&quot;;</span><br><span class="line"></span><br><span class="line">    @run_fieldInfo(value = &#123;163&#125;)</span><br><span class="line">    public int id = 55;</span><br><span class="line"></span><br><span class="line">    @run_methodInfo(name = &quot;彩笔学长&quot;, data = &quot;finance&quot;)</span><br><span class="line">    public static String getMethod() &#123;</span><br><span class="line">        return RunTimeTest.class.getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用反射解析注解</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 解析运行时注解</span><br><span class="line"> */</span><br><span class="line">private void showRunTimeInfo() &#123;</span><br><span class="line">    StringBuffer sb = new StringBuffer();</span><br><span class="line">    //获取Class 注解</span><br><span class="line">    Class&lt;?&gt; clazz = RunTimeTest.class;</span><br><span class="line">    Constructor&lt;?&gt;[] constructors = clazz.getConstructors();</span><br><span class="line">    //获取包含的注解类信息</span><br><span class="line">    run_classInfo runClassInfo = clazz.getAnnotation(run_classInfo.class);</span><br><span class="line">    if (runClassInfo != null) &#123;</span><br><span class="line">        //获取class注解</span><br><span class="line">        sb.append(&quot;Class注解: &quot;).append(&quot;\n&quot;);</span><br><span class="line">        sb.append(Modifier.toString(clazz.getModifiers())).append(&quot; &quot;)</span><br><span class="line">                .append(clazz.getSimpleName()).append(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">        sb.append(&quot;注解值：&quot;).append(&quot;\n&quot;)</span><br><span class="line">                .append(runClassInfo.value()).append(&quot;\n\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取Field注解</span><br><span class="line">    sb.append(&quot;Field注解：&quot;).append(&quot;\n&quot;);</span><br><span class="line">    Field[] fields = clazz.getDeclaredFields(); //获取自身的不包括继承类</span><br><span class="line">    for (Field field : fields) &#123;</span><br><span class="line">        //获取field注解类信息</span><br><span class="line">        run_fieldInfo fieldInfo = field.getAnnotation(run_fieldInfo.class);</span><br><span class="line">        if (fieldInfo != null) &#123;</span><br><span class="line">            sb.append(Modifier.toString(field.getModifiers())).append(&quot; &quot;)</span><br><span class="line">                    .append(field.getType().getSimpleName()).append(&quot; &quot;)</span><br><span class="line">                    .append(field.getName()).append(&quot;\n&quot;);</span><br><span class="line">            sb.append(&quot;注解值： &quot;).append(&quot;\n&quot;)</span><br><span class="line">                    .append(Arrays.toString(fieldInfo.value())).append(&quot;\n\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取Method 注解</span><br><span class="line">    sb.append(&quot;Method注解： &quot;).append(&quot;\n&quot;);</span><br><span class="line">    Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">    for (Method method : methods) &#123;</span><br><span class="line">        run_methodInfo methodInfo = method.getAnnotation(run_methodInfo.class);</span><br><span class="line">        if (methodInfo != null) &#123;</span><br><span class="line">            sb.append(Modifier.toString(method.getModifiers())).append(&quot; &quot;)</span><br><span class="line">                    .append(method.getReturnType().getSimpleName()).append(&quot; &quot;)</span><br><span class="line">                    .append(method.getName()).append(&quot;\n&quot;);</span><br><span class="line">            sb.append(&quot;注解值：&quot;).append(&quot;\n&quot;);</span><br><span class="line">            sb.append(&quot;name: &quot;).append(methodInfo.name()).append(&quot;\n&quot;);</span><br><span class="line">            sb.append(&quot;data: &quot;).append(methodInfo.data()).append(&quot;\n&quot;);</span><br><span class="line">            sb.append(&quot;id: &quot;).append(methodInfo.id()).append(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    tvDes.setText(sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##0x04 参考文献</p><ul><li><a href="http://www.cnblogs.com/lbangel/p/3523741.html" target="_blank" rel="noopener">http://www.cnblogs.com/lbangel/p/3523741.html</a></li><li><a href="http://blog.csdn.net/github_35180164/article/details/52107204" target="_blank" rel="noopener">http://blog.csdn.net/github_35180164/article/details/52107204</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00-概述&quot;&gt;&lt;a href=&quot;#0x00-概述&quot; class=&quot;headerlink&quot; title=&quot;0x00 概述&quot;&gt;&lt;/a&gt;0x00 概述&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="Annotation" scheme="https://xsfelvis.github.io/categories/Annotation/"/>
    
    
      <category term="Annotation" scheme="https://xsfelvis.github.io/tags/Annotation/"/>
    
  </entry>
  
  <entry>
    <title>MAC使用记录</title>
    <link href="https://xsfelvis.github.io/2016/10/29/MAC%20%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <id>https://xsfelvis.github.io/2016/10/29/MAC 使用记录/</id>
    <published>2016-10-28T16:00:00.000Z</published>
    <updated>2018-06-04T04:53:41.900Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h2><p>使用MAC一些记录，方面以后更换设备时候查阅，不断更新</p><h2 id="ox01-软件包"><a href="#ox01-软件包" class="headerlink" title="ox01 软件包"></a>ox01 软件包</h2><blockquote><p>包括常用的工作软件<br><a href="百度云地址">http://pan.baidu.com/s/1bNRkdS</a></p></blockquote><p>加密后的提取码：ejZmOA== （8*8）</p><ul><li>Android studio</li><li>CleanMyMac</li><li>charles</li><li>Mweb</li><li>sublime</li><li>Tunnelblick</li><li>sourceTree</li><li>office</li><li>gasMark</li><li>jdk</li><li>xmind</li><li>evernote</li></ul><p>推荐一个常用的软件下载地址<a href="xclient.info">http://xclient.info/</a></p><h2 id="ox02插件"><a href="#ox02插件" class="headerlink" title="ox02插件"></a>ox02插件</h2><blockquote><p>zsh<br>其实装机时mac已经预制了很多脚本工具<br>在 /etc/shells 中<br>手动安装：</p></blockquote><ol><li><p>clone 项目到本地<br><code>git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</code></p></li><li><p>创建一个zsh的一个配置<br>要是已经有一个~/.zshrc文件的话，建议先备份，使用命令<br><code>cp ~/.zshrc ~/.zshrc.orig</code><br>然后开始创建zsh的配置文件<br><code>cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</code></p></li><li><p>设置zsh为你默认的shell<br><code>chsh -s /bin/zsh</code></p></li></ol><blockquote><p>git</p></blockquote><p>开发必备，这里说一下一台电脑管理多个git账号<br>在 .ssh文件夹中建立一个名称为config无后缀文本,管理你的id_rsa,其中github的不要重新命名就用两次enter之后自动生成的，有的公司会屏蔽github端口，在这个配置文件中可以更改端口<br>比如我的config文件管理了github和公司的gitlab（敏感信息已屏蔽）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User your github name</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">port 443</span><br><span class="line"></span><br><span class="line">Host your git host name</span><br><span class="line">User your git name</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_ne </span><br><span class="line">port 80</span><br></pre></td></tr></table></figure><p>上面的~/.ssh/id_rsa_ne 是在生成id_rsa时按完第一个enter输入你定义的名称，github用默认的id_rsa否则ssh -T git@github会出错的</p><blockquote><p>adb  环境配置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xsfelvis@xsfelviss-Mac-mini:~</span><br><span class="line">&gt; echo $HOME </span><br><span class="line">/Users/xsfelvis</span><br><span class="line"></span><br><span class="line">xsfelvis@xsfelviss-Mac-mini:~</span><br><span class="line">&gt; touch .bash_profile</span><br><span class="line"></span><br><span class="line">xsfelvis@xsfelviss-Mac-mini:~</span><br><span class="line">&gt; open -e .bash_profile</span><br></pre></td></tr></table></figure><p>打开之后输入sdk下platform-tools的路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$&#123;PATH&#125;:~/Library/Android/sdk/platform-tools</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00&quot;&gt;&lt;a href=&quot;#0x00&quot; class=&quot;headerlink&quot; title=&quot;0x00&quot;&gt;&lt;/a&gt;0x00&lt;/h2&gt;&lt;p&gt;使用MAC一些记录，方面
      
    
    </summary>
    
      <category term="工具" scheme="https://xsfelvis.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="MAC" scheme="https://xsfelvis.github.io/tags/MAC/"/>
    
  </entry>
  
  <entry>
    <title>认识Dalvik虚拟机</title>
    <link href="https://xsfelvis.github.io/2016/10/20/%E8%AE%A4%E8%AF%86Dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>https://xsfelvis.github.io/2016/10/20/认识Dalvik虚拟机/</id>
    <published>2016-10-19T16:00:00.000Z</published>
    <updated>2018-06-04T04:49:24.641Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>虽然Android平台使用java开发，但是android程序去不是运行在标准java虚拟机上，为了解决移动设备软件运行效率问题及规避Oracle公司版权，Google为android平台专门设计一套虚拟机来运行Android程序，即Dalvik Virtual Manchine(Dalvik 虚拟机)，它的作者是Dan Bornstein,名称由来于他祖先曾居住过的名叫Dalvik的小渔村</p><h1 id="Dalvik虚拟机的特点"><a href="#Dalvik虚拟机的特点" class="headerlink" title="Dalvik虚拟机的特点"></a>Dalvik虚拟机的特点</h1><blockquote><p>主要特点</p></blockquote><ul><li>体积小</li><li>专有的DEX可执行文件，体积小执行速度快</li><li>常量池采用32位索引值，寻址类方法名称、字段名、常量更快</li><li>基于寄存器架构，拥有自己的一套完整指令系统</li><li>提供了对象生命周期管理、堆栈管理、线程管理、安全和异常管理以及垃圾回收等重要功能</li><li>所有的Android程序都运行在Android系统进程里，每个进程都对应着一个Dalvik虚拟机实例</li></ul><h1 id="Dalvik虚拟机与java虚拟机区别"><a href="#Dalvik虚拟机与java虚拟机区别" class="headerlink" title="Dalvik虚拟机与java虚拟机区别"></a>Dalvik虚拟机与java虚拟机区别</h1><ul><li>1、Java虚拟机运行的是Java字节码，Dalvik运行的是Dalvik字节码</li></ul><p>所有的Dalvik字节码由Java字节码转换而来，并被打包到一个DEX可执行文件，Dalvik虚拟机通过解释DEX文件来执行这些字节码</p><ul><li>2、Dalvik可执行文件体积更小</li></ul><p>Android SDK中有一个叫dx的工具负责将java字节码转换为Dalvik字节码。dx工具将Java类文件重新排列，消除类文件中出现的所有冗余信息，避免虚拟机初始化时出现重复的文件加载与解析过程。</p><p>（注：一般情况下，Java类文件包含多个不同的方法签名，如果其他的类文件引用该类文件中的方法，方法签名也会复制到其中，就会造成多个不同的类会同时包含相同的方法签名，同样的，大量的字符串常量在多个类文件中也会被重复使用，这些冗余信息会直接增加文件的体积，），同时也会严重影响虚拟机解析文件的效率。</p><p>dx工具针对这个做了专门的处理，它将所有java类文件中常量池进行分解，消除其中的冗余信息，重新形成一个常量池，所有类文件共享同一个常量池，从而减小了体积</p><p><img src="http://i.imgur.com/nwkRTaC.png" alt=""></p><ul><li>3、Java虚拟机与Dalvik虚拟机架构不同</li></ul><blockquote><p>架构不同</p></blockquote><p>Java虚拟机基于栈架构，程序在运行时虚拟机需要频繁的从栈上读取或者写入数据，该过程需要更多的指令分派和内存访问，耗费CPU时间<br>，Dalvik虚拟机基于寄存器架构，数据访问通过寄存器间接传递，这样访问要比基于栈的方式要快很多。</p><blockquote><p>虚拟机运行状态不同</p></blockquote><p>Java虚拟机的指令集被称为零地址形式的指令集，所谓零地址形式，是指指令的源参数与目标参数都是隐含的，通过Java虚拟机中提供的一种数据结构“求值栈”来传递。对于Java程序来说，每个线程在执行时都有一个PC计数器与一个Java栈，PC计数器只对当前方法有效，Java虚拟机通过它的值来取指令执行,Java栈用于记录java方法调用的“活动记录”，Java栈以帧为单位保存线程的运行状态</p><p><img src="http://i.imgur.com/AwvCDiN.png" alt=""></p><p>第一条指令 iload_1 表示将第二个int类型局部变量进栈</p><p>第三条指令 iadd 从栈顶弹出两个int类型值，将值相加，然后把结果压回栈顶</p><p>第四、五条指令 分别压入第一个和第二个参数</p><p>第六条指令 isub 从栈顶弹出两个int类型值，将值相减，然后把结果压回栈顶</p><p>第七条指令 imul从栈顶弹出两个int型值，将两值相乘，然后把结果压回栈顶</p><p>第八条指令 ireturn返回一个int值</p><p>Dalvik虚拟机运行时同样为每个线程维护一个PC计数器与调用栈，与Java虚拟机不同的是，这个调用栈维护一份寄存器列表，同样的程序Dalvik命令明显减少</p><p><img src="http://i.imgur.com/9F7jahW.png" alt=""></p><h1 id="所处位置"><a href="#所处位置" class="headerlink" title="所处位置"></a>所处位置</h1><p>Android 系统架构采用分层思想，Dalvik虚拟机位于Android运行时环境，它与一些核心库共同承担Android应用程序的运行工作</p><p><img src="http://i.imgur.com/9RhIzBQ.png" alt=""></p><p>android启动加载完内核后，第一个执行的是init进程，init进程首先要做的是设备初始化，然后读取init.rc文件并启动系统中的重要的外部程序Zygote。</p><p>Zygote进程是Android所有进程的孵化器进程，它启动后会首先初始化Dalvik虚拟机，然后启动system_server并进入Zygote模式，通过socket等候命令。当执行一个Android应用程序时，system_server进程通过socket方式发送命令给zygote，zygote收到命令之后通过fork自身创建一个Daalvik虚拟机的实例来执行应用程序的入口程序，这样一个程序就启动完了</p><p>其中Zygote提供了三种创建进程的方法</p><ul><li>fork(),创建一个Zygote进程</li><li>forkAndSecialize(),创建一个非Zygote进程</li><li>forkSystemSever（），创建一个系统服务进程</li></ul><p>其中Zygote进程可以再fork出其他进程，非zygote进程则不能fork其他进程，而服务系统的进程终止后它的子进程也必须终止。</p><h1 id="关于Dalvik虚拟机JIT（即时编译）"><a href="#关于Dalvik虚拟机JIT（即时编译）" class="headerlink" title="关于Dalvik虚拟机JIT（即时编译）"></a>关于Dalvik虚拟机JIT（即时编译）</h1><p>JIT 又称动态编译，是一种通过在运行时将字节码翻译为机器码的技术，使得程序的执行速度更快，在Android2.2版本的Dalvik虚拟机引入了JIT技术</p><p>主流的JIT包含两种字节码编译方式</p><ul><li>method方式 以函数或者方法为单位进行编译</li><li>trace方式 以trace为单位进行编译</li></ul><p>注：trace是指：在函数中一般很少顺序执行代码的，多数代码都被分为好几条执行路径，其中有的函数路径实际过程很少被执行的，这部分被称为冷路径，而执行比较频繁的被称为热路径，采用传统的method方式会编译整个方法的代码，这会使得冷路径上浪费很多编译时间，并且耗费更多的内存：trace方式编译则能够快速的获取热路径代码，使用更短的时间与更少的内存来编译代码，目前Dalvik虚拟机默认采用trace方式编译代码同时也支持method方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;虽然Android平台使用java开发，
      
    
    </summary>
    
      <category term="Android" scheme="https://xsfelvis.github.io/categories/Android/"/>
    
    
      <category term="Dalvik" scheme="https://xsfelvis.github.io/tags/Dalvik/"/>
    
  </entry>
  
  <entry>
    <title>Android可执行文件</title>
    <link href="https://xsfelvis.github.io/2016/10/19/Android-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"/>
    <id>https://xsfelvis.github.io/2016/10/19/Android-可执行文件/</id>
    <published>2016-10-18T16:00:00.000Z</published>
    <updated>2018-06-04T04:48:22.424Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Android程序的生成"><a href="#Android程序的生成" class="headerlink" title="Android程序的生成"></a>Android程序的生成</h1><p>通常分为7步</p><ul><li>打包资源，生成R.java文件</li></ul><p>打包资源的工具aapt位于android-sdk\platform-tools目录下</p><ul><li>处理aidl文件，生成相应的java文件，对没有使用到aidl的android工程这一步可以跳过</li></ul><p>使用到的工具为aidl，位于android-sdk\platform-tools目录下</p><ul><li>编译工程源码，生成相应的class文件</li></ul><p>这一步调用javac编译工程src目录下所有的java源文件，生成的class文件位于工程的bin\classes目录下</p><ul><li>转换所有的class文件，生成classes.dex文件</li></ul><p>android系统Dalvik虚拟机的可执行文件为DEX格式，程序运行所需的classes.dex就是在这一步生成的，使用到的工具为dx，位于android-sdk\platform-tools</p><ul><li>打包生成APK文件</li></ul><p>打包的工具为apkbuilder，位于android-sdk\tools目录</p><ul><li>对APK文件进行签名</li></ul><p>Android的应用程序需要签名才能在Android设备上安装，在编译调试时候会使用一个debug.keystore对apk签名，另一种是打包发布时候进行签名，需要提供一个符合android开发文档中要求的签名</p><ul><li>对签名后的APK文件进行对齐处理</li></ul><p>使用工具zipalign，位于android-sdk\tools目录，主要工作就是将apk包进行对齐处理，使得apk包中所有资源文件距离文件起始偏移为4字节整数倍，这样通过内存映射访问apk文件时速度会更快</p><h1 id="dex文件格式"><a href="#dex文件格式" class="headerlink" title="dex文件格式"></a>dex文件格式</h1><blockquote><p>数据类型</p></blockquote><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>u1</td><td>等同于unit8_t,表示1字节的无符号数</td><td></td></tr><tr><td>u2</td><td>等同于unit16_t,表示2字节的无符号数</td><td></td></tr><tr><td>u4</td><td>等同于unit32_t,表示4字节的无符号数</td><td></td></tr><tr><td>u8</td><td>等同于unit64_t,表示8字节的无符号数</td><td></td></tr><tr><td>sleb128</td><td>有符号LEB128,可变字节1~5字节</td><td></td></tr><tr><td>uleb128</td><td>无符号LEB128,可变字节1~5字节</td><td></td></tr><tr><td>sleb128p1</td><td>无符号LEB128值加1,可变字节1~5字节</td><td></td></tr></tbody></table><blockquote><p>dex文件整体结构</p></blockquote><p>dex文件的整体结构比较简单，它是由多个结构组合而成的，一共有7个部分组成：</p><p>dex header——指定了dex文件的一些属性，并记录了其他6各部分数据结构在dex文件中的物理偏移</p><p>string_ids到class_def结构可以理解为“索引结构区”</p><p>data：真实的数据存放区</p><p>link_data:静态链接数据区</p><p><img src="http://i.imgur.com/pi8sQPd.png" alt=""></p><h1 id="odex文件"><a href="#odex文件" class="headerlink" title="odex文件"></a>odex文件</h1><p>odex文件的结构可以理解为dex文件的一个超集，它在dex文件头部添加了一些数据，然后在dex文件尾部添加了dex文件的依赖库以及一些辅助效果</p><p><img src="http://i.imgur.com/z86H4Py.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Android程序的生成&quot;&gt;&lt;a href=&quot;#Android程序的生成&quot; class=&quot;headerlink&quot; title=&quot;Android程序的生成&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Android" scheme="https://xsfelvis.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://xsfelvis.github.io/tags/Android/"/>
    
      <category term="dex" scheme="https://xsfelvis.github.io/tags/dex/"/>
    
  </entry>
  
  <entry>
    <title>认识Smali</title>
    <link href="https://xsfelvis.github.io/2016/10/12/%E8%AE%A4%E8%AF%86smali/"/>
    <id>https://xsfelvis.github.io/2016/10/12/认识smali/</id>
    <published>2016-10-11T16:00:00.000Z</published>
    <updated>2018-06-04T04:47:04.104Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="什么是smali"><a href="#什么是smali" class="headerlink" title="什么是smali"></a>什么是smali</h1><p>Smali，Baksmali分别是指安卓系统里的Java虚拟机（Dalvik）所使用的一种.dex格式文件的汇编器，反汇编器。其语法是一种宽松式的Jasmin/dedexer语法，而且它实现了.dex格式所有功能，当我们对apk反编译之后，便会生成此类文件，其中在dalvik字节码中，寄存器都是32位的，可以支持任何类型，64位类型要用2个寄存器表示，其中Dalvik字节码有两种类型：<code>原始类型</code>和`引用类型(包括对象和数组)</p><h1 id="为什么要学会smali"><a href="#为什么要学会smali" class="headerlink" title="为什么要学会smali"></a>为什么要学会smali</h1><p>当我们反编译之后得到jar或者smali文件，android采用java语言开发，但是android系统使用自己的dalvik虚拟机，代码编译最终不是采用java的class，而是使用smali。因此我们反编译得到的代码，jar的话很多地方无法正确的解释出来，如果我们反编译的是smali则可以正确的理解程序的意思，因此学会smali十分有必要</p><h1 id="smali语法"><a href="#smali语法" class="headerlink" title="smali语法"></a>smali语法</h1><blockquote><p>类型：<br>首先介绍下 Dalvik 字节码是什么</p></blockquote><ul><li><p>Dalvik是google专门为android 操作系统设计的一个虚拟机，经过深度优化。虽然android上的程序是使用java来开发的，但是dalvik和标准java虚拟机是两回事。Dalvik虚拟机是基于寄存器的，而JVM是基于栈的。Dalvik有专属的文件执行格式dex（dalvik executable），而JVM则执行的是java字节码，Dalvik vm比jvm速度更快，占用空间更少。</p></li><li><p>通过Dalvik的字节码我们不能直接看到原来的逻辑代码，这时需要借助ApkTool或者dex2jar+jd-jui工具来查看，但是，注意的是最终我们修改apk需要操作的文件是.smali文件，而不是导出来的java文件重新编译<br>Dalvik字节码有两种类型：<code>原始类型</code>和<code>引用类型(包括对象和数组)</code></p></li><li><p>原始类型</p></li></ul><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>V</td><td>void - can only be used for return types</td><td></td></tr><tr><td>Z</td><td>boolean</td><td></td></tr><tr><td>B</td><td>byte</td><td></td></tr><tr><td>S</td><td>short</td><td></td></tr><tr><td>C</td><td>char</td><td></td></tr><tr><td>I</td><td>int</td><td></td></tr><tr><td>J</td><td>long(64bits)</td><td></td></tr><tr><td>F</td><td>float</td><td></td></tr><tr><td>D</td><td>double(64bits)</td><td></td></tr><tr><td>[XXX</td><td>array</td></tr><tr><td>Lxxx/yyy</td><td>object</td></tr></tbody></table><ul><li>对象类型</li></ul><blockquote><p>Lpackage/name/ObjectName; 相当于java中的package.name.ObjectName;</p></blockquote><p>L：表示这是一个对象类型</p><p>package/name：对象所在的包</p><p>ObjectName：对象名称</p><p>；： 标识对象结束</p><p>其中内部类 LpakeageName/objectName$subObjectname</p><ul><li>数据类型</li></ul><p>[i 表示一个int类型的一维数组，相当于int[]</p><p>增加一个维度增加一个[，如[[i,表示int[][]</p><p>其中：每一维最多255个</p><p>对象数组表示也是类似，如String数组的表示是[Ljava/lang/String</p><ul><li>方法表示</li></ul><blockquote><p>Lpackage/name/ObjectName;-&gt;MethodName(III)Z</p></blockquote><p>Lpackage/name/ObjectName 表示类型</p><p>methodName 表示方法名</p><p>III 表示参数（这里表示为3个整型参数）</p><p>说明：方法的参数是一个接一个的，中间没有隔开</p><p>方法的定义一般为：</p><p>Func-Name(Para-Type1Para-Type2Para-Type3……)Return-Type</p><p>其中参数之间没有分隔符，例如：</p><p>hello()V  对应  void hello()</p><p>hello(III)Z 对应 boolean hello(int,int,int)</p><p>hello(Z[I[ILjava/lang/String;j) Ljava/lang/String 对应 String hello（boolean，int[],int[],String,long）</p><ul><li>字段表示</li></ul><blockquote><p>Lpackage/name/ObjectName;-&gt;FieldName:Ljava/lang/String;</p></blockquote><p>说明： 包名，字段名和各字段类型</p><ul><li>寄存器与变量</li></ul><blockquote><p>什么是寄存器：</p></blockquote><p>在smali里所有的才做都必须经过寄存器来进行：本地寄存器用v开头以数字结尾的符号来表示，如v0，v1</p><p>参数寄存器则使用p开头数字结尾的符号来表示，如p0，p1，特别要注意的是，p0不一定是函数中的第一个参数，在非static函数中，p0代指this，p1表示函数的第一个参数，p2表示函数的第二个参数，而在static函数中p0才对应第一个参数(因为java的static方法中没有this方法)</p><blockquote><p>简单指令解析</p></blockquote><p> set-object v0，Lcom/aaa;-&gt;ID:Ljava/lang/String</p><p> set-object 就是用来获取变量值保存到紧接着的参数寄存器中，上面的表示它获取ID这个String类型的成员变量并放到v0这个寄存器中</p><p> iget-object v0，p0，Lcom/aaa;-&gt;view:Lcom/aaa/view;</p><p> 这里可以看到iget-object指令比sget-object多了一个参数，该变量就是所在类的实例，在这里就是p0即，this</p><p> put指令的使用和get指令是统一的如下：</p><p> const/4 v3,0x0</p><p> sput-object v3,Lcom/aaa;-&gt;timer:Lcom/aaa/timer;</p><p> 相当于：this.timer = null;</p><p> .loacl v0,args:Landroid/os/Message;</p><p> const/4 v1,0x12</p><p> input v1,v0,Landroid/os/Message;-&gt;what:l</p><p> 相当于：args.what = 18;</p><p>指定一个方法中有多少寄存器可以使用有两种方式</p><blockquote><p>.registers 指令指定了方法中寄存器的总数</p><p>.locals 指令表明了方法中非参寄存器的总数，出现在方法中的第一行</p></blockquote><p>说明：</p><p>寄存器采用v和p来命名</p><p>v表示本地寄存器，p表示参数寄存器，二者关系如下：</p><p>Long和Double类型是64位，需要2个寄存器</p><p>如果有一个方法有两个本地变量，有3个参数，则表示如下：</p><pre><code>v0 第一个本地寄存器v1 第二个本地寄存器v2 p0 (this)v3 p1 第一个参数v4 p2 第二个参数v5 p3 第三个参数</code></pre><ul><li>基本语法</li></ul><p>.filed private isFlag:z  定义变量</p><p>.nethod 方法</p><p>.parameter 方法参数</p><p>.prologue 方法开始</p><p>.line 123 此方法位于123行</p><p>invoke-super 调用父函数</p><p>const/high16 v0,0x7fo3  把0x7fo3赋值给v0</p><p>invoke-direct 调用函数</p><p>return-void  函数返回void</p><p>.end method 函数结束</p><p>new-instance 创建实例</p><p>iput-object  对象赋值</p><p>iget-object 调用对象</p><p>invoke-static 调用静态函数</p><ul><li>条件跳转</li></ul><p>“if-eq VA,VB,:cond_xx “  如果VA=VB则跳转到cond_xx</p><p>“if-ne VA,VB,:cond_xx “  如果VA!=VB则跳转到cond_xx</p><p>“if-lt VA,VB,:cond_xx “  如果VA&lt;VB则跳转到cond_xx</p><p>“if-ge VA,VB,:cond_xx “  如果VA&gt;=VB则跳转到cond_xx</p><p>“if-gt VA,VB,:cond_xx “  如果VA&gt;VB则跳转到cond_xx</p><p>“if-le VA,VB,:cond_xx “  如果VA&lt;=VB则跳转到cond_xx</p><p>“if-eqz VA,:cond_xx “    如果VA=0则跳转到cond_xx</p><p>“if-nez VA,:cond_xx “    如果VA!=0则跳转到cond_xx</p><p>“if-ltz VA,:cond_xx “    如果VA&lt;0则跳转到cond_xx</p><p>“if-gez VA,:cond_xx “    如果VA&gt;=0则跳转到cond_xx</p><p>“if-gtz VA,:cond_xx “    如果VA&gt;0则跳转到cond_xx</p><p>“if-lez VA,:cond_xx “    如果VA&lt;=0则跳转到cond_xx</p><h1 id="smali-函数分析"><a href="#smali-函数分析" class="headerlink" title="smali 函数分析"></a>smali 函数分析</h1><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>smali中的函数和成员变量一样也分为两种类型</p><ul><li>direct</li><li>virtual</li></ul><p>简而言之 direct method就是private函数，其余的public和protected都属于virtual method。因此在函数调用时有invoke-direct，invoke-virtual，，另外还有invoke-static、invoke-super以及invoke-interface</p><blockquote><p>1、invoke-static： 用于调用static函数的</p></blockquote><p>如：</p><p>invoke-static{}，Lcom/aaa;-&gt;CheckSignature()Z</p><p>const-string v0,”NDKLIB”</p><p>invoke-static {v0}，Ljava/lang/System;-&gt;loadLibray(Ljava/lang/String;)V </p><p>这两句对应着 static void System.loadLiary(String)来加载NDK编译的so库方法，这里的v0就是参数“NDKLIB”</p><blockquote><p>2、invoke-super:调用父类方法用的指令，一般用于调用onCreate、onDestroy等方法</p><p>3、invoke-direct 调用private函数</p></blockquote><p>如：</p><p>invoke-direct{p0}，Landroid/app/TabActivity;-&gt;<init>()V</init></p><p>对应就是在TabActvity中定义一个private函数</p><blockquote><p>4、invoke-virtual</p></blockquote><p>用于调用protected和public函数</p><blockquote><p>5、 invoke-xxx/range:当方法</p></blockquote><p>当方法的参数多于5个时（含5个），不能直接使用上面的指令，而是在后面加上/range，并且传递参数不需要写全，可以以省略号替代，如：</p><p>invoke-direct/range{v0……v5}，Lcmb/pb/ui/PBContainerActivity;-&gt;h(ILjava/lang/CharSeqence;Ljava/lang/String;Landroid/content/Intent;I)Z</p><h3 id="函数返回结果操作"><a href="#函数返回结果操作" class="headerlink" title="函数返回结果操作"></a>函数返回结果操作</h3><p>在java代码汇总调用函数和返回结果可以用一条语句完成，而在smali里则需要分开来完成，使得使用上述指令后，如果调用的函数返回非void，那么还需要用到move-result(返回基本数据类型)和move-result-object(返回对象)指令，如：</p><p>const-string v0，“hello”</p><p>invoke-static{v0}，Lcmb/pbi;-&gt;t(Ljava/lang/String;)Ljava/lang/String;</p><p>move-result-object v2</p><p>其中v2保存的就是调用t方法返回的String字符串</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>.local 4 //本地寄存器4个，即v0，v1，v2，v3</p><p>const/4 v2 0x1  //4字节常量v2=1</p><p>const/16 v1 0x10 //16字节常量 v1=16</p><p>：local v1，“length”：I //本地寄存器int length =v1</p><p>if-nez v1,: cond_1  //如果v1！=0，跳转至cond_1</p><p>：cond_0 //cond_0标签</p><p>：goto_0  //goto_0标签</p><p>return v2  //返回v2</p><p>：cond_1   //开始执行cond_1标签代码</p><p>const/4 v0，0x0  //4字节常量 v0=0</p><p>：local v0，”i”:I  //本地寄存器 int i=0</p><p>：goto_1  //开始执行goto_1标签代码</p><p>if-lt v0，v1，：cond_2  //如果v0&lt;v1,则跳转cond_2</p><p>const/16 v3,0x28  //接上，如果v0&gt;=v1,则执行 16字节常量v3=40</p><p>if-le v1,v3,:cond_0 //接上，如果v1&lt;=v3,则跳转至cond_0,即返回v2的值</p><p>const/4 v2,0x0  //接上，如果v1大于v3，则4字节常量 v2=0</p><p>goto：goto_0 //跳转至goto_0,即返回v2值</p><p>：cond_2   //cond_2标签</p><p>xor-int/lit8 v1,v1,0x3b //将第二个v1寄存器中的值与0x3b(59)进行异或运算，得到的赋值给第一个v1寄存器中</p><p>add-int/lit8 v0,v0,0x01 //将第二个v0寄存器中的值加上0x1(1),所得的值放入到第一个v0寄存器中</p><p>goto：goto_1 //跳转至goto_1,标签，这里可以看出cond_2,实际是一个for循环，而不是简单的IF判断</p><p>翻译成代码</p><pre><code>int v2 = 1;int v1 = 16;if (v1 != 0){        for (int v0 = 0; v0 &lt; v1;)        {                v1 = v1 ^ 59;                v0++;        }        if (v1 &gt; 40)        {                v2 = 0;        }}return v2;</code></pre><h1 id="java代码转变为samli代码"><a href="#java代码转变为samli代码" class="headerlink" title="java代码转变为samli代码"></a>java代码转变为samli代码</h1><p>方法一：</p><p>可以使用android SDK提供的一个工具dx，该jar包位于android-sdk\build-tools\23.0.1\lib，找到该包后执行以下命令</p><blockquote><p>javac Test.java  得到Test.class</p><p>java -jar dx.jar –dex –output=Test.dex Test.class 得到dex文件</p></blockquote><p>这时候会使用到另外一个工具baksmali，该工具位于android-sdk\platform-tools\，找到该包后执行以下命令</p><blockquote><p>java -jar baksmali.jar Test.dex 得到smali文件</p></blockquote><p>但是jdk1.8第二步无效，jdk1.7可以</p><p>方法二：</p><p>Android studio装 code2smali插件</p><p><a href="https://github.com/ollide/intellij-java2smali" target="_blank" rel="noopener">https://github.com/ollide/intellij-java2smali</a></p><p>参考：</p><p><a href="http://yeungeek.com/2015/08/23/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B9%8B%E4%BA%8C-Smali%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/" target="_blank" rel="noopener">http://yeungeek.com/2015/08/23/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B9%8B%E4%BA%8C-Smali%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/</a></p><p><a href="http://blog.isming.me/2015/01/14/android-decompile-smali/" target="_blank" rel="noopener">http://blog.isming.me/2015/01/14/android-decompile-smali/</a></p><p><a href="http://www.cnblogs.com/gordon0918/p/5466514.html" target="_blank" rel="noopener">http://www.cnblogs.com/gordon0918/p/5466514.html</a></p><p><a href="http://www.52pojie.cn/thread-395689-1-1.html" target="_blank" rel="noopener">http://www.52pojie.cn/thread-395689-1-1.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;什么是smali&quot;&gt;&lt;a href=&quot;#什么是smali&quot; class=&quot;headerlink&quot; title=&quot;什么是smali&quot;&gt;&lt;/a&gt;什么是smali&lt;/h1
      
    
    </summary>
    
      <category term="安全" scheme="https://xsfelvis.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="安全" scheme="https://xsfelvis.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="smali" scheme="https://xsfelvis.github.io/tags/smali/"/>
    
  </entry>
  
  <entry>
    <title>Andfix学习</title>
    <link href="https://xsfelvis.github.io/2016/10/10/Andfix%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>https://xsfelvis.github.io/2016/10/10/Andfix学习记录/</id>
    <published>2016-10-09T16:00:00.000Z</published>
    <updated>2018-06-04T04:46:05.640Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="概述篇"><a href="#概述篇" class="headerlink" title="概述篇"></a>概述篇</h1><p>AndFix，全称是Android hot-fix。是阿里开源的一个热补丁框架，允许APP在不重新发布版本的情况下修复线上的bug。支持Android 2.3 到 7.0，并且支持arm 与 X86系统架构的设备。完美支持Dalvik与ART的Runtime，补丁文件是以 .apatch 结尾的文件，并且是立即生效的</p><p>项目地址<a href="https://github.com/alibaba/AndFix" target="_blank" rel="noopener">https://github.com/alibaba/AndFix</a></p><p>官方ReadMe</p><blockquote><p>大致修复图</p></blockquote><p><img src="https://github.com/alibaba/AndFix/raw/master/images/principle.png" alt=""></p><blockquote><p>How to Use(官方)</p></blockquote><p>Initialize PatchManager,</p><pre><code>`patchManager = new PatchManager(context); patchManager.init(appversion);//current version`</code></pre><p>Load patch,</p><pre><code>`patchManager.loadPatch();`</code></pre><p>You should load patch as early as possible, generally, in the initialization phase of your application(such as Application.onCreate()).</p><p>Add patch,</p><pre><code>`patchManager.addPatch(path);//path of the patch file that was downloaded`</code></pre><p>When a new patch file has been downloaded, it will become <code>effective immediately</code> by addPatch</p><p>还有一点就是混淆需要注意</p><pre><code>`-keep class * extends java.lang.annotation.Annotation -keepclasseswithmembernames class * {  native &lt;methods&gt;;  } -keep class com.alipay.euler.andfix.** { *; } `</code></pre><p>如何制作一个apatch呢，阿里在这个开源项目中提供了一个工具<a href="https://github.com/alibaba/AndFix/blob/master/tools/apkpatch-1.0.3.zip" target="_blank" rel="noopener">https://github.com/alibaba/AndFix/blob/master/tools/apkpatch-1.0.3.zip</a><br>，这里先大致介绍一下原理：通过diff增量比对两个apk改变的地方，在其上通过加上注解标记，生成一个apatch</p><p><img src="http://images2015.cnblogs.com/blog/886182/201603/886182-20160311145621210-104524703.png" alt=""></p><p>例如旧的apk为1.apk，新的apk为2.apk, -o表示补丁的输出目录，-k表示keystore, -p表示keystore的密码，-a表示alias, -e表示entry password。</p><p><img src="http://images2015.cnblogs.com/blog/886182/201603/886182-20160311192720366-164535579.png" alt=""></p><p>命令输入有点麻烦，可以自己写一个win的脚本</p><blockquote><p>apkpatch -f 2.apk -t 1.apk -o . -k finance.keystore  -p finance.tech.netease.com -a android.finance.163.com -e finance.tech.netease.com</p></blockquote><p>这样基本可以照猫画虎折腾热更新了,当然不要忘记添加读写权限</p><pre><code>`&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;`</code></pre><h1 id="原理篇"><a href="#原理篇" class="headerlink" title="原理篇"></a>原理篇</h1><ul><li><p>andfix 深入</p></li><li><p>补丁深入</p></li></ul><h2 id="andfix-原理"><a href="#andfix-原理" class="headerlink" title="andfix 原理"></a>andfix 原理</h2><p>andfix的核心原理就是方法替换 在通过其apath工具给需要替换的方法加上注解@repleaceMethod，这样在执行时把有bug的方法替换成补丁文件中执行的方法。（在Native 层使用指针替换的方式替换bug的方法，从而达到修复bug的目的），具体过程如下图：</p><p><img src="http://i.imgur.com/ErUHzr9.jpg" alt=""></p><ul><li>加载补丁</li></ul><p>使用虚拟机的JarFile加载的补丁文件，读取PATCH.MF文件得到补丁类名称</p><ul><li>获取补丁方法</li></ul><p>使用DexFile读取patch文件的dex文件，获取后根据注解获取补丁方法</p><ul><li><p>获取bug所在的方法</p><p>根据注解中获取到的类名和方法，使用ClassLaoder获取到class，然后根据反射得到bug Method，并将其访问属性修改为public<br>—————————————–java 层————————————————————-</p></li><li><p>Native 层替换方法</p></li></ul><p>使用JNI来替换bug所在方法对象的属性来修复bug</p><p>简要类之间关系图<br><img src="http://i.imgur.com/hXtSBHF.png" alt=""></p><p>修复的具体过程为：</p><p>1）我们及时修复好bug之后，我们可以apkpatch工具将两个apk做一次对比，然后找出不同的部分。生成的apatch了文件。若果这个时候，我们把后缀改成zip再解压开，里面有一个dex文件。反编译之后查看一下源码，里面就是被修复的代码所在的类文件,这些更改过的类都加上了一个_CF的后缀，并且变动的方法都被加上了一个叫@MethodReplace的annotation，通过clazz和method指定了需要替换的方法。(后面补丁原理会说到)</p><p>2）客户端得到补丁文件后就会根据annotation来寻找需要替换的方法。从AndFixManager.fix方法开始，客户端找到对应的需要替换的方法，然后在fix方法的具体实现中调用fixClass方法进行方法替换过程。</p><p>3）由JNI层完成方法的替换。fixClass方法遍历补丁class里的方法，在jni层对所需要替换的方法进行一一替换。(AndfixManager#replaceMethod)</p><blockquote><p>源码解析</p></blockquote><p>遵循使用时四步走：</p><blockquote><p>Step1：初始化PatchManger</p></blockquote><pre><code>`PatchManager patchManager = new PatchManager();`</code></pre><p>参阅 patchManager类源码——&gt;AndfixManager 其中包含了Compat兼容性检测类、SecurityChecker安全性检查类</p><pre><code>`public AndFixManager(Context context) {    mContext = context;    //判断机型是否支持Andfix 阿里的YunOs不支持    mSupport = Compat.isSupport();    if (mSupport) {        //初始化签名判断类        mSecurityChecker = new SecurityChecker(mContext);        mOptDir = new File(mContext.getFilesDir(), DIR);        // make directory fail        if (!mOptDir.exists() &amp;&amp; !mOptDir.mkdirs()) {            mSupport = false;            Log.e(TAG, &quot;opt dir create error.&quot;);        } else if (!mOptDir.isDirectory()) {// not directory            //如果不是目录则删除            mOptDir.delete();            mSupport = false;        }    }}`</code></pre><blockquote><p>Step2:使用PatchManger检查版本</p></blockquote><pre><code>`patchManager.init(apk版本)`</code></pre><p>参阅patchManager#init ——&gt;Patch 构造函数初始化 init<br>主要是版本比对，记录版本号；根据版本号将patch清除或者加载到缓存中</p><p>参阅Patch#init</p><pre><code>`    public void init(String appVersion) {    if (!mPatchDir.exists() &amp;&amp; !mPatchDir.mkdirs()) {// make directory fail        Log.e(TAG, &quot;patch dir create error.&quot;);        return;    } else if (!mPatchDir.isDirectory()) {// not directory        mPatchDir.delete();        return;    }    SharedPreferences sp = mContext.getSharedPreferences(SP_NAME,            Context.MODE_PRIVATE);//缓存版本号    String ver = sp.getString(SP_VERSION, null);    if (ver == null || !ver.equalsIgnoreCase(appVersion)) {        //根据传入版本号作对比，若不同，则删除本地的补丁文件        cleanPatch();        sp.edit().putString(SP_VERSION, appVersion).commit();//传入新的版本号    } else {        initPatchs();//初始化patch列表，把本地的patch加载到内存中    }}private void initPatchs() {    File[] files = mPatchDir.listFiles();    for (File file : files) {        addPatch(file);    }}`</code></pre><p>Patch文件的加载 使用JarFile读取Patch文件，读取一些属性如patchname，createtime，其中如果本地保存了多个补丁，那么AndFix会按照补丁生成的时间顺序加载补丁。具体是根据.apatch文件中的PATCH.MF的字段Created-Time。</p><blockquote><p>step3:loadPatch</p></blockquote><pre><code>`patchManager.loadPatch();`</code></pre><p>参阅patchManager#loadPatch</p><p>提供了3个重载方法</p><pre><code>`public void loadPatch()//andfix 初始化之后调用 private void loadPatch(Patch patch)//下载补丁完成后调用，addPatch(path) public void loadPatch(String patchName, ClassLoader classLoader)//提供了自定义类加载器的实现 `</code></pre><p>这三个核心都是调用了public synchronized void fix(File file, ClassLoader classLoader, List<string> classes)</string></p><p>参看AndfixManager#fix</p><pre><code>`public synchronized void fix(File file, ClassLoader classLoader,        List&lt;String&gt; classes) {    if (!mSupport) {        return;    }    //判断补丁的签名    if (!mSecurityChecker.verifyApk(file)) {// security check fail        return;    }    try {        File optfile = new File(mOptDir, file.getName());        boolean saveFingerprint = true;        if (optfile.exists()) {            // need to verify fingerprint when the optimize file exist,            // prevent someone attack on jailbreak device with            // Vulnerability-Parasyte.            // btw:exaggerated android Vulnerability-Parasyte            // http://secauo.com/Exaggerated-Android-Vulnerability-Parasyte.html            //如果本地已经存在补丁文件，则校验指纹信息            if (mSecurityChecker.verifyOpt(optfile)) {                saveFingerprint = false;            } else if (!optfile.delete()) {                return;            }        }        //加载patch文件中的dex        final DexFile dexFile = DexFile.loadDex(file.getAbsolutePath(),                optfile.getAbsolutePath(), Context.MODE_PRIVATE);        if (saveFingerprint) {            mSecurityChecker.saveOptSig(optfile);        }        ClassLoader patchClassLoader = new ClassLoader(classLoader) {            //重写了ClassLoader的findClass方法            @Override            protected Class&lt;?&gt; findClass(String className)                    throws ClassNotFoundException {                Class&lt;?&gt; clazz = dexFile.loadClass(className, this);                if (clazz == null                        &amp;&amp; className.startsWith(&quot;com.alipay.euler.andfix&quot;)) {                    return Class.forName(className);// annotation注解class                                                    // not found                }                if (clazz == null) {                    throw new ClassNotFoundException(className);                }                return clazz;            }        };        Enumeration&lt;String&gt; entrys = dexFile.entries();        Class&lt;?&gt; clazz = null;        while (entrys.hasMoreElements()) {            String entry = entrys.nextElement();            if (classes != null &amp;&amp; !classes.contains(entry)) {                continue;// skip, not need fix            }            clazz = dexFile.loadClass(entry, patchClassLoader);//获取有bug的类文件            if (clazz != null) {                fixClass(clazz, classLoader);//核心-            }        }    } catch (IOException e) {        Log.e(TAG, &quot;pacth&quot;, e);    }}`</code></pre><p>fix——&gt;fixclass——&gt;replaceMethod——&gt;Andfix#replaceMethod(Method dest,Method src) Native方法</p><pre><code>`private void fixClass(Class&lt;?&gt; clazz, ClassLoader classLoader) {    //反射找到clazz中的所有方法    Method[] methods = clazz.getDeclaredMethods();    //MethodReplace的注解    MethodReplace methodReplace;    String clz;    String meth;    for (Method method : methods) {        //遍历所有方法，找到有MethodReplace注解的方法，即需要替换的方法        methodReplace = method.getAnnotation(MethodReplace.class);//获取此方法的注解，有bug的方法生成patch的类中的方法都是有注解的        if (methodReplace == null)            continue;        clz = methodReplace.clazz(); //获取注解中的clazz的值        meth = methodReplace.method(); //获取注解中method的值        if (!isEmpty(clz) &amp;&amp; !isEmpty(meth)) {            //找到需要替换的方法后调用replaceMethod替换方法            replaceMethod(classLoader, clz, meth, method);        }    }}</code></pre><p>`</p><pre><code>`private void replaceMethod(ClassLoader classLoader, String clz,        String meth, Method method) {    try {        String key = clz + &quot;@&quot; + classLoader.toString();        //根据key查找缓存中的数据，该缓存记录了已经被修复过得class        Class&lt;?&gt; clazz = mFixedClass.get(key);        if (clazz == null) {// class not load            //找不到说明该class没有被修复过，则通过类加载器去加载            Class&lt;?&gt; clzz = classLoader.loadClass(clz);            // initialize target class            //通过C层改写accessFlag，把需要替换的类的所有方法(Field)改成了public            clazz = AndFix.initTargetClass(clzz);//初始化target class        }        if (clazz != null) {// initialize class OK            mFixedClass.put(key, clazz);            Method src = clazz.getDeclaredMethod(meth,                    method.getParameterTypes());  //根据反射拿到有bug的类的方法            //这里是调用了jni，art和dalvik分别执行不同的替换逻辑，在cpp进行实现            AndFix.addReplaceMethod(src, method);//替换方法 src是有bug的方法，method是补丁方法        }    } catch (Exception e) {        Log.e(TAG, &quot;replaceMethod&quot;, e);    }}`</code></pre><p> <code>Natvie方法的分析</code>见下面</p><p>前三步都是一开始初始化时候要做的，而最后一步第四步则是补丁下载好之后再做的</p><blockquote><p>step4: 添加Patch</p></blockquote><pre><code>`patchManager.addPatch(path)`</code></pre><p>参阅PatchManager#addPatch，最终还是执行loadpatch</p><p>appPatch——&gt;copy到andfix默认的文件夹下——&gt;执行loadPatch(补丁立即生效)</p><pre><code>`    public void addPatch(String path) throws IOException {    File src = new File(path);    File dest = new File(mPatchDir, src.getName());    if(!src.exists()){        throw new FileNotFoundException(path);    }    if (dest.exists()) {        Log.d(TAG, &quot;patch [&quot; + path + &quot;] has be loaded.&quot;);        return;    }    //这一步很重要，通过这一步将你所下载保存的patch文件，copy到andfix自己默认的文件夹内存的data/data/apatch    FileUtil.copyFile(src, dest);// copy to patch&apos;s directory    Patch patch = addPatch(dest);    if (patch != null) {        //加载patch 补丁立即生效        loadPatch(patch);    }}`</code></pre><p>小结一下：<br>可以看出andfix的核心就是两大步</p><ul><li>java层 实现加载补丁文件，安全验证等操作，然后根据补丁汇总的注解找到将要替换的方法，交给Native层去处理替换方法</li><li>native层：利用java hook的技术来替换要修复的方法</li></ul><h2 id="附-Native-分析"><a href="#附-Native-分析" class="headerlink" title="附 Native 分析"></a>附 Native 分析</h2><p>在JNI目录下 art和darvik文件中</p><p>andfix.cpp#replaceMethod——&gt;art_method_replace.cpp(根据版本)——art_method_replace_5_0.cpp</p><ul><li><p>Dalvik</p><p>Dalvik是Google公司自己设计用于Android平台的Java虚拟机。Dalvik虚拟机是Google等厂商合作开发的Android移动设备平台的核心组成部分之一。它可以支持已转换为 .dex（即Dalvik Executable）格式的Java应用程序的运行，.dex格式是专为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。Dalvik 经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik 应用作为一个独立的Linux 进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。</p></li><li><p>ART</p></li></ul><p>Android操作系统已经成熟，Google的Android团队开始将注意力转向一些底层组件，其中之一是负责应用程序运行的Dalvik运行时。Google开发者已经花了两年时间开发更快执行效率更高更省电的替代ART运行时。 ART代表Android Runtime，其处理应用程序执行的方式完全不同于Dalvik，Dalvik是依靠一个Just-In-Time (JIT)编译器去解释字节码。开发者编译后的应用代码需要通过一个解释器在用户的设备上运行，这一机制并不高效，但让应用能更容易在不同硬件和架构上运 行。ART则完全改变了这套做法，在应用安装时就预编译字节码到机器语言，这一机制叫Ahead-Of-Time (AOT）编译。在移除解释代码这一过程后，应用程序执行将更有效率，启动更快。</p><p>-优缺点</p><p>ART优点：</p><p>1、系统性能的显著提升。</p><p>2、应用启动更快、运行更快、体验更流畅、触感反馈更及时。</p><p>3、更长的电池续航能力。</p><p>4、支持更低的硬件。</p><p>ART缺点：</p><p>1、更大的存储空间占用，可能会增加10%-20%。</p><p>2、更长的应用安装时间。</p><p>总的来说ART的功效就是“空间换时间”。</p><blockquote><p>其他重要函数</p></blockquote><p>PatchManage#removeAllPatch()</p><p>这个函数是在PatchManage#init(viersin) verision不同时调用的方法一样，清空补丁目录文件，这在做保护的时候十分重要。</p><pre><code>`    public void removeAllPatch() {    cleanPatch();    SharedPreferences sp = mContext.getSharedPreferences(SP_NAME,            Context.MODE_PRIVATE);    sp.edit().clear().commit();}`</code></pre><p>比如在laodPatch,包括初始化的时候patchManager.loadPatch()和patchManager.addPatch(其实也是调用loadpath)</p><pre><code>`public void loadPatch() {    mLoaders.put(&quot;*&quot;, mContext.getClassLoader());// wildcard    Set&lt;String&gt; patchNames;    List&lt;String&gt; classes;    for (Patch patch : mPatchs) {        patchNames = patch.getPatchNames();        for (String patchName : patchNames) {            classes = patch.getClasses(patchName);//获取patch对用的class类集合            mAndFixManager.fix(patch.getFile(), mContext.getClassLoader(),                    classes);//核心-修复bug方法        }    }}`</code></pre><p>   因此需要在以下两处做好保护</p><pre><code>`public void starAndfix() {    try {        mPatchManager = new PatchManager(context);        mPatchManager.init(BuildConfig.VERSION_NAME);//更换版本号，补丁会被清除        AppLog.d(TAG, &quot;inited.&quot;);        mPatchManager.loadPatch();                  ……        requestHotFixServer(lastSign);    } catch (Throwable throwable) {        mPatchManager.removeAllPatch();        AppLog.d(TAG, &quot;outer catch error remove apatch&quot;);    }}`` try{                mPatchManager.addPatch(context.getFilesDir() + &quot;/&quot; + DIR + APATCH_PATH);            }catch (Throwable throwable){                mPatchManager.removeAllPatch();                AppLog.d(TAG, &quot;inner catch error remove apatch&quot;);            }`</code></pre><h2 id="补丁原理"><a href="#补丁原理" class="headerlink" title="补丁原理"></a>补丁原理</h2><h3 id="apkPatch工具解析"><a href="#apkPatch工具解析" class="headerlink" title="apkPatch工具解析"></a>apkPatch工具解析</h3><p>apkpatch是一个jar包，并没有开源出来，我们可以使用JD-GUI来查看其源码。首先找到Main.class 位于com.euler.patch包下，找到main方法 Main#97</p><pre><code>`public static void main(final String[] args) {    .....    //根据上面命令输入拿到参数           ApkPatch apkPatch = new ApkPatch(from, to, name, out, keystore, password, alias, entry);   apkPatch.doPatch();}`</code></pre><p>——&gt;ApkPatch#doPatch</p><pre><code>` public void doPatch() {try {  //生成smail文件夹  File smaliDir = new File(this.out, &quot;smali&quot;);  if (!smaliDir.exists())    smaliDir.mkdir();  try  {    FileUtils.cleanDirectory(smaliDir);  } catch (IOException e) {    throw new RuntimeException(e);  }  //新建diff.dex文件  File dexFile = new File(this.out, &quot;diff.dex&quot;);  if ((dexFile.exists()) &amp;&amp; (!dexFile.delete())) {    throw new RuntimeException(&quot;diff.dex can&apos;t be removed.&quot;);  }  //新建diff.apatch文件  File outFile = new File(this.out, &quot;diff.apatch&quot;);  if ((outFile.exists()) &amp;&amp; (!outFile.delete())) {    throw new RuntimeException(&quot;diff.apatch can&apos;t be removed.&quot;);  }  //第一步：拿到两个apk文件对比，对比信息写入DiffInfo  DiffInfo info = new DexDiffer().diff(this.from, this.to);  //第二步：将对比结果info写入.smail文件中，然后打包成dex文件  this.classes = buildCode(smaliDir, dexFile, info);  //第三步：将生成的dex文件写入jar包，并根据输入的签名信息进行签名生成diff.apatch文件  build(outFile, dexFile);  //第四步：将diff.apatch文件重命名  release(this.out, dexFile, outFile);} catch (Exception e) {  e.printStackTrace();}}`</code></pre><p>代码翻译一下：</p><ul><li>对比apk文件，得到所需信息</li><li>将结果打包为apatch文件</li></ul><p>主要的就是对比文件信息的DexDiffer().diff(this.from, this.to)方法</p><p>——&gt;diff#DexDiffer#diff</p><pre><code>`public DiffInfo diff(File newFile, File oldFile)throws IOException{//提取新apk的dex文件DexBackedDexFile newDexFile = DexFileFactory.loadDexFile(newFile, 19,   true);//提取旧apk的dex文件DexBackedDexFile oldDexFile = DexFileFactory.loadDexFile(oldFile, 19,   true);DiffInfo info = DiffInfo.getInstance();boolean contains = false;for (DexBackedClassDef newClazz : newDexFile.getClasses()) {  Set oldclasses = oldDexFile    .getClasses();  for (DexBackedClassDef oldClazz : oldclasses) {    //对比相同的方法，存储为修改的方法    if (newClazz.equals(oldClazz)) {      //对比class文件的变量      compareField(newClazz, oldClazz, info);      //对比class的方法，如果同一个类中没有相同的方法，则判断为新增方法(后面方法)      compareMethod(newClazz, oldClazz, info);      contains = true;      break;    }  }  if (!contains)  {    info.addAddedClasses(newClazz);  }}return info;}`</code></pre><p>从这段代码可以看出dex diff得到两个apk文件的差别信息，变量和方法</p><blockquote><p>变量</p></blockquote><pre><code>`public void addAddedFields(DexBackedField field) {this.addedFields.add(field);throw new RuntimeException(&quot;can,t add new Field:&quot; +   field.getName() + &quot;(&quot; + field.getType() + &quot;), &quot; + &quot;in class :&quot; +   field.getDefiningClass()); } public void addModifiedFields(DexBackedField field) { this.modifiedFields.add(field); throw new RuntimeException(&quot;can,t modified Field:&quot; +   field.getName() + &quot;(&quot; + field.getType() + &quot;), &quot; + &quot;in class :&quot; +   field.getDefiningClass());}`</code></pre><p>可以看出不支持增加成员变量，也不支持修改成员变量。</p><blockquote><p>方法</p></blockquote><pre><code>`public void addAddedMethods(DexBackedMethod method) {System.out.println(&quot;add new Method:&quot; + method.getReturnType() +   &quot;  &quot; + method.getName() + &quot;(&quot; +   Formater.formatStringList(method.getParameterTypes()) +   &quot;)  in Class:&quot; + method.getDefiningClass());this.addedMethods.add(method);if (!this.modifiedClasses.contains(method.classDef))  this.modifiedClasses.add(method.classDef);}public void addModifiedMethods(DexBackedMethod method) {System.out.println(&quot;add modified Method:&quot; + method.getReturnType() +   &quot;  &quot; + method.getName() + &quot;(&quot; +   Formater.formatStringList(method.getParameterTypes()) +   &quot;)  in Class:&quot; + method.getDefiningClass());this.modifiedMethods.add(method);if (!this.modifiedClasses.contains(method.classDef))  this.modifiedClasses.add(method.classDef);}}`</code></pre><p>可以看出对比方法过程中对比两个dex文件中同时存在的方法，如果方法实现不同则存储为修改过的方法；如果方法名不同，存储为新增的方法，也就是说AndFix支持增加新的方法</p><p>最后还有一点需要注意下：<br>在diff#DexDiffer#diff中<br>    //提取新apk的dex文件<br>    DexBackedDexFile newDexFile = DexFileFactory.loadDexFile(newFile, 19, true);</p><p>——&gt;org#jf#dexlib2#DexFileFactory</p><pre><code>`public static DexBackedDexFile loadDexFile(String path, int api, boolean experimental)throws IOException{return loadDexFile(new File(path), &quot;classes.dex&quot;, new Opcodes(api, experimental));}`</code></pre><p>可以看出只提取出了classes.dex这个文件，所以并不支持multidex，如果使用了multidex方案，并且修复的类不在同一个dex文件中，那么补丁就不会生效。</p><h3 id="生成补丁解析"><a href="#生成补丁解析" class="headerlink" title="生成补丁解析"></a>生成补丁解析</h3><p>当时在研究热更新时出现了使用release包加壳后的补丁不能使，为了更好地研究生成的补丁的使用，需要进一步研究一下生成的补丁具体是什么。</p><blockquote><p>工具： jadx</p></blockquote><p>使用参考：<a href="https://liuzhichao.com/2016/jadx-decompiler.html" target="_blank" rel="noopener">https://liuzhichao.com/2016/jadx-decompiler.html</a></p><blockquote><p>将加壳前和加壳后生成的补丁，后缀改为zip，得到noshell.out.zip和shell.out.zip，解压后二者都是由两部分组成</p></blockquote><p><img src="http://i.imgur.com/6TLvmKO.png" alt=""></p><p>通过jadx查看 未加壳生成的补丁dex文件<br><img src="http://i.imgur.com/3QTF5Es.png" alt=""><br>可以清楚看到加注解的方法，注解之中写了clazz和method的值，对应着apk包中的类名和方法名称；然后就是前后替换的地方</p><p>而当用jadx查看加壳后引起一场的补丁时候，<br><img src="http://i.imgur.com/Zi75LwY.png" alt=""></p><p>可以看出，加壳之后两个apk根本无法通过diff正确生成补丁，初步推断应该是加壳引入更大的混淆，是的前后两个apk根本无法通过增量比对判断变化，这种error补丁后补丁加入之后会引起 java.lang.VerifyError<br><img src="http://i.imgur.com/8Mcue65.png" alt=""></p><p>因此做好异常保护十分重要</p><h1 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h1><blockquote><p>优点</p></blockquote><p>1）可以多次打补丁。如果本地保存了多个补丁，那么AndFix会按照补丁生成的时间顺序加载补丁。具体是根据.apatch文件中的PATCH.MF的字段Created-Time。</p><p>2）安全性</p><p>readme提示开发者需要验证下载过来的apatch文件的签名是否就是在使用apkpatch工具时使用的签名，如果不验证那么任何人都可以制作自己的apatch文件来对你的APP进行修改。 但是我看到AndFix已经做了验证，如果补丁文件的证书和当前apk的证书不是同一个的话，就不能加载补丁。 官网还有一条，提示需要验证optimize file的指纹，应该是为了防止有人替换掉本地保存的补丁文件，所以要验证MD5码，然而SecurityChecker类里面也已经做了这个工作。。但是这个MD5码是保存在sharedpreference里面，如果手机已经root那么还是可以被访问的。</p><p>3）不需要重启APP即可应用补丁。</p><blockquote><p>缺点</p></blockquote><p>1）不支持YunOS </p><p>2）无法添加新类和新的字段 </p><p>3）需要使用加固前的apk制作补丁，但是补丁文件很容易被反编译，也就是修改过的类源码容易泄露 </p><p>4）使用加固平台可能会使热补丁功能失效 </p><p>5）无法添加类和字段</p><p>6)如果使用了multidex方案，并且修复的类不在同一个dex文件中，那么补丁就不会生效。</p><h1 id="再次总结"><a href="#再次总结" class="headerlink" title="再次总结"></a>再次总结</h1><p>andfix热补丁的原理就是，通过加载差分补丁，把需要替换的方法注入到native层，然后通过替换新老方法的函数指针，从而达到bug修复的目的，但是由于Andfix是动态的跳过了类的初始化，所以对于静态方法，静态成员变量，构造方法，是不能处理的，而且也不支持新增成员变量和修改成员变量。</p><h1 id="其他一些坑"><a href="#其他一些坑" class="headerlink" title="其他一些坑"></a>其他一些坑</h1><ul><li>自己下载文件的位置不要跟andfix默认的位置一致，否则源码执行addpatch先会在默认位置检查，如果存在直接return而不会去执行loadpatch</li><li>含有loadpatch的地方要做好保护</li><li>需要提供未加壳apk生成的补丁文件，而不是加壳后的补丁</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;概述篇&quot;&gt;&lt;a href=&quot;#概述篇&quot; class=&quot;headerlink&quot; title=&quot;概述篇&quot;&gt;&lt;/a&gt;概述篇&lt;/h1&gt;&lt;p&gt;AndFix，全称是Androi
      
    
    </summary>
    
      <category term="开源学习" scheme="https://xsfelvis.github.io/categories/%E5%BC%80%E6%BA%90%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Andfix" scheme="https://xsfelvis.github.io/tags/Andfix/"/>
    
  </entry>
  
  <entry>
    <title>Fragment Study</title>
    <link href="https://xsfelvis.github.io/2016/10/04/fragment-study/"/>
    <id>https://xsfelvis.github.io/2016/10/04/fragment-study/</id>
    <published>2016-10-03T16:00:00.000Z</published>
    <updated>2018-06-04T04:44:19.335Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>fragment 必须始终嵌入在Actvity中，其生命周期直接受宿主Activity生命周期影响， 例如，当 Activity 暂停时，其中的所有片段也会暂停；当 Activity 被销毁时，所有片段也会被销毁。 不过，当 Activity 正在运行（处于已恢复生命周期状态）时，您可以独立操纵每个片段，如添加或移除它们。</li><li>不过，片段并非必须成为 Activity 布局的一部分；您还可以将没有自己 UI 的片段用作 Activity 的不可见工作线程</li></ul><h2 id="onCreateView的两种方式"><a href="#onCreateView的两种方式" class="headerlink" title="onCreateView的两种方式"></a>onCreateView的两种方式</h2><pre><code>` public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {    enableLoadHelper(true);    if (savedInstanceState != null) {        fofItem = (AtlasAssetInfo.FOFItem) savedInstanceState.getSerializable(AtlasAssetDetailActivity.ATLAS_ORDER);    }    return onCreateView(R.layout.fragment_atlas_asset_detail, inflater, container);}`</code></pre><p>官方写法：</p><pre><code>` public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {    enableLoadHelper(true);    if (savedInstanceState != null) {        fofItem = (AtlasAssetInfo.FOFItem) savedInstanceState.getSerializable(AtlasAssetDetailActivity.ATLAS_ORDER);    }    return onCreateView(R.layout.fragment_atlas_asset_detail, inflater, container);}`</code></pre><p>参考：<br><a href="https://developer.android.com/guide/components/fragments.html?hl=zh-cn#Lifecycle" target="_blank" rel="noopener">https://developer.android.com/guide/components/fragments.html?hl=zh-cn#Lifecycle</a></p><h1 id="Fragemnet的坑"><a href="#Fragemnet的坑" class="headerlink" title="Fragemnet的坑"></a>Fragemnet的坑</h1><p>介绍坑之前先介绍一个概念：内存重启<br>安卓app有一种特殊情况，就是 app运行在后台的时候，系统资源紧张的时候导致把app的资源全部回收（杀死app的进程），这时把app再从后台返回到前台时，app会重启。这种情况下文简称为：“内存重启”。（屏幕旋转等配置变化也会造成当前Activity重启，本质与“内存重启”类似）</p><p>先给出一张fragment详细的生命周期图<br><img src="http://i.imgur.com/tQqHoSb.png" alt=""></p><p>图片来自<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0605/2996.html" target="_blank" rel="noopener">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0605/2996.html</a></p><p>下面查阅资料结合自己实际中遇到困难总结了<br>有些场景都是开启了不保留活动</p><h3 id="geActvity-空指针"><a href="#geActvity-空指针" class="headerlink" title="geActvity()空指针"></a>geActvity()空指针</h3><blockquote><p>原因：</p></blockquote><p>能你遇到过getActivity()返回null，或者平时运行完好的代码，在“内存重启”之后，调用getActivity()的地方却返回null，报了空指针异常。<br>大多数情况下的原因：你在调用了getActivity()时，当前的Fragment已经onDetach()了宿主Activity。<br>比如：你在pop了Fragment之后，该Fragment的异步任务仍然在执行，并且在执行完成后调用了getActivity()方法，这样就会空指针。</p><blockquote><p>解决方法：</p></blockquote><p>在Fragment基类里设置一个Activity activity的全局变量，在onAttach(Activity activity)里赋值，使用mActivity代替getActivity()，保证Fragment即使在onDetach后，仍持有Activity的引用（有引起内存泄露的风险，但是相比空指针闪退，这种做法“安全”些）</p><pre><code>`@Overridepublic void onAttach(Context context) {super.onAttach(context);this.mActivity = (Activity)context;}`</code></pre><p>或者如果该Context需要在Activity被销毁后还存在，则使用getActivity().getApplicationContext()</p><h3 id="臭名昭著的Can-not-perform-this-action-after-onSaveInstanceState"><a href="#臭名昭著的Can-not-perform-this-action-after-onSaveInstanceState" class="headerlink" title="臭名昭著的Can not perform this action after onSaveInstanceState"></a>臭名昭著的Can not perform this action after onSaveInstanceState</h3><blockquote><p>原因：</p></blockquote><p>在你离开当前Activity等情况下，系统会调用onSaveInstanceState()<code>调用时机是onPause之后onStop之前</code>帮你保存当前Activity&amp;Fragment的一些状态、数据等，而在离开后（onSaveInstanceState()已经被执行），你又去执行Fragment的相关事务方法后，就会抛出该异常！</p><blockquote><p>解决方式：</p></blockquote><p>解决方法2个：</p><p>1、（不推荐）该事务使用commitAllowingStateLoss()方法提交，但是有可能导致该次提交无效！</p><p>2、（推荐）在重新回到该Activity的时候（比如onStart里），再执行该事务！</p><p>Note：上次的首页广告MainActivity中需要重新修改</p><p>================================================================================</p><p>The exception was thrown because you attempted to commit a FragmentTransaction after the activity’s state had been saved, resulting in a phenomenon known as Activity state loss</p><p>When the framework calls onSaveInstanceState(), it passes the method a Bundle object for the Activity to use to save its state, and the Activity records in it the state of its dialogs, fragments, and views. When the method returns, the system parcels the Bundle object across a Binder interface to the System Server process, where it is safely stored away. When the system later decides to recreate the Activity, it sends this same Bundle object back to the application, for it to use to restore the Activity’s old state.</p><p>So why then is the exception thrown? Well, the problem stems from the fact that these Bundle objects represent a snapshot of an Activity at the moment onSaveInstanceState() was called, and nothing more. That means when you call FragmentTransaction#commit() after onSaveInstanceState() is called, the transaction won’t be remembered because it was never recorded as part of the Activity’s state in the first place. From the user’s point of view, the transaction will appear to be lost, resulting in accidental UI state loss. In order to protect the user experience, Android avoids state loss at all costs, and simply throws an IllegalStateException whenever it occurs.</p><p>参考<br><a href="http://www.androiddesignpatterns.com/2013/08/fragment-transaction-commit-state-loss.html（已翻译）" target="_blank" rel="noopener">http://www.androiddesignpatterns.com/2013/08/fragment-transaction-commit-state-loss.html（已翻译）</a></p><h3 id="Fragment重叠问题"><a href="#Fragment重叠问题" class="headerlink" title="Fragment重叠问题"></a>Fragment重叠问题</h3><blockquote><p>源码分析：</p><p>Step1:Fragment恢复保存机制</p></blockquote><p>我们知道Activity中有个onSaveInstanceState()方法，该方法在app进入后台、屏幕旋转前、跳转下一个Activity等情况下会被调用，此时系统帮我们保存一个Bundle类型的数据，我们可以根据自己的需求，手动保存一些例如播放进度等数据，而后如果发生了页面重启，我们可以在onRestoreInstanceState()或onCreate()里get该数据，从而恢复播放进度等状态。(关于onSaveInstance参见最后)</p><p>而产生Fragment重叠就是页面保存机制有关，大致原因是在页面重启前，帮我们保存了Fragment的状态，但是在重启恢复时，<code>视图的可见状态并没有帮我们保存</code>，而fragment默认状态是show状态，因此产生了页面重叠</p><pre><code>`public class FragmentActivity extends ... {final FragmentController mFragments = FragmentController.createController(new HostCallbacks());protected void onCreate(@Nullable Bundle savedInstanceState) {    ...省略    if (savedInstanceState != null) {        Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);        mFragments.restoreAllState(p, nc != null ? nc.fragments : null);    }}@Overrideprotected void onSaveInstanceState(Bundle outState) {    super.onSaveInstanceState(outState);    Parcelable p = mFragments.saveAllState();    ...省略}}`</code></pre><p>可以看出fragmentActvity确实做了fragment的状态的保存，从上面可以看出最终实现还是在mFragments进行restoreAllState、saveAllState()的处理，而mFragments是FragmentController，它是一个Controller，内部通过FragmentHostCallback间接控制FragmentManagerImpl，因此具体实现还是在FragmentManagerImpl中</p><pre><code>`final class FragmentManagerImpl extends FragmentManager {Parcelable saveAllState() {    ...省略 详细保存过程    FragmentManagerState fms = new FragmentManagerState();    fms.mActive = active;    fms.mAdded = added;    fms.mBackStack = backStack;    return fms;}void restoreAllState(Parcelable state, List&lt;Fragment&gt; nonConfig) {    // 恢复核心代码    FragmentManagerState fms = (FragmentManagerState)state;    FragmentState fs = fms.mActive[i];    if (fs != null) {        Fragment f = fs.instantiate(mHost, mParent);    ｝}}`</code></pre><p>从源码可以看出通过onSaveAllState可以看出保存状态其实是通过<code>FragmentManager#FragmentManagerState()</code>来保存了fragment的状态、回退栈、下标等，而在restoreAllState中通过<code>Fragment#FragmentState</code>的instantiate方法恢复了fragment的实例,继续看一下这两个类</p><pre><code>`final class FragmentManagerState implements Parcelable {FragmentState[] mActive;           // Fragment状态int[] mAdded;                      // 所处Fragment栈下标BackStackState[] mBackStack;       // 回退栈状态...}`</code></pre><p>我们只看Fragment#FragmentState，它也实现了Parcelable，保存了Fragment的类名、下标、id、Tag、ContainerId以及Arguments等数据：</p><pre><code>`final class FragmentState implements Parcelable {final String mClassName;final int mIndex;final boolean mFromLayout;final int mFragmentId;final int mContainerId;final String mTag;final boolean mRetainInstance;final boolean mDetached;final Bundle mArguments;...//  在FragmentManagerImpl的restoreAllState()里被调用public Fragment instantiate(FragmentHostCallback host, Fragment parent) {    ...省略    mInstance = Fragment.instantiate(context, mClassName, mArguments);}}`</code></pre><p>至此我们就清楚了，FragmentActvity通过FragmentState来保存Fragment实例</p><blockquote><p>Step2 发生重叠的根本原因？？？？？</p></blockquote><p>在Fragment#FragmentState中并没有保存Hidden字段，因此在以add方式加载Fragment的场景下，系统在恢复Fragment时，mHidden＝false，即show状态，这样在页面重启后，Activity内的Fragment都是以show状态显示的，而如果你不进行处理，那么就会发生Fragment重叠现象！</p><blockquote><p>Step3 为什么重复replace|add Fragment 或者 使用show , hide控制Fragment会导致重叠？</p></blockquote><ul><li>重复replace|add Fragment</li></ul><p>一般情况下，我们会在Activity的onCreate()里或者Fragment的onCreateView()里加载根Fragment，如果在这里没有进行页面重启的判断的话，就可能导致重复加载Fragment引起重叠，正确的写法应该是先判断 saveInstanceState是否为空</p><pre><code>`@Override protected void onCreate(@Nullable Bundle savedInstanceState) {  ...  // 判空， Fragment同理  if(saveInstanceState == null){        // 这里replace或add 根Fragment  }}`</code></pre><ul><li>使用show , hide控制Fragment</li></ul><p>我们使用show(),hide()时，都是使用add的方式加载Fragment的，add配合hide使Fragment的视图改变为GONE状态；而replace是销毁Fragment 的视图。<br>当页面重启时add的fragment会走全部生命周期，创建生命周期，而repleace的非栈顶的fragment不会走生命周期，只有back时候才会走生命周期，创建视图在使用replace加载Fragment时，页面重启后，Fragment视图都还没创建，所以mHidden没有意义，不会发生重叠现象；<br>而在使用add加载时，视图是存在的并且叠加在一起，页面重启后 mHidden=false，所有的Fragment都会是show状态显示出来（即VISIBLE），从而造成了Fragment重叠！</p><p><a href="http://www.jianshu.com/p/78ec81b42f92" target="_blank" rel="noopener">http://www.jianshu.com/p/78ec81b42f92</a></p><blockquote><p>step4 彻底解决</p></blockquote><p>1、加载根fragment时候需要进行判断</p><pre><code>`public class MainActivity ... {@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) {    ...    // 这里一定要在save为null时才加载Fragment，Fragment中onCreateView等生命周里加载根子Fragment同理    // 因为在页面重启时，Fragment会被保存恢复，而此时再加载Fragment会重复加载，导致重叠    if(saveInstanceState == null){          // 这里加载根Fragment    }}}`</code></pre><p>2、重写BaseFragment</p><pre><code>`public class BaseFragment extends Fragment {private static final String STATE_SAVE_IS_HIDDEN = &quot;STATE_SAVE_IS_HIDDEN&quot;;@Overridepublic void onCreate(@Nullable Bundle savedInstanceState) {...if (savedInstanceState != null) {    boolean isSupportHidden = savedInstanceState.getBoolean(STATE_SAVE_IS_HIDDEN);    FragmentTransaction ft = getFragmentManager().beginTransaction();    if (isSupportHidden) {        ft.hide(this);    } else {        ft.show(this);    }    ft.commit();}@Overridepublic void onSaveInstanceState(Bundle outState) {    ...    outState.putBoolean(STATE_SAVE_IS_HIDDEN, isHidden());}}`</code></pre><p>参考 <a href="http://www.jianshu.com/p/c12a98a36b2b" target="_blank" rel="noopener">http://www.jianshu.com/p/c12a98a36b2b</a></p><p>一般满足下面2个条件才可能会发生重叠：</p><p>1、发生了页面重启（旋转屏幕、内存不足等情况被强杀重启）。</p><p>2、重复replace｜add Fragment 或者 使用show , hide控制Fragment；</p><p>大致原因就是系统在页面重启前，帮我们保存了Fragment的状态，但是在重启后恢复时，<code>视图的可见状态没帮我们保存</code>，而Fragment默认的是show状态，所以产生了Fragment重叠现象。</p><blockquote><p>解决方式：</p></blockquote><p><a href="http://www.jianshu.com/p/c12a98a36b2b" target="_blank" rel="noopener">http://www.jianshu.com/p/c12a98a36b2b</a></p><p>要是使用fragmentpageAdapter</p><p>核心是FragmentState没帮我们保存Hidden状态，那就我们自己来保存，在页面重启后，我们自己来决定Fragment是否显示！<br>解决思路转变了，由Activity/父Fragment来管理子Fragment的Hidden状态转变为 由Fragment自己来管理自己的Hidden状态！</p><pre><code>`public class BaseFragment extends Fragment {private static final String STATE_SAVE_IS_HIDDEN = &quot;STATE_SAVE_IS_HIDDEN&quot;;@Overridepublic void onCreate(@Nullable Bundle savedInstanceState) {...if (savedInstanceState != null) {    boolean isSupportHidden = savedInstanceState.getBoolean(STATE_SAVE_IS_HIDDEN);    FragmentTransaction ft = getFragmentManager().beginTransaction();    if (isSupportHidden) {        ft.hide(this);    } else {        ft.show(this);    }    ft.commit();}@Overridepublic void onSaveInstanceState(Bundle outState) {    ...    outState.putBoolean(STATE_SAVE_IS_HIDDEN, isHidden());}}`</code></pre><p>其实是因为加载根Fragment时没有经过判断的原因，当在类似onCreate等初始化生命周期里加载根Fragment（即第一个Fragment）时，需要下面的判断，避免重复加载相同的Fragment：</p><pre><code>`public class MainActivity ... {@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) {    ...    // 这里一定要在save为null时才加载Fragment，Fragment中onCreateView等生命周里加载根子Fragment同理    // 因为在页面重启时，Fragment会被保存恢复，而此时再加载Fragment会重复加载，导致重叠    if(saveInstanceState == null){          // 这里加载根Fragment    }}}`</code></pre><p>解决方式二：</p><pre><code>` @Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    if (savedInstanceState != null) {        List&lt;Fragment&gt; fragments = getSupportFragmentManager().getFragments();        if (fragments != null &amp;&amp; fragments.size() &gt; 0) {            boolean showFlag = false;            FragmentTransaction ft = getSupportFragmentManager().beginTransaction();            for (int i = fragments.size() - 1; i &gt;= 0; i--) {                Fragment fragment = fragments.get(i);                if (fragment != null) {                    if (!showFlag) {                        ft.show(fragments.get(i));                        showFlag = true;                    } else {                        ft.hide(fragments.get(i));                    }                }            }            ft.commit();        }    }}`</code></pre><h3 id="恶心的Activity重建以及恢复其Fragment"><a href="#恶心的Activity重建以及恢复其Fragment" class="headerlink" title="恶心的Activity重建以及恢复其Fragment"></a>恶心的Activity重建以及恢复其Fragment</h3><p>一个思路就是阻止系统恢复Fragment，我们可以自己来加载，因为重建也会走到Activity的onCreate，所以我们有理由重走一遍初始化流程。怎么阻止呢，就是在FragmentActivity保存所有Fragment状态前把Fragment从FragmentManager中移除掉。<br>    <code>@Override    public void onSaveInstance(Bundle out) {    FragmentTransaction ft = getSupportFragmentManager().benginTransaction();    ft.remove(frag);    ft.commitAllowStateLoss();    super.onSaveInstance(out);    }</code><br><a href="http://toughcoder.net/blog/2015/04/30/android-fragment-the-bad-parts/" target="_blank" rel="noopener">http://toughcoder.net/blog/2015/04/30/android-fragment-the-bad-parts/</a></p><p>###FragmentPagerAdapter与FragmentStatePagerAdapter区别</p><p><a href="http://www.cnblogs.com/lianghui66/p/3607091.html(已做总结" target="_blank" rel="noopener">http://www.cnblogs.com/lianghui66/p/3607091.html(已做总结</a>)</p><p>##补充一下InstanceState详解：</p><p><a href="http://www.cnblogs.com/hanyonglu/archive/2012/03/28/2420515.html" target="_blank" rel="noopener">http://www.cnblogs.com/hanyonglu/archive/2012/03/28/2420515.html</a></p><p>##让多个Fragment 切换时不重新实例化</p><p>通常是用repleace方法完成，该方法实际是将remove和add方法合在一起</p><pre><code>`public void switchContent(Fragment fragment) {if(mContent != fragment) {    mContent = fragment;    mFragmentMan.beginTransaction()        .setCustomAnimations(android.R.anim.fade_in, R.anim.slide_out)        .replace(R.id.content_frame, fragment) // 替换Fragment，实现切换        .commit();}}`</code></pre><p>但是这样做有一个问题，每次切换的时候Fragment都会实例化，重新加载一遍数据，这样非常消耗性能和用户的数据流量，如何让多个Fragment彼此切换时不重新实例化？<br>其实replace方法只是在上一个Fragment不再需要时采用的简便方法，正确的切换方式是add(),切换时hide,add另外一个Fragment，再次切换时只需要hide当前，show另外一个，这样就可以做到多个Fragment切换时不重新实例化。</p><pre><code>`public void switchContent(Fragment from, Fragment to) {if (mContent != to) {    mContent = to;    FragmentTransaction transaction = mFragmentMan.beginTransaction().setCustomAnimations(            android.R.anim.fade_in, R.anim.slide_out);    if (!to.isAdded()) {    // 先判断是否被add过        transaction.hide(from).add(R.id.content_frame, to).commit(); // 隐藏当前的fragment，add下一个到Activity中    } else {        transaction.hide(from).show(to).commit(); // 隐藏当前的fragment，显示下一个    }}}`</code></pre><p>参考：<br><a href="https://yrom.net/blog/2013/03/10/fragment-switch-not-restart/" target="_blank" rel="noopener">https://yrom.net/blog/2013/03/10/fragment-switch-not-restart/</a></p><p>##关于Fragment的懒加载</p><p>情景：一个Actvity里面可能会以viewPager(或者其它容器)与多个Fragment来组合使用，而如果每个Fragment都需要去加载数据、或者从本地加载、网络加载，那么在这个activity刚创建的时候就需要初始化大量资源，那么如何做到当切换到这个fragment的时候才去初始化？</p><p>方法：<br>利用<code>setUserVisibleHint</code></p><pre><code>`public abstract class LazyFragment extends Fragment {protected boolean isVisible;/** * 在这里实现Fragment数据的缓加载. * @param isVisibleToUser */@Overridepublic void setUserVisibleHint(boolean isVisibleToUser) {    super.setUserVisibleHint(isVisibleToUser);    if(getUserVisibleHint()) {        isVisible = true;        onVisible();    } else {        isVisible = false;        onInvisible();    }}protected void onVisible(){    lazyLoad();}protected abstract void lazyLoad();protected void onInvisible(){}}`</code></pre><p>在这里主要增加了3个方法</p><ul><li>onVisible 即fragment被设置为不可见时调用</li><li>lazyLoad抽象方法，在onVisible中调用</li></ul><p>使用如下：<br>    <code>public class OpenResultFragment extends LazyFragment{        // 标志位，标志已经初始化完成。        private boolean isPrepared;        @Override        public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {            Log.d(LOG_TAG, &quot;onCreateView&quot;);            View view = inflater.inflate(R.layout.fragment_open_result, container, false);            //XXX初始化view的各控件        isPrepared = true;            lazyLoad();            return view;        }        @Override        protected void lazyLoad() {            if(!isPrepared || !isVisible) {                return;            }            //填充各控件的数据        }    }</code><br>参考：<br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1021/1813.html" target="_blank" rel="noopener">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1021/1813.html</a></p><h1 id="Useage"><a href="#Useage" class="headerlink" title="Useage"></a>Useage</h1><p>AtlasAssetDetailActivity#addFragment</p><pre><code>`public class AtlasAssetDetailActivity extends BaseActivity {public static final String ATLAS_ORDER = &quot;atlas_order&quot;;@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_atlas_asset_detail);    addFragment(AtlasAssetDetailFragment.newInstance(getIntent().getExtras()));}public void addFragment(Fragment fragment) {    FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();    Fragment oldFragment = getSupportFragmentManager().findFragmentById(R.id.container);    if (oldFragment != null) {        transaction.hide(oldFragment);        transaction.addToBackStack(null);        transaction.setCustomAnimations(android.R.anim.fade_in, android.R.anim.fade_out);    }    transaction.add(R.id.container, fragment);    transaction.commit();}public void popFragment() {    getSupportFragmentManager().popBackStack();}</code></pre><p>}`</p><p>AtlasAssetDetailFragment#中通过selectTab切换hodler达到这种目的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;fragment 必须始终嵌
      
    
    </summary>
    
      <category term="Android" scheme="https://xsfelvis.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://xsfelvis.github.io/tags/Android/"/>
    
      <category term="Fragment" scheme="https://xsfelvis.github.io/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>《Fragment Transactions &amp; Activity State Loss</title>
    <link href="https://xsfelvis.github.io/2016/10/01/%E3%80%90%E8%AF%91%E6%96%87-Fragment-Transactions-&amp;-Activity-State-Loss/"/>
    <id>https://xsfelvis.github.io/2016/10/01/【译文-Fragment-Transactions-&amp;-Activity-State-Loss/</id>
    <published>2016-09-30T16:00:00.000Z</published>
    <updated>2018-06-04T04:44:21.749Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="一个异常堆栈"><a href="#一个异常堆栈" class="headerlink" title="一个异常堆栈"></a>一个异常堆栈</h1><p>下面所示的异常堆栈追踪在Honeycomb最早版本就一直在出现在StackOverflow上，困扰着诸多开发者</p><pre><code>`java.lang.IllegalStateException: Can not perform this action after onSaveInstanceStateat android.support.v4.app.FragmentManagerImpl.checkStateLoss(FragmentManager.java:1341)at android.support.v4.app.FragmentManagerImpl.enqueueAction(FragmentManager.java:1352)at android.support.v4.app.BackStackRecord.commitInternal(BackStackRecord.java:595)at android.support.v4.app.BackStackRecord.commit(BackStackRecord.java:574)`</code></pre><p>这篇文章就是来解释这个异常发生的<code>原因</code>和异常抛出的<code>时机</code>，并且给出了一些有益的建议来避免这个异常的发生</p><h2 id="为什么会抛出这个异常？"><a href="#为什么会抛出这个异常？" class="headerlink" title="为什么会抛出这个异常？"></a>为什么会抛出这个异常？</h2><p>这个异常的抛出是由于你准备在actvity的状态已经被保存后来做一次<code>FragmentTransaction</code>的commit，这将会导致<code>Actvity state loss</code>的现象的出现。</p><p>在我们深入讨论这个现象之前，我们先来看一下在<code>onSaveInstanceState()</code>方法调用后发生了什么。正如我在上一篇博文中提到的<a href="http://www.androiddesignpatterns.com/2013/08/binders-death-recipients.html" title="Binders &amp; Death Recipients" target="_blank" rel="noopener">http://www.androiddesignpatterns.com/2013/08/binders-death-recipients.html</a>，在android runtime 期间 android应用自己几乎不能控制自己，android系统有权在任何时候释放内存，因此后台的actvity也会被毫无征兆的kill掉。为了确保这种无法估计的行为对用户是无感知的，framework给予每个activity在觉察自己可能（back键除外）会被销毁时调用<code>onSaveInstanceState()</code>来保存自己的状态，用户在前后台切换actvity时，保存的状态数据将会被恢复时，而不会觉察到这个activity是否已经是被系统kill的，在用户看来这是“无缝”切换的。<br>当framework调用<code>onSaveInstanceState()</code>，它传递一个Bundle对象给actvity来保存它的diaglog、fragments、view的信息<br>。当方法回调时，系统通过Binder接口传递这个Bundle对象到System Sever，在这里Bundle对象将被安全的存储。然后系统之后重建actvity时再将刚才的Bundle传递给应用，这时actvity得到之前保存的状态</p><p>铺垫只是解释完之后下面将详细解释为什么会抛出这个异常。这个问题源于这样一个事实，传递的<code>Bundle</code>对象代表着activity在调用<code>onSaveInstanceState()</code>这一时刻的肖像刻画，这就意味着，在<code>onSaveInstanceState()</code>之后调用<code>FragmentTransaction#commit()</code>这个transaction将不会被记录，因为它一开始就没有被记录在Activity的状态中。从用户看来，actvity切换恢复时这个transaction体现为丢失的，这将导致Activity的UI状态丢失。为了保护用户的体验，Android不惜一切代价避免状态丢失，出现时就抛出一个异常来提醒开发者。</p><h2 id="何时抛出这个异常"><a href="#何时抛出这个异常" class="headerlink" title="何时抛出这个异常"></a>何时抛出这个异常</h2><p>如果你之前遇到过这个异常，你可能会注意到，这个异常的抛出随着平台不同的而变得有点不一致。举例来说，你可能会发现老旧的机器抛出这个异常更少些，或者使用support library比官方的framework更容易出现这个异常。这些轻微的矛盾导致了一些诸如“support library 有bug，不可信”的论调，然而这通常都不是真的。</p><p>这些轻微矛盾的出现是源于在<code>Honeycomb</code>中Activity生命周期的变化，在<code>Honeycomb</code>之前，actvity在调用OnPause方法之后才能被killed的，这就意味着<code>onSaveInstanceState()</code>需要在在<code>OnPause</code>之前调用。而在<code>Honeycomb</code>版本时，actvity只有在onStop之后才能被killed，这也就意味着<code>onSaveInstanceState()</code>需要在在<code>OnStop</code>之前调用而不是以前版本中的<code>OnPause</code>之前调用</p><p><img src="http://i.imgur.com/obpq3Fv.png" alt=""></p><p>Activity生命周期的微小改变，将使得<code>support library</code>有时需要基于平台来改变它的一些行为，举例来说，在<code>Honeycomb</code>及其以上的设备中，每次在<code>onSaveInstanceState()</code>之后commit都会抛出这个异常，然而在<code>Honeycomb</code>之前的设备中异常就会出现少一些。android团队被迫做出让步：为了老版本的内在更好地兼容，老的设备不得不忍受在 onPause() and onStop()之间的状态丢失support library的行为在不同平台之间总结如下</p><p><img src="http://i.imgur.com/fPwTxit.png" alt=""></p><h1 id="如何避免这个异常"><a href="#如何避免这个异常" class="headerlink" title="如何避免这个异常"></a>如何避免这个异常</h1><p>当你明白到底真正发生了什么你就会发现activity避免状态丢失是多么简单。如果你在这篇博文中做到这一步，希望你能明白整个<br>support library是如何工作的，并且为什么避免状态丢失是如此重要。为了方便你在这篇博文寻找一个快速修复的方法，这里有一些建议需要牢牢记住，当你在应用中使用<code>FragmentTransactions</code>的时候</p><ul><li>在Actvity的生命周期中commit transactions需要小心谨慎</li></ul><p>大多数应用只会在在onCreate中第一次commit transaction，这当然不会遇到这种问题，然而当你的transaction企图在Activity生命周期其他方法，诸如onActivityResult(), onStart(), and onResume()中commit时，这时事情就变得棘手了。举例来说，你不该在 FragmentActivity#onResume()中commit transaction，这是由于有一些情况，这个方法有时候会在activity状态恢复前调用(参考<a href="developer.android.com/reference/android/support/v4/app/FragmentActivity.html#onResume(">developer.android.com/reference/android/support/v4/app/FragmentActivity.html#onResume()</a>))。因此如果你的应用需要在Activity生命周期onCreate()之外commit transaction，只在<code>FragmentActivity#onResumeFragments()</code> or<code>Activity#onPostResume()</code>方法中去commit，这两个方法能够保证Activty状态保存之后再调用，这样就避免了状态丢失(参考<a href="http://stackoverflow.com/questions/16265733/failure-delivering-result-onactivityforresult" target="_blank" rel="noopener">http://stackoverflow.com/questions/16265733/failure-delivering-result-onactivityforresult</a>)</p><ul><li>避免在异步中执行 commit transactions</li></ul><p>这包括了常用的一些方法，诸如：AsyncTask#onPostExecute() and LoaderManager.LoaderCallbacks#onLoadFinished()等。由于这些方法根本不知道在当前Activity哪一个生命周期的去调用了他们，因而在其中commit transaction就会出问题。比如</p><blockquote><p>An activity executes an AsyncTask.</p><p>The user presses the “Home” key, causing the activity’s onSaveInstanceState() and onStop() methods to be called.</p><p>The AsyncTask completes and onPostExecute() is called, unaware that the Activity has since been stopped.</p><p>A FragmentTransaction is committed inside the onPostExecute() method, causing an exception to be thrown.</p></blockquote><p>总而言之就是要在异步回调方法中避免去commit transaction来避免这个异常的发生。谷歌工程师看起来也是同意这种观念的。通过android gruop的这个文章(<a href="https://groups.google.com/d/msg/android-developers/dXZZjhRjkMk/QybqCW5ukDwJ" target="_blank" rel="noopener">https://groups.google.com/d/msg/android-developers/dXZZjhRjkMk/QybqCW5ukDwJ</a>) ，谷歌android team 认为通过异步commit transaction 带来的UI变化并不利于用户体验。如果你的应用不得不在异步中提交，你将不得不使用<code>commitAllowingStateLoss()</code>并且处理好状态可能丢失的发生的情形（<a href="http://stackoverflow.com/questions/7992496/how-to-handle-asynctask-onpostexecute-when-paused-to-avoid-illegalstateexception" target="_blank" rel="noopener">http://stackoverflow.com/questions/7992496/how-to-handle-asynctask-onpostexecute-when-paused-to-avoid-illegalstateexception</a>和<a href="http://stackoverflow.com/questions/8040280/how-to-handle-handler-messages-when-activity-fragment-is-paused" target="_blank" rel="noopener">http://stackoverflow.com/questions/8040280/how-to-handle-handler-messages-when-activity-fragment-is-paused</a>）</p><ul><li>将 commitAllowingStateLoss()作为最后使用的手段 </li></ul><p>commit和commitAllowingStateLoss唯一的区别就是后者在状态丢失时候不会抛出异常，通常不会使用这个方法，因为这将意味着状态的可能丢失。最好的方式就是写好你的应用，这样transaction确保在activity状态保存之后commit，这样用户体验会更好。除非状态丢失不可避免了，否则不要使用commitAllowingStateLoss()</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;一个异常堆栈&quot;&gt;&lt;a href=&quot;#一个异常堆栈&quot; class=&quot;headerlink&quot; title=&quot;一个异常堆栈&quot;&gt;&lt;/a&gt;一个异常堆栈&lt;/h1&gt;&lt;p&gt;下面所示
      
    
    </summary>
    
      <category term="Android" scheme="https://xsfelvis.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://xsfelvis.github.io/tags/Android/"/>
    
      <category term="Fragment" scheme="https://xsfelvis.github.io/tags/Fragment/"/>
    
  </entry>
  
</feed>
