<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>渡口一艘船</title>
  
  <subtitle>不积跬步，无以至千里；不积小流，无以成江海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xsfelvis.github.io/"/>
  <updated>2019-07-06T14:52:51.359Z</updated>
  <id>https://xsfelvis.github.io/</id>
  
  <author>
    <name>云来</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记拉美司机端首页出车动画的一次调优</title>
    <link href="https://xsfelvis.github.io/2019/07/06/%E5%8F%B8%E6%9C%BA%E7%AB%AF%E9%A6%96%E9%A1%B5%E5%87%BA%E8%BD%A6%E5%8A%A8%E7%94%BB%E8%B0%83%E4%BC%98/"/>
    <id>https://xsfelvis.github.io/2019/07/06/司机端首页出车动画调优/</id>
    <published>2019-07-05T16:00:00.000Z</published>
    <updated>2019-07-06T14:52:51.359Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="记首页出车动画的一次调优"><a href="#记首页出车动画的一次调优" class="headerlink" title="记首页出车动画的一次调优"></a>记首页出车动画的一次调优</h1><p><a name="AHRGJ"></a></p><h1 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h1><p>国际化司机端 机器参差不齐，拉美司机端 机型都是非常低端，特别是巴西，拉取omega数据统计 内存2G及以下，占比70%+，而澳洲司机端都是高端三星机器平均内存都是4G以上，因而我们必须得”压榨”我们的代码，吝啬的分配cpu以及内存。</p><p><a name="peH6Q"></a></p><h1 id="2、发现问题"><a href="#2、发现问题" class="headerlink" title="2、发现问题"></a>2、发现问题</h1><p> <br>介入卡顿优化之后，发现有个Top3的ANR以及一些相关卡顿</p><table><thead><tr><th style="text-align:left">【ANR】at com.sdu.didi.component.controlpanel.ControlPanelView$15.onAnimationUpdate(ControlPanelView.java:154)</th></tr></thead><tbody><tr><td style="text-align:left"></td></tr></tbody></table><p> <br>在拉美一些配置一般的机型上容易出现，大多是内存只有1G和2G的机型,根据omenga信息可以定位到ANR是由于首页出车动画在波纹属性动画刷新的时候会卡顿，卡顿严重了就ANR了，而且首页出车动画基本是一直在跑着的，确实影响用户体验</p><p><a name="WetJc"></a></p><h1 id="3、分析问题"><a href="#3、分析问题" class="headerlink" title="3、分析问题"></a>3、分析问题</h1><p><a name="5L7YM"></a></p><h3 id="分析代码"><a href="#分析代码" class="headerlink" title="分析代码"></a>分析代码</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1557567776245-c75cd9ca-2c07-44e5-82be-a5d017002363.png#align=left&amp;display=inline&amp;height=620&amp;name=image.png&amp;originHeight=1990&amp;originWidth=1110&amp;size=2521781&amp;status=done&amp;width=346" alt="image.png"><br> <br>看了下代码</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1557567788487-342f7f68-9aa2-4bfb-9424-a74c2a7a2f22.png#align=left&amp;display=inline&amp;height=241&amp;name=image.png&amp;originHeight=289&amp;originWidth=894&amp;size=94748&amp;status=done&amp;width=746" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1562422446957-50c23054-2271-45a8-8e4b-616f6fd69dba.png#align=left&amp;display=inline&amp;height=176&amp;name=image.png&amp;originHeight=179&amp;originWidth=169&amp;size=16921&amp;status=done&amp;width=166" alt="image.png"></p><p>嗯，不卡才怪呢，之前的同学为了实现这个无限循环的波纹动效，<strong>通过自定义一个圆点view，然后通过属性动画改变这个圆点的宽高、透明度，然后在动画变化时requestLayout</strong>，这个效果是实现了，但是性能是极差的，属性动画这些操作都是主线程去执行的 在高端机型是可能性能hold住但是拉美的手机上有的直接就扛不住了，看来需要压榨一下我们的代码了。</p><p><a name="4L8FY"></a></p><h1 id="4、解决问题"><a href="#4、解决问题" class="headerlink" title="4、解决问题"></a>4、解决问题</h1><p><a name="2TTaV"></a></p><h2 id="SurfaceView"><a href="#SurfaceView" class="headerlink" title="SurfaceView"></a>SurfaceView</h2><p>Android中 View是通过刷新来重绘视图，系统通过发出<code>VSYNC</code>信号来进行屏幕的重绘，刷新的时间间隔是<code>16ms</code>,如果我们可以在16ms以内将绘制工作完成，则没有任何问题，<strong>如果我们绘制过程逻辑很复杂，并且我们的界面更新还非常频繁，这时候就会造成界面的卡顿</strong>，影响用户体验，为此Android提供了<code>SurfaceView</code>来解决这一问题</p><p>SurfaceView 继承自View，是 Android 中一种比较特殊的视图（View），</p><ul><li>它跟普通View最大的区别是它有自己的Surface，在WMS中有对应的WindowState，在SurfaceFlinger中有Layer</li><li>一般的Activity包含的多个View会组成View hierachy的树形结构，<strong>只有最顶层的DecorView，也就是根结点视图，才是对WMS可见的</strong>。这个<strong>DecorView在WMS中有一个对应的WindowState</strong>。相应地，<strong>在SF中对应的Layer</strong>。</li><li>而<strong>SurfaceView自带一个Surface，这个Surface在WMS中有自己对应的WindowState</strong>，在SF中也会有自己的Layer。虽然在App端它仍在View hierachy中，但在Server端（WMS和SF）中，<strong>它与宿主窗口是分离的</strong>。这样的好处是对这个Surface的渲染可以放到单独线程去做，渲染时可以有自己的GL context。这对于一些游戏、视频等性能相关的应用非常有益，因为它不会影响主线程对事件的响应。</li></ul><p>综合这些特点，SurfaceView 一般用在游戏、视频、摄影等一些复杂 UI 且高效的图像的显示，这类的图像处理都需要开单独的线程来处理。它的优点如下</p><ul><li>SurfaceView 通过子线程中进行画面更新，View 则在主线程中进行画面更新。</li><li>SurfaceView 用于被动更新，如频繁画面更新，View 则用于主动更新，如触摸点击等事件响应等。</li><li>SurfaceView 在底层实现了双缓冲机制，效率大大提升了，View 则没有。</li></ul><p>下面清晰说明了SurfaceView的原理</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1562422851868-fbe4d81d-00ee-4af3-9f14-d7f31c97f4e1.png#align=left&amp;display=inline&amp;height=405&amp;name=image.png&amp;originHeight=498&amp;originWidth=829&amp;size=28427&amp;status=done&amp;width=675" alt="image.png"></p><p>如果当前画面需要不停绘制或者数据处理量较大时，为避免 UI 线程堵塞，就用 SurfaceView 代替 View。<br>SurfaceView拥有独立的绘图表面，即它不与其宿主窗口共享同一个绘图表面，由于拥有独立的绘图表面，因此SurfaceView的UI就可以在一个独立的线程中进行行绘制，由于不占用主线程资源,使得它可以实现大多复杂而高效的界面绘制，如视频播放 <strong>VideoView</strong> 和OpenGl es的 <strong>GLSurfaceView</strong><br><strong>直播软件的 不停地点赞动效、天气软件的全屏雨雪动效、游戏中的流水、云之类的变化等等</strong></p><p>使用SurfaceView一顿操作之后 <br>使用 HandlerThread + SurfaceView一顿操作后 我们使用一台小米2s(内存2G)来看下效果，<br><br><br></p><p><a name="xcJX9"></a></p><h1 id="5、效果"><a href="#5、效果" class="headerlink" title="5、效果"></a>5、效果</h1><p><strong>前置条件： 小米2s 内存2G、只运行2个软件（司机端、模拟定位软件）、打开app后置于首页出车页面无其他操作</strong><br>**<br><a name="CtNKr"></a></p><h2 id="优化前首页cpu消耗"><a href="#优化前首页cpu消耗" class="headerlink" title="优化前首页cpu消耗"></a>优化前首页cpu消耗</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1557543949230-c0dc0486-c6c5-4d76-80da-9992ea02c83d.png#align=left&amp;display=inline&amp;height=351&amp;originHeight=351&amp;originWidth=1682&amp;status=done&amp;width=1682" alt=""> <br>可以看出 基本在30%左右，一会儿手机就开始发烫了<br><br><a name="Gydvl"></a></p><h2 id="使用surfaceview优化后cpu消耗"><a href="#使用surfaceview优化后cpu消耗" class="headerlink" title="使用surfaceview优化后cpu消耗"></a>使用surfaceview优化后cpu消耗</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1557566168403-92c9f6da-8976-4c25-9ee4-15ae93c71f44.png#align=left&amp;display=inline&amp;height=381&amp;originHeight=381&amp;originWidth=1674&amp;status=done&amp;width=1674" alt=""><br> <br>可以看出从cpu消耗从 <strong> 30%直降到 10%不到</strong>! 达到预期效果</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1562423420946-3ba0e117-0095-43fe-b809-70fd8c6aca1d.png#align=left&amp;display=inline&amp;height=183&amp;name=image.png&amp;originHeight=188&amp;originWidth=184&amp;size=23203&amp;status=done&amp;width=179" alt="image.png"></p><p><a name="vfBbm"></a></p><h1 id="4、一些思考"><a href="#4、一些思考" class="headerlink" title="4、一些思考"></a>4、一些思考</h1><p>1、在做业务的同时得保持技术的思考，不光可以反哺业务，而且不会迷失在业务的汪洋大海中<br>2、需要”折腾”，以改过为能，不以无过为贵，改的越多犯错概率确实会高，但是我们不是有阿波罗开关嘛<br>3、做国际化司机端coding得多一点点性能的考虑，国内的Android手机其实很好了，有时候并不会在意一些性能开销，这跟国际化业务是有点区别的<br>4、能落实到业务中的技术才是好技术，不然可能会成为”屠龙术”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;记首页出车动画的一次调优&quot;&gt;&lt;a href=&quot;#记首页出车动画的一次调优&quot; class=&quot;headerlink&quot; title=&quot;记首页出车动画的一次调优&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="业务" scheme="https://xsfelvis.github.io/categories/%E4%B8%9A%E5%8A%A1/"/>
    
    
      <category term="业务" scheme="https://xsfelvis.github.io/tags/%E4%B8%9A%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Gradle插件之Transform</title>
    <link href="https://xsfelvis.github.io/2019/05/02/gradle%E6%8F%92%E4%BB%B6%E4%B9%8BTransform/"/>
    <id>https://xsfelvis.github.io/2019/05/02/gradle插件之Transform/</id>
    <published>2019-05-01T16:00:00.000Z</published>
    <updated>2019-05-02T15:15:46.294Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Gradle插件之Tranform"><a href="#Gradle插件之Tranform" class="headerlink" title="Gradle插件之Tranform"></a>Gradle插件之Tranform</h1><p><a name="Transform"></a></p><h1 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h1><p>修改一个class 得知道我们什么时候编译完成，并且要在class文件被转化成dex文件之前去修改，从1.5.0-beta1开始，android的gradle插件引入了com.android.build.api.transform.Transform，可以点击 <a href="http://tools.android.com/tech-docs/new-build-system/transform-api" target="_blank" rel="noopener">transform-api </a>查看相关内容。</p><p><a name="7efcb0ce"></a></p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ul><li>我们需要对编译class文件做自定义的处理。</li><li>读取编译产生的class文件，做一些其他事情，</li></ul><p><a name="7f77168f"></a></p><h1 id="Transform原理"><a href="#Transform原理" class="headerlink" title="Transform原理"></a>Transform原理</h1><p><a name="4a9fe82c"></a></p><h2 id="Tranform原理介绍"><a href="#Tranform原理介绍" class="headerlink" title="Tranform原理介绍"></a>Tranform原理介绍</h2><ul><li>从 Android Gradle 1.5.0-beta1 开始，引入了 <code>com.android.build.api.transform.Transform</code>，其实 <code>Transform</code> 也是一个 task，<strong>每新建一个 <code>Transform</code>，都有一个新的 <code>task</code> 和它对应</strong>。</li></ul><p>在1.5以下，preDex这个task会将依赖的module 编译后的class打成jar，然后Dex这个tasj则会将所有的class打包成dex<br>1.5以上，preDex和Dex这两个task已经消失，取而代之的是 TransfromClassesWithDexForDebug</p><ul><li>在 .java 文件 —-&gt; .class 文件 —-&gt; .dex 文件的过程中，是通过一个一个的 task 执行完成其中的每一个步骤的。<code>Trasnform</code> 注册之后，其执行的时机是在项目被打包成 dex 文件之前，正是操纵字节码的时机，多个 <code>Transform</code> 之间是串行执行的，执行流程如下图所示：</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1555769721615-be6bac1c-aeff-47a3-9d0c-bf6db7fd8775.png#align=left&amp;display=inline&amp;height=104&amp;name=image.png&amp;originHeight=156&amp;originWidth=1124&amp;size=16432&amp;status=done&amp;width=746" alt="image.png"></p><p>每一个Tranform 都有一个输入一个输出，上一个Transform的输出是下一个transform的输入</p><p><strong>Tips:输出地址不是由你任意指定的。而是根据输入的内容、作用范围等由<code>TransformOutputProvider</code>生成</strong>，比如，你要获取输出路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String dest = outputProvider.getContentLocation(directoryInput.name,</span><br><span class="line">              directoryInput.contentTypes, directoryInput.scopes, Format.DIRECTORY)</span><br></pre></td></tr></table></figure><p><a name="e1ae164d"></a></p><h2 id="Tranform原理之数据流动："><a href="#Tranform原理之数据流动：" class="headerlink" title="Tranform原理之数据流动："></a>Tranform原理之数据流动：</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1555848259413-5ed9a54b-2990-4465-a686-608d10df0bc6.png#align=left&amp;display=inline&amp;height=487&amp;name=image.png&amp;originHeight=1090&amp;originWidth=900&amp;size=187409&amp;status=done&amp;width=402" alt="image.png"><br><br><br>每个Tranform其实都是一个gradle task，Android编译器中的TaskManager将每个Tranform串联起来，第一个tranform接收来自javac编译的结果，以及已经拉取到本地的第三方依赖(jar、aar)，还有resource 资源(这里的resource指的是asset目录下的资源)这些编译的中间产物，在tranform组成的链条上流动，每个tranform节点可以对class进行处理再传递给下一个tranform，我们常见的混淆、Desugar等逻辑，都是封装在一个个tranform中，而我们定义的tranform会插入到这个tranform链条的自前面。<br><br><br>上图指的是<strong>消费型</strong> 即当前的tranform需要将消费类型输出给下一个tranform，另一种是<strong>引用型</strong>，当前tranform可以读取这些输入而不需要输出给下一个tranform类型，比如instant run 就是这种方式，检查两次编译间的diff<br>TaskManager#createPostCompilationTasks</p><p><a name="8308cf04"></a></p><h2 id="Tranfrom原理之数据过滤机制"><a href="#Tranfrom原理之数据过滤机制" class="headerlink" title="Tranfrom原理之数据过滤机制"></a>Tranfrom原理之数据过滤机制</h2><p><a name="ContenType"></a></p><h3 id="ContenType"><a href="#ContenType" class="headerlink" title="ContenType"></a>ContenType</h3><p>数据输入可以通过Scope和ContentType两个维度过滤<br><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1555849076995-f0db2b0e-4364-4855-9ba2-cf10f41ebf19.png#align=left&amp;display=inline&amp;height=364&amp;name=image.png&amp;originHeight=500&amp;originWidth=900&amp;size=27014&amp;status=done&amp;width=655" alt="image.png"><br><br><br>ContentType，顾名思义，就是数据类型，在插件开发中，我们一般只能使用CLASSES和RESOURCES两种类型，注意，其中的CLASSES已经包含了class文件和jar文件<br><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1555849200722-f3b34aa4-c62b-48c8-8b53-5d4df9346e75.png#align=left&amp;display=inline&amp;height=584&amp;name=image.png&amp;originHeight=977&amp;originWidth=900&amp;size=182619&amp;status=done&amp;width=538" alt="image.png"><br><br><br><br><br>从图中可以看到，除了CLASSES和RESOURCES，还有一些我们开发过程无法使用的类型，比如DEX文件，这些隐藏类型在一个独立的枚举类ExtendedContentType中，这些类型只能给Android编译器使用。另外，我们一般使用TransformManager中提供的几个常用的ContentType集合和Scope集合，如果是要处理所有class和jar的字节码，ContentType我们一般使用<strong>TransformManager.CONTENT_CLASS。</strong><br><a name="Scope"></a></p><h3 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1555849323746-c58b3668-9b0a-4299-9ece-2a898afbcc38.png#align=left&amp;display=inline&amp;height=491&amp;name=image.png&amp;originHeight=923&amp;originWidth=900&amp;size=184623&amp;status=done&amp;width=479" alt="image.png"><br><br><br>TransformManager有几个常用的Scope集合方便开发者使用。<br>如果是要处理所有class字节码，Scope我们一般使用<strong>TransformManager.SCOPE_FULL_PROJECT</strong>。<br></p><p>集成Tranform类实现以下几个方法</p><ul><li>String getName()</li></ul><p>该方法表示当前Transform在task列表中的名字，返回值最终经过一系列的拼接，具体拼接实现在TransformManager的getTaskNamePrefix()方法中，拼接格式：transform${InputType1}And${InputType2}And${InputTypeN}And${name}For${flavor}${BuildType}<br> </p><ul><li>Set<qualifiedcontent.contenttype> getInputTypes()</qualifiedcontent.contenttype></li></ul><p>指定输入类型，可以指定要处理文件的类型</p><ul><li>Set<qualifiedcontent.scope> getScopes()</qualifiedcontent.scope></li></ul><p>指定Transform的作用范围</p><ul><li>boolean isIncremental()</li></ul><p>该方法表示当前Transform是否支持增量编译</p><ul><li><p>void transform(Context context, Collection<transforminput> inputs,</transforminput></p><pre><code>Collection&lt;TransformInput&gt; referencedInputs,&lt;br /&gt;                  TransformOutputProvider outputProvider, boolean isIncremental)</code></pre></li></ul><p>其中    <em>// Transform的inputs有两种类型，一种是目录，一种是jar包，要分开遍历</em><br>_<br>在app-&gt;build-&gt;intermediates-&gt;transforms中，可以看到所有的Transform，包括我们刚才自定义的Transform。<br><a name="69d9bbc4"></a></p><h2 id="核心api"><a href="#核心api" class="headerlink" title="核心api"></a>核心api</h2><p><a name="46552165"></a></p><h3 id="如何获取class文件-TransformInvocation"><a href="#如何获取class文件-TransformInvocation" class="headerlink" title="如何获取class文件 TransformInvocation"></a>如何获取class文件 TransformInvocation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;</span><br><span class="line">        <span class="keyword">return</span> TransformManager.CONTENT_CLASS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;? <span class="keyword">super</span> QualifiedContent.Scope&gt; getScopes() &#123;</span><br><span class="line">        <span class="keyword">return</span> TransformManager.SCOPE_FULL_PROJECT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIncremental</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>配置 Transform 的输入类型为 Class， 作用域为全工程。 这样在 transform(TransformInvocation transformInvocation) 方法中， transformInvocation.inputs 会传入工程内所有的 class 文件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransformInvocation</span> </span>&#123;</span><br><span class="line"><span class="comment">// 返回transform运行的上下文，在android gradle plugin中有唯一的实现类TransformTask</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">Context <span class="title">getContext</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取transform的输入</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">Collection&lt;TransformInput&gt; <span class="title">getInputs</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the referenced-only inputs which are not consumed by this transformation.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the referenced-only inputs.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span> <span class="function">Collection&lt;TransformInput&gt; <span class="title">getReferencedInputs</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the list of secondary file changes since last. Only secondary files that this</span></span><br><span class="line"><span class="comment">     * transform can handle incrementally will be part of this change set.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the list of changes impacting a &#123;<span class="doctag">@link</span> SecondaryInput&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span> <span class="function">Collection&lt;SecondaryInput&gt; <span class="title">getSecondaryInputs</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//TransformOutputProvider用于删除输出目录或者创建文件对应的生成目录</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">TransformOutputProvider <span class="title">getOutputProvider</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// transform过程是否支持增量编译</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isIncremental</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出TransformInvovation包含了输入输出相关信息，<br><strong>其输出内容是由TransformOutProvider来做处理，TransformOutputProvider#getContentLocation()方法可以获取文件的输出目录</strong>，如果目录存在的话直接返回，如果不存在就会重新创建一个在执行编译过程中会生成对应的目录，<br>例如在<strong>/app/build/intermediates/transforms目录下生成了一个名为<code>ajx</code>的目录</strong>，这个名称就是根据自定义的Transform类<code>getName()</code>方法返回的字符串来的。</p><p>inputs 包含两个部分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransformInput</span> </span>&#123;</span><br><span class="line">    <span class="function">Collection&lt;JarInput&gt; <span class="title">getJarInputs</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Collection&lt;DirectoryInput&gt; <span class="title">getDirectoryInputs</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看接口方法可知，包含了 jar 包和目录。子 module 的 java 文件在编译过程中也会生成一个 jar 包然后编译到主工程中</p><p><a name="850ef8b8"></a></p><h3 id="Transform的输入输出"><a href="#Transform的输入输出" class="headerlink" title="Transform的输入输出"></a>Transform的输入输出</h3><p>可以通过<code>TransformInvocation</code>来获取输入,同时也获得了输出的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void transform(TransformInvocation invocation) &#123;</span><br><span class="line">        for (TransformInput input : invocation.getInputs()) &#123;</span><br><span class="line">            input.getJarInputs().parallelStream().forEach(jarInput -&gt; &#123;</span><br><span class="line">            File src = jarInput.getFile();</span><br><span class="line">            JarFile jarFile = new JarFile(file);</span><br><span class="line">            Enumeration&lt;JarEntry&gt; entries = jarFile.entries();</span><br><span class="line">            while (entries.hasMoreElements()) &#123;</span><br><span class="line">                JarEntry entry = entries.nextElement();</span><br><span class="line">                //处理</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们在做完自定义的处理后，如果想自己输出一些东西怎么办？ 比如一个class文件,就可以通过<code>TransformOutputProvider</code>来完成。比如下面这段代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File dest = invocation.getOutputProvider().getContentLocation(</span><br><span class="line">&quot;susion&quot;, </span><br><span class="line">TransformManager.CONTENT_CLASS, </span><br><span class="line">ImmutableSet.of(QualifiedContent.Scope.PROJECT), </span><br><span class="line">Format.DIRECTORY);</span><br></pre></td></tr></table></figure><p>这段代码就是在本工程(<code>ImmutableSet.of(QualifiedContent.Scope.PROJECT)</code>)下产生一个目录(<code>Format.DIRECTORY</code>), 目录的名字是(<code>susion</code>),里面的内容是<code>TransformManager.CONTENT_CLASS</code>。<br>创建这个文件夹后，我们就可以向其中写入一些内容，比如class文件。</p><p><a name="bbde7594"></a></p><h3 id="Transform-与-Gradle-Task-之间的关系？"><a href="#Transform-与-Gradle-Task-之间的关系？" class="headerlink" title="Transform 与 Gradle Task 之间的关系？"></a>Transform 与 Gradle Task 之间的关系？</h3><p>Gradle 包中有一个 TransformManager 的类，用来管理所有的 Transform。 在里面找到了这样的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T extends Transform&gt; Optional&lt;AndroidTask&lt;TransformTask&gt;&gt; addTransform(TaskFactory taskFactory, TransformVariantScope scope, T transform, ConfigActionCallback&lt;T&gt; callback) &#123;</span><br><span class="line">                ...</span><br><span class="line">                this.transforms.add(transform);</span><br><span class="line">                AndroidTask task1 = this.taskRegistry.create(taskFactory, new ConfigAction(scope.getFullVariantName(), taskName, transform, inputStreams, referencedStreams, outputStream, this.recorder, callback));</span><br><span class="line">                ...</span><br><span class="line">                return Optional.ofNullable(task1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>addTransform 方法在执行过程中，会将 Transform 包装成一个 AndroidTask 对象。<br>所以可以理解为<strong>一个 Transform 就是一个 Task</strong></p><p><a name="bdd31b98"></a></p><h3 id="如何得到文件的增量"><a href="#如何得到文件的增量" class="headerlink" title="如何得到文件的增量"></a>如何得到文件的增量</h3><p>再回到 TransformInput 这个接口，输入源分为 JarInput 和 DirectoryInput<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JarInput</span> <span class="keyword">extends</span> <span class="title">QualifiedContent</span> </span>&#123;</span><br><span class="line">    <span class="function">Status <span class="title">getStatus</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Status 是一个枚举：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Status &#123;</span><br><span class="line">    NOTCHANGED,</span><br><span class="line">    ADDED,</span><br><span class="line">    CHANGED,</span><br><span class="line">    REMOVED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以在输入源中， 获取了 JarInput 的对象时，可以同时得到每个 jar 的变更状态。需要注意的是：比如先 clean 再编译时， jar 的状态是 NOTCHANGED<br>再看看 DirectoryInput：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DirectoryInput</span> <span class="keyword">extends</span> <span class="title">QualifiedContent</span> </span>&#123;</span><br><span class="line">    <span class="function">Map&lt;File, Status&gt; <span class="title">getChangedFiles</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>changedFiles 是一个 Map，其中会包含所有变更后的文件，以及每个文件对应的状态。同样需要注意的是：先 clean 再编译时， changedFiles 是空的。<br>所以在处理增量时，只需要根据每个文件的状态进行相应的处理即可，不需要每次所有流程都重新来一遍。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomTransform</span> <span class="keyword">extends</span> <span class="title">Transform</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"CustomTransform"</span>;</span><br><span class="line">    <span class="keyword">public</span> CustomTransform() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"CustomTransform"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> transform(TransformInvocation transformInvocation) <span class="keyword">throws</span> TransformException, InterruptedException, IOException &#123;</span><br><span class="line">        <span class="keyword">super</span>.transform(transformInvocation);</span><br><span class="line">        <span class="comment">//当前是否是增量编译</span></span><br><span class="line">        <span class="keyword">boolean</span> isIncremental = transformInvocation.isIncremental();</span><br><span class="line">        <span class="comment">//消费型输入，可以从中获取jar包和class文件夹路径。需要输出给下一个任务</span></span><br><span class="line">        Collection&lt;TransformInput&gt; inputs = transformInvocation.getInputs();</span><br><span class="line">        <span class="comment">//引用型输入，无需输出。</span></span><br><span class="line">        Collection&lt;TransformInput&gt; referencedInputs = transformInvocation.getReferencedInputs();</span><br><span class="line">        <span class="comment">//OutputProvider管理输出路径，如果消费型输入为空，你会发现OutputProvider == null</span></span><br><span class="line">        TransformOutputProvider outputProvider = transformInvocation.getOutputProvider();</span><br><span class="line">        <span class="keyword">for</span>(TransformInput <span class="string">input :</span> inputs) &#123;</span><br><span class="line">            <span class="keyword">for</span>(JarInput <span class="string">jarInput :</span> input.getJarInputs()) &#123;</span><br><span class="line">                File dest = outputProvider.getContentLocation(</span><br><span class="line">                        jarInput.getFile().getAbsolutePath(),</span><br><span class="line">                        jarInput.getContentTypes(),</span><br><span class="line">                        jarInput.getScopes(),</span><br><span class="line">                        Format.JAR);</span><br><span class="line">                <span class="comment">//将修改过的字节码copy到dest，就可以实现编译期间干预字节码的目的了        </span></span><br><span class="line">                FileUtils.copyFile(jarInput.getFile(), dest);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(DirectoryInput <span class="string">directoryInput :</span> input.getDirectoryInputs()) &#123;</span><br><span class="line">                File dest = outputProvider.getContentLocation(directoryInput.getName(),</span><br><span class="line">                        directoryInput.getContentTypes(), directoryInput.getScopes(),</span><br><span class="line">                        Format.DIRECTORY);</span><br><span class="line">                <span class="comment">//将修改过的字节码copy到dest，就可以实现编译期间干预字节码的目的了        </span></span><br><span class="line">                FileUtils.copyDirectory(directoryInput.getFile(), dest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;</span><br><span class="line">        <span class="keyword">return</span> TransformManager.CONTENT_CLASS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123;</span><br><span class="line">        return TransformManager.SCOPE_FULL_PROJECT;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;QualifiedContent.ContentType&gt; getOutputTypes() &#123;</span><br><span class="line">        return super.getOutputTypes();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;? super QualifiedContent.Scope&gt; getReferencedScopes() &#123;</span><br><span class="line">        return TransformManager.EMPTY_SCOPES;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Map&lt;String, Object&gt; getParameterInputs() &#123;</span><br><span class="line">        return super.getParameterInputs();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean isCacheable() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override </span><br><span class="line">    public boolean isIncremental() &#123;</span><br><span class="line">        return true; //是否开启增量编译</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="05ff7704"></a></p><h3 id="关于是否支持增量-编译"><a href="#关于是否支持增量-编译" class="headerlink" title="关于是否支持增量 编译"></a>关于是否支持增量 编译</h3><p>Transform 的 <code>isIncremental()</code> 方法表示是否支持增量编译，返回true的话表示支持，</p><p>这个时候可以根据 <code>com.android.build.api.transform.TransformInput</code> 来获得更改、移除或者添加的文件目录或者jar包。</p><p>JarInput有一个方法是<code>getStatus()</code>来获取 <code>com.android.build.api.transform.Status</code>。Status是一个枚举类，包含了NOTCHANGED、ADDED、CHANGED、REMOVED，所以可以根据JarInput的status来对它进行相应的处理，比如添加或者移除。<br>DirectoryInput有一个方法<code>getChangedFiles()</code>开获取一个Map<file, status="">集合，所以可以遍历这个Map集合，然后根据File对应的Status来对File进行处理。<br><strong>如果不支持增量编译，就在处理.class之前把之前的输出目录中的文件删除。</strong></file,></p><p><a name="88eb9faf"></a></p><h2 id="Tranform的优化：增量与并发"><a href="#Tranform的优化：增量与并发" class="headerlink" title="Tranform的优化：增量与并发"></a>Tranform的优化：增量与并发</h2><p>果直接这样使用，会大大拖慢编译时间，为了解决这个问题，摸索了一段时间后，也借鉴了Android编译器中Desugar等几个Transform的实现，发现我们可以使用增量编译，并且上面transform方法遍历处理每个jar/class的流程，其实可以并发处理，加上一般编译流程都是在PC上，所以我们可以尽量敲诈机器的资源。<br>想要开启增量编译，我们需要重写Transform的这个接口，返回true。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> isIncremental() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然开启了增量编译，但也并非每次编译过程都是支持增量的，毕竟一次clean build完全没有增量的基础，所以，我们需要检查当前编译是否是增量编译。</p><p>1、如果不是增量编译，则清空output目录，然后按照前面的方式，逐个class/jar处理<br>2、如果是增量编译，则要检查每个文件的Status，Status分四种，并且对这四种文件的操作也不尽相同<br><em><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1555851854048-d84acc5a-90a3-47f4-b239-75ee4d05dd06.png#align=left&amp;display=inline&amp;height=407&amp;name=image.png&amp;originHeight=491&amp;originWidth=900&amp;size=37044&amp;status=done&amp;width=746" alt="image.png"></em></p><p>NOTCHANGED: 当前文件不需处理，甚至复制操作都不用；<br><br>ADDED、CHANGED: 正常处理，输出给下一个任务；<br><br>REMOVED: 移除outputProvider获取路径对应的文件。</p><p>代码如下所述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(TransformInvocation transformInvocation)</span></span>&#123;</span><br><span class="line">    Collection&lt;TransformInput&gt; inputs = transformInvocation.getInputs();</span><br><span class="line">    TransformOutputProvider outputProvider = transformInvocation.getOutputProvider();</span><br><span class="line">    <span class="keyword">boolean</span> isIncremental = transformInvocation.isIncremental();</span><br><span class="line">    <span class="comment">//如果非增量，则清空旧的输出内容</span></span><br><span class="line">    <span class="keyword">if</span>(!isIncremental) &#123;</span><br><span class="line">        outputProvider.deleteAll();</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">for</span>(TransformInput input : inputs) &#123;</span><br><span class="line">        <span class="keyword">for</span>(JarInput jarInput : input.getJarInputs()) &#123;</span><br><span class="line">            Status status = jarInput.getStatus();</span><br><span class="line">            File dest = outputProvider.getContentLocation(</span><br><span class="line">                    jarInput.getName(),</span><br><span class="line">                    jarInput.getContentTypes(),</span><br><span class="line">                    jarInput.getScopes(),</span><br><span class="line">                    Format.JAR);</span><br><span class="line">            <span class="keyword">if</span>(isIncremental &amp;&amp; !emptyRun) &#123;</span><br><span class="line">                <span class="keyword">switch</span>(status) &#123;</span><br><span class="line">                    <span class="keyword">case</span> NOTCHANGED:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> ADDED:</span><br><span class="line">                    <span class="keyword">case</span> CHANGED:</span><br><span class="line">                        transformJar(jarInput.getFile(), dest, status);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> REMOVED:</span><br><span class="line">                        <span class="keyword">if</span> (dest.exists()) &#123;</span><br><span class="line">                            FileUtils.forceDelete(dest);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                transformJar(jarInput.getFile(), dest, status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(DirectoryInput directoryInput : input.getDirectoryInputs()) &#123;</span><br><span class="line">            File dest = outputProvider.getContentLocation(directoryInput.getName(),</span><br><span class="line">                    directoryInput.getContentTypes(), directoryInput.getScopes(),</span><br><span class="line">                    Format.DIRECTORY);</span><br><span class="line">            FileUtils.forceMkdir(dest);</span><br><span class="line">            <span class="keyword">if</span>(isIncremental &amp;&amp; !emptyRun) &#123;</span><br><span class="line">                String srcDirPath = directoryInput.getFile().getAbsolutePath();</span><br><span class="line">                String destDirPath = dest.getAbsolutePath();</span><br><span class="line">                Map&lt;File, Status&gt; fileStatusMap = directoryInput.getChangedFiles();</span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;File, Status&gt; changedFile : fileStatusMap.entrySet()) &#123;</span><br><span class="line">                    Status status = changedFile.getValue();</span><br><span class="line">                    File inputFile = changedFile.getKey();</span><br><span class="line">                    String destFilePath = inputFile.getAbsolutePath().replace(srcDirPath, destDirPath);</span><br><span class="line">                    File destFile = <span class="keyword">new</span> File(destFilePath);</span><br><span class="line">                    <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">                        <span class="keyword">case</span> NOTCHANGED:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> REMOVED:</span><br><span class="line">                            <span class="keyword">if</span>(destFile.exists()) &#123;</span><br><span class="line">                                FileUtils.forceDelete(destFile);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> ADDED:</span><br><span class="line">                        <span class="keyword">case</span> CHANGED:</span><br><span class="line">                            FileUtils.touch(destFile);</span><br><span class="line">                            transformSingleFile(inputFile, destFile, srcDirPath);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                transformDir(directoryInput.getFile(), dest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><a name="7b4a9adb"></a></p><h2 id="注册tranfrom操作"><a href="#注册tranfrom操作" class="headerlink" title="注册tranfrom操作"></a>注册tranfrom操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">project.android.registerTransform(<span class="keyword">new</span> ToastTransform())</span><br></pre></td></tr></table></figure><p><a name="8032e5c2"></a></p><h1 id="操作字节码-Javassit"><a href="#操作字节码-Javassit" class="headerlink" title="操作字节码 Javassit"></a>操作字节码 Javassit</h1><p>要修改class字节码，我们要是自己手动改二进制文件，有点困难，好在有Javassist这个库，可以让我们直接修改编译后的class二进制代码。<br>要使用到Javassist，我们得在buildsrc模块下的build.gradle添加依赖包：<br>compile ‘org.javassist:javassist:3.20.0-GA’</p><ul><li>ClassPool 对象</li></ul><p>通过该对象可以获取已经编译好的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.get(<span class="string">"com.hc.MyClass"</span>);</span><br><span class="line">cc.setSuperclass(pool.get(<span class="string">"com.hc.ParentClass"</span>));</span><br><span class="line">cc.writeFile();</span><br></pre></td></tr></table></figure><p>面代码就实现了修改<code>MyClass</code>类的父类为<code>ParentClass</code>.</p><p><a name="d17a0f0b"></a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://cloud.tencent.com/developer/article/1378925" target="_blank" rel="noopener">一起玩转</a><a href="https://cloud.tencent.com/developer/article/1378925" target="_blank" rel="noopener">Android</a><a href="https://cloud.tencent.com/developer/article/1378925" target="_blank" rel="noopener">项目中的字节码（</a><a href="https://cloud.tencent.com/developer/article/1378925" target="_blank" rel="noopener">Transform</a><a href="https://cloud.tencent.com/developer/article/1378925" target="_blank" rel="noopener">篇)</a></li><li><a href="">通过自定义</a><a href="">Gradle</a><a href="">插件修改编译后的</a><a href="">class</a><a href="https://blog.csdn.net/huachao1001/article/details/51819972" target="_blank" rel="noopener">文件</a></li><li><a href="https://www.jianshu.com/p/031b62d02607" target="_blank" rel="noopener">Gradle Transform API </a><a href="https://www.jianshu.com/p/031b62d02607" target="_blank" rel="noopener">的基本使用</a></li><li><a href="http://lijiankun24.com/%E7%83%AD%E4%BF%AE%E5%A4%8D%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A1%86%E6%9E%B6%E9%9B%8F%E5%BD%A2%EF%BC%88%E4%B8%89%EF%BC%89/" target="_blank" rel="noopener">热修复之自定义热修复框架雏形（三）</a></li><li><a href="https://www.jianshu.com/p/dfc4681f8090" target="_blank" rel="noopener">Android AOP三剑客之Javassist</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Gradle插件之Tranform&quot;&gt;&lt;a href=&quot;#Gradle插件之Tranform&quot; class=&quot;headerlink&quot; title=&quot;Gradle插件
      
    
    </summary>
    
      <category term="Gradle插件" scheme="https://xsfelvis.github.io/categories/Gradle%E6%8F%92%E4%BB%B6/"/>
    
    
      <category term="Gradle插件" scheme="https://xsfelvis.github.io/tags/Gradle%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Gradle插件调试</title>
    <link href="https://xsfelvis.github.io/2019/05/02/gradle%E6%8F%92%E4%BB%B6%E8%B0%83%E8%AF%95/"/>
    <id>https://xsfelvis.github.io/2019/05/02/gradle插件调试/</id>
    <published>2019-05-01T16:00:00.000Z</published>
    <updated>2019-05-02T15:17:35.004Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Gradle插件调试"><a href="#Gradle插件调试" class="headerlink" title="Gradle插件调试"></a>Gradle插件调试</h1><ul><li>./gradlew :app:assemble -Dorg.gradle.debug=true  –no-daemon</li><li>执行后</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1556618887426-44860d79-bde5-439f-be19-aec5fce81756.png#align=left&amp;display=inline&amp;height=193&amp;name=image.png&amp;originHeight=234&amp;originWidth=399&amp;size=51997&amp;status=done&amp;width=329" alt="image.png"></p><ul><li><p>选择remote </p></li><li><p>执行task</p></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://fucknmb.com/2017/07/05/%E5%8F%88%E6%8E%8C%E6%8F%A1%E4%BA%86%E4%B8%80%E9%A1%B9%E6%96%B0%E6%8A%80%E8%83%BD-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95Gradle%E6%8F%92%E4%BB%B6/" target="_blank" rel="noopener">又掌握了一项新技能</a><a href="https://fucknmb.com/2017/07/05/%E5%8F%88%E6%8E%8C%E6%8F%A1%E4%BA%86%E4%B8%80%E9%A1%B9%E6%96%B0%E6%8A%80%E8%83%BD-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95Gradle%E6%8F%92%E4%BB%B6/" target="_blank" rel="noopener"> - </a><a href="https://fucknmb.com/2017/07/05/%E5%8F%88%E6%8E%8C%E6%8F%A1%E4%BA%86%E4%B8%80%E9%A1%B9%E6%96%B0%E6%8A%80%E8%83%BD-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95Gradle%E6%8F%92%E4%BB%B6/" target="_blank" rel="noopener">断点调试</a><a href="https://fucknmb.com/2017/07/05/%E5%8F%88%E6%8E%8C%E6%8F%A1%E4%BA%86%E4%B8%80%E9%A1%B9%E6%96%B0%E6%8A%80%E8%83%BD-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95Gradle%E6%8F%92%E4%BB%B6/" target="_blank" rel="noopener"> Gradle </a><a href="https://fucknmb.com/2017/07/05/%E5%8F%88%E6%8E%8C%E6%8F%A1%E4%BA%86%E4%B8%80%E9%A1%B9%E6%96%B0%E6%8A%80%E8%83%BD-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95Gradle%E6%8F%92%E4%BB%B6/" target="_blank" rel="noopener">插件</a></li><li><a href="https://www.jianshu.com/p/99c8e953654e" target="_blank" rel="noopener">如何调试</a><a href="https://www.jianshu.com/p/99c8e953654e" target="_blank" rel="noopener">Gradle Plugin</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Gradle插件调试&quot;&gt;&lt;a href=&quot;#Gradle插件调试&quot; class=&quot;headerlink&quot; title=&quot;Gradle插件调试&quot;&gt;&lt;/a&gt;Gradle
      
    
    </summary>
    
      <category term="Gradle插件" scheme="https://xsfelvis.github.io/categories/Gradle%E6%8F%92%E4%BB%B6/"/>
    
    
      <category term="Gradle插件" scheme="https://xsfelvis.github.io/tags/Gradle%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android中的AOP</title>
    <link href="https://xsfelvis.github.io/2019/05/02/Android%E4%B8%AD%E7%9A%84aop/"/>
    <id>https://xsfelvis.github.io/2019/05/02/Android中的aop/</id>
    <published>2019-05-01T16:00:00.000Z</published>
    <updated>2019-05-01T17:38:50.937Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h1><p>AOP(Aspect Oriented Program的首字母缩写)是一种面向切面编程的思想。这种编程思想是相对于OOP(ObjectOriented Programming即面向对象编程)来说的。</p><p>先来说一下大家熟悉的面向对象编程:面向对象的特点是<strong>继承、多态和封装</strong>。而封装就要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配。实际上也就是说，让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使类可重用。但是面向对象的编程天生有个<strong>缺点就是分散代码的同时，也增加了代码的重复性</strong>。<br>比如我希望在项目里面所有的模块都增加日志统计模块,按照OOP的思想,我们需要在各个模块里面都添加统计代码,但是如果按照AOP的思想,可以将统计的地方抽象成切面,只需要在切面里面添加统计代码就OK了。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1556721211921-33629bc8-7287-48b0-8b3a-a6360dd9b181.png#align=left&amp;display=inline&amp;height=303&amp;name=image.png&amp;originHeight=374&amp;originWidth=738&amp;size=112522&amp;status=done&amp;width=598" alt="image.png"><br>其实在服务端的领域AOP已经被玩的风生水起,例如Spring的框架。</p><p>代码demo链接 <a href="https://github.com/xsfelvis/android-aop" target="_blank" rel="noopener">https://github.com/xsfelvis/android-aop</a></p><p><a name="6H2nb"></a></p><h1 id="1、APT-JavaPoet"><a href="#1、APT-JavaPoet" class="headerlink" title="1、APT + JavaPoet"></a>1、APT + JavaPoet</h1><p>APT(Annotation Processing Tool 的简称)，可以在<strong>代码编译期解析注解</strong>，结合JavaPoet 生成新的 Java 文件，减少手动的代码输入。现在有很多主流库都用上了 APT，比如 Dagger2, ButterKnife, EventBus3 等<br>更多可以参考<a href="https://juejin.im/post/584d4aa00ce463005c5dbc36" target="_blank" rel="noopener">编译时注解之APT</a></p><p><a name="Oih8L"></a></p><h3 id="1、定义注解"><a href="#1、定义注解" class="headerlink" title="1、定义注解"></a>1、定义注解</h3><p>例如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BindView &#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a name="jJ6Ug"></a></p><h3 id="2、定义Processor派生自AbstractProcessor-并且使用-AutoService标注"><a href="#2、定义Processor派生自AbstractProcessor-并且使用-AutoService标注" class="headerlink" title="2、定义Processor派生自AbstractProcessor 并且使用@AutoService标注"></a>2、定义Processor派生自AbstractProcessor 并且使用@AutoService标注</h3><p>AutoService会自动在META-INF文件夹下生成Processor配置信息文件，该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，<br>就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入</p><p><a name="wfWNA"></a></p><h3 id="3、提取注解信息"><a href="#3、提取注解信息" class="headerlink" title="3、提取注解信息"></a>3、提取注解信息</h3><p>在Processor中提取注解信息 结合一些手段去处理，比如<a href="https://github.com/square/javapoet" target="_blank" rel="noopener">JavaPoet</a>，或者 <a href="https://juejin.im/post/584d4b5b0ce463005c5dc444" target="_blank" rel="noopener">JavaPoet使用指南</a></p><p><a name="KevoG"></a></p><h2 id="核心点"><a href="#核心点" class="headerlink" title="核心点"></a>核心点</h2><ul><li>处理Processor中的 注解信息的套路</li><li>javapoet中的代码生成 <a href="https://docs.oracle.com/javase/7/docs/api/javax/lang/model/element/Element.html" target="_blank" rel="noopener">Elements</a></li></ul><p><a name="GtN3R"></a></p><h1 id="2、AspectJ"><a href="#2、AspectJ" class="headerlink" title="2、AspectJ"></a>2、AspectJ</h1><p><a name="Srnp1"></a></p><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><ul><li>AspectJ 是使用最为广泛的 AOP 实现方案，适用于 Java 平台，官网地址：<a href="http://www.eclipse.org/aspectj/" target="_blank" rel="noopener">http://www.eclipse.org/aspectj/</a>  其中AspectJ 是在静态织入代码，<strong>即在编译期注入代码的</strong>。<br></li><li>AspectJ 提供了一套全新的语法实现，完全兼容 Java（跟 Java 之间的区别，只是多了一些关键词而已）。同时，还提供了纯 Java 语言的实现，通过注解的方式，完成代码编织的功能。因此我们在使用 AspectJ 的时候有以下<strong>两种方式</strong>：<ul><li>使用 AspectJ 的语言进行开发<br></li><li>通过 AspectJ 提供的注解在 Java 语言上开发<br></li></ul></li><li>因为最终的目的其实都是需要在字节码文件中织入我们自己定义的切面代码，不管使用哪种方式接入 AspectJ，都需要使用 AspectJ 提供的代码编译工具 ajc 进行编译。<br></li><li><p>在 Android Studio 上一般使用注解的方式使用 AspectJ，因为 Android Studio 没有 AspectJ 插件，无法识别 AspectJ 的语法（不过在 Intellij IDEA 收费版上可以使用 AspectJ 插件），所以后面的语法说明和示例都是以注解的实现方式<br><br><a name="ugwrc"></a></p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2></li><li><p>JoinPoints（连接点）</p></li></ul><p>JoinPoints（连接点），程序中可能作为代码注入目标的特定的点。在AspectJ中可以作为JoinPoints的地方包括<br><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1556723494645-9e547577-fc46-4bed-80a1-6fe3be57ec09.png#align=left&amp;display=inline&amp;height=659&amp;name=image.png&amp;originHeight=982&amp;originWidth=1000&amp;size=500067&amp;status=done&amp;width=671" alt="image.png"></p><ul><li>PointCuts(切入点)</li></ul><p>PointCuts(切入点)，其实就是代码注入的位置。与前面的JoinPoints不同的地方在于，其实PointCuts是有条件限定的JoinPoints。比如说，在一个Java源文件中，会有很多的JoinPoints，但是我们只希望对其中带有@debug注解的地方才注入代码。所以，PointCuts是通过语法标准给JoinPoints添加了筛选条件限定</p><ul><li>Advice(通知)</li></ul><p>Advice(通知)，其实就是注入到class文件中的代码片。典型的 Advice 类型有 <strong>before、after 和 around</strong>，分别表示在目标方法执行之前、执行后和完全替代目标方法执行的代码</p><ul><li>Aspect(切面)</li></ul><p>Aspect(切面)，Pointcut 和 Advice 的组合看做切面。</p><ul><li>Weaving</li></ul><p>注入代码（advices）到目标位置（joint points）的过程</p><p><a name="zJLFC"></a></p><h1 id="3、Javassit"><a href="#3、Javassit" class="headerlink" title="3、Javassit"></a>3、Javassit</h1><p><a name="UNJbJ"></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://www.javassist.org/" target="_blank" rel="noopener">Javassist</a>作用是在<strong>编译器间修改class文件</strong>，与之相似的ASM（热修复框架女娲）也有这个功能，可以让我们直接修改编译后的class二进制代码，</p><p>首先我们得知道什么时候编译完成，并且我们要赶在class文件被转化为dex文件之前去修改。在Transfrom这个api出来之前，想要在项目被打包成dex之前对class进行操作，必须自定义一个Task，然后插入到predex或者dex之前，在自定义的Task中可以使用javassist或者asm对class进行操作。而Transform则更为方便，Transfrom会有他自己的执行时机，不需要我们插入到某个Task前面。Tranfrom一经注册便会自动添加到Task执行序列中，并且正好是项目被打包成dex之前。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1556726166135-a920f880-a176-4245-b02c-712fd259f8b0.png#align=left&amp;display=inline&amp;height=698&amp;name=image.png&amp;originHeight=858&amp;originWidth=540&amp;size=205943&amp;status=done&amp;width=439" alt="image.png"></p><p><a name="zhk9i"></a></p><h2 id="常用方式"><a href="#常用方式" class="headerlink" title="常用方式"></a>常用方式</h2><p>需要配合自定义 GradlePlugin、TransForm,往往在TransForm期间使用Javassit 去完成一些需要的aop，关于自定义Gradle插件这里就不继续展开了</p><p>ClassPool、CtClass、CtMethod核心类的使用在这里展示的很详细。</p><blockquote><p>1、初始化ClassPool设置<br>2、通过包名取到对应的CtClass<br>3、CtMethodi插入代码块，写文件，释放，结束整个注入代码过程。</p></blockquote><p><a name="t0CzO"></a></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这几种AOP方式各自最大的特点就是编织代码的时机不同，这个需要在使用的时候根据实际需要来，</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1556732269388-878028df-cd00-483e-b56f-2a2361b34008.png#align=left&amp;display=inline&amp;height=490&amp;name=image.png&amp;originHeight=980&amp;originWidth=1252&amp;size=70185&amp;status=done&amp;width=626" alt="image.png"></p><p>通常aop可以用来处理以下问题</p><ul><li>日志、监控</li><li>登陆</li><li>修复第三方代码，比如第三方jar包</li><li>hook 某些代码为封装过的安全性更好的代码， 比如hook系统toast或者Gson等等</li><li>……</li></ul><p><a name="FJCqi"></a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://juejin.im/post/5a771b8b6fb9a0633c65e947#heading-9" target="_blank" rel="noopener">Android Annotation</a><a href="https://juejin.im/post/5a771b8b6fb9a0633c65e947#heading-9" target="_blank" rel="noopener">扫盲笔记</a></li><li><a href="https://www.jianshu.com/p/e66e8926c01d" target="_blank" rel="noopener">Android AOP</a><a href="https://www.jianshu.com/p/e66e8926c01d" target="_blank" rel="noopener">三剑客之</a><a href="https://www.jianshu.com/p/e66e8926c01d" target="_blank" rel="noopener">APT</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;什么是AOP&quot;&gt;&lt;a href=&quot;#什么是AOP&quot; class=&quot;headerlink&quot; title=&quot;什么是AOP&quot;&gt;&lt;/a&gt;什么是AOP&lt;/h1&gt;&lt;p&gt;AOP(
      
    
    </summary>
    
      <category term="AOP" scheme="https://xsfelvis.github.io/categories/AOP/"/>
    
    
      <category term="AOP" scheme="https://xsfelvis.github.io/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>Gradle插件从入门到进阶</title>
    <link href="https://xsfelvis.github.io/2019/05/02/Gradle%E6%8F%92%E4%BB%B6%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/"/>
    <id>https://xsfelvis.github.io/2019/05/02/Gradle插件从入门到进阶/</id>
    <published>2019-05-01T16:00:00.000Z</published>
    <updated>2019-05-02T15:14:17.388Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Gradle插件从入门到进阶"><a href="#Gradle插件从入门到进阶" class="headerlink" title="Gradle插件从入门到进阶"></a>Gradle插件从入门到进阶</h1><p><a name="scdur"></a></p><h1 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h1><p>Gradle本身的领域对象主要有Project和Task。Project为Task提供了执行上下文，所有的Plugin要么向Project中添加用于配置的Property，要么向Project中添加不同的Task。一个Task表示一个逻辑上较为独立的执行过程，比如编译Java源代码，拷贝文件，打包Jar文件，甚至可以是执行一个系统命令或者调用Ant。另外，一个Task可以读取和设置Project的Property以完成特定的操作。<br><a name="frNjm"></a></p><h2 id="Groovy-基础"><a href="#Groovy-基础" class="headerlink" title="Groovy 基础"></a>Groovy 基础</h2><ul><li><p><a href="https://gradle.org/" target="_blank" rel="noopener">官网</a></p></li><li><p><a href="https://blog.csdn.net/yanbober/article/details/49047515" target="_blank" rel="noopener">Groovy脚本基础全攻略</a></p></li><li><a href="https://blog.csdn.net/zhaoyanjun6/article/details/70313790" target="_blank" rel="noopener">groovy使用完全解析</a></li><li><p><a href="https://docs.gradle.org/current/dsl/index.html" target="_blank" rel="noopener">gradle dsl 基础</a><br><a name="8ce6e53d"></a></p><h2 id="Android-DSL-基础"><a href="#Android-DSL-基础" class="headerlink" title="Android DSL 基础"></a>Android DSL 基础</h2></li><li><p><a href="http://google.github.io/android-gradle-dsl/current/index.html" target="_blank" rel="noopener">ASL</a></p></li></ul><p>相关代码在 <a href="https://github.com/xsfelvis/GradlePluginStudy" target="_blank" rel="noopener">https://github.com/xsfelvis/GradlePluginStudy</a></p><p><a name="l5q5r"></a></p><h1 id="2、核心概念"><a href="#2、核心概念" class="headerlink" title="2、核心概念"></a>2、核心概念</h1><p><a name="Jbmkp"></a></p><h2 id="Project对象"><a href="#Project对象" class="headerlink" title="Project对象"></a><a href="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html" target="_blank" rel="noopener">Project</a>对象</h2><p>自定义插件类是通过实现Plugin 接口，并将 org.gradle.api.Project作为模板参数，其中org.gradle.api.Project的实例对象将作为参数传给<code>void apply(Project project)</code>函数，根据官网，可以看出Project是与Gradle交互的主接口，通过Project可以使用gradle的所有特性，并且 Project与build.grale是一对一的关系。简而言之，就是通过代码使用Gradle，通过Project这个入口即可</p><p>我们对project的理解更多来源于项目目录中的<code>build.gradle</code>文件（因为它其实就是project对象的委托，在脚本中的配置方法都对应着Project中的API，当构建进程启动后Gradle基于build.gradle中的配置实例化org.gradle.api.Project类，本质上可以认为是包含多个Task的容器，所有的Task都存放在TaskContainer中，<code>Project</code>对象的类图如下所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1556208386784-dec2456e-561a-42f6-a679-a8c47f089872.png#align=left&amp;display=inline&amp;height=1221&amp;name=image.png&amp;originHeight=1221&amp;originWidth=587&amp;size=231915&amp;status=done&amp;width=587" alt="image.png"><br><a name="RRwSQ"></a></p><h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><p>在build.gradle脚本文件中，我们不仅可以对单独project进行配置，也可以定义project块的共有逻辑等，参考下面的定义。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1556039101293-ed67fa06-d53e-436e-9e98-3b5a8d78d851.png#align=left&amp;display=inline&amp;height=326&amp;name=image.png&amp;originHeight=382&amp;originWidth=875&amp;size=106084&amp;status=done&amp;width=746" alt="image.png"></p><p>常见的例子<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为所有项目添加仓库源配置</span></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        google()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为所有子项目添加mavenPublish的配置块</span></span><br><span class="line">subprojects &#123;</span><br><span class="line">    mavenPublish &#123;</span><br><span class="line">        groupId = maven.config.groupId</span><br><span class="line">        releaseRepo = maven.config.releaseRepo</span><br><span class="line">        snapshotRepo = maven.config.snapshotRepo</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a name="eb9j4"></a></p><h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><p><a href="https://docs.gradle.org/current/javadoc/org/gradle/api/Task.html" target="_blank" rel="noopener">Gradle Task API</a></p><p>Gradle构建脚本默认的名字是build.gradle，当在shell中执行gradle命令时，Gradle会去当前目录下寻找名字是build.gradle的文件。在Gradle中一个原子性的操作叫做task，简单理解为task是Gradle脚本中的最小可执行单元。</p><p>下面是task的类图。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1556039163910-6ee5a942-7599-4a9c-a78a-ccf14e3d4783.png#align=left&amp;display=inline&amp;height=450&amp;name=image.png&amp;originHeight=450&amp;originWidth=702&amp;size=90267&amp;status=done&amp;width=702" alt="image.png"><br><a name="IlHJD"></a></p><h3 id="Task的Actions"><a href="#Task的Actions" class="headerlink" title="Task的Actions"></a>Task的Actions</h3><p>一个Task是由一序列Action组成的，当运行一个Task的时候，这个Task里的Action序列会按照顺序执行</p><p><a name="aeQtc"></a></p><h3 id="Task的几种常见写法"><a href="#Task的几种常见写法" class="headerlink" title="Task的几种常见写法"></a>Task的几种常见写法</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">task myTask1 &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">"doLast in task1"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task myTask2 &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">"doLast in task2"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//采用 Project.task(String name) 方法来创建</span></span><br><span class="line">project.task(<span class="string">"myTask3"</span>).doLast &#123;</span><br><span class="line">    println <span class="string">"doLast in task3"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//采用 TaskContainer.create(String name) 方法来创建</span></span><br><span class="line">project.tasks.create(<span class="string">"myTask4"</span>).doLast &#123;</span><br><span class="line">    println <span class="string">"doLast in task4"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">project.tasks.create(<span class="string">"myTask5"</span>) &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">"doLast in task5"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前task的动作（action）声明主要包含两个方法：</p><ul><li>doFirst  等价操作 缩写 leftShift &lt;&lt;（5.0会废弃）</li><li>doLast</li></ul><p>在 Gradle 中定义 Task 的时候，可以指定更多的参数，如下所示：</p><table><thead><tr><th>参数名</th><th>含义</th><th>默认值</th></tr></thead><tbody><tr><td>name</td><td>task的名字</td><td>必须指定，不能为空</td></tr><tr><td>type</td><td>task的父类</td><td>默认值为org.gradle.api.DefaultTask</td></tr><tr><td>overwrite</td><td>是否替换已经存在的同名task</td><td>false</td></tr><tr><td>group</td><td>task所属的分组名</td><td>null</td></tr><tr><td>description</td><td>task的描述</td><td>null</td></tr><tr><td>dependsOn</td><td>task依赖的task集合</td><td>无</td></tr><tr><td>constructorArgs</td><td>构造函数参数</td><td>无</td></tr></tbody></table><p><a name="pMxNC"></a></p><h3 id="Task的依赖"><a href="#Task的依赖" class="headerlink" title="Task的依赖"></a>Task的依赖</h3><p>gradle中任务的执行顺序是不确定的。通过task之间的依赖关系，gradle能够确保所依赖的task会被当前的task先执行。使用task的<code>dependsOn()</code>方法，允许我们为task声明一个或者多个task依赖。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">task first&#123;</span><br><span class="line">    doLast&#123;</span><br><span class="line">        println(<span class="string">"first"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task second&#123;</span><br><span class="line">    doLast&#123;</span><br><span class="line">        println(<span class="string">"second"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task third&#123;</span><br><span class="line">    doLast&#123;</span><br><span class="line">        println(<span class="string">"third"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task test(<span class="string">dependsOn:</span>[second,first])&#123;</span><br><span class="line">    doLast&#123;</span><br><span class="line">        println(<span class="string">"first"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">third.dependsOn(test)</span><br></pre></td></tr></table></figure><p>执行顺序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; Task :app:first </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; Task :app:second </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; Task :app:test1 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; Task :app:third</span><br></pre></td></tr></table></figure><p><a name="6m5Ir"></a></p><h3 id="Task的类型"><a href="#Task的类型" class="headerlink" title="Task的类型"></a>Task的类型</h3><p>有copy、jar、Delete 等等 可以参考Doc文档</p><p>task copyFile(type: Copy) {<br>   from ‘xml’<br>   into ‘destination’<br>}</p><p><a name="K5PMg"></a></p><h3 id="自定义Task"><a href="#自定义Task" class="headerlink" title="自定义Task"></a>自定义Task</h3><p> Gradle 中通过 task 关键字创建的 task，默认的父类都是 org.gradle.api.DefaultTask，这里定义了一些 task 的默认行为。看看下面这个例子：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义Task类，必须继承自DefaultTask</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SayHelloTask</span> <span class="keyword">extends</span> <span class="title">DefaultTask</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    String msg = <span class="string">"default name"</span></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">18</span>        </span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数必须用@javax.inject.Inject注解标识</span></span><br><span class="line">    <span class="meta">@javax</span>.inject.Inject</span><br><span class="line">    SayHelloTask(<span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过@TaskAction注解来标识该Task要执行的动作</span></span><br><span class="line">    <span class="meta">@TaskAction</span></span><br><span class="line">    <span class="keyword">void</span> sayHello() &#123;</span><br><span class="line">        println <span class="string">"Hello $msg ! age is $&#123;age&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过constructorArgs参数来指定构造函数的参数值</span></span><br><span class="line">task hello1(<span class="string">type:</span> SayHelloTask, <span class="string">constructorArgs:</span> [<span class="number">30</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过type参数指定task的父类，可以在配置代码里修改父类的属性</span></span><br><span class="line">task hello2(<span class="string">type:</span> SayHelloTask, <span class="string">constructorArgs:</span> [<span class="number">18</span>]) &#123;</span><br><span class="line">        <span class="comment">//配置代码里修改 SayHelloTask 里的字段 msg 的值</span></span><br><span class="line">    msg = <span class="string">"hjy"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <br>执行这两个task</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="string">Task :</span>hello1</span><br><span class="line">Hello <span class="keyword">default</span> name ! age is <span class="number">30</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="string">Task :</span>hello2</span><br><span class="line">Hello hjy ! age is <span class="number">18</span></span><br></pre></td></tr></table></figure><p><br><br><a name="vRDtb"></a></p><h3 id="Task的类图"><a href="#Task的类图" class="headerlink" title="Task的类图"></a>Task的类图</h3><p>Gradle所说的Task是org.gradle.api.Task接口，默认实现是org.gradle.api.DefaultTask类，其类图如下<br><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1556193021427-9d3cda16-11cd-4908-8f9c-aac56947ad6e.png#align=left&amp;display=inline&amp;height=806&amp;name=image.png&amp;originHeight=1081&amp;originWidth=1000&amp;size=214151&amp;status=done&amp;width=746" alt="image.png"></p><p><a name="eejch"></a></p><h3 id="TaskContainer接口解析"><a href="#TaskContainer接口解析" class="headerlink" title="TaskContainer接口解析"></a>TaskContainer接口解析</h3><p>TaskContianer 是用来管理所有的 Task 实例集合的，可以通过 Project.getTasks() 来获取 TaskContainer 实例。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">org.gradle.api.tasks.TaskContainer接口：</span><br><span class="line"><span class="comment">//查找task</span></span><br><span class="line">findByPath(<span class="string">path:</span> String): Task</span><br><span class="line">getByPath(<span class="string">path:</span> String): Task</span><br><span class="line">getByName(<span class="string">name:</span> String): Task</span><br><span class="line">withType(<span class="string">type:</span> Class): TaskCollection</span><br><span class="line">matching(<span class="string">condition:</span> Closure): TaskCollection</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建task</span></span><br><span class="line">create(<span class="string">name:</span> String): Task</span><br><span class="line">create(<span class="string">name:</span> String, <span class="string">configure:</span> Closure): Task </span><br><span class="line">create(<span class="string">name:</span> String, <span class="string">type:</span> Class): Task</span><br><span class="line">create(<span class="string">options:</span> Map&lt;String, ?&gt;): Task</span><br><span class="line">create(<span class="string">options:</span> Map&lt;String, ?&gt;, configure: Closure): Task</span><br><span class="line"></span><br><span class="line"><span class="comment">//当task被加入到TaskContainer时的监听</span></span><br><span class="line">whenTaskAdded(<span class="string">action:</span> Closure)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//当有task创建时</span></span><br><span class="line">getTasks().whenTaskAdded &#123; Task task -&gt;</span><br><span class="line">    println <span class="string">"The task $&#123;task.getName()&#125; is added to the TaskContainer"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//采用create(name: String)创建</span></span><br><span class="line">getTasks().create(<span class="string">"task1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//采用create(options: Map&lt;String, ?&gt;)创建</span></span><br><span class="line">getTasks().create([<span class="string">name:</span> <span class="string">"task2"</span>, <span class="string">group:</span> <span class="string">"MyGroup"</span>, <span class="string">description:</span> <span class="string">"这是task2描述"</span>, <span class="string">dependsOn:</span> [<span class="string">"task1"</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment">//采用create(options: Map&lt;String, ?&gt;, configure: Closure)创建</span></span><br><span class="line">getTasks().create(<span class="string">"task3"</span>, &#123;</span><br><span class="line">    group <span class="string">"MyGroup"</span></span><br><span class="line">    setDependsOn([<span class="string">"task1"</span>, <span class="string">"task2"</span>])</span><br><span class="line">    setDescription <span class="string">"这是task3描述"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>默认情况下，我们常见的task都是<code>org.gradle.api.DefaultTask</code>类型。但是在gradle当中有相当丰富的task类型我们可以直接使用。要更改task的类型，我们可以参考下面的示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task createDistribution(type:Zip)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更多关于task的类型，可以参考gradle的<a href="https://link.juejin.im?target=https%3A%2F%2Fdocs.gradle.org%2Fcurrent%2Fdsl%2Findex.html%23N10376" target="_blank" rel="noopener">官方文档</a></p><p><a href="https://www.jianshu.com/p/cd1a78dc8346" target="_blank" rel="noopener">https://www.jianshu.com/p/cd1a78dc8346</a><br><a href="https://www.ezlippi.com/blog/2015/07/gradle-tasks-guide.html" target="_blank" rel="noopener">https://www.ezlippi.com/blog/2015/07/gradle-tasks-guide.html</a><br><a href="https://blog.csdn.net/lzyzsd/article/details/46935405" target="_blank" rel="noopener">https://blog.csdn.net/lzyzsd/article/details/46935405</a></p><p><a name="vyLYu"></a></p><h3 id="Task的增量构建"><a href="#Task的增量构建" class="headerlink" title="Task的增量构建"></a>Task的增量构建</h3><p>Gradle 支持一种叫做 up-to-date 检查的功能，也就是常说的增量构建。Gradle 的 Task 会把每次运行的结果缓存下来，当下次运行时，会检查输出结果有没有变更，如果没有变更则跳过运行，这样可以提高 Gradle 的构建速度。<br>通常，一个 task 会有一些输入(inputs)和一些输出(outputs)，task 的输入会影响其输出结果，以官网中的一张图为例：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1556205376270-23df6fcc-2d91-45ba-af71-ce6a810df505.png#align=left&amp;display=inline&amp;height=371&amp;name=image.png&amp;originHeight=497&amp;originWidth=1000&amp;size=140744&amp;status=done&amp;width=746" alt="image.png"></p><p>图中表示一个java编译的task，它的输入有2种，一是JDK版本号，一是源文件，它的输出结果为class文件，只要JSK版本号与源文件有任何变动，最终编译出的class文件肯定不同的。当我们执行过一次·编译任务之后，再次运行该task，如果发现他的输入没有任何改动，那么它编译后的结果肯定也是不变的，可以直接从缓存里获取输出，这样Gradle会标识该task为UP-TO-DATE,从而跳过该task的执行<br><a name="FnBef"></a></p><h4 id="TaskInputs、TaskOutputs介绍"><a href="#TaskInputs、TaskOutputs介绍" class="headerlink" title="TaskInputs、TaskOutputs介绍"></a>TaskInputs、TaskOutputs介绍</h4><p>如何实现一个增量构建呢，至少指定一个输入，一个输出，Task.getInputs() 对象类型为 TaskInputs，Task.getOutputs() 对象类型为 TaskOuputs，从中也可以看到inputs、outputs都支持哪些数据类型</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">task test1 &#123;</span><br><span class="line">    <span class="comment">//设置inputs</span></span><br><span class="line">    inputs.property(<span class="string">"name"</span>, <span class="string">"hjy"</span>)</span><br><span class="line">    inputs.property(<span class="string">"age"</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="comment">//设置outputs</span></span><br><span class="line">    outputs.file(<span class="string">"$buildDir/test.txt"</span>)</span><br><span class="line"></span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">"exec task task1"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task test2 &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">"exec task task2"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一次的运行结果</span></span><br><span class="line">&gt; <span class="string">Task :</span>test1</span><br><span class="line">exec task task1</span><br><span class="line"></span><br><span class="line">&gt; <span class="string">Task :</span>test2</span><br><span class="line">exec task task2</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL <span class="keyword">in</span> <span class="number">0</span>s</span><br><span class="line"><span class="number">2</span> actionable <span class="string">tasks:</span> <span class="number">2</span> executed</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二次的运行结果</span></span><br><span class="line">&gt; <span class="string">Task :</span>test2</span><br><span class="line">exec task task2</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL <span class="keyword">in</span> <span class="number">0</span>s</span><br><span class="line"><span class="number">2</span> actionable <span class="string">tasks:</span> <span class="number">1</span> executed, <span class="number">1</span> up-to-date</span><br></pre></td></tr></table></figure><p>从结果中可以看到，第2次运行时，test1 task 并没有运行，而是被标记为 up-to-date，而 test2 task 则每次都会运行，这就是典型的增量构建。<br><a name="yvIpg"></a></p><p>#####<br><a name="eWUON"></a></p><h4 id="taskInputs、taskOutputs注解"><a href="#taskInputs、taskOutputs注解" class="headerlink" title="taskInputs、taskOutputs注解"></a>taskInputs、taskOutputs注解</h4><p>可以通过task注解来实现增量构建，这是一种更加灵活方便的方式</p><table><thead><tr><th>注解名</th><th>属性类型</th><th>描述</th></tr></thead><tbody><tr><td>@Input</td><td>任意Serializable类型</td><td>一个简单的输入值</td></tr><tr><td>@InputFile</td><td>File</td><td>一个输入文件，不是目录</td></tr><tr><td>@InputDirectory</td><td>File</td><td>一个输入目录，不是文件</td></tr><tr><td>@InputFiles</td><td>Iterable<file></file></td><td>File列表，包含文件和目录</td></tr><tr><td>@OutputFile</td><td>File</td><td>一个输出文件，不是目录</td></tr><tr><td>@OutputDirectory</td><td>File</td><td>一个输出目录，不是文件</td></tr><tr><td>@OutputFiles</td><td>Map<string, file="">或Iterable<file></file></string,></td><td>输出文件列表</td></tr><tr><td>@OutputDirectories</td><td>Map<string, file="">或Iterable<file></file></string,></td><td>输出目录列表</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SayHelloTask</span> <span class="keyword">extends</span> <span class="title">DefaultTask</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义输入</span></span><br><span class="line">    <span class="meta">@Input</span></span><br><span class="line">    String username;</span><br><span class="line">    <span class="meta">@Input</span></span><br><span class="line">    <span class="keyword">int</span> age</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义输出</span></span><br><span class="line">    <span class="meta">@OutputDirectory</span></span><br><span class="line">    File destDir;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TaskAction</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        println <span class="string">"Hello $username ! age is $age"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">test</span><span class="params">(type: SayHelloTask)</span> </span>&#123;</span><br><span class="line">    age = <span class="number">18</span></span><br><span class="line">    username = <span class="string">"hjy"</span></span><br><span class="line">    destDir = file(<span class="string">"$buildDir/test"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="BeBdj"></a></p><h2 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h2><p><a name="tJ22i"></a></p><h3 id="ext命名空间"><a href="#ext命名空间" class="headerlink" title="ext命名空间"></a>ext命名空间</h3><p>Gradle中很多模型类都提供了特别的属性支持，比如<code>Project</code>.在gradle内部，这些属性会以键值对的形式存储。使用ext命名空间，我们可以方便的添加属性。下面的方式都是支持的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//在project中添加一个名为groupId的属性</span><br><span class="line">project.ext.groupId=&quot;tech.easily&quot;</span><br><span class="line">// 使用ext块添加属性</span><br><span class="line">ext&#123;</span><br><span class="line">    artifactId=&apos;EasyDependency&apos;</span><br><span class="line">    config=[</span><br><span class="line">            key:&apos;value&apos;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>值得注意的是，只有在声明属性的时候我们需要使用<code>ext</code>命名空间，在使用属性的时候，<code>ext</code>命名空间是可以省略的。</p></blockquote><p><a name="7B2XT"></a></p><h3 id="属性文件"><a href="#属性文件" class="headerlink" title="属性文件"></a>属性文件</h3><p>正如我们经常在Android项目中看到的，我们可以在项目的根目录下新建一个<code>gradle.properties</code>文件，并在文件中定义简单的键值对形式的属性。这些属性能够被项目中的gradle脚本所访问。如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># gradle.properties</span><br><span class="line"># 注意文件的注释是以#开头的</span><br><span class="line">groupId=tech.easily</span><br><span class="line">artifactId=EasyDependency</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></p><p>有的时候，我们可能需要在代码中动态的创建属性文件并读取文件中的属性（比如自定义插件的时候），我们可以使用<code>java.util.Properties</code>类。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void createPropertyFile() &#123;</span><br><span class="line">    def localPropFile = new File(it.projectDir.absolutePath + &quot;/local.properties&quot;)</span><br><span class="line">    def defaultProps = new Properties()</span><br><span class="line">    if (!localPropFile.exists()) &#123;</span><br><span class="line">        localPropFile.createNewFile()</span><br><span class="line">        defaultProps.setProperty(&quot;debuggable&quot;, &apos;true&apos;)</span><br><span class="line">        defaultProps.setProperty(&quot;groupId&quot;, GROUP)</span><br><span class="line">        defaultProps.setProperty(&quot;artifactId&quot;, project.name)</span><br><span class="line">        defaultProps.setProperty(&quot;versionName&quot;, VERSION_NAME)</span><br><span class="line">        defaultProps.store(new FileWriter(localPropFile), &quot;properties auto generated for resolve dependencies&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        localPropFile.withInputStream &#123; stream -&gt;</span><br><span class="line">            defaultProps.load(stream)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>关于属性很重要的一点是属性是可以继承的。在一个项目中定义的属性会自动的被其子项目继承，不管我们是用以上哪种方式添加属性都是适用的。</strong></p></blockquote><p><a name="ksE1R"></a></p><h2 id="ExtensionContainer"><a href="#ExtensionContainer" class="headerlink" title="ExtensionContainer"></a>ExtensionContainer</h2><p><a name="gMdOo"></a></p><h3 id="Extension简介"><a href="#Extension简介" class="headerlink" title="Extension简介"></a>Extension简介</h3><p>就是 Gradle 的 Extension，翻译成中文意思就叫扩展。它的作用就是通过实现自定义的 Extension，可以在 Gradle 脚本中增加类似 android 这样命名空间的配置，Gradle 可以识别这种配置，并读取里面的配置内容。</p><p>一般我们通过ExtensionContainer来创建Extension，这个类跟TaskContainer命名有点类似。TaskContainer是用来创建并管理Task的，而ExtensionContainer则是用来创建并管理Extension的，通过Project的以下API可以获取到ExtensionContainer对象<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExtensionContainer getExtensions()</span><br></pre></td></tr></table></figure></p><p><a name="o5EOM"></a></p><h3 id="简单的Extension"><a href="#简单的Extension" class="headerlink" title="简单的Extension"></a>简单的Extension</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/先定义一个普通的java类，包含<span class="number">2</span>个属性</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age</span><br><span class="line">    String username</span><br><span class="line">    String toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name = $&#123;username&#125;, age = $&#123;age&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个名为 foo 的Extension</span></span><br><span class="line">getExtensions().create(<span class="string">"foo"</span>, Foo)</span><br><span class="line"><span class="comment">//配置Extension</span></span><br><span class="line">foo &#123;</span><br><span class="line">    age = <span class="number">30</span></span><br><span class="line">    username = <span class="string">"hjy"</span></span><br><span class="line">&#125;</span><br><span class="line">task testExt.doLast &#123;</span><br><span class="line">    <span class="comment">//能直接通过 project 获取到自定义的 Extension</span></span><br><span class="line">    println project.foo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>foo 就是我们自定义的 Extension 了，它里面能配置的属性与类 Foo 中的字段是一致的，在 build.gradle 中可以直接通过 project.foo 来访问。每个 Extension 实际上与某个类是相关联的，在 build.gradle 中通过 DSL 来定义，Gradle 会识别解析并生成一个对象实例，通过该类可以获取我们所配置的信息。<br> Project 有个扩展属性是通过 ext 命名空间配置的，可以看到 ext 与这里是类似的，不同的是 ext 可以配置任何键值对的属性值，而这里只能识别我们定义的 Java 类里的属性值。</p><p><a name="coFAz"></a></p><h3 id="ExtensionContainer主要api及用法"><a href="#ExtensionContainer主要api及用法" class="headerlink" title="ExtensionContainer主要api及用法"></a>ExtensionContainer主要api及用法</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; T create(String name, Class&lt;T&gt; type, Object... constructionArguments)</span><br><span class="line">&lt;T&gt; T create(Class&lt;T&gt; publicType, String name, Class&lt;? extends T&gt; instanceType, Object... constructionArguments)</span><br></pre></td></tr></table></figure><p>先来看看后面这个 API 所有参数的含义。</p><ul><li>publicType：创建的 Extension 实例暴露出来的类类型；</li><li>name：要创建的Extension的名字，可以是任意符合命名规则的字符串，不能与已有的重复，否则会抛异常；</li><li>instanceType：该Extension的类类型；</li><li>constructionArguments：类的构造函数参数值</li></ul><p>官方文档里还说明了一个特性，创建的 Extension 对象都默认实现了 ExtensionAware 接口，并注明出处。</p><p>示例</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    String username</span><br><span class="line">    <span class="keyword">int</span> legs</span><br><span class="line"></span><br><span class="line">    Animal(String name) &#123;</span><br><span class="line">        username = name</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> setLegs(<span class="keyword">int</span> c) &#123;</span><br><span class="line">        legs = c</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"This animal is $username, it has $&#123;legs&#125; legs."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span> <span class="keyword">extends</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> age</span><br><span class="line">    String owner</span><br><span class="line"></span><br><span class="line">    Pig(<span class="keyword">int</span> age, String owner) &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"Pig"</span>)</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">        <span class="keyword">this</span>.owner = owner</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">" Its age is $age, its owner is $owner."</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建的Extension是 暴露出来Animal 类型,创建extension名称是name,该extension的类型是Pig，后面2个是参数</span></span><br><span class="line">Animal aAnimal = getExtensions().create(Animal, <span class="string">"animal"</span>, Pig, <span class="number">3</span>, <span class="string">"hjy"</span>)</span><br><span class="line"><span class="comment">//创建的Extension是 Pig 类型</span></span><br><span class="line">Pig aPig = getExtensions().create(<span class="string">"pig"</span>, Pig, <span class="number">5</span>, <span class="string">"kobe"</span>)</span><br><span class="line"></span><br><span class="line">animal &#123;</span><br><span class="line">    legs = <span class="number">4</span>    <span class="comment">//配置属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pig &#123;</span><br><span class="line">    setLegs <span class="number">2</span>   <span class="comment">//这个是方法调用，也就是 setLegs(2)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task testExt &lt;&lt; &#123;</span><br><span class="line">    println aAnimal</span><br><span class="line">    println aPig</span><br><span class="line">    <span class="comment">//验证 aPig 对象是 ExtensionAware 类型的</span></span><br><span class="line">    println <span class="string">"aPig is a instance of ExtensionAware : $&#123;aPig instanceof ExtensionAware&#125;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="ZCEZN"></a></p><h3 id="增加Extension"><a href="#增加Extension" class="headerlink" title="增加Extension"></a>增加Extension</h3><ul><li>create() 方法会创建并返回一个 Extension 对象，</li><li>add() 方法，唯一的差别是它并不会返回一个 Extension 对象</li></ul><p>基于前面的这个实例，我们可以换一种写法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getExtensions().add(Pig, &quot;mypig&quot;, new Pig(5, &quot;kobe&quot;))</span><br><span class="line">mypig &#123;</span><br><span class="line">    username = &quot;MyPig&quot;</span><br><span class="line">    legs = 4</span><br><span class="line">    age = 1</span><br><span class="line">&#125;</span><br><span class="line">task testExt &lt;&lt; &#123;</span><br><span class="line">    def aPig = project.getExtensions().getByName(&quot;mypig&quot;)</span><br><span class="line">    println aPig</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a name="ZGXZe"></a></p><h3 id="查找Extension"><a href="#查找Extension" class="headerlink" title="查找Extension"></a>查找Extension</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object findByName(String name)</span><br><span class="line">&lt;T&gt; T findByType(Class&lt;T&gt; type)</span><br><span class="line">Object getByName(String name)       //找不到会抛异常</span><br><span class="line">&lt;T&gt; T getByType(Class&lt;T&gt; type)  //找不到会抛异常</span><br></pre></td></tr></table></figure><p><a name="y6SZf"></a></p><h3 id="嵌套Extension-方式一"><a href="#嵌套Extension-方式一" class="headerlink" title="嵌套Extension 方式一"></a>嵌套Extension 方式一</h3><p>类似下面这样的配置应该随处可见：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">outer &#123;</span><br><span class="line">    </span><br><span class="line">    outerName &quot;outer&quot;</span><br><span class="line">    msg &quot;this is a outer message.&quot;</span><br><span class="line">    inner &#123;</span><br><span class="line">        innerName &quot;inner&quot;</span><br><span class="line">        msg &quot;This is a inner message.&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以通过下面的方式来创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterExt</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    String outerName</span><br><span class="line">    String msg</span><br><span class="line">    InnerExt innerExt = <span class="keyword">new</span> InnerExt()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">outerName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        outerName = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">msg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建内部Extension，名称为方法名 inner</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inner</span><span class="params">(Action&lt;InnerExt&gt; action)</span> </span>&#123;</span><br><span class="line">        action.execute(inner)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建内部Extension，名称为方法名 inner</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inner</span><span class="params">(Closure c)</span> </span>&#123;</span><br><span class="line">        org.gradle.util.ConfigureUtil.configure(c, innerExt) </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OuterExt[ name = $&#123;outerName&#125;, msg = $&#123;msg&#125;] "</span> + innerExt</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerExt</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    String innerName</span><br><span class="line">    String msg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">innerName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        innerName = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">msg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"InnerExt[ name = $&#123;innerName&#125;, msg = $&#123;msg&#125;]"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def outExt = getExtensions().create(<span class="string">"outer"</span>, OuterExt)</span><br><span class="line"></span><br><span class="line">outer &#123;</span><br><span class="line">    </span><br><span class="line">    outerName <span class="string">"outer"</span></span><br><span class="line">    msg <span class="string">"this is a outer message."</span></span><br><span class="line"></span><br><span class="line">    inner &#123;</span><br><span class="line">        innerName <span class="string">"inner"</span></span><br><span class="line">        msg <span class="string">"This is a inner message."</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task testExt doLast &#123;</span><br><span class="line">    println outExt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键在以下下面的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void inner(Action&lt;InnerExt&gt; action)</span><br><span class="line">void inner(Closure c)</span><br></pre></td></tr></table></figure></p><p>定义在outer内部的inner,Gradle 解析时本质上会调用 outer.inner(……)方法，该方法的参数是一个闭包(Script Block) 所以在类OuterExt中必须定义inner方法</p><p><a name="AFMCp"></a></p><h3 id="嵌套Extension方式二-NamedDomainObjectContainer"><a href="#嵌套Extension方式二-NamedDomainObjectContainer" class="headerlink" title="嵌套Extension方式二(NamedDomainObjectContainer)"></a>嵌套Extension方式二(NamedDomainObjectContainer)</h3><p><a name="LOQa2"></a></p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>Gradle Extension 的时候，说到名为 android 的 Extension 是由 BaseExtension 这个类来实现的，里面对 buildTypes 是这样定义的：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> NamedDomainObjectContainer&lt;BuildType&gt; buildTypes;</span><br></pre></td></tr></table></figure></p><p>buildTypes 就是 NamedDomainObjectContainer 类型的，先来看看 buildTypes 在 Android 中是怎么使用的，下面这段代码应该都很熟悉了，它定义了 debug、relase 两种打包模式：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            <span class="comment">// 是否开启混淆</span></span><br><span class="line">            minifyEnabled <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 开启ZipAlign优化</span></span><br><span class="line">            zipAlignEnabled <span class="literal">true</span></span><br><span class="line">            <span class="comment">//去掉不用资源</span></span><br><span class="line">            shrinkResources <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 混淆文件位置</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">            <span class="comment">// 使用release签名</span></span><br><span class="line">            signingConfig signingConfigs.hmiou</span><br><span class="line">        &#125;</span><br><span class="line">        debug &#123;</span><br><span class="line">            signingConfig signingConfigs.hmiou</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当我们新建一个项目时候，默认会有debug和release这2个配置，那么debug、release可以修改其他名字吗，能增加其他名字来配置吗，比如想增加一个测试包配置test，还有就是release里面都能配置哪些属性呢<br>我来说下结果，如果不确定的，可以实际验证一下：</p><ul><li>debug、release 是可以修改成其他名字的，你可以替换成你喜欢的名字；</li><li>你可以增加任意不同名字的配置，比如增加一个开发版本的打包配置 dev ；</li><li>可配置的属性可参考接口：com.android.builder.model.BuildType ；</li></ul><p>可以看到它是非常灵活的，<strong>可以根据不同的场景定义不同的配置，每个不同的命名空间都会生成一个 BuildType 配置</strong>。要实现这样的功能，必须使用 NamedDomainObjectContainer 类型。</p><p><a name="Nakno"></a></p><h4 id="什么是NamedDomainObjectContainer"><a href="#什么是NamedDomainObjectContainer" class="headerlink" title="什么是NamedDomainObjectContainer"></a>什么是NamedDomainObjectContainer</h4><p>顾名思义就是命名领域对象容器，它的主要功能有：</p><ul><li>通过DSL创建指定type的对象实例</li><li>指定的type必须有一个public构造函数，且必须带有一个String name的参数</li><li>它是一个实现了SortedSet接口的容器，所以所有领域对象的name属性都必须是唯一的,在容器内部会用name属性来排序</li></ul><blockquote><p>named domain object container is a specialisation of NamedDomainObjectSet that adds the ability to create instances of the element type.<br>Note that a container is an implementation of SortedSet, which means that the container is guaranteed to only contain elements with unique names within this container. Furthermore, items are ordered by their name.</p></blockquote><p><a name="tjza8"></a></p><h4 id="创建NamedDomainObjectContainer"><a href="#创建NamedDomainObjectContainer" class="headerlink" title="创建NamedDomainObjectContainer"></a>创建NamedDomainObjectContainer</h4><p>NamedDomainObjectContainer 需要通过 Project.container(…) API 来创建，其定义为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; NamedDomainObjectContainer&lt;T&gt; container(Class&lt;T&gt; type)</span><br><span class="line">&lt;T&gt; NamedDomainObjectContainer&lt;T&gt; container(Class&lt;T&gt; type, NamedDomainObjectFactory&lt;T&gt; factory)</span><br><span class="line">&lt;T&gt; NamedDomainObjectContainer&lt;T&gt; container(java.lang.Class&lt;T&gt; type, Closure factoryClosure</span><br></pre></td></tr></table></figure></p><p>来看个具体的实例：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是领域对象类型定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDomainObj</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//必须定义一个 name 属性，并且这个属性值初始化以后不要修改</span></span><br><span class="line">    String name</span><br><span class="line"></span><br><span class="line">    String msg</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数必须有一个 name 参数</span></span><br><span class="line">    <span class="keyword">public</span> TestDomainObj(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> msg(String msg) &#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name = $&#123;name&#125;, msg = $&#123;msg&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个扩展</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestExtension</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个 NamedDomainObjectContainer 属性</span></span><br><span class="line">    NamedDomainObjectContainer&lt;TestDomainObj&gt; testDomains</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TestExtension(Project project) &#123;</span><br><span class="line">        <span class="comment">//通过 project.container(...) 方法创建 NamedDomainObjectContainer </span></span><br><span class="line">        NamedDomainObjectContainer&lt;TestDomainObj&gt; domainObjs = project.container(TestDomainObj)</span><br><span class="line">        testDomains = domainObjs</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//让其支持 Gradle DSL 语法</span></span><br><span class="line">    <span class="keyword">void</span> testDomain(Action&lt;NamedDomainObjectContainer&lt;TestDomainObj&gt;&gt; action) &#123;</span><br><span class="line">        action.execute(testDomains)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> test() &#123;</span><br><span class="line">        <span class="comment">//遍历命名领域对象容器，打印出所有的领域对象值</span></span><br><span class="line">        testDomains.all &#123; data -&gt;</span><br><span class="line">            println data        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个名为 test 的 Extension</span></span><br><span class="line"><span class="keyword">def</span> testExt = getExtensions().create(<span class="string">"test"</span>, TestExtension, project)</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">    testDomain &#123;</span><br><span class="line">        domain2 &#123;</span><br><span class="line">            msg <span class="string">"This is domain2"</span></span><br><span class="line">        &#125;</span><br><span class="line">        domain1 &#123;</span><br><span class="line">            msg <span class="string">"This is domain1"</span></span><br><span class="line">        &#125;</span><br><span class="line">        domain3 &#123;</span><br><span class="line">            msg <span class="string">"This is domain3"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task myTask doLast &#123;</span><br><span class="line">    testExt.test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = domain1, msg = This is domain1</span><br><span class="line">name = domain2, msg = This is domain2</span><br><span class="line">name = domain3, msg = This is domain3</span><br></pre></td></tr></table></figure></p><p><a name="s3BYi"></a></p><h4 id="查找和遍历"><a href="#查找和遍历" class="headerlink" title="查找和遍历"></a>查找和遍历</h4><p>NamedDomainObjectContainer 既然是一个容器类，与之相应的必然会有查找容器里的元素和遍历容器的方法：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">void</span> all(Closure action)</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">&lt;T&gt; T getByName(String name)</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">&lt;T&gt; T findByName(String name)</span><br></pre></td></tr></table></figure></p><p>还是接着前面的例子：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过名字查找</span></span><br><span class="line">TestDomainObj testData = testDomains.getByName(<span class="string">"domain2"</span>)</span><br><span class="line">println <span class="string">"getByName: $&#123;testData&#125;"</span></span><br><span class="line"><span class="comment">//遍历命名领域对象容器，打印出所有的领域对象值</span></span><br><span class="line">testDomains.all &#123; data -&gt;</span><br><span class="line">    println data        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是，Gradle 中有很多容器类的迭代遍历方法有 each(Closure action)、all(Closure action)，但是一般我们都会用 all(…) 来进行容器的迭代。all(…) 迭代方法的特别之处是，不管是容器内已存在的元素，还是后续任何时刻加进去的元素，都会进行遍历。</p><p><a name="DQ1C1"></a></p><h3 id="Android的Extension"><a href="#Android的Extension" class="headerlink" title="Android的Extension"></a>Android的Extension</h3><p>我们在gradle中会看到 android{}<br><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1556265446764-f824db8c-0d7f-4a36-b9ac-5c2dac1725d5.png#align=left&amp;display=inline&amp;height=242&amp;name=image.png&amp;originHeight=483&amp;originWidth=1000&amp;size=213329&amp;status=done&amp;width=500" alt="image.png"></p><p>defaultConfig、productFlavors、signingConfigs、buildTypes 这4个内部 Extension对象是怎么定义的，通过查看源码可以找到一个叫 <strong>BaseExtension</strong> 的类，里面的相关代码如下：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DefaultConfig defaultConfig;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NamedDomainObjectContainer&lt;ProductFlavor&gt; productFlavors;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NamedDomainObjectContainer&lt;BuildType&gt; buildTypes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NamedDomainObjectContainer&lt;SigningConfig&gt; signingConfigs;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> defaultConfig(Action&lt;DefaultConfig&gt; action) &#123;</span><br><span class="line">        <span class="keyword">this</span>.checkWritability();</span><br><span class="line">        action.execute(<span class="keyword">this</span>.defaultConfig);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> buildTypes(Action&lt;? super NamedDomainObjectContainer&lt;BuildType&gt;&gt; action) &#123;</span><br><span class="line">        this.checkWritability();</span><br><span class="line">        action.execute(this.buildTypes);</span><br><span class="line">    &#125;</span><br><span class="line">    public void productFlavors(Action&lt;? super NamedDomainObjectContainer&lt;ProductFlavor&gt;&gt; action) &#123;</span><br><span class="line">        this.checkWritability();</span><br><span class="line">        action.execute(this.productFlavors);</span><br><span class="line">    &#125;</span><br><span class="line">    public void signingConfigs(Action&lt;? super NamedDomainObjectContainer&lt;SigningConfig&gt;&gt; action) &#123;</span><br><span class="line">        this.checkWritability();</span><br><span class="line">        action.execute(this.signingConfigs);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在 app 的 build.gradle 里我们通常会采用插件 <strong>apply plugin: ‘com.android.application’</strong> ，而在 library module 中则采用插件 <strong>apply plugin: ‘com.android.library’,AppPlugin</strong> 就是插件 <strong>com.android.application</strong> 的实现类，<strong>LibraryPlugin</strong> 则是插件 <strong>com.android.library</strong> 的实现类，接着再看看 AppPlugin 里是怎样创建 Extension 的：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppPlugin</span> <span class="keyword">extends</span> <span class="title">BasePlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> AppPlugin(Instantiator instantiator, ToolingModelBuilderRegistry registry) &#123;</span><br><span class="line">        <span class="keyword">super</span>(instantiator, registry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> BaseExtension createExtension(Project project, ProjectOptions projectOptions, Instantiator instantiator, AndroidBuilder androidBuilder, SdkHandler sdkHandler, NamedDomainObjectContainer&lt;BuildType&gt; buildTypeContainer, NamedDomainObjectContainer&lt;ProductFlavor&gt; productFlavorContainer, NamedDomainObjectContainer&lt;SigningConfig&gt; signingConfigContainer, NamedDomainObjectContainer&lt;BaseVariantOutput&gt; buildOutputs, ExtraModelInfo extraModelInfo) &#123;</span><br><span class="line">        <span class="keyword">return</span> (BaseExtension)project.getExtensions().create(<span class="string">"android"</span>, AppExtension.<span class="keyword">class</span>, <span class="keyword">new</span> Object[]&#123;project, projectOptions, instantiator, androidBuilder, sdkHandler, buildTypeContainer, productFlavorContainer, signingConfigContainer, buildOutputs, extraModelInfo&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">        <span class="keyword">super</span>.apply(project);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 createExtension() 方法中，可以看到创建了一个名为 android 的 Extension，该 Extension 的类型为 AppExtension，而 AppExtension 的继承结构为 AppExtension -&gt; TestedExtension -&gt; BaseExtension，所以它的实现逻辑大部分都是在 BaseExtension 里实现的。</p><p>在Android 工程中的build.gradle 文件中,我们配置相关信息使用 android{} 节点,从 AppPlugin 也能看出其 Extension的名称为 android ,所以获取方法如下:</p><ul><li>project.extensions.getByName</li><li>project.extensions.getByType</li></ul><p><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def getInfo() &#123;</span><br><span class="line">//或者 直接 project.android</span><br><span class="line">    BaseExtension extension = project.extensions.getByName(&quot;android&quot;)</span><br><span class="line">    def android = project.extensions.getByType(AppExtension)</span><br><span class="line">    project.android</span><br><span class="line">    </span><br><span class="line">    println &quot;buildToolsVersion:$&#123;extension.buildToolsVersion&#125;&quot;</span><br><span class="line">    println &quot;compileSdkVersion:$&#123;extension.getCompileSdkVersion()&#125;&quot;</span><br><span class="line">    println &quot;applicationId:$&#123;extension.defaultConfig.applicationId&#125;&quot;</span><br><span class="line">    println &quot;minSdkVersion:$&#123;extension.defaultConfig.minSdkVersion&#125;&quot;</span><br><span class="line">    println &quot;targetSdkVersion:$&#123;extension.defaultConfig.targetSdkVersion&#125;&quot;</span><br><span class="line">    println &quot;versionCode:$&#123;extension.defaultConfig.versionCode&#125;&quot;</span><br><span class="line">    println &quot;versionName:$&#123;extension.defaultConfig.versionName&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更详细的请参考 </p><ul><li><a href="http://google.github.io/android-gradle-dsl/current/index.html" target="_blank" rel="noopener">ASL</a><br><a name="apKmL"></a><h1 id="3、构建生命周期"><a href="#3、构建生命周期" class="headerlink" title="3、构建生命周期"></a>3、构建生命周期</h1></li></ul><p><a name="6743b681"></a></p><h3 id="三个阶段"><a href="#三个阶段" class="headerlink" title="三个阶段"></a>三个阶段</h3><p>每次构建的<strong>本质其实就是执行一系列的Task</strong>，某些Task可能依赖其他Task，那些没有依赖的Task总会被最先执行，而且每个Task只会被执行一遍，每次构建的依赖关系是在构建的配置阶段确定的，在gradle构建中，构建的生命周期主要包括以下三个阶段：</p><ul><li><strong>初始化（Initialization）</strong></li></ul><p>构建工具会根据每个build.gradle文件创建出一个Project实例，初始化阶段会执行项目根目录下的Settings.gradle文件，来分析哪些项目参与构建</p><blockquote><p>include ‘:app’<br>include ‘:libraries:someProject’</p></blockquote><ul><li><strong>配置（Configuration）</strong></li></ul><p>这个阶段通过执行构建脚本来为每个project创建并分配Task。配置阶段会去加载所有参与构建的项目的build.gradle文件，会将build.gradle文件实例化为一个Gradle的project对象，然后分析project之间的依赖关系，下载依赖文件，分析project下的task之间的依赖关系<br><br><br></p><ul><li><strong>执行（Execution）</strong></li></ul><p>这是Task真正被执行的阶段，Gradle会根据依赖关系决定哪些Task需要被执行，以及执行的先后顺序。<br>task是Gradle中的最小执行单元，我们所有的构建，编译，打包，debug，test等都是执行了某一个task，一个project可以有多个task，task之间可以互相依赖。例如我有两个task，taskA和taskB，指定taskA依赖taskB，然后执行taskA，这时会先去执行taskB，taskB执行完毕后在执行taskA。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1556187110722-537b15e2-6470-443b-b4d1-ac1e6bd1cbaf.png#align=left&amp;display=inline&amp;height=275&amp;name=image.png&amp;originHeight=275&amp;originWidth=727&amp;size=81528&amp;status=done&amp;width=727" alt="image.png"><br>在根目录和app目录下的build.gradle中会引用下面的插件</p><p>dependencies {<br>        classpath ‘com.android.tools.build:gradle:2.2.2’<br>    }</p><p>apply plugin: ‘com.android.application’</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1556371938551-daac116f-1a1c-4d09-bf3f-417540040dd9.png#align=left&amp;display=inline&amp;height=391&amp;name=image.png&amp;originHeight=599&amp;originWidth=388&amp;size=182758&amp;status=done&amp;width=253" alt="image.png"><br><a name="uE3w6"></a></p><p>###<br><a name="lFk5D"></a></p><h3 id="Android-三个文件重要的gradle"><a href="#Android-三个文件重要的gradle" class="headerlink" title="Android 三个文件重要的gradle"></a>Android 三个文件重要的gradle</h3><p>Gradle项目有3个重要的文件需要深入理解：</p><ul><li>settings.gradle </li></ul><p>settings.gradle 文件会在构建的 initialization 阶段被执行，它用于告诉构建系统哪些模块需要包含到构建过程中。对于单模块项目， settings.gradle 文件不是必需的。对于多模块项目，如果没有该文件，构建系统就不能知道该用到哪些模块。</p><ul><li>项目根目录的 build.gradle </li></ul><p>项目根目录的 build.gradle 文件用来配置针对所有模块的一些属性。它默认包含2个代码块：buildscript{…}和allprojects{…}。前者用于配置构建脚本所用到的代码库和依赖关系，后者用于定义所有模块需要用到的一些公共属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &apos;com.android.tools.build:gradle:2.3.2&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task clean(type: Delete) &#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buildscript：定义了 Android 编译工具的类路径。repositories中, jCenter是一个著名的 Maven 仓库。<br>allprojects:中定义的属性会被应用到所有 moudle 中，但是为了保证每个项目的独立性，我们一般不会在这里面操作太多共有的东西。</p><ul><li>模块目录的 build.gradle 。</li></ul><p>模块级配置文件 build.gradle 针对每个moudle 的配置，如果这里的定义的选项和顶层 build.gradle定义的相同。它有3个重要的代码块：plugin，android 和 dependencies。</p><p><a name="XbmTU"></a></p><h3 id="常用gradle命令"><a href="#常用gradle命令" class="headerlink" title="常用gradle命令"></a>常用gradle命令</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建</span></span><br><span class="line">gradlew <span class="string">app:</span>clean    <span class="comment">//移除所有的编译输出文件，比如apk</span></span><br><span class="line"></span><br><span class="line">gradlew <span class="string">app:</span>build   <span class="comment">//构建 app module ，构建任务，相当于同时执行了check任务和assemble任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//检测</span></span><br><span class="line">gradlew <span class="string">app:</span>check   <span class="comment">//执行lint检测编译。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打包</span></span><br><span class="line">gradlew <span class="string">app:</span>assemble <span class="comment">//可以编译出release包和debug包，可以使用gradlew assembleRelease或者gradlew assembleDebug来单独编译一种包</span></span><br><span class="line"></span><br><span class="line">gradlew <span class="string">app:</span>assembleRelease  <span class="comment">//app module 打 release 包</span></span><br><span class="line"></span><br><span class="line">gradlew <span class="string">app:</span>assembleDebug  <span class="comment">//app module 打 debug 包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//安装，卸载</span></span><br><span class="line"></span><br><span class="line">gradlew <span class="string">app:</span>installDebug  <span class="comment">//安装 app 的 debug 包到手机上</span></span><br><span class="line"></span><br><span class="line">gradlew <span class="string">app:</span>uninstallDebug  <span class="comment">//卸载手机上 app 的 debug 包</span></span><br><span class="line"></span><br><span class="line">gradlew <span class="string">app:</span>uninstallRelease  <span class="comment">//卸载手机上 app 的 release 包</span></span><br><span class="line"></span><br><span class="line">gradlew <span class="string">app:</span>uninstallAll  <span class="comment">//卸载手机上所有 app 的包</span></span><br></pre></td></tr></table></figure><p><a name="aTKQj"></a></p><h3 id="监听生命周期"><a href="#监听生命周期" class="headerlink" title="监听生命周期"></a>监听生命周期</h3><p>在gradle的构建过程中，gradle为我们提供了非常丰富的钩子，帮助我们针对项目的需求定制构建的逻辑，如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1556078731941-534fb4b2-30f5-4b99-92c9-5ae4fc9a5e58.png#align=left&amp;display=inline&amp;height=205&amp;name=image.png&amp;originHeight=205&amp;originWidth=730&amp;size=56119&amp;status=done&amp;width=730" alt="image.png"></p><p>要监听这些生命周期，主要有两种方式：</p><ul><li>添加监听器</li><li>使用钩子的配置块</li></ul><p>关于可用的钩子可以参考<code>Gradle</code>和<code>Project</code>中的定义，常用的钩子包括：<br><a name="Gradle"></a></p><p>####<br><a name="uk5Bg"></a></p><h4 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h4><p>Project提供的生命周期回调方法有</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 Project 进行配置前调用</span></span><br><span class="line"><span class="keyword">void</span> beforeEvaluate(Closure closure)</span><br><span class="line"><span class="comment">//在 Project 配置结束后调用</span></span><br><span class="line"><span class="keyword">void</span> afterEvaluate(Closure closure)</span><br></pre></td></tr></table></figure><p>beforeEvaluate 必须在父模块的 build.gradle 对子模块进行配置才能生效，因为在当前模块的 build.gradle 中配置，它自己本身都没配置好，所以不会监听到。</p><p>settings.gradle 代码：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">":app"</span></span><br></pre></td></tr></table></figure></p><p>build.gradle 代码：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对子模块进行配置</span></span><br><span class="line">subprojects &#123; sub -&gt;</span><br><span class="line">    sub.beforeEvaluate &#123; proj -&gt;</span><br><span class="line">        println <span class="string">"子项目beforeEvaluate回调..."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">println <span class="string">"根项目配置开始---"</span></span><br><span class="line">task rootTest &#123;</span><br><span class="line">    println <span class="string">"根项目里任务配置---"</span></span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">"执行根项目任务..."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">println <span class="string">"根项目配置结束---"</span></span><br></pre></td></tr></table></figure></p><p>app/build.gradle 代码：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">println <span class="string">"APP子项目配置开始---"</span></span><br><span class="line">afterEvaluate &#123;</span><br><span class="line">    println <span class="string">"APP子项目afterEvaluate回调..."</span></span><br><span class="line">&#125;</span><br><span class="line">task appTest &#123;</span><br><span class="line">    println <span class="string">"APP子项目里任务配置---"</span></span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">"执行子项目任务..."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">println <span class="string">"APP子项目配置结束---"</span></span><br></pre></td></tr></table></figure></p><p>在根目录执行：gradle -q，结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">根项目配置开始---</span><br><span class="line">根项目里任务配置---</span><br><span class="line">根项目配置结束---</span><br><span class="line">子项目beforeEvaluate回调...</span><br><span class="line">APP子项目配置开始---</span><br><span class="line">APP子项目里任务配置---</span><br><span class="line">APP子项目配置结束---</span><br><span class="line">APP子项目afterEvaluate回调...</span><br></pre></td></tr></table></figure></p><p>project.android 获取到<a href="http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.AppExtension.html" target="_blank" rel="noopener"><code>AppExtension</code></a>:</p><p><a name="8ibti"></a></p><p>####<br><a name="MJ5Zh"></a></p><p>####<br><a name="sklTv"></a></p><h4 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h4><p>Gradle 提供的生命周期回调方法很多，部分与 Project 里的功能雷同：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在project进行配置前调用，child project必须在root project中设置才会生效，root project必须在settings.gradle中设置才会生效</span></span><br><span class="line"><span class="keyword">void</span> beforeProject(Closure closure)</span><br><span class="line"><span class="comment">//在project配置后调用</span></span><br><span class="line">afterProject(Closure closure)</span><br><span class="line"><span class="comment">//构建开始前调用</span></span><br><span class="line"><span class="keyword">void</span> buildStarted(Closure closure)</span><br><span class="line"><span class="comment">//构建结束后调用</span></span><br><span class="line"><span class="keyword">void</span> buildFinished(Closure closure)</span><br><span class="line"><span class="comment">//所有project配置完成后调用</span></span><br><span class="line"><span class="keyword">void</span> projectsEvaluated(Closure closure)</span><br><span class="line"><span class="comment">//当settings.gradle中引入的所有project都被创建好后调用，只在该文件设置才会生效</span></span><br><span class="line"><span class="keyword">void</span> projectsLoaded(Closure closure)</span><br><span class="line"><span class="comment">//settings.gradle配置完后调用，只对settings.gradle设置生效</span></span><br><span class="line"><span class="keyword">void</span> settingsEvaluated(Closure closure)</span><br></pre></td></tr></table></figure></p><ul><li>beforeProject()/afterProject()<br>等同于<code>Project</code>中的<code>beforeEvaluate</code>和<code>afterEvaluate</code></li><li>settingsEvaluated()<br>settings脚本被执行完毕，<code>Settings</code>对象配置完毕</li><li>projectsLoaded()<br>所有参与构建的项目都从settings中创建完毕</li><li>projectsEvaluated()<br>所有参与构建的项目都已经被评估完</li></ul><p>我们修改 setting.gradle 的代码如下：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">gradle.settingsEvaluated &#123;</span><br><span class="line">    println <span class="string">"settings：执行settingsEvaluated..."</span></span><br><span class="line">&#125;</span><br><span class="line">gradle.projectsLoaded &#123;</span><br><span class="line">    println <span class="string">"settings：执行projectsLoaded..."</span></span><br><span class="line">&#125;</span><br><span class="line">gradle.projectsEvaluated &#123;</span><br><span class="line">    println <span class="string">"settings: 执行projectsEvaluated..."</span></span><br><span class="line">&#125;</span><br><span class="line">gradle.beforeProject &#123; proj -&gt;</span><br><span class="line">    println <span class="string">"settings：执行$&#123;proj.name&#125; beforeProject"</span></span><br><span class="line">&#125;</span><br><span class="line">gradle.afterProject &#123; proj -&gt;</span><br><span class="line">    println <span class="string">"settings：执行$&#123;proj.name&#125; afterProject"</span></span><br><span class="line">&#125;</span><br><span class="line">gradle.buildStarted &#123;</span><br><span class="line">    println <span class="string">"构建开始..."</span></span><br><span class="line">&#125;</span><br><span class="line">gradle.buildFinished &#123;</span><br><span class="line">    println <span class="string">"构建结束..."</span></span><br><span class="line">&#125;</span><br><span class="line">include <span class="string">":app"</span></span><br></pre></td></tr></table></figure></p><p>这个时候的执行结果如下：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">settings：执行settingsEvaluated...</span><br><span class="line">settings：执行projectsLoaded...</span><br><span class="line">settings：执行test beforeProject</span><br><span class="line">根项目配置开始---</span><br><span class="line">根项目里任务配置---</span><br><span class="line">根项目配置结束---</span><br><span class="line">settings：执行test afterProject</span><br><span class="line">settings：执行app beforeProject</span><br><span class="line">子项目beforeEvaluate回调...</span><br><span class="line">APP子项目配置开始---</span><br><span class="line">APP子项目里任务配置---</span><br><span class="line">APP子项目配置结束---</span><br><span class="line">settings：执行app afterProject</span><br><span class="line">APP子项目afterEvaluate回调...</span><br><span class="line"><span class="string">settings:</span> 执行projectsEvaluated...</span><br><span class="line">构建结束...</span><br></pre></td></tr></table></figure></p><p>可以看到 gradle.beforeProject 与 project.beforeEvaluate 是类似的，同样 afterProject 与 afterEvaluate 也是类似的。</p><p>除此之外，Gradle 还有一个通用的设置生命周期监听器的方法：<strong>addListener</strong><br><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1556294955734-077629bb-f1c0-4edf-a849-6bad29cb7e73.png#align=left&amp;display=inline&amp;height=322&amp;name=image.png&amp;originHeight=643&amp;originWidth=1000&amp;size=373331&amp;status=done&amp;width=500" alt="image.png"><br>上面的 BuildListener、ProjectEvaluationListener 等与前面的部分 API 功能是一致的，这里不再赘述了。<br><a name="TaskExecutionGraph"></a></p><p>####<br><a name="dZ3JG"></a></p><h4 id="TaskExecutionGraph-Task执行图"><a href="#TaskExecutionGraph-Task执行图" class="headerlink" title="TaskExecutionGraph(Task执行图)"></a>TaskExecutionGraph(Task执行图)</h4><p>Gradle 在配置完成后，会对所有的 task 生成一个有向无环图，这里叫做 task 执行图，他们决定了 task 的执行顺序等。同样，Gradle 可以对 task 的执行生命周期进行监听。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//任务执行前掉用</span><br><span class="line">void afterTask(Closure closure)</span><br><span class="line">//任务执行后调用</span><br><span class="line">void beforeTask(Closure closure)</span><br><span class="line">//所有需要被执行的task已经task之间的依赖关系都已经确立</span><br><span class="line">void whenReady(Closure closure)</span><br></pre></td></tr></table></figure></p><p>通过 gradle.getTaskGraph() 方法来获取 task 执行图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TaskExecutionGraph taskGraph = gradle.getTaskGraph()</span><br><span class="line">taskGraph.whenReady &#123;</span><br><span class="line">    println &quot;task whenReady&quot;</span><br><span class="line">&#125;</span><br><span class="line">taskGraph.beforeTask &#123; Task task -&gt;</span><br><span class="line">    println &quot;任务名称：$&#123;task.name&#125; beforeTask&quot;</span><br><span class="line">&#125;</span><br><span class="line">taskGraph.afterTask &#123; Task task -&gt;</span><br><span class="line">    println &quot;任务名称：$&#123;task.name&#125; afterTask&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>生命周期回调的执行顺序：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gradle.settingsEvaluated-&gt;</span><br><span class="line">gradle.projectsLoaded-&gt;</span><br><span class="line">gradle.beforeProject-&gt;</span><br><span class="line">project.beforeEvaluate-&gt;</span><br><span class="line">gradle.afterProject-&gt;</span><br><span class="line">project.afterEvaluate-&gt;</span><br><span class="line">gradle.projectsEvaluated-&gt;</span><br><span class="line">gradle.taskGraph.graphPopulated-&gt;</span><br><span class="line">gradle.taskGraph.whenReady-&gt;</span><br><span class="line">gradle.buildFinished</span><br></pre></td></tr></table></figure></p><p><a name="o5gjg"></a></p><h1 id="4、自定义插件开发"><a href="#4、自定义插件开发" class="headerlink" title="4、自定义插件开发"></a>4、自定义插件开发</h1><p><a name="6e3f99de"></a></p><h3 id="三种方式"><a href="#三种方式" class="headerlink" title="三种方式"></a>三种方式</h3><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>Build script</td><td>把插件写在 build.gradle 文件中，一般用于简单的逻辑，只在该 build.gradle 文件中可见</td></tr><tr><td>buildSrc 项目</td><td>将插件源代码放在 rootProjectDir/buildSrc/src/main/groovy 中，只对该项目中可见，适用于逻辑较为复杂</td></tr><tr><td><strong>独立项目</strong></td><td>一个独立的 Groovy 和 Java 项目，可以把这个项目打包成 Jar 文件包，一个 Jar 文件包还可以包含多个插件入口，将文件包发布到托管平台上，供其他人使用。本文将着重介绍此类。</td></tr></tbody></table><p>具体从插件开发可以参考</p><ul><li><a href="https://xsfelvis.github.io/2018/06/09/%E8%AF%91%E6%96%87_Writing%20Custom%20Plugins/">Writing Custom Plugins</a></li><li><a href="http://blog.bugtags.com/2016/03/28/embrace-android-studio-gradle-plugin/" target="_blank" rel="noopener">拥抱 Android Studio 之五：Gradle 插件开发</a></li><li><a href="http://lijiankun24.com/%E7%83%AD%E4%BF%AE%E5%A4%8D%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A1%86%E6%9E%B6%E9%9B%8F%E5%BD%A2%EF%BC%88%E4%B8%89%EF%BC%89/" target="_blank" rel="noopener">热修复之自定义热修复框架雏形（三）</a></li></ul><p>需要注意的是 在main目录下创建<br>1、resources/META-INF/gradle-plugins文件夹，<br>2、在<strong>gradle-plugins文件夹下创建一个xxx.properties文件</strong>，(<strong>com.learntransform.testtransform.properties</strong>)<br>注意：这个xxx就是在app下的build.gradle中引入时的名字，例如：<strong>apply plugin: ‘xxx’（</strong>apply plugin:’com.learntransform.testtransform’<strong>）</strong><br>3、在文件书写引用到插件 implementation-class=me.xsfdev.learntransform.Hotfix<br><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1556806007519-8dca98a3-a43f-4ffa-b4ba-451bf4ce8f30.png#align=left&amp;display=inline&amp;height=275&amp;name=image.png&amp;originHeight=549&amp;originWidth=1000&amp;size=339915&amp;status=done&amp;width=500" alt="image.png"></p><p><a name="73a05e0f"></a></p><h3 id="插件的本地化"><a href="#插件的本地化" class="headerlink" title="插件的本地化"></a>插件的本地化</h3><ul><li>本地插件module</li><li><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">group = &apos;com.learntranform&apos;</span><br><span class="line">version = &apos;1.0.1&apos;</span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        flatDir &#123;</span><br><span class="line">            name &quot;localRepository&quot;</span><br><span class="line">            dir &quot;../app/localRepository/libs&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>工程的gradle</p></li><li><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext.kotlin_version = <span class="string">'1.2.41'</span></span><br><span class="line">    repositories &#123;</span><br><span class="line">        flatDir &#123;</span><br><span class="line">            name <span class="string">'localRepository'</span></span><br><span class="line">            dir <span class="string">"app/localRepository/libs"</span></span><br><span class="line">        &#125;</span><br><span class="line">        mavenLocal()</span><br><span class="line">        jcenter()</span><br><span class="line">        google()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(group: <span class="string">'com.plugintest'</span>, name: <span class="string">'hellodsl'</span>, version: <span class="string">'1.0.0'</span>) &#123;</span><br><span class="line">            changing = <span class="keyword">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        classpath(group: <span class="string">'com.learntransform'</span>, name: <span class="string">'learntransform'</span>, version: <span class="string">'1.0.1'</span>) &#123;</span><br><span class="line">            changing = <span class="keyword">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:3.1.2'</span></span><br><span class="line">        classpath <span class="string">"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"</span></span><br><span class="line">        classpath <span class="string">'com.novoda:bintray-release:0.8.0'</span> <span class="comment">//jcenter添加</span></span><br><span class="line">        classpath <span class="string">'com.xsfdev:complexcriptdsl:1.0.0'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>完整代码可以参考 <a href="https://github.com/xsfelvis/GradlePluginStudy/blob/master/learntransform/build.gradle" target="_blank" rel="noopener">LearnGradle</a></p><p><a name="4YWev"></a></p><h1 id="5、常用方法"><a href="#5、常用方法" class="headerlink" title="5、常用方法"></a>5、常用方法</h1><p><a name="android.applicationVariants"></a></p><h2 id="android-applicationVariants"><a href="#android-applicationVariants" class="headerlink" title="android.applicationVariants"></a>android.applicationVariants</h2><p>更多参考需要看源码</p><p>android.applicationVariants 返回的是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public DomainObjectSet&lt;ApplicationVariant&gt; getApplicationVariants() &#123;</span><br><span class="line">      return applicationVariantList;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>一层层追 相关的有<br><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1556122864808-85593771-2038-40a0-a121-faca52cabe6b.png#align=left&amp;display=inline&amp;height=769&amp;name=image.png&amp;originHeight=1442&amp;originWidth=1398&amp;size=163578&amp;status=done&amp;width=746" alt="image.png"><br>在BaseVariant中<br><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1556123502143-259a6f70-5190-4072-9cd2-dc93476d3a29.png#align=left&amp;display=inline&amp;height=611&amp;name=image.png&amp;originHeight=611&amp;originWidth=439&amp;size=95538&amp;status=done&amp;width=439" alt="image.png"></p><p><a name="UWA8x"></a></p><h2 id="Task-upToDateWhen"><a href="#Task-upToDateWhen" class="headerlink" title="Task#upToDateWhen"></a>Task#upToDateWhen</h2><p>每次都会编译</p><p><code>outputs.upToDateWhen { true }</code> doesn’t mean “the task is up-to-date.” It just means that the outputs are up-to-date for that particular spec. Gradle will still do its own up-to-date checks.<br>The other thing that may be confusing is where the task’s actions are defined. If the actions are defined in the build script, the build script itself is an input to the task. So changes to the build script will make the task out-of-date.<br>So if I had a task like:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">task myTask &#123;</span><br><span class="line">    def outputFile = file(&quot;output.txt&quot;)</span><br><span class="line">    outputs.file outputFile</span><br><span class="line">    doLast &#123;</span><br><span class="line">        outputFile.text = &quot;Done&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    outputs.upToDateWhen &#123; false &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Whenever I run this, <code>myTask</code> is out-of-date. If I switch the false to true, the first time I run it, the task is out-of-date still (because the buildscript changed). When I run it again, it would be up-to-date (all inputs are the same). You’ll see this at <code>--info</code> level logging.</p><p><a name="0JsjK"></a></p><h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><p><a name="VXMJb"></a></p><h2 id="Failed-to-notify-project-evaluation-listener"><a href="#Failed-to-notify-project-evaluation-listener" class="headerlink" title="Failed to notify project evaluation listener"></a>Failed to notify project evaluation listener</h2><p>The versions of the Android Gradle plugin and Gradle are not compatible.</p><p><a name="nLY5q"></a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://juejin.im/post/5b000522f265da0b7f44d1c7" target="_blank" rel="noopener">作为Android开发你必须明白的Gradle基础</a></li><li><a href="https://www.ctolib.com/topics-123427.html" target="_blank" rel="noopener">使用</a><a href="https://www.ctolib.com/topics-123427.html" target="_blank" rel="noopener">IDEA</a><a href="https://www.ctolib.com/topics-123427.html" target="_blank" rel="noopener">开发</a><a href="https://www.ctolib.com/topics-123427.html" target="_blank" rel="noopener">Gradle</a><a href="https://www.ctolib.com/topics-123427.html" target="_blank" rel="noopener">插件</a><a href="https://www.ctolib.com/topics-123427.html" target="_blank" rel="noopener"> : </a><a href="https://www.ctolib.com/topics-123427.html" target="_blank" rel="noopener">获取</a><a href="https://www.ctolib.com/topics-123427.html" target="_blank" rel="noopener">Android</a><a href="https://www.ctolib.com/topics-123427.html" target="_blank" rel="noopener">工程信息</a></li><li><a href="https://www.jianshu.com/u/5ac1ca917290" target="_blank" rel="noopener">https://www.jianshu.com/u/5ac1ca917290</a></li><li><a href="https://www.jianshu.com/p/8e89a0b8acf8" target="_blank" rel="noopener">Android Gradle</a><a href="https://www.jianshu.com/p/8e89a0b8acf8" target="_blank" rel="noopener">学习(二)：如何创建</a><a href="https://www.jianshu.com/p/8e89a0b8acf8" target="_blank" rel="noopener">Task</a></li><li><a href="https://www.jianshu.com/p/c45861426eba" target="_blank" rel="noopener">Android Gradle</a><a href="https://www.jianshu.com/p/c45861426eba" target="_blank" rel="noopener">学习(三)：</a><a href="https://www.jianshu.com/p/c45861426eba" target="_blank" rel="noopener">Task</a><a href="https://www.jianshu.com/p/c45861426eba" target="_blank" rel="noopener">进阶学习</a></li><li><a href="https://www.jianshu.com/p/e5de9538effa" target="_blank" rel="noopener">Project详解(四)</a></li><li><a href="https://www.jianshu.com/p/167cd4b82653" target="_blank" rel="noopener">Android Gradle</a><a href="https://www.jianshu.com/p/167cd4b82653" target="_blank" rel="noopener">学习(六)：</a><a href="https://www.jianshu.com/p/167cd4b82653" target="_blank" rel="noopener">NamedDomainObjectContainer</a><a href="https://www.jianshu.com/p/167cd4b82653" target="_blank" rel="noopener">详解</a></li><li><a href="https://www.jianshu.com/p/2e19268bf387" target="_blank" rel="noopener">Android Gradle</a><a href="https://www.jianshu.com/p/2e19268bf387" target="_blank" rel="noopener">学习(七)：</a><a href="https://www.jianshu.com/p/2e19268bf387" target="_blank" rel="noopener">Gradle</a><a href="https://www.jianshu.com/p/2e19268bf387" target="_blank" rel="noopener">构建生命周期</a></li><li><a href="http://www.cnblogs.com/davenkin/p/gradle-learning-1.html" target="_blank" rel="noopener">Gradle</a><a href="http://www.cnblogs.com/davenkin/p/gradle-learning-1.html" target="_blank" rel="noopener">学习系列之一</a><a href="http://www.cnblogs.com/davenkin/p/gradle-learning-1.html" target="_blank" rel="noopener">——Gradle</a><a href="http://www.cnblogs.com/davenkin/p/gradle-learning-1.html" target="_blank" rel="noopener">快速入门</a></li><li><a href="https://blog.csdn.net/zhaoyanjun6/column/info/18954" target="_blank" rel="noopener">Gradle实战指南</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Gradle插件从入门到进阶&quot;&gt;&lt;a href=&quot;#Gradle插件从入门到进阶&quot; class=&quot;headerlink&quot; title=&quot;Gradle插件从入门到进阶
      
    
    </summary>
    
      <category term="Gradle插件" scheme="https://xsfelvis.github.io/categories/Gradle%E6%8F%92%E4%BB%B6/"/>
    
    
      <category term="Gradle插件" scheme="https://xsfelvis.github.io/tags/Gradle%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>EasyAdapter</title>
    <link href="https://xsfelvis.github.io/2019/04/19/EasyAdapter/"/>
    <id>https://xsfelvis.github.io/2019/04/19/EasyAdapter/</id>
    <published>2019-04-18T16:00:00.000Z</published>
    <updated>2019-04-19T03:14:43.952Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="常规写法的探讨"><a href="#常规写法的探讨" class="headerlink" title="常规写法的探讨"></a>常规写法的探讨</h2><p>常规的写法，为了使用 <code>RecyclerView</code>，必须指定一个 <code>adapter</code> 和 一个 <code>LayoutManager</code>。其中自定义的 <code>adapter</code> 必须继承自 <code>RecyclerView.Adapter</code>，其中必须实现几个接口：</p><ul><li><p>public ItemViewHolder onCreateViewHolder(ViewGroup viewGroup, int viewType)<br>在这个接口当中根据类别创建 <code>ViewHolder</code> 和 inflate <code>layout</code>，要是有多个item需要写一堆if-else</p></li><li><p>public void onBindViewHolder(ItemViewHolder viewHolder, int position)或者</p><pre><code>public void onBindViewHolder(TRealViewHolder holder, int position, List&lt;Object&gt; payloads)&lt;br /&gt;</code></pre><p><br>在这个接口当中根据位置 <code>position</code> 取出对应的数据，并用于刷新 <code>viewHolder</code> 里面的 <code>UI</code>。<br></p></li><li><p>public int getItemCount()<br>在这个接口当中根据位置保存的数据数量指定列表控件 <code>item</code> 的数量<br></p></li></ul><p><strong>因此可以看出</strong></p><ol><li>👆以上几个接口的套路都是固定的，可以做一层统一的封装</li><li>其次 <code>onCreateViewHolder</code> 和 <code>onBindViewHolder</code> 还不足以清晰直观的表达 <code>itemView</code> 是创建还是复用<br></li><li><code>Model</code> 和 <code>ViewHolder</code> 之间的映射关系没有做硬性规定</li></ol><p><a name="8a483843"></a></p><h2 id="针对改进"><a href="#针对改进" class="headerlink" title="针对改进"></a>针对改进</h2><ul><li>注解的方式加载布局         </li><li>将数据和视图分离</li><li>更加清晰的holder复用</li></ul><p><a name="a491b1bc"></a></p><h3 id="1、注解的方式加载布局"><a href="#1、注解的方式加载布局" class="headerlink" title="1、注解的方式加载布局"></a>1、注解的方式加载布局</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EasyViewHolderAnnotation</span>(resId = R.layout.item_infoone)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfoViewViewHolderOne</span> <span class="keyword">extends</span> <span class="title">BaseEasyViewHolder</span>&lt;<span class="title">ItemOneData</span>&gt; </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InfoViewViewHolderOne</span><span class="params">(Context context, View itemView, RecyclerView recyclerView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, itemView, recyclerView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inflate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化控件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">(EasyAdapterItem&lt;ItemOneData&gt; tAdapterItem)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tAdapterItem == <span class="keyword">null</span> || tAdapterItem.getDataModel() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ItemOneData model = tAdapterItem.getDataModel();</span><br><span class="line">        <span class="comment">//使用datamodel刷新 UI</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="d3ba7598"></a></p><h3 id="2、数据与视图分离"><a href="#2、数据与视图分离" class="headerlink" title="2、数据与视图分离"></a>2、数据与视图分离</h3><p>举个例子 上面的InfoViewViewHolderOne需要使用 ItemDataModel的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfoViewHolderItemOne</span> <span class="keyword">implements</span> <span class="title">EasyAdapterItem</span>&lt;<span class="title">ItemOneData</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ItemOneData mItemOneData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InfoViewHolderItemOne</span><span class="params">(ItemOneData goodInfo)</span> </span>&#123;</span><br><span class="line">        mItemOneData = goodInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> VIEW_TYPE_INFO_ONE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ItemOneData <span class="title">getDataModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mItemOneData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绑定是通过一个map来进行数据数据绑定，这样复用更加清晰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SparseArray&lt;Class&lt;? extends BaseEasyViewHolder&gt;&gt; viewHolders = <span class="keyword">new</span> SparseArray&lt;Class&lt;? extends BaseEasyViewHolder&gt;&gt;() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            put(ViewItemType.VIEW_TYPE_INFO_ONE, InfoViewViewHolderOne.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p><a name="4b30c109"></a></p><h2 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/215777/1555579402657-55755ccb-5f54-4923-91d6-20fb836904bb.png#align=left&amp;display=inline&amp;height=616&amp;name=image.png&amp;originHeight=1232&amp;originWidth=1600&amp;size=209351&amp;status=done&amp;width=800" alt="image.png"></p><p><a name="ecff77a8"></a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>结合示例代码</p><p>1、定义 <code>ViewItemType</code> 类型枚举值:<br>2、定义具体 <code>InfoViewViewHolderOne</code> class和对应数据 <code>ItemOneData</code> 类型<br>3、绑定holder和viewitemType</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SparseArray&lt;Class&lt;? extends BaseEasyViewHolder&gt;&gt; viewHolders = <span class="keyword">new</span> SparseArray&lt;Class&lt;? extends BaseEasyViewHolder&gt;&gt;() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            put(ViewItemType.VIEW_TYPE_INFO_ONE, InfoViewViewHolderOne.class);</span><br><span class="line">            put(ViewItemType.VIEW_TYPE_INFO_TWO, InfoViewViewHolderTwo.class);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>4、初始化 数据源 List<easyadapteritem> mTAdapterItems</easyadapteritem></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;EasyAdapterItem&gt; mAdapterItems = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>5、将Adapter设置给 RecyclerView</p><p><a name="0ba75d5d"></a></p><h2 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h2><ul><li>泛型、抽象</li><li>注解</li><li>反射</li></ul><p><a name="9415a826"></a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>由于使用到了反射去创建viewHolder，因此继承BaseEasyViewHolder时候注意防止混淆</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">me</span>.<span class="title">xsfdev</span>.<span class="title">easyadapterlib</span>.<span class="title">base</span>.** </span>&#123;*;&#125;</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> * <span class="keyword">extends</span> <span class="title">me</span>.<span class="title">xsfdev</span>.<span class="title">easyadapterlib</span>.<span class="title">base</span>.<span class="title">BaseEasyViewHolder</span></span>&#123;*;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;常规写法的探讨&quot;&gt;&lt;a href=&quot;#常规写法的探讨&quot; class=&quot;headerlink&quot; title=&quot;常规写法的探讨&quot;&gt;&lt;/a&gt;常规写法的探讨&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="工具" scheme="https://xsfelvis.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Adapter" scheme="https://xsfelvis.github.io/tags/Adapter/"/>
    
  </entry>
  
  <entry>
    <title>深入理解动态代理</title>
    <link href="https://xsfelvis.github.io/2019/02/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>https://xsfelvis.github.io/2019/02/22/深入理解动态代理/</id>
    <published>2019-02-21T16:00:00.000Z</published>
    <updated>2019-02-22T14:49:21.165Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>千山鸟飞绝，万径人踪灭。</p><p>孤舟蓑笠翁，独钓寒江雪</p><p>——唐·柳宗元《江雪》</p><p>首发于我的公众号</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU5OTgzNzM0NA==&amp;mid=2247483807&amp;idx=1&amp;sn=2981adda8dd17924cda1c9b05ad17f58&amp;chksm=feaf9e50c9d8174662f43f039de9b500094635d83fbff1a4df2c0923ef51dffbf11a2ae0d135&amp;token=722070929&amp;lang=zh_CN#rd" target="_blank" rel="noopener">深入理解动态代理</a></p></blockquote><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>最近在阅读retrofit源码时,有个关键的所在就是动态代理，细细回想了一下动态代理,发现之前有些细节还没有理解到位，本篇博文将重新深入理解一下动态代理。</p><h1 id="二、关于代理"><a href="#二、关于代理" class="headerlink" title="二、关于代理"></a>二、关于代理</h1><p>中华名族是一个含蓄的名族，讲究微妙和间接的交流方式。对象之间的间接通信也是同样是面向对象设计中一条重要的审美观，迪米特法则也指出“一个对象应该对其他对象保持最少的了解”,间接间通信可以达到“高内聚，低耦合”的效果。<br>代理是一种重要的手段之一，比如生活中的微商代理，厂家委托其代理销售商品，我们只跟微商打交道，不知道背后的“厂家是谁”，微商和厂家就可以抽象为 “代理类”和“委托类”，这样就可以，隐藏委托类的实现、实现客户与委托类之间的解耦，可以不用修改委托类的情况下做一些额外的处理</p><h2 id="2-1、代理模式简介"><a href="#2-1、代理模式简介" class="headerlink" title="2.1、代理模式简介"></a>2.1、代理模式简介</h2><p>在《Java与模式》一书中指出”代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的访问”，类图如下<br><img src="https://user-gold-cdn.xitu.io/2019/2/22/16915a41d98d4237?w=1172&amp;h=422&amp;f=png&amp;s=38943" alt="image.png"><br>通过类图可以发现，代理模式的代理对象<code>Proxy</code>和目标对象<code>Subject</code>实现同一个接口，客户调用的是<code>Proxy</code>对象，<code>Proxy</code>可以控制<code>Subject</code>的访问，真正的功能实现是在<code>Subject</code>完成的。</p><p>适用场景:</p><ul><li>不希望某些类被直接访问。<br></li><li>访问之前希望先进行一些预处理。<br></li><li>希望对被访问的对象进行内存、权限等方面的控制。 </li></ul><p>优点如下</p><ul><li>代理模式是通过使用引用代理对象来访问真实对象，在这里代理对象充当用于连接客户端和真实对象的中介者。<br></li><li>代理模式主要用于远程代理、虚拟代理和保护代理。其中保护代理可以进行访问权限控制。<br></li></ul><h2 id="2-2、静态代理"><a href="#2-2、静态代理" class="headerlink" title="2.2、静态代理"></a>2.2、静态代理</h2><p>“静态”代理，若代理类在程序运行前已经存在，这种通常称为静态代理，比如微商A只代理A品牌的面膜,消费者通过微商才能买到某厂的面膜(控制权)，其中微商和工厂都实现了了Sell的接口</p><blockquote><p>委托类面膜工厂</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">FactoryOne</span> :<span class="type">SellMask&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">sell</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"FactoryOne: 来自工厂A的面膜"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>微商静态代理</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BusinessAgent</span> : <span class="type">SellMask &#123;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> sellMask: SellMask</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        sellMask = FactoryOne()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">sell</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"BusinessAgent: 微商代理开始在朋友圈打广告"</span>)</span><br><span class="line">        sellMask.sell()</span><br><span class="line">        print(<span class="string">"BusinessAgent: 赚了一大把"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共同接口<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SellMask</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sell</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-3、相似模式的比较"><a href="#2-3、相似模式的比较" class="headerlink" title="2.3、相似模式的比较"></a>2.3、相似模式的比较</h2><p>既然获得引用就可以做一些扩展之类的事情，这点跟装饰者模式、适配器模式看起来很像，三者都属于结构型模式，但是代理模式核心是为其它对象提供一种代理以控制对这个对象的访问()<br><br></p><blockquote><p>代理模式 VS 适配器模式</p></blockquote><p>看上去很像，它们都可视为一个对象提供一种前置的接口，但是适配器模式的用意是改变所考虑的对象的接口，而代理模式并不能改变所代理的对象的接口，这一点上两个模式有着明显的区别，下图分别是 对象适配器和类的适配器UML图</p><p><img src="https://user-gold-cdn.xitu.io/2019/2/22/16915a41d9a53c4a?w=1286&amp;h=900&amp;f=png&amp;s=82798" alt="image.png"><br><br></p><blockquote><p>代理模式VS 装饰模式</p></blockquote><p>装饰者模式与所装饰的对象有着相同的接口，这一点跟代理模式相同，但是装饰模式更强调为所装饰的对象提供增强功能，而代理模式则是对对象的使用施加控制，并不提供对象本身的增强功能；被代理对象由代理对象创建，客户端甚至不需要知道被代理类的存在；被装饰对象由客户端创建并传给装饰对象。装饰者UML图如下</p><p><img src="https://user-gold-cdn.xitu.io/2019/2/22/16915a41d9bb2a1a?w=1358&amp;h=590&amp;f=png&amp;s=78546" alt="image.png"></p><p>你以为这就完了吗？下面👇才是重头戏！</p><h1 id="三、深入理解动态代理"><a href="#三、深入理解动态代理" class="headerlink" title="三、深入理解动态代理"></a>三、深入理解动态代理</h1><h2 id="3-1、什么是动态代理"><a href="#3-1、什么是动态代理" class="headerlink" title="3.1、什么是动态代理"></a>3.1、什么是动态代理</h2><p>代理类在程序运行时创建的代理方式被成为 动态代理。即代理类并不是在代码中定义的，而是在运行时根据我们在Java代码中”规定”的信息自动生成。静态代理容易造成代码的膨胀，。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数。 还是以上面的卖面膜微商为例，她在进货市场进行一番比较之后再决定代理哪个品牌的面膜。</p><h2 id="3-2、如何使用动态代理"><a href="#3-2、如何使用动态代理" class="headerlink" title="3.2、如何使用动态代理"></a>3.2、如何使用动态代理</h2><p>跟上文一样，微商和面膜工厂都实现了sell接口，这里就不赘述了，下面看下与众不同的地方，实现动态代理需要实现InvocationHandler接口</p><blockquote><p>实现InvocationHandler接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object;<span class="comment">//被引用的代理</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newProxyInstance</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(object.getClass().getClassLoader(),object.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"代理商 包装发朋友圈"</span>);</span><br><span class="line">        Object result = method.invoke(object,args);</span><br><span class="line">        System.out.println(<span class="string">"代理商 赚钱"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>target 属性表示委托类对象</li><li><code>InvocationHandler</code>是负责连接代理类和委托类的中间类必须实现的接口。其中只有一个 invoke函数需要实现</li><li>invoke函数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br></pre></td></tr></table></figure><p>下面好好看看这个核心函数的参数含义</p><ul><li>proxy 代通过dynamicproxy.newProxyInstance(business)自动生成的代理类 $Proxy0.class(下文会详细介绍)</li><li>method表示代理对象被调用的函数，比如sellMask接口里面的sell方法</li><li>args 表示代理大力调用函数的的参数，这里sell方法无参数</li></ul><p>调用代理对象的每个函数，实际上最终都是走到InvocationHandler的invoke函数，因此可以在这里做一些统一的处理，AOP的雏形就慢慢出现了，我们也可以根据method方法名做一些判断，从而实现对某些函数的特殊处理。</p><blockquote><p>使用动态代理</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    System.getProperties().put(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>)  <span class="comment">//加入这个可以获取代理类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> maskFactory = FactoryMaskOne()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dynamicproxy: DynamicProxy = DynamicProxy()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sellMask: SellMask = dynamicproxy.newProxyInstance(maskFactory) <span class="keyword">as</span> SellMask</span><br><span class="line"></span><br><span class="line">    sellMask.sell()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将委托类面膜工程FactoryMaskOne传到dynamicproxy.newProxyInstance中，通过下面的函数返回了一个代理对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Object newProxyInstance(Object object) &#123;</span><br><span class="line">        this.object = object;</span><br><span class="line">        return Proxy.newProxyInstance(object.getClass().getClassLoader(),object.getClass().getInterfaces(),this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>实际代理类就是在这个时候动态生成的，后续调用到这个代理类的函数就会直接调用invoke函数，让我们细细看下这个Proxy.newProxyInstance</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure><p>法的三个参数含义分别如下：</p><ul><li>loader：定义了代理类的ClassLoder;</li><li>interfaces：代理类实现的接口列表</li><li>h：调用处理器，也就是我们上面定义的实现了InvocationHandler接口的类实例</li></ul><p>这里简单总结一下，委托类通过<strong>newProxyInstance </strong>方法获取动态生成的代理类的实例(本例是$Proxy0.class),然后可以通过这个代理类实例调用代理的方法获得委托类的控制权，对代理类的调用实际上都会走到invoke方法，在这里我们调用委托类的相应方法，并且可以添加自己的一些逻辑，比如统一处理登陆、校验之类的。</p><h2 id="3-3、动态生成的代理类-Proxy0"><a href="#3-3、动态生成的代理类-Proxy0" class="headerlink" title="3.3、动态生成的代理类$Proxy0"></a>3.3、动态生成的代理类$Proxy0</h2><p>在Android Studio中调用不了<code>ProxyGenerator</code>这个类,这个类在sun.misc包中,使用IntelliJ IDE创建java工程，需要看一下<a href="">jdk</a>的反射中Proxy和生成的代理类$Proxy0的源码，可以使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成$Proxy0的class文件</span></span><br><span class="line">System.getProperties().put(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><p>生成的代理类在com.sun.proxy包里面完整代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">SellMask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//可以看到接口方法都交由h的invoke方法处理，h在父类Proxy中定义为InvocationHandler接口</span></span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"dev.proxy.SellMask"</span>).getMethod(<span class="string">"sell"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从生成的代理类中可以看到</p><ul><li>动态生成的代理类是以<code>$Proxy</code>为类名前缀，继承自<code>Proxy</code>，并且实现了<code>Proxy.newProxyInstance(…)</code>第二个参数传入的所有接口的类。</li><li>接口方法都交由h的invoke方法处理，h在父类Proxy中定义为InvocationHandler接口，为Proxy.newProxyInstance(…)的第三个参数<h2 id="3-4-动态代理类如何生成"><a href="#3-4-动态代理类如何生成" class="headerlink" title="3.4 动态代理类如何生成"></a>3.4 动态代理类如何生成</h2></li><li>关注点1 Proxy.newProxyInstance(……)函数</li></ul><p>动态代理类是在调用 Proxy.newProxyInstance(……)函数时生成的，精简后的核心代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">        ……</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">         * 得到动态代理类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ……</span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//然后将InvocationHandler作为代理类构造函数入参新建代理类对象</span></span><br><span class="line">            <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">           ……</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到 首先调用它先调用<code>getProxyClass(loader, interfaces)</code>得到动态代理类，然后将<code>InvocationHandler</code>作为代理类构造函数入参新建代理类对象。</p><ul><li>关注点2  Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</li></ul><p>如何获取到 生成动态代理类呢，一步步追踪，我们发现，在Proxy#ProxyClassFactory类中，在ProxyGenerator中去生成动态代理，类名以$Proxy+num作为标记</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">       * Generate the specified proxy class.</span><br><span class="line">       */</span><br><span class="line">      byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">          proxyName, interfaces, accessFlags);</span><br><span class="line">      try &#123;</span><br><span class="line">          return defineClass0(loader, proxyName,</span><br><span class="line">                              proxyClassFile, 0, proxyClassFile.length);</span><br><span class="line">      &#125; catch (ClassFormatError e) &#123;</span><br><span class="line">          throw new IllegalArgumentException(e.toString());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇主要java中的代理模式以及跟其他模式的对比，并重点介绍了JDK中的动态代理机制，像AOP、retrofit核心机制之一就使用到了这种技术，但Java动态代理是基于接口的，如果对象没有实现接口我们该如何代理呢？那就需要CGLIB了，<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">CGLIB</a>(<em>Code Generation Library</em>)是一个基于<a href="http://www.baeldung.com/java-asm" target="_blank" rel="noopener">ASM</a>的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB通过继承方式实现代理，这里就不展开赘述了。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://juejin.im/post/5a99048a6fb9a028d5668e62" target="_blank" rel="noopener">https://juejin.im/post/5a99048a6fb9a028d5668e62</a></li><li><a href="https://juejin.im/post/5ad3e6b36fb9a028ba1fee6a" target="_blank" rel="noopener">https://juejin.im/post/5ad3e6b36fb9a028ba1fee6a</a></li><li><a href="http://www.cnblogs.com/xiaoluo501395377/p/3383130.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaoluo501395377/p/3383130.html</a></li><li><a href="https://www.zhihu.com/question/20794107" target="_blank" rel="noopener">https://www.zhihu.com/question/20794107</a></li><li><a href="https://blog.csdn.net/qq_27095957/article/details/80184291" target="_blank" rel="noopener">https://blog.csdn.net/qq_27095957/article/details/80184291</a></li><li><a href="http://a.codekk.com/detail/Android/Caij/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86" target="_blank" rel="noopener">http://a.codekk.com/detail/Android/Caij/公共技术点之 Java 动态代理</a></li><li><a href="https://www.jianshu.com/p/0391a8e93d3d" target="_blank" rel="noopener">https://www.jianshu.com/p/0391a8e93d3d</a></li></ul><blockquote><p>欢迎关注我的公众号，一起学习，共同提高~<br><br><img src="https://user-gold-cdn.xitu.io/2019/2/22/16915a41d97876fc?w=304&amp;h=302&amp;f=jpeg&amp;s=46553" alt=""></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;千山鸟飞绝，万径人踪灭。&lt;/p&gt;
&lt;p&gt;孤舟蓑笠翁，独钓寒江雪&lt;/p&gt;
&lt;p&gt;——唐·柳宗元《江雪》&lt;/p&gt;
&lt;p&gt;首发于我的公众号&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="设计模式" scheme="https://xsfelvis.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://xsfelvis.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式精简图册</title>
    <link href="https://xsfelvis.github.io/2019/02/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B2%BE%E7%AE%80%E5%9B%BE%E5%86%8C/"/>
    <id>https://xsfelvis.github.io/2019/02/19/设计模式精简图册/</id>
    <published>2019-02-18T16:00:00.000Z</published>
    <updated>2019-02-19T16:00:59.407Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="设计模式精简图册"><a href="#设计模式精简图册" class="headerlink" title="设计模式精简图册"></a>设计模式精简图册</h1><blockquote><p>首发于我的公众号</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU5OTgzNzM0NA==&amp;tempkey=OTk2X1BicGw2U2lQRURlOVBhMUU3SklRenkyQW5lMF9xRWRWOHVjTlJyaE5yRGJrcVh1UElfU3VtOGxsdTVMSTRuREs0X0JJYVpvRGRFMUVheXNxMmJXZ3pJR0V3aUFDV3VpSWZIa09VZ2J3Nkw5Z19BVENlaHpZSkZvbEZ2UWNqZEVwbGE2WTRoVVZBQmZta1RqdzE4UTV2TFUwOG90WHlpTURuRmw2dWd%2Bfg%3D%3D&amp;chksm=7eaf9eac49d817baef4bd670f1571d475435e108ca8246731fb3c47c52cfccac32905e63d13f#rd" target="_blank" rel="noopener">设计模式图册</a></p></blockquote><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><h3 id="创建型模式："><a href="#创建型模式：" class="headerlink" title="创建型模式："></a>创建型模式：</h3><p>主要用于创建对象，包括</p><ul><li>工厂方法(Factory Method)</li><li>抽象工厂(Abstract Factory)</li><li>单例(Singleton)</li><li>生成器(Builder)</li><li><p>原型(Prototype)</p><h3 id="结构型模式："><a href="#结构型模式：" class="headerlink" title="结构型模式："></a>结构型模式：</h3><p>用于处理类或者对象的组合，包括</p></li><li><p>适配器(Adapter)</p></li><li>装饰者(Decorator)</li><li>代理(Proxy)</li><li>外观(Facade)</li><li>桥接(<span data-type="color" style="color:rgb(84, 84, 84)"><span data-type="background" style="background-color:rgb(255, 255, 255)">Bridge Pattern</span></span>)</li><li>组合(Composite)</li><li>轻量(<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">Flyweigh</span></span>)</li></ul><h3 id="行为型模式："><a href="#行为型模式：" class="headerlink" title="行为型模式："></a>行为型模式：</h3><p>用于描述类与对象怎样的交互和分配职责，包括</p><ul><li>策略(Strategy)</li><li>观察者(Observer)</li><li>命令(Command)</li><li>模板方法(Template Method)</li><li>迭代器(Iterator)</li><li>状态(State)</li><li>责任链(Chain)</li><li>解释器(Interpreter)</li><li>中介者(Mediator)</li><li>备忘录(Memo)</li><li>访问者(Visitor)</li></ul><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="单一职责原则-Single-responsibility-principle"><a href="#单一职责原则-Single-responsibility-principle" class="headerlink" title="单一职责原则(Single responsibility principle)"></a>单一职责原则(Single responsibility principle)</h3><ul><li>核心<br><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。</span></span></li><li>问题产生<br>类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。</li><li>解决方案<br>遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。</li></ul><p>但是由于职责扩散会导致在实际中往往会有悖于单一职责</p><h3 id="里氏代换原则-Liskov-Substitution-Principle-LSP"><a href="#里氏代换原则-Liskov-Substitution-Principle-LSP" class="headerlink" title="里氏代换原则(Liskov Substitution Principle LSP)"></a>里氏代换原则(Liskov Substitution Principle LSP)</h3><ul><li>核心<br><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">所有引用基类的地方必须能透明地使用其子类的对象。</span></span></li><li>问题产生<br>有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。</li><li>解决方案<br>当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。</li></ul><p>继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。</p><p>继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。</p><h3 id="接口隔离原则-Interface-Segregation-Principle"><a href="#接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="接口隔离原则(Interface Segregation Principle)"></a>接口隔离原则(Interface Segregation Principle)</h3><ul><li>核心<br><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上</span></span><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">。</span></span></li><li>问题产生<br><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。</span></span></li><li>解决方案<br><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。</span></span></li></ul><p>接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。</p><p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p><ul><li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li><li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li></ul><p>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</p><h3 id="迪米特原则-Law-of-Demeter-Least-Knowledge-Principle"><a href="#迪米特原则-Law-of-Demeter-Least-Knowledge-Principle" class="headerlink" title="迪米特原则(Law of Demeter/Least Knowledge Principle )"></a>迪米特原则(<span data-type="color" style="color:rgb(34, 34, 34)"><span data-type="background" style="background-color:rgb(255, 255, 255)">Law of Demeter/Least Knowledge Principle </span></span>)</h3><ul><li>核心<br><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">迪米特法则又叫最少知道原则，一个对象应该对其他对象保持最少的了解。</span></span></li><li>问题产生<br><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</span></span></li><li>解决方案<br><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">尽量降低类与类之间的耦合。</span></span></li></ul><p><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息，</span></span><br><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">迪米特法则还有一个更简单的定义：只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。</span></span></p><h3 id="依赖倒置原则（Dependence-Inversion-Principle）"><a href="#依赖倒置原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒置原则（Dependence Inversion Principle）"></a>依赖倒置原则（Dependence Inversion Principle）</h3><ul><li>核心<br><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</span></span></li><li>问题产生<br>类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。</li><li>解决方案<br><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。</span></span></li></ul><p>依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。</p><p>依赖倒置原则的核心思想是面向接口编程，</p><h3 id="开闭原则-Open-Close-Principle"><a href="#开闭原则-Open-Close-Principle" class="headerlink" title="开闭原则(Open Close Principle)"></a>开闭原则(Open Close Principle)</h3><ul><li>核心<br><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</span></span></li><li>问题产生<br><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。</span></span></li><li>解决方案<br>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</li></ul><p><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">开闭原则无非就是想表达这样一层意思：用抽象构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。</span></span></p><h2 id="几个原则的关联性"><a href="#几个原则的关联性" class="headerlink" title="几个原则的关联性"></a>几个原则的关联性</h2><p><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">用抽象构建框架，用实现扩展细节的注意事项而已：</span></span></p><ul><li><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">单一职责原则告诉我们实现类要职责单一；</span></span></li><li><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">里氏替换原则告诉我们不要破坏继承体系；</span></span></li><li><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">依赖倒置原则告诉我们要面向接口编程；</span></span></li><li><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">接口隔离原则告诉我们在设计接口的时候要精简单一；</span></span></li><li><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">迪米特法则告诉我们要降低耦合。</span></span><br><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。</span></span></li></ul><h2 id="创建型设计模式-创建对象"><a href="#创建型设计模式-创建对象" class="headerlink" title="创建型设计模式(创建对象)"></a>创建型设计模式(创建对象)</h2><h3 id="工厂方法-Factory-Method-Pattern"><a href="#工厂方法-Factory-Method-Pattern" class="headerlink" title="工厂方法(Factory Method Pattern)"></a>工厂方法(Factory Method Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="90px"><br>      <col width="740px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Factory Method</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/169066ffce5cc3db?w=525&h=177&f=gif&s=4810" data-width="525"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/169066ffce5cc3db?w=525&h=177&f=gif&s=4810" width="525"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当一个类不知道它所必须创建的对象的类的时候。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当一个类希望由它的子类来指定它所创建的对象的时候。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">在工厂方法中，用户只需要知道所要产品的具体工厂，无须关系具体的创建过程，甚至不需要具体产品类的类名。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p"> 在系统增加新的产品时，我们只需要添加一个具体产品类和对应的实现工厂，无需对原工厂进行任何修改，很好地符合了“开闭原则”。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">每次增加一个产品时，都需要增加一个具体类和对象实现工厂，是的系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p"> 简单工厂模式的要点就在于当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p"> 简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，但是如果产品过多时，会导致工厂代码非常复杂。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="抽象工厂-Abstract-Factory-Pattern"><a href="#抽象工厂-Abstract-Factory-Pattern" class="headerlink" title="抽象工厂(Abstract Factory Pattern)"></a>抽象工厂(Abstract Factory Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="94px"><br>      <col width="736px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Abstract Factory</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/169066ffce813741?w=568&h=253&f=gif&s=9088" data-width="568"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/169066ffce813741?w=568&h=253&f=gif&s=9088" width="568"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">一个系统要独立于它的产品的创建、组合和表示时。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">一个系统要由多个产品系列中的一个来配置时。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当你要强调一系列相关的产品对象的设计以便进行联合使用时。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当你提供一个产品类库，而只想显示它们的接口而不是实现时。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">抽象工厂隔离了具体类的生成，是的客户端不需要知道什么被创建。所有的具体工厂都实现了抽象工厂中定义的公共接口，因此只需要改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">添加新的行为时比较麻烦。如果需要添加一个新产品族对象时，需要更改接口及其下所有子类，这必然会带来很大的麻烦。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">抽象工厂模式中主要的优点在于具体类的隔离，是的客户端不需要知道什么被创建了。其缺点在于增加新的等级产品结构比较复杂，需要修改接口及其所有子类。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="生成器-建造者模式-Builder-Pattern"><a href="#生成器-建造者模式-Builder-Pattern" class="headerlink" title="生成器/建造者模式(Builder Pattern)"></a>生成器/建造者模式(Builder Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="100px"><br>      <col width="730px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Builder</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/169066ffcfb3a6e6?w=568&h=200&f=gif&s=4696" data-width="568"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/169066ffcfb3a6e6?w=568&h=200&f=gif&s=4696" width="568"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当构造过程必须允许被构造的对象有不同的表示时。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，使得我们能够更加精确的控制复杂对象的产生过程。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">将产品的创建过程与产品本身分离开来，可以使用相同的创建过程来得到不同的产品。也就说细节依赖抽象。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">建造者模式是将一个复杂对象的创建过程给封装起来，客户只需要知道可以利用对象名或者类型就能够得到一个完整的对象实例，而不需要关心对象的具体创建过程。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">建造者模式将对象的创建过程与对象本身隔离开了，使得细节依赖于抽象，符合依赖倒置原则。可以使用相同的创建过程来创建不同的产品对象。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="原型模式-Prototype-Pattern"><a href="#原型模式-Prototype-Pattern" class="headerlink" title="原型模式(Prototype Pattern)"></a>原型模式(Prototype Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="105px"><br>      <col width="725px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Prototype</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/169066ffcef96639?w=518&h=242&f=gif&s=5229" data-width="518"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/169066ffcef96639?w=518&h=242&f=gif&s=5229" width="518"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当要实例化的类是在运行时刻指定时，例如，通过动态装载；或者</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">为了避免创建一个与产品类层次平行的工厂类层次时；或者</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">如果创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">可以使用深克隆保持对象的状态。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">原型模式提供了简化的创建结构。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">在实现深克隆的时候可能需要比较复杂的代码。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">需要为每一个类配备一个克隆方法，而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事，必须修改其源代码，违背了“开闭原则”。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">原型模式向客户隐藏了创建对象的复杂性。客户只需要知道要创建对象的类型，然后通过请求就可以获得和该对象一模一样的新对象，无须知道具体的创建过程。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">克隆分为浅克隆和深克隆两种。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">我们虽然可以利用原型模式来获得一个新对象，但有时对象的复制可能会相当的复杂，比如深克隆。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="单例模式-Singleton-Pattern"><a href="#单例模式-Singleton-Pattern" class="headerlink" title="单例模式(Singleton Pattern)"></a>单例模式(Singleton Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="110px"><br>      <col width="720px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Singleton</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/169066ffd087c1e5?w=394&h=146&f=gif&s=3706" data-width="394"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/169066ffd087c1e5?w=394&h=146&f=gif&s=3706" width="394"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">保证一个类仅有一个实例，并提供一个访问它的全局访问点。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">节约了系统资源。由于系统中只存在一个实例对象，对与一些需要频繁创建和销毁对象的系统而言，单 例模式无疑节约了系统资源和提高了系统的性能。<br>              </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">单例类的职责过重，在一定程度上违背了“单一职责原则”。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">单例模式中确保程序中一个类最多只有一个实例。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">单例模式的构造器是私有了，而且它必须要提供实例的全局访问点。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">单例模式可能会因为多线程的问题而带来安全隐患。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BetterSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BetterSingleton2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BetterSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.BETTER_SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>​ <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span>  BetterSingleton BETTER_SINGLETON = <span class="keyword">new</span> BetterSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建型设计模式小结"><a href="#创建型设计模式小结" class="headerlink" title="创建型设计模式小结"></a>创建型设计模式小结</h3><table><thead><tr><th style="text-align:left"><strong>模式</strong></th><th>场景发散</th><th style="text-align:left"><strong>一句话概括</strong></th></tr></thead><tbody><tr><td style="text-align:left">工厂方法(Factory Method)</td><td>new太多如何管理</td><td style="text-align:left">生产系列产品。</td></tr><tr><td style="text-align:left">抽象工厂(Abstract Factory)</td><td>new太多如何管理</td><td style="text-align:left">一次生产多个不同产品。</td></tr><tr><td style="text-align:left">生成器(Builder)</td><td>车手选车</td><td style="text-align:left">生产有很多组件的产品。</td></tr><tr><td style="text-align:left">原型(Prototype)</td><td>复制不能很难</td><td style="text-align:left">克隆对象。</td></tr><tr><td style="text-align:left">单件(Singleton)</td><td>如何管理全局信息</td><td style="text-align:left">全局只有一个。</td></tr></tbody></table><h2 id="结构型设计模式-处理类或者对象的组合"><a href="#结构型设计模式-处理类或者对象的组合" class="headerlink" title="结构型设计模式(处理类或者对象的组合)"></a>结构型设计模式(处理类或者对象的组合)</h2><h3 id="桥接模式-Bridge-Pattern"><a href="#桥接模式-Bridge-Pattern" class="headerlink" title="桥接模式(Bridge Pattern)"></a>桥接模式(Bridge Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="131px"><br>      <col width="699px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Bridge</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/169066ffd161b914?w=600&h=246&f=gif&s=5880" data-width="600"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/169066ffd161b914?w=600&h=246&f=gif&s=5880" width="600"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">将抽象部分与它的实现部分分离，使它们都可以独立地变化。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">分离抽象接口及其实现部分。提高了比继承更好的解决方案。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">实现细节对客户透明，可以对用户隐藏实现细节。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">桥接模式实现了抽象化与实现化的脱耦。他们两个互相独立，不会影响到对方。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">对于两个独立变化的维度，使用桥接模式再适合不过了。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">对于“具体的抽象类”所做的改变，是不会影响到客户。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="轻量模式-享元模式-FlyWeightPattern"><a href="#轻量模式-享元模式-FlyWeightPattern" class="headerlink" title="轻量模式/享元模式(FlyWeightPattern)"></a>轻量模式/享元模式(FlyWeightPattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="130px"><br>      <col width="700px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Flyweight</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/169066fff2baad07?w=598&h=369&f=gif&s=9534" data-width="598"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/169066fff2baad07?w=598&h=369&f=gif&s=9534" width="598"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">运用共享技术有效地支持大量细粒度的对象。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">一个应用程序使用了大量的对象。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">完全由于使用大量的对象，造成很大的存储开销。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">对象的大多数状态都可变为外部状态。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">应用程序不依赖于对象标识。由于F l y w e i g h t 对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">享元模式的优点在于它能够极大的减少系统中对象的个数。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">享元模式由于使用了外部状态，外部状态相对独立，不会影响到内部状态，所以享元模式使得享元对象能够在不同的环境被共享。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">由于享元模式需要区分外部状态和内部状态，使得应用程序在某种程度上来说更加复杂化了。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。 </div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">享元模式可以极大地减少系统中对象的数量。但是它可能会引起系统的逻辑更加复杂化。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">享元模式的核心在于享元工厂，它主要用来确保合理地共享享元对象。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">内部状态为不变共享部分，存储于享元享元对象内部，而外部状态是可变部分，它应当由客户端来负责。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="外观模式-Facade-Pattern"><a href="#外观模式-Facade-Pattern" class="headerlink" title="外观模式(Facade Pattern)"></a>外观模式(Facade Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="130px"><br>      <col width="700px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Facade</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/169066fff3c18dd3?w=476&h=185&f=gif&s=3356" data-width="476"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/169066fff3c18dd3?w=476&h=185&f=gif&s=3356" width="476"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">为子系统中的一组接口提供一个一致的界面，F a c a d e 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。F a c a d e 可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过f a c a d e 层。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">客户程序与抽象类的实现部分之间存在着很大的依赖性。引入f a c a d e 将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当你需要构建一个层次结构的子系统时，使用f a c a d e 模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过f a c a d e 进行通讯，从而简化了它们之间的依赖关系。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">引入外观模式，是客户对子系统的使用变得简单了，减少了与子系统的关联对象，实现了子系统与客户之间的松耦合关系。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p"> 外观模式的主要优点就在于减少了客户与子系统之间的关联对象，使用客户对子系统的使用变得简单了，也实现了客户端与子系统之间的松耦合关系。它的缺点就在于违背了“开闭原则”。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">如果需要实现一个外观模式，需要将子系统组合进外观中，然后将工作委托给子系统执行。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="装饰者模式-Decorator-Pattern"><a href="#装饰者模式-Decorator-Pattern" class="headerlink" title="装饰者模式(Decorator Pattern)"></a>装饰者模式(Decorator Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="134px"><br>      <col width="696px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Decorator</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/1690670008f047fb?w=645&h=285&f=gif&s=7475" data-width="645"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/1690670008f047fb?w=645&h=285&f=gif&s=7475" width="645"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动态地给一个对象添加一些额外的职责。就增加功能来说，D e c o r a t o r 模式相比生成子类更为灵活。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">处理那些可以撤消的职责。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">装饰者模式可以提供比继承更多的灵活性</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">可以通过一种动态的方式来扩展一个对象的功能，在运行时选择不同的装饰器，从而实现不同的行为。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">会产生很多的小对象，增加了系统的复杂性</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">装饰者模式意味着一群装饰者类，这些类用来包装具体组件</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">装饰者可以在被装饰者的行为前面或者后面加上自己的行为，甚至可以将被装饰者的行为整个取代掉，从而达到特定的目的。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">可以用多个装饰者包装一个组件。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">装饰者一般对于组件的客户是透明的，除非客户程序依赖于组件的具体类型。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">装饰者会导致设计中出现许多的小对象，如果过度的使用，会让系统变得更加复杂。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">装饰者和被装饰者对象有相同的超类型。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="组合模式-Composite-Pattern"><a href="#组合模式-Composite-Pattern" class="headerlink" title="组合模式(Composite Pattern)"></a>组合模式(Composite Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="139px"><br>      <col width="691px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Composite</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/169067000a66785d?w=571&h=257&f=gif&s=6139" data-width="571"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/169067000a66785d?w=571&h=257&f=gif&s=6139" width="571"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">将对象组合成树形结构以表示?部分-整体?的层次结构。C o m p o s i t e 使得用户对单个对象和组合对象的使用具有一致性。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">你想表示对象的部分-整体层次结构。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，使得增加新构件也更容易。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">客户端调用简单，客户端可以一致的使用组合结构或其中单个对象。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">定义了包含叶子对象和容器对象的类层次结构，叶子对象可以被组合成更复杂的容器对象，而这个容器对象又可以被组合，这样不断递归下去，可以形成复杂的树形结构。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">更容易在组合体内加入对象构件，客户端不必因为加入了新的对象构件而更改原有代码。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">使设计变得更加抽象，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象子类都有关联，会有冗余代码</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p"> 组合模式用于将多个对象组合成树形结构以表示“整体-部分”的结构层次。组合模式对单个对象（叶子对象）和组合对象（容器对象）的使用具有一致性。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">组合对象的关键在于它定义了一个抽象构建类，它既可表示叶子对象，也可表示容器对象，客户仅仅需要针对这个抽象构建进行编程，无须知道他是叶子对象还是容器对象，都是一致对待。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p"> 组合模式虽然能够非常好地处理层次结构，也使得客户端程序变得简单，但是它也使得设计变得更加抽象，而且也很难对容器中的构件类型进行限制，这会导致在增加新的构件时会产生一些问题。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="代理模式-Proxy-Pattern"><a href="#代理模式-Proxy-Pattern" class="headerlink" title="代理模式(Proxy Pattern)"></a>代理模式(Proxy Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="140px"><br>      <col width="690px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Proxy</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/169067000f5e737e?w=540&h=226&f=gif&s=4257" data-width="540"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/169067000f5e737e?w=540&h=226&f=gif&s=4257" width="540"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">为其他对象提供一种代理以控制对这个对象的访问。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">不希望某些类被直接访问。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">访问之前希望先进行一些预处理。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">希望对被访问的对象进行内存、权限等方面的控制。 模式。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了的作用和保护了目标对象的</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">代理模式是通过使用引用代理对象来访问真实对象，在这里代理对象充当用于连接客户端和真实对象的中介者。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">代理模式主要用于远程代理、虚拟代理和保护代理。其中保护代理可以进行访问权限控制。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="适配器模式-Adapter-Pattern"><a href="#适配器模式-Adapter-Pattern" class="headerlink" title="适配器模式(Adapter Pattern)"></a>适配器模式(Adapter Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="150px"><br>      <col width="680px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Adapter</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/169067001155f956?w=524&h=197&f=gif&s=4173" data-width="524"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/169067001155f956?w=524&h=197&f=gif&s=4173" width="524"><br>            </div><pre><code>        &lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;center&quot; data-src=&quot;http://www.uml.org.cn/chanpin/intro/WebHelp/Adapter_Class.gif&quot; data-width=&quot;543&quot;&gt;          &lt;img src=&quot;http://www.uml.org.cn/chanpin/intro/WebHelp/Adapter_Class.gif&quot; width=&quot;543&quot; /&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td rowspan=&quot;1&quot; colSpan=&quot;1&quot;&gt;      &lt;div data-type=&quot;p&quot;&gt;动机&lt;/div&gt;    &lt;/td&gt;    &lt;td rowspan=&quot;1&quot; colSpan=&quot;1&quot;&gt;      &lt;div data-type=&quot;p&quot;&gt;将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。&lt;/div&gt;    &lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td rowspan=&quot;1&quot; colSpan=&quot;1&quot;&gt;      &lt;div data-type=&quot;p&quot;&gt;适用性&lt;/div&gt;    &lt;/td&gt;    &lt;td rowspan=&quot;1&quot; colSpan=&quot;1&quot;&gt;      &lt;ul data-type=&quot;unordered-list&quot;&gt;        &lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;          &lt;div data-type=&quot;p&quot;&gt;你想使用一个已经存在的类，而它的接口不符合你的需求。&lt;/div&gt;        &lt;/li&gt;        &lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;          &lt;div data-type=&quot;p&quot;&gt;你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。&lt;/div&gt;        &lt;/li&gt;        &lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;          &lt;div data-type=&quot;p&quot;&gt;（仅适用于对象Adapter ）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。&lt;/div&gt;        &lt;/li&gt;      &lt;/ul&gt;    &lt;/td&gt;  &lt;/tr&gt;  &lt;tr height=&quot;34px&quot;&gt;    &lt;td rowspan=&quot;1&quot; colSpan=&quot;1&quot;&gt;      &lt;div data-type=&quot;p&quot;&gt;优点&lt;/div&gt;    &lt;/td&gt;    &lt;td rowspan=&quot;1&quot; colSpan=&quot;1&quot;&gt;      &lt;ul data-type=&quot;unordered-list&quot;&gt;        &lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;          &lt;div data-type=&quot;p&quot;&gt;将目标类和适配者类解耦，通过使用适配器让不兼容的接口变成了兼容，让客户从实现的接口解耦。&lt;/div&gt;        &lt;/li&gt;        &lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;          &lt;div data-type=&quot;p&quot;&gt;增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。&lt;/div&gt;        &lt;/li&gt;        &lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;          &lt;div data-type=&quot;p&quot;&gt;灵活性和扩展性都非常好在不修改原有代码的基础上增加新的适配器类，符合“开闭原则”。&lt;/div&gt;        &lt;/li&gt;      &lt;/ul&gt;    &lt;/td&gt;  &lt;/tr&gt;  &lt;tr height=&quot;34px&quot;&gt;    &lt;td rowspan=&quot;1&quot; colSpan=&quot;1&quot;&gt;      &lt;div data-type=&quot;p&quot;&gt;缺点&lt;/div&gt;    &lt;/td&gt;    &lt;td rowspan=&quot;1&quot; colSpan=&quot;1&quot;&gt;      &lt;ul data-type=&quot;unordered-list&quot;&gt;        &lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;          &lt;div data-type=&quot;p&quot;&gt;过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。&lt;/div&gt;        &lt;/li&gt;        &lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;          &lt;div data-type=&quot;p&quot;&gt;因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。&lt;/div&gt;        &lt;/li&gt;      &lt;/ul&gt;    &lt;/td&gt;  &lt;/tr&gt;  &lt;tr height=&quot;34px&quot;&gt;    &lt;td rowspan=&quot;1&quot; colSpan=&quot;1&quot;&gt;      &lt;div data-type=&quot;p&quot;&gt;小结&lt;/div&gt;    &lt;/td&gt;    &lt;td rowspan=&quot;1&quot; colSpan=&quot;1&quot;&gt;      &lt;ul data-type=&quot;unordered-list&quot;&gt;        &lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;          &lt;div data-type=&quot;p&quot;&gt;当我们需要使用的一个现有的类，但是他的接口并不符合我们的需求时，我们可以使用适配器模式。&lt;/div&gt;        &lt;/li&gt;        &lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;          &lt;div data-type=&quot;p&quot;&gt;适配器模式分为类适配器和对象适配器，其中类适配器需要用到多重继承。&lt;/div&gt;        &lt;/li&gt;      &lt;/ul&gt;    &lt;/td&gt;  &lt;/tr&gt;&lt;/tbody&gt;</code></pre><p>  </p></div></td></tr></tbody></table><br></div><p></p><h3 id="结构型设计模式小结"><a href="#结构型设计模式小结" class="headerlink" title="结构型设计模式小结"></a>结构型设计模式小结</h3><table><thead><tr><th style="text-align:left">模式</th><th>场景发散</th><th style="text-align:left">一句话说明</th></tr></thead><tbody><tr><td style="text-align:left">桥(Bridge)</td><td>麻烦的日志记录</td><td style="text-align:left">将“抽象”和“实现”自由搭配。</td></tr><tr><td style="text-align:left">轻量(Flyweight)</td><td>森林里的树太多了</td><td style="text-align:left">轻松地处理“大量”对象。</td></tr><tr><td style="text-align:left">外观(Façade)</td><td>超级手机</td><td style="text-align:left">同时提供简单接口和复杂接口。</td></tr><tr><td style="text-align:left">装饰者(Decorator)</td><td>星巴克的饮料计较系统</td><td style="text-align:left">不改变接口但要增强功能。</td></tr><tr><td style="text-align:left">组合(Composite)</td><td>超酷的绘图软件</td><td style="text-align:left">不管你是老子还是儿子，都一样处理。</td></tr><tr><td style="text-align:left">代理(Proxy)</td><td>找中介租房</td><td style="text-align:left">代理要控制你的访问，同时让你的访问更舒服 。</td></tr><tr><td style="text-align:left">适配器(Adapter)</td><td>老掉牙系统的重生</td><td style="text-align:left">不改变功能但要改变接口</td></tr></tbody></table><h2 id="行为型设计模式-类与对象怎样的交互和分配职责"><a href="#行为型设计模式-类与对象怎样的交互和分配职责" class="headerlink" title="行为型设计模式(类与对象怎样的交互和分配职责)"></a>行为型设计模式(类与对象怎样的交互和分配职责)</h2><h3 id="观察者模式-Observer-Pattern"><a href="#观察者模式-Observer-Pattern" class="headerlink" title="观察者模式(Observer Pattern)"></a>观察者模式(Observer Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="145px"><br>      <col width="685px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Observer</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/1690670017eda10c?w=615&h=243&f=gif&s=7719" data-width="615"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/1690670017eda10c?w=615&h=243&f=gif&s=7719" width="615"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之, 你不希望这些对象是紧密耦合的。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当两个对象之间送耦合，他们依然可以交互，但是不太清楚彼此的细节。观察者模式提供了一种对象设计，让主题和观察者之间送耦合。主题所知道只是一个具体的观察者列表，每一个具体观察者都符合一个抽象观察者的接口。主题并不认识任何一个具体的观察者，它只知道他们都有一个共同的接口。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">观察者模式支持“广播通信”。主题会向所有的观察者发出通知。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">观察者模式符合“开闭原则”的要求。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进 行循环调用，可能导致系统崩溃。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">观察者模式定义了对象之间的一对多关系。多个观察者监听同一个被观察者，当该被观察者的状态发生改变时，会通知所有的观察者。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">观察者模式中包含四个角色。主题，它指被观察的对象。具体主题是主题子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；观察者，将对观察主题的改变做出反应；具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="策略模式-Strategy-Pattern"><a href="#策略模式-Strategy-Pattern" class="headerlink" title="策略模式(Strategy Pattern)"></a>策略模式(Strategy Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="150px"><br>      <col width="680px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Strategy</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/16906700244d00fb?w=539&h=186&f=gif&s=5220" data-width="539"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/16906700244d00fb?w=539&h=186&f=gif&s=5220" width="539"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">许多相关的类仅仅是行为有异。策略模式提供了一种用多个行为中的一个行为来配置一个类的方法。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">需要使用一个算法的不同变体。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">一个类定义了多种行为, 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的S t r a t e g y 类中以代替这些条件语句。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">策略模式提供了可以替换继承关系的办法。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">使用策略模式可以避免使用多重条件转移语句。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">客户端必须知道所有的策略类，并自行决定使用哪一个策略类。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">策略模式将造成产生很多策略类，</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">一个系统需要动态地在几种算法中选择一种。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="迭代器模式-Iterator-Pattern"><a href="#迭代器模式-Iterator-Pattern" class="headerlink" title="迭代器模式(Iterator Pattern)"></a>迭代器模式(Iterator Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="152px"><br>      <col width="678px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Iterator</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/169067001fb0546f?w=560&h=276&f=gif&s=5453" data-width="560"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/169067001fb0546f?w=560&h=276&f=gif&s=5453" width="560"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">访问一个聚合对象的内容而无需暴露它的内部表示。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">支持对聚合对象的多种遍历。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">为遍历不同的聚合结构提供一个统一的接口(即, 支持多态迭代)。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">它支持以不同的方式遍历一个聚合对象。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">迭代器简化了聚合类。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">在同一个聚合上可以有多个遍历。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">将遍历聚合对象中数据的行为提取出来，封装到一个迭代器中，通过专门的迭代器来遍历聚合对象的内部数据，这就是迭代器模式的本质。迭代器模式是“单一职责原则”的完美体现。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当使用迭代器的时候，我们依赖聚合提供遍历。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">迭代器提供了一个通用的接口，让我们遍历聚合的项，放我们编码使用聚合项时，就可以使用多态机制。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="命令模式-Command-Pattern"><a href="#命令模式-Command-Pattern" class="headerlink" title="命令模式(Command Pattern)"></a>命令模式(Command Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="160px"><br>      <col width="670px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Command</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="left" data-src="https://user-gold-cdn.xitu.io/2019/2/19/1690670025102900?w=603&h=212&f=gif&s=4649" data-width="603"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/1690670025102900?w=603&h=212&f=gif&s=4649" width="603"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">抽象出待执行的动作以参数化某对象，你可用过程语言中的回调（c a l l b a c k ）函数表达这种参数化机制。所谓回调函数是指函数先在某处注册，而它将在稍后某个需要的时候被调用。C o m m a n d 模式是回调机制的一个面向对象的替代品。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">在不同的时刻指定、排列和执行请求。一个C o m m a n d 对象可以有一个与初始请求无关的生存期。如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可将负责该请求的命令对象传送给另一个不同的进程并在那儿实现该请求。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">支持取消操作。C o m m a n d 的E x c u t e 操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。C o m m a n d 接口必须添加一个U n e x e c u t e 操作，该操作取消上一次E x e c u t e 调用的效果。执行的命令被存储在一个历史列表中。可通过向后和向前遍历这一列表并分别调用U n e x e c u t e 和E x e c u t e 来实现重数不限的取消和重做。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍。在C o m m a n d 接口中添加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。从崩溃中恢复的过程包括从磁盘中重新读入记录下来的命令并用E x e c u t e 操作重新执行它们。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">用构建在原语操作上的高层操作构造一个系统。这样一种结构在支持事务( t r a n s a c t i o n )的信息系统中很常见。一个事务封装了对数据的一组变动。C o m m a n d 模式提供了对事务进行建模的方法。C o m m a n d 有一个公共的接口，使得你可以用同一种方式调用所有的事务。同时使用该模式也易于添加新事务以扩展系统。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">降低了系统耦合度</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">新的命令可以很容易添加到系统中去。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">使用命令模式可能会导致某些系统有过多的具体命令类。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">命令模式的本质就是将命令对象进行封装打包，将发出命令的责任和执行命令的责任进行割开。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">命令模式中发送者只需要知道如何发送请求命令，无须关心命令执行具体过程。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">在发送者和接收者两者间是通过命令对象进行沟通的。请求命令本身就当做一个对象在两者间进行传递，它封装了接收者和一组动作。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p"> 命令模式支持撤销。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">命令模式队列请求和日志请求。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="访问者模式-Visitor-Pattern"><a href="#访问者模式-Visitor-Pattern" class="headerlink" title="访问者模式(Visitor Pattern)"></a>访问者模式(Visitor Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="89px"><br>      <col width="668px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Visitor</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/16906700257347dc?w=536&h=417&f=gif&s=11308" data-width="536"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/16906700257347dc?w=536&h=417&f=gif&s=11308" width="536"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作?污染?这些对象的类。Vi s i t o r 使得你可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用Vi s i t o r 模式让每个应用仅包含需要用到的操作。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">使得新增新的访问操作变得更加简单。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">能够使得用户在不修改现有类的层次结构下，定义该类层次结构的操作。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">将有关元素对象的访问行为集中到一个访问者对象中，而不是分散搞一个个的元素类中。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">增加新的元素类很困难。在访问者模式中，每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，违背了“开闭原则”的要求。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">破坏封装。当采用访问者模式的时候，就会打破组合类的封装。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">1.SomeClass 的 Accept()方法就是访问原来类的小口， Accept()方法只有一句代码，就是: visitor.NewMethod(this) ，这是访问者模式的精妙之处。 2.SomeClass 的新功能通过实现 IVisitor 接口的类来实现。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">访问者模式封装了对象结构元素之上的操作，使得新增元素的操作变得非常简单。所以它比较适用于那么对象结构很少变化的类。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">访问者模式中对象结构存储了不同类型的元素对象，以供不同访问者访问。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="解释器模式-Interpreter-Pattern"><a href="#解释器模式-Interpreter-Pattern" class="headerlink" title="解释器模式(Interpreter Pattern)"></a>解释器模式(Interpreter Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="154px"><br>      <col width="596px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Interpreter</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/1690670030b73b10?w=450&h=242&f=gif&s=4615" data-width="450"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/1690670030b73b10?w=450&h=242&f=gif&s=4615" width="450"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当有一个语言需要解释执行, 并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。而当存在以下情况时该模式效果最好：</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">该文法简单对于复杂的文法, 文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无需构建抽象语法树即可解释表达式, 这样可以节省空间而且还可能节省时间。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的, 而是首先将它们转换成另一种形式。例如，正则表达式通常被转换成状态机。但即使在这种情况下, 转换器仍可用解释器模式实现, 该模式仍是有用的。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">可扩展性比较好，灵活。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">增加了新的解释表达式的方式。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">易于实现文法。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">执行效率比较低，可利用场景比较少。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">对于复杂的文法比较难维护。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">在解释器模式中由于语法是由很多类表示的，所以可扩展性强。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">虽然解释器的可扩展性强，但是如果语法规则的数目太大的时候，该模式可能就会变得异常复杂。所以解释器模式适用于文法较为简单的。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">解释器模式可以处理脚本语言和编程语言。常用于解决某一特定类型的问题频繁发生情况。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="中介者模式-Mediator-Pattern"><a href="#中介者模式-Mediator-Pattern" class="headerlink" title="中介者模式(Mediator Pattern)"></a>中介者模式(Mediator Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="130px"><br>      <col width="620px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Mediator</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/1690670033512cc2?w=535&h=166&f=gif&s=3603" data-width="535"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/1690670033512cc2?w=535&h=166&f=gif&s=3603" width="535"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">一个对象引用其他很多对象并且直接与这些对象通信,导致难以复用该对象。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">想定制一个分布在多个类中的行为，而又不想生成太多的子类。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p"> 简化了对象之间的关系，将系统的各个对象之间的相互关系进行封装，将各个同事类解耦，使系统成为松耦合系统。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p"> 减少了子类的生成。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">可以减少各同事类的设计与实现。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">由于中介者对象封装了系统中对象之间的相互关系，导致其变得非常复杂，使得系统维护比较困难。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">每个控件不需要直接和别的控件打交道，只需要知道中介者就可以了。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">每个控件都需要保持保持中介者的引用，而中介者不一定需要保持每个控件的引用</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">Mediator 的代码可能很复杂。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="备忘录模式-Memento-Pattern"><a href="#备忘录模式-Memento-Pattern" class="headerlink" title="备忘录模式(Memento Pattern)"></a>备忘录模式(Memento Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="129px"><br>      <col width="621px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Mediator</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/1690670033512cc2?w=535&h=166&f=gif&s=3603" data-width="535"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/1690670033512cc2?w=535&h=166&f=gif&s=3603" width="535"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">一个对象引用其他很多对象并且直接与这些对象通信,导致难以复用该对象。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">想定制一个分布在多个类中的行为，而又不想生成太多的子类。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">给用户提供了一种可以恢复状态的机制。可以是用户能够比较方便地回到某个历史的状态。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">实现了信息的封装。使得用户不需要关心状态的保存细节。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">到需要保存对象多个状态，并且可以恢复到任意状态，可考虑备忘录模式。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">将对象、对象状态和状态的保存办法分离，设计上会更加灵活。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">但对象属性的备份、恢复、保存等动作，都是可能比较耗时的。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">备忘录模式只是提供了保存对象状态的一种解决方案框架 ，真正应用时还需要解决这些 问题:1.如何设计 Memento? 2.怎样保存多个对象? 3.怎样保存组织成树结构的多个对象?</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="模板方法模式-TemplateMethod-Pattern"><a href="#模板方法模式-TemplateMethod-Pattern" class="headerlink" title="模板方法模式(TemplateMethod Pattern)"></a>模板方法模式(TemplateMethod Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="152px"><br>      <col width="598px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Template Method</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/1690670043aff038?w=395&h=225&f=gif&s=4901" data-width="395"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/1690670043aff038?w=395&h=225&f=gif&s=4901" width="395"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Te m p l a t e M e t h o d 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">算法的骨架是不变的，但其中的步骤实现可能有变化，这时可应用模板方法。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">模板方法模式在定义了一组算法，将具体的实现交由子类负责。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">模板方法模式是一种代码复用的基本技术。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">模板方法模式导致一种反向的控制结构，通过一个父类调用其子类的操作，通过对子类的扩展增加新的行为，符合“开闭原则”。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">每一个不同的实现都需要一个子类来实现，导致类的个数增加，是的系统更加庞大。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">模板方法模式定义了算法的步骤，将这些步骤的实现延迟到了子类。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">模板方法模式为我们提供了一种代码复用的重要技巧。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">模板方法模式的抽象类可以定义抽象方法、具体方法和钩子。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">为了防止子类改变算法的实现步骤，我们可以将模板方法声明为final。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="状态模式-State-Pattern"><a href="#状态模式-State-Pattern" class="headerlink" title="状态模式(State Pattern)"></a>状态模式(State Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="153px"><br>      <col width="597px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>State</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/1690670043f86963?w=472&h=190&f=gif&s=4128" data-width="472"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/1690670043f86963?w=472&h=190&f=gif&s=4128" width="472"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常, 有多个操作包含这一相同的条件结构。S t a t e模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">封装了转换规则。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">枚举可能的状态，在枚举状态之前需要确定状态种类。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">状态模式的使用必然会增加系统类和对象的个数。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">状态模式允许一个对象基于内部状态而拥有不同的行为。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">Context会将行为委托给当前状态对象。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">状态模式对“开闭原则”支持不是很好。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="责任链模式-Chain-of-Responsibility-Pattern"><a href="#责任链模式-Chain-of-Responsibility-Pattern" class="headerlink" title="责任链模式(Chain of Responsibility Pattern)"></a>责任链模式(Chain of Responsibility Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="156px"><br>      <col width="594px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Chain of Responsibility</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/169067004412f3b7?w=412&h=218&f=gif&s=3962" data-width="412"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/169067004412f3b7?w=412&h=218&f=gif&s=3962" width="412"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">可处理一个请求的对象集合应被动态指定。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">降低耦合度。它将请求的发送者和接受者解耦。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">简化了对象。使得对象不需要知道链的结构。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">增加新的请求处理类很方便。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">不能保证请求一定被接收。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">系统性能将受到一定影响，而且在进行代码调试时不太方便；可能会造成循环调用</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">可能不容易观察运行时的特征，有碍于除错。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">职责链模式将请求的发送者和接受者解耦了。客户端不需要知道请求处理者的明确信息，甚至不需要知道链的结构，它只需要将请求进行发送即可。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">职责链模式能够非常方便的动态增加新职责或者删除职责。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">客户端发送的请求可能会得不到处理。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">处理者不需要知道链的结构，只需要明白他的后续者是谁就可以了。这样就简化了系统中的对象。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="行为型设计模式小结"><a href="#行为型设计模式小结" class="headerlink" title="行为型设计模式小结"></a>行为型设计模式小结</h3><table><thead><tr><th style="text-align:left">模式</th><th>场景发散</th><th style="text-align:left">一句话说明</th></tr></thead><tbody><tr><td style="text-align:left">观察者(Observer)</td><td>同步更新的问题</td><td style="text-align:left">一呼百应。</td></tr><tr><td style="text-align:left">策略(Strategy)</td><td>设计你的战士</td><td style="text-align:left">分离算法。</td></tr><tr><td style="text-align:left">迭代器(Iterator)</td><td>集合访问的烦恼</td><td style="text-align:left">以一致的方式访问集合， “松绑 ”遍历算法代码。</td></tr><tr><td style="text-align:left">命令(Command)</td><td>神奇的Do与Undo</td><td style="text-align:left">分离功能调用者与功能实现者。</td></tr><tr><td style="text-align:left">访问者(Visitor)</td><td>增加新方法的烦恼</td><td style="text-align:left">不改变对象结构增加新方法。</td></tr><tr><td style="text-align:left">解释器(Interpreter)</td><td>超级表达解释引擎</td><td style="text-align:left">语法解释。</td></tr><tr><td style="text-align:left">中介者(Mediator)</td><td>麻烦的多角关系</td><td style="text-align:left">处理多对多关系。</td></tr><tr><td style="text-align:left">备忘录(Memento)</td><td>假如一切可以重来</td><td style="text-align:left">保存对象的多个状态并可任意恢复。</td></tr><tr><td style="text-align:left">模板方法(Template Method)</td><td>万能的排序器</td><td style="text-align:left">定义好框架算法 ，某些步骤可自己定义 。</td></tr><tr><td style="text-align:left">状态(State)</td><td>是攻击还是逃走</td><td style="text-align:left">方便地处理不同状态不同行为，以及状态之间的转换。</td></tr><tr><td style="text-align:left">责任链(Chain)</td><td>邮件自动处理系统</td><td style="text-align:left">用不同的规则去处理请求。</td></tr></tbody></table><h2 id="模式比较"><a href="#模式比较" class="headerlink" title="模式比较"></a>模式比较</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.uml.org.cn/sjms/201211023.asp" target="_blank" rel="noopener">http://www.uml.org.cn/sjms/201211023.asp</a></li><li><a href="http://www.cnblogs.com/chenssy/p/3357683.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenssy/p/3357683.html</a></li><li><a href="https://academy.realm.io/cn/posts/donn-felker-solid-part-1/" target="_blank" rel="noopener">https://academy.realm.io/cn/posts/donn-felker-solid-part-1/</a></li><li><a href="http://www.cnblogs.com/chenssy/p/3357683.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenssy/p/3357683.html</a></li><li>《硬啃设计模式》</li><li>《HeadFirst 设计模式》</li><li><p>GoF 《可复用面向对象软件的基础》</p><pre><code>欢迎关注我的公众号，一起学习，共同提高~</code></pre><p><img src="https://user-gold-cdn.xitu.io/2019/2/18/168ff71fee39e5cf?w=304&amp;h=302&amp;f=jpeg&amp;s=46553" alt="公众号小.jpg"></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;设计模式精简图册&quot;&gt;&lt;a href=&quot;#设计模式精简图册&quot; class=&quot;headerlink&quot; title=&quot;设计模式精简图册&quot;&gt;&lt;/a&gt;设计模式精简图册&lt;/h1
      
    
    </summary>
    
      <category term="设计模式" scheme="https://xsfelvis.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://xsfelvis.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Dart语法基础</title>
    <link href="https://xsfelvis.github.io/2019/01/13/Dart%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>https://xsfelvis.github.io/2019/01/13/Dart语法基础/</id>
    <published>2019-01-12T16:00:00.000Z</published>
    <updated>2019-01-13T14:46:12.554Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Dart语法基础"><a href="#Dart语法基础" class="headerlink" title="Dart语法基础"></a>Dart语法基础</h1><h1 id="Dart语言简介"><a href="#Dart语言简介" class="headerlink" title="Dart语言简介"></a>Dart语言简介</h1><p>在Dart官方网站上，对于Dart的描述如下：</p><blockquote><p>Developers at Google and elsewhere use Dart to create high-quality, mission-critical apps for iOS, Android, and the web. With features aimed at client-side development, Dart is a great fit for both mobile and web apps.<br>Google和其他地方的一些开发者使用Dart语言为Android、iOS和web构建高质量，关键任务的应用程序，针对客户端开发的特点，Dart非常适合移动和Web应用程序。</p></blockquote><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">Dart是Google推出的一门编程语言，最初是希望取代Javascript运行在浏览器端，后来慢慢发展成可以开发Android、iOS和Web端App的一门高质量的编程语言，目前Dart的版本是Dart2，官网是：</span></span><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.dartlang.org%2F" target="_blank" rel="noopener">www.dartlang.org/</a></p><p>更加详细的可以参考</p><ul><li>英文官方文档 <a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.dartlang.org%2F" target="_blank" rel="noopener">www.dartlang.org/</a></li><li>中文官方文档 <a href="http://dart.goodev.org/guides/language" target="_blank" rel="noopener">http://dart.goodev.org/guides/language</a></li><li>在线联系 <a href="https://dartpad.dartlang.org/" target="_blank" rel="noopener">https://dartpad.dartlang.org/</a></li></ul><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><p>Dart语言博采众长，在我们学习Dart时候需要记住以下核心概念</p><ul><li><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">一切都是对象，一切对象都是class的实例，哪怕是数字类型、方法甚至null都是对象，所有的对象都是继承自</span></span><code>Object</code></li><li><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">Dart是强类型语言，但变量类型是可选的因为Dart可以自动推断变量类型</span></span></li><li>Dart支持范型，<code>List&lt;int&gt;</code>表示一个整型的数据列表，<code>List&lt;dynamic&gt;</code>则是一个对象的列表，其中可以装任意对象</li><li>Dart支持顶层方法（如<code>main</code>方法），也支持类方法或对象方法，同时你也可以在方法内部创建方法</li><li>Dart支持顶层变量，也支持类变量或对象变量</li><li><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">跟Java不同的是，Dart没有</span></span><code>public</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span><code>protected</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span><code>private</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">等关键字，如果某个变量以下划线（</span></span><code>_</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">）开头，代表这个变量在库中是私有的</span></span></li></ul><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="声明变量的方式"><a href="#声明变量的方式" class="headerlink" title="声明变量的方式"></a>声明变量的方式</h2><p>可以明确指定某个变量的类型，如<code>int</code> <code>bool</code> <code>String</code>，也可以用<code>var</code>或 <code>dynamic</code>来声明一个变量，Dart会自动推断其数据类型。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  int b = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">String</span> s = <span class="string">"hello"</span>;</span><br><span class="line">  dynamic c = <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="final和const"><a href="#final和const" class="headerlink" title="final和const"></a>final和const</h2><p><code>final</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">修饰的变量是不可改变的，而</span></span><code>const</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">修饰的表示一个常量，声明普通变量可以使用</span></span><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:#E9E9E9">var</span></span></p><h1 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h1><p>Dart有如下几种内建的数据类型：</p><ul><li>numbers</li><li>strings</li><li>booleans</li><li>lists(或者是arrays)</li><li>maps</li><li>runes（UTF-32字符集的字符）</li><li>symbols</li></ul><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul><li>检测两个 String 的内容是否一样事，我们使用 == 进行比较；如果要测试两个对象是否是同一个对象（indentity test），使用 identical 函数</li><li><ul><li>进行拼接</li></ul></li><li>\${} 字符串内表达式</li><li>三个单引号或者双引号可以创建多行字符串对象</li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><a href="http://dart.goodev.org/guides/libraries/library-tour#collections" target="_blank" rel="noopener">http://dart.goodev.org/guides/libraries/library-tour#collections</a></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use a List constructor.</span></span><br><span class="line"><span class="keyword">var</span> vegetables = <span class="keyword">new</span> List();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Or simply use a list literal.</span></span><br><span class="line"><span class="keyword">var</span> fruits = [<span class="string">'apples'</span>, <span class="string">'oranges'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//list是泛型类型也可以指定里面保存的类型</span></span><br><span class="line"><span class="keyword">var</span> fruits = <span class="keyword">new</span> List&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">fruits.add(<span class="string">'apples'</span>);</span><br></pre></td></tr></table></figure><h3 id="核心api"><a href="#核心api" class="headerlink" title="核心api"></a>核心api</h3><ul><li>add</li><li>addAll</li><li>length</li><li>indexOf</li><li>sort</li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><span data-type="color" style="color:rgb(82, 82, 82)"><span data-type="background" style="background-color:rgb(255, 255, 255)">map是一个关联键和值的对象。键和值都可以是任何类型的对象。每个键只出现一次，但是您可以多次使用相同的值。Dart对map的支持是通过map字面量和map类型来提供的。</span></span></p><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;</span><br><span class="line"><span class="comment">// Keys      Values</span></span><br><span class="line">  <span class="string">'first'</span> : <span class="string">'partridge'</span>,</span><br><span class="line">  <span class="string">'second'</span>: <span class="string">'turtledoves'</span>,</span><br><span class="line">  <span class="string">'fifth'</span> : <span class="string">'golden rings'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nobleGases = &#123;</span><br><span class="line"><span class="comment">// Keys  Values</span></span><br><span class="line">  <span class="number">2</span> :   <span class="string">'helium'</span>,</span><br><span class="line">  <span class="number">10</span>:   <span class="string">'neon'</span>,</span><br><span class="line">  <span class="number">18</span>:   <span class="string">'argon'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造函数实现</span></span><br><span class="line"><span class="keyword">var</span> gifts = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">gifts[<span class="string">'first'</span>] = <span class="string">'partridge'</span>;</span><br><span class="line">gifts[<span class="string">'second'</span>] = <span class="string">'turtledoves'</span>;</span><br><span class="line">gifts[<span class="string">'fifth'</span>] = <span class="string">'golden rings'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nobleGases = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">nobleGases[<span class="number">2</span>] = <span class="string">'helium'</span>;</span><br><span class="line">nobleGases[<span class="number">10</span>] = <span class="string">'neon'</span>;</span><br><span class="line">nobleGases[<span class="number">18</span>] = <span class="string">'argon'</span>;</span><br></pre></td></tr></table></figure><h3 id="核心api-1"><a href="#核心api-1" class="headerlink" title="核心api"></a>核心api</h3><ul><li><p>添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;<span class="string">'first'</span>: <span class="string">'partridge'</span>&#125;;</span><br><span class="line">gifts[<span class="string">'fourth'</span>] = <span class="string">'calling birds'</span>; <span class="comment">// Add a key-value pair</span></span><br></pre></td></tr></table></figure></li><li><p>获取map对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;<span class="string">'first'</span>: <span class="string">'partridge'</span>&#125;;</span><br><span class="line">assert(gifts[<span class="string">'first'</span>] == <span class="string">'partridge'</span>);</span><br></pre></td></tr></table></figure></li></ul><p>如果查找的key不存在则返回null</p><ul><li>length 获取map中键值对的数目</li><li>containsKey</li><li>putIfAbsent()<br><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)">但是只有该 key 在 map 中不存在的时候才设置这个值，否则 key 的值保持不变</span></span></li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h3><p><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>Set 是一个无序集合，里面不能保护重复的数据。 由于是无序的，所以无法通过索引来从 set 中获取数据<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ingredients = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">ingredients.addAll([<span class="string">'gold'</span>, <span class="string">'titanium'</span>, <span class="string">'xenon'</span>]);</span><br><span class="line">assert(ingredients.length == <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adding a duplicate item has no effect.</span></span><br><span class="line">ingredients.add(<span class="string">'gold'</span>);</span><br><span class="line">assert(ingredients.length == <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove an item from a set.</span></span><br><span class="line">ingredients.remove(<span class="string">'gold'</span>);</span><br><span class="line">assert(ingredients.length == <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><h3 id="核心api-2"><a href="#核心api-2" class="headerlink" title="核心api"></a>核心api</h3><ul><li><code>contains()</code><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>和 <code>containsAll()</code><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>来判断 set 中是否包含 一个或者多个对象</li></ul><h2 id="常用集合函数"><a href="#常用集合函数" class="headerlink" title="常用集合函数"></a>常用集合函数</h2><ul><li><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>List 和 Set 实现了 Iterable ,虽然 Map 没有实现 Iterable，但是 Map 的 keys 和 values 属性实现了 Iterable</li><li>isEmpty</li><li><p><code>forEach()</code><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>函数可以遍历集合数据，在 Map 上使用 <code>forEach()</code> 的时候，方法需要能 接收两个参数（key 和 value）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var teas = [&apos;green&apos;, &apos;black&apos;, &apos;chamomile&apos;, &apos;earl grey&apos;];</span><br><span class="line"></span><br><span class="line">teas.forEach((tea) =&gt; print(&apos;I drink $tea&apos;));</span><br><span class="line">//map</span><br><span class="line">hawaiianBeaches.forEach((k, v) &#123;</span><br><span class="line">  print(&apos;I want to visit $k and swim at $v&apos;);</span><br><span class="line">  // I want to visit Oahu and swim at</span><br><span class="line">  // [Waikiki, Kailua, Waimanalo], etc.</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>可以使用 <code>map().toList()</code> 或者 <code>map().toSet()</code> 来 强制立刻执行 map 的方法：</p></li></ul><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>Dart是一个面向对象的编程语言，所以即使是函数也是一个对象，也有一种类型<code>Function</code>，这就意味着函数可以赋值给某个变量或者作为参数传给另外的函数。虽然Dart推荐你给函数加上返回值，但是<strong>不加返回值的函数同样可以正常工作</strong>，另外你还可以用<code>=&gt;</code>代替<code>return</code>语句<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// =&gt;是return语句的简写</span></span><br><span class="line">add3(a, b) =&gt; a + b;</span><br></pre></td></tr></table></figure></p><p>所有的函数都有返回值，如果没有指定<code>return</code>语句，那么该函数的返回值为<code>null</code>。</p><h3 id="命名参数、位置参数、参数默认值"><a href="#命名参数、位置参数、参数默认值" class="headerlink" title="命名参数、位置参数、参数默认值"></a>命名参数、位置参数、参数默认值</h3><ul><li>命名参数</li></ul><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">使用花括号将函数的参数括起来就是定义了命名参数</span></span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sayHello(&#123;<span class="built_in">String</span> name&#125;) &#123;</span><br><span class="line">  print(<span class="string">"hello, my name is $name"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHello2(&#123;<span class="attr">name</span>: <span class="built_in">String</span>&#125;) &#123;</span><br><span class="line">  print(<span class="string">"hello, my name is $name"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以以<code>{type paramName}</code>或者<code>{paramName: type}</code>两种方式声明参数，而调用命名参数时，需要以<code>funcName(paramName: paramValue)</code>的形式调用。<br>可以使用<code>@required</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">注解来标识一个命名参数，这代表该参数是必须的，你不传则会报错</span></span></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Scrollbar(&#123;Key key, @required Widget child&#125;)</span><br></pre></td></tr></table></figure><ul><li>位置参数<br><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">使用中括号</span></span><code>[]</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">括起来的参数是函数的位置参数，代表该参数可传可不传，位置参数只能放在函数的参数列表的最后面</span></span></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sayHello(<span class="built_in">String</span> name, int age, [<span class="built_in">String</span> hobby]) &#123; <span class="comment">// 位置参数可以有多个，比如[String a, int b]</span></span><br><span class="line">  StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">  sb.write(<span class="string">"hello, this is $name and I am $age years old"</span>);</span><br><span class="line">  <span class="keyword">if</span> (hobby != <span class="literal">null</span>) &#123;</span><br><span class="line">    sb.write(<span class="string">", my hobby is $hobby"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  print(sb.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="comment">// hello, this is zhangsan and I am 20 years old</span></span><br><span class="line">  sayHello(<span class="string">"zhangsan"</span>, <span class="number">20</span>);</span><br><span class="line">  <span class="comment">// hello, this is zhangsan and I am 20 years old, my hobby is play football</span></span><br><span class="line">  sayHello(<span class="string">"zhangsan"</span>, <span class="number">20</span>, <span class="string">"play football"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参数默认值</li></ul><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">可以为命名参数或者位置参数设置默认值</span></span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命名参数的默认值</span></span><br><span class="line">int add(&#123;int a, int b = <span class="number">3</span>&#125;) &#123; <span class="comment">// 不能写成：int add(&#123;a: int, b: int = 3&#125;)</span></span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位置参数的默认值</span></span><br><span class="line">int sum(int a, int b, [int c = <span class="number">3</span>]) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="函数作为一等方法对象"><a href="#函数作为一等方法对象" class="headerlink" title="函数作为一等方法对象"></a>函数作为一等方法对象</h3><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">函数作为参数传给另一个函数</span></span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">printNum(int a) &#123;</span><br><span class="line">  print(<span class="string">"$a"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="comment">//  依次打印：1,2,3</span></span><br><span class="line">  <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  arr.forEach(printNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者将函数赋值给某个变量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">printNum(int a) &#123;</span><br><span class="line">  print(<span class="string">"$a"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = printNum;</span><br><span class="line">  <span class="built_in">Function</span> f2 = printNum;</span><br><span class="line">  <span class="keyword">var</span> f3 = <span class="function">(<span class="params">int a</span>) =&gt;</span> print(<span class="string">"a = $a"</span>);</span><br><span class="line">  f1(<span class="number">1</span>);</span><br><span class="line">  f2(<span class="number">2</span>);</span><br><span class="line">  f3(<span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><ul><li><p><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)">创建没有名字的方法，称之为 </span></span><em>匿名方法</em><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)">，有时候也被称为 </span></span><em>lambda</em><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>或者 <em>closure 闭包</em><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)">。 你可以把匿名方法赋值给一个变量， 然后你可以使用这个方法，比如添加到集合或者从集合中删除</span></span></p></li><li><p>匿名函数类似于<code>Java</code>中的接口，往往在某个函数的参数为函数时使用到。</p><h2 id="词法闭包"><a href="#词法闭包" class="headerlink" title="词法闭包"></a>词法闭包</h2><p>一个 <em>闭包</em> 是一个方法对象，不管该对象在何处被调用， 该对象都可以访问其作用域内 的变量。</p></li></ul><p><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)">下面的示例中，</span></span><code>makeAdder()</code><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>捕获到了变量 <code>addBy</code><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)">。 不管你在那里执行 </span></span><code>makeAdder()</code><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>所返回的函数，都可以使用 <code>addBy</code><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span> makeAdder(num addBy) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">num i</span>) =&gt;</span> addBy + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><table><thead><tr><th style="text-align:left">描述</th><th style="text-align:left">操作符</th></tr></thead><tbody><tr><td style="text-align:left">unary postfix</td><td style="text-align:left"><code><em>expr</em></code><code>++</code>    <code><em>expr</em></code><code>–</code>    <code>()</code>    <code>[]</code>    <code>.</code>    <code>?.</code></td></tr><tr><td style="text-align:left">unary prefix</td><td style="text-align:left"><code>-</code><code><em>expr</em></code>    <code>!</code><code><em>expr</em></code>    <code>~</code><code><em>expr</em></code>    <code>++</code><code><em>expr</em></code>    <code>–</code><code><em>expr</em></code></td></tr><tr><td style="text-align:left">multiplicative</td><td style="text-align:left"><code>*</code>    <code>/</code>    <code>%</code>  <code>~/</code></td></tr><tr><td style="text-align:left">additive</td><td style="text-align:left"><code>+</code>    <code>-</code></td></tr><tr><td style="text-align:left">shift</td><td style="text-align:left"><code>&lt;&lt;</code>    <code>&gt;&gt;</code></td></tr><tr><td style="text-align:left">bitwise AND</td><td style="text-align:left"><code>&amp;</code></td></tr><tr><td style="text-align:left">bitwise XOR</td><td style="text-align:left"><code>^</code></td></tr><tr><td style="text-align:left">bitwise OR</td><td style="text-align:left">`</td><td>`</td></tr><tr><td style="text-align:left">relational and type test</td><td style="text-align:left"><code>&gt;=</code>    <code>&gt;</code>    <code>&lt;=</code>    <code>&lt;</code>    <code>as</code>    <code>is</code>    <code>is!</code></td></tr><tr><td style="text-align:left">equality</td><td style="text-align:left"><code>==</code>    <code>!=</code></td></tr><tr><td style="text-align:left">logical AND</td><td style="text-align:left"><code>&amp;&amp;</code></td></tr><tr><td style="text-align:left">logical OR</td><td style="text-align:left">`</td><td></td><td>`</td></tr><tr><td style="text-align:left">if null</td><td style="text-align:left"><code>??</code></td></tr><tr><td style="text-align:left">conditional</td><td style="text-align:left"><code><em>expr1</em></code><code> ? </code><code><em>expr2</em></code><code> : </code><code><em>expr3</em></code></td></tr><tr><td style="text-align:left">cascade</td><td style="text-align:left"><code>..</code></td></tr><tr><td style="text-align:left">assignment</td><td style="text-align:left"><code>=</code>    <code>*=</code>    <code>/=</code>    <code>~/=</code>    <code>%=</code>    <code>+=</code>    <code>-=</code>    <code>&lt;&lt;=</code>    <code>&gt;&gt;=</code>    <code>&amp;=</code>    <code>^=</code>    `</td><td>=<code></code>??=`</td></tr></tbody></table><h3 id="类型判定操作符"><a href="#类型判定操作符" class="headerlink" title="类型判定操作符"></a>类型判定操作符</h3><p><code>as</code>、 <code>is</code>、 和 <code>is!</code> 操作符是在运行时判定对象 类型的操作符：</p><table><thead><tr><th style="text-align:left">操作符</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left"><code>as</code></td><td style="text-align:left">类型转换</td></tr><tr><td style="text-align:left"><code>is</code></td><td style="text-align:left">如果对象是指定的类型返回 True</td></tr><tr><td style="text-align:left"><code>is!</code></td><td style="text-align:left">如果对象是指定的类型返回 False</td></tr></tbody></table><h3 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h3><p>使用 <code>=</code> 操作符来赋值。 但是还有一个 <code>??=</code> 操作符用来指定 值为 null 的变量的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = value;   <span class="comment">// 给 a 变量赋值</span></span><br><span class="line">b ??= value; <span class="comment">// 如果 b 是 null，则赋值给 b；</span></span><br><span class="line">             <span class="comment">// 如果不是 null，则 b 的值保持不变</span></span><br></pre></td></tr></table></figure></p><h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><p>Dart 有两个特殊的操作符可以用来替代 if-else 语句：</p><ul><li><p><code><em>condition</em></code><code> ? </code><code><em>expr1</em></code><code> : </code><code><em>expr2</em></code><br>如果 <em>condition</em> 是 true，执行 <em>expr1</em> (并返回执行的结果)； 否则执行 <em>expr2</em> 并返回其结果。<br>如果你需要基于布尔表达式 的值来赋值， 考虑使用 <code>?:</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> finalStatus = m.isFinal ? <span class="string">'final'</span> : <span class="string">'not final'</span>;</span><br></pre></td></tr></table></figure></li><li><p><code><em>expr1</em></code><code> ?? </code><code><em>expr2</em></code><br>如果 <em>expr1</em> 是 non-null，返回其值； 否则执行 <em>expr2</em> 并返回其结果。<br>如果布尔表达式是测试值是否为 null， 考虑使用 <code>??</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> toString() =&gt; msg ?? <span class="keyword">super</span>.toString();</span><br></pre></td></tr></table></figure></li></ul><h3 id="级联操作符"><a href="#级联操作符" class="headerlink" title="级联操作符"></a>级联操作符</h3><p>级联操作符 (<code>..</code>) 可以在同一个对象上 连续调用多个函数以及访问成员变量。 使用级联操作符可以避免创建 临时变量， 并且写出来的代码看起来 更加流畅：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">querySelector(<span class="string">'#button'</span>) <span class="comment">// Get an object.</span></span><br><span class="line">  ..text = <span class="string">'Confirm'</span>   <span class="comment">// Use its members.</span></span><br><span class="line">  ..classes.add(<span class="string">'important'</span>)</span><br><span class="line">  ..onClick.listen(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">window</span>.alert(<span class="string">'Confirmed!'</span>));</span><br></pre></td></tr></table></figure></p><p>级联调用也可以嵌套：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">final addressBook = (<span class="keyword">new</span> AddressBookBuilder()</span><br><span class="line">      ..name = <span class="string">'jenny'</span></span><br><span class="line">      ..email = <span class="string">'jenny@example.com'</span></span><br><span class="line">      ..phone = (<span class="keyword">new</span> PhoneNumberBuilder()</span><br><span class="line">            ..number = <span class="string">'415-555-0100'</span></span><br><span class="line">            ..label = <span class="string">'home'</span>)</span><br><span class="line">          .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure></p><p>在方法上使用级联需要十分小心，无法再void上使用级联操作符<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Does not work</span></span><br><span class="line"><span class="keyword">var</span> sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">sb.write(<span class="string">'foo'</span>)..write(<span class="string">'bar'</span>);</span><br></pre></td></tr></table></figure></p><h3 id="其他操作符"><a href="#其他操作符" class="headerlink" title="其他操作符"></a>其他操作符</h3><table><thead><tr><th style="text-align:left">Operator</th><th style="text-align:left">Name</th><th style="text-align:left">Meaning</th></tr></thead><tbody><tr><td style="text-align:left"><code>()</code></td><td style="text-align:left">使用方法</td><td style="text-align:left">代表调用一个方法</td></tr><tr><td style="text-align:left"><code>[]</code></td><td style="text-align:left">访问 List</td><td style="text-align:left">访问 list 中特定位置的元素</td></tr><tr><td style="text-align:left"><code>.</code></td><td style="text-align:left">访问 Member</td><td style="text-align:left">访问元素，例如 <code>foo.bar</code> 代表访问 <code>foo</code> 的 <code>bar</code> 成员</td></tr><tr><td style="text-align:left"><code>?.</code></td><td style="text-align:left">条件成员访问</td><td style="text-align:left">和 <code>.</code> 类似，但是左边的操作对象不能为 null，例如 <code>foo?.bar</code> 如果 <code>foo</code> 为 null 则返回 null，否则返回 <code>bar</code> 成员</td></tr></tbody></table><h1 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h1><p><code>if / else</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span><code>switch</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span><code>for /while</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span><code>try / catch</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">语句跟</span></span><code>Java</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">中都类似，</span></span><code>try / catch</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">语句可能稍有不同</span></span></p><h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h3><p>捕获异常可以避免异常继续传递（你重新抛出rethrow异常除外）。 捕获异常给你一个处理 该异常的机会：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; on OutOfLlamasException &#123;</span><br><span class="line">  buyMoreLlamas();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于可以抛出多种类型异常的代码，你可以指定 多个捕获语句。每个语句分别对应一个异常类型， 如果捕获语句没有指定异常类型，则 该可以捕获任何异常类型：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; on OutOfLlamasException &#123;</span><br><span class="line">  <span class="comment">// A specific exception</span></span><br><span class="line">  buyMoreLlamas();</span><br><span class="line">&#125; on Exception <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// Anything else that is an exception</span></span><br><span class="line">  print(<span class="string">'Unknown exception: $e'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// No specified type, handles all</span></span><br><span class="line">  print(<span class="string">'Something really unknown: $e'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)">使用 </span></span><code>on</code><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>来指定异常类型，使用 <code>catch</code><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>来 捕获异常对象。<br>使用 <code>rethrow</code> 关键字可以 把捕获的异常给 重新抛出。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">final foo = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> misbehave() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    foo = <span class="string">"You can't change a final variable's value."</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    print(<span class="string">'misbehave() partially handled $&#123;e.runtimeType&#125;.'</span>);</span><br><span class="line">    rethrow; <span class="comment">// Allow callers to see the exception.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    misbehave();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    print(<span class="string">'main() finished handling $&#123;e.runtimeType&#125;.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="类的定义与构造方法"><a href="#类的定义与构造方法" class="headerlink" title="类的定义与构造方法"></a>类的定义与构造方法</h2><p><code>Dart</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">中的类没有访问控制，所以你不需要用</span></span><code>private</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">, </span></span><code>protected</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">, </span></span><code>public</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">等修饰成员变量或成员函数</span></span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  int age;</span><br><span class="line">  <span class="built_in">String</span> gender;</span><br><span class="line">  Person(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age, <span class="keyword">this</span>.gender);</span><br><span class="line">  sayHello() &#123;</span><br><span class="line">    print(<span class="string">"hello, this is $name, I am $age years old, I am a $gender"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">上面的</span></span><code>Person</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">类中有3个成员变量，一个构造方法和一个成员方法，看起来比较奇怪的是</span></span><code>Person</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">的构造方法，里面传入的3个参数都是</span></span><code>this.xxx</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">，而且没有大括号</span></span><code>{}</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">包裹的方法体，这种语法是Dart比较独特而简洁的构造方法声明方式，它等同于下面的代码：</span></span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person(<span class="built_in">String</span> name, int age, <span class="built_in">String</span> gender) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">由于</span></span><code>Dart</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">中的类没有访问控制权限，所以你可以直接用</span></span><code>obj.var</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">的方式访问一个对象的成员变量。</span></span></p><h3 id="命名构造函数"><a href="#命名构造函数" class="headerlink" title="命名构造函数"></a>命名构造函数</h3><p>使用命名构造函数可以为一个类实现多个构造函数， 或者使用命名构造函数来更清晰的表明你的意图：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  num x, y;</span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">  <span class="comment">// 类的命名构造方法</span></span><br><span class="line">  Point.origin() &#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="comment">// 调用Point类的命名构造方法origin()</span></span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> Point.origin();</span><br><span class="line">  <span class="keyword">var</span> p2 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="调用超类构造函数"><a href="#调用超类构造函数" class="headerlink" title="调用超类构造函数"></a>调用超类构造函数</h3><p>子类的构造函数会自动调用超类的 无名无参数的默认构造函数。 超类的构造函数在子类构造函数体开始执行的位置调用。 如果提供了一个 <a href="http://dart.goodev.org/guides/language/language-tour#initializer-list" target="_blank" rel="noopener">initializer list</a>（初始化参数列表） ，则初始化参数列表在超类构造函数执行之前执行。 下面是构造函数执行顺序：</p><ol><li>initializer list（初始化参数列表）</li><li>superclass’s no-arg constructor（超类的无名构造函数）</li><li>main class’s no-arg constructor（主类的无名构造函数）</li></ol><p>如果超类没有无名无参数构造函数， 则你需要手工的调用超类的其他构造函数。 在构造函数参数后使用冒号 (<code>:</code>) 可以调用 超类构造函数。<br><code>Dart</code>中使用<code>extends</code>关键字做类的继承，如果一个类只有命名的构造方法，在继承时需要注意，如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  Human.fromJson(<span class="built_in">Map</span> data) &#123;</span><br><span class="line">    print(<span class="string">"Human's fromJson constructor"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">  Man.fromJson(<span class="built_in">Map</span> data) : <span class="keyword">super</span>.fromJson(data) &#123;</span><br><span class="line">    print(<span class="string">"Man's fromJson constructor"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="重定向构造函数"><a href="#重定向构造函数" class="headerlink" title="重定向构造函数"></a>重定向构造函数</h3><p>有时候一个构造函数会调动类中的其他构造函数。 一个重定向构造函数是没有代码的，在构造函数声明后，使用 冒号调用其他构造函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  num x;</span><br><span class="line">  num y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The main constructor for this class.</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Delegates to the main constructor.</span></span><br><span class="line">  Point.alongXAxis(num x) : <span class="keyword">this</span>(x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h2><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">使用abstract修饰一个类，则这个类是抽象类，</span></span><br><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"><strong>抽象类中可以有抽象方法和非抽象方法</strong></span></span><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">，抽象方法没有方法体，需要子类去实现，如下代码：</span></span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 抽象方法，没有方法体，需要子类去实现</span></span><br><span class="line">  <span class="keyword">void</span> doSomething();</span><br><span class="line">  <span class="comment">// 普通的方法</span></span><br><span class="line">  <span class="keyword">void</span> greet() &#123;</span><br><span class="line">    print(<span class="string">"hello world!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EffectiveDoer</span> <span class="keyword">extends</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 实现了父类的抽象方法</span></span><br><span class="line">  <span class="keyword">void</span> doSomething() &#123;</span><br><span class="line">    print(<span class="string">"I'm doing something..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>枚举类型通常称之为 <em>enumerations</em> 或者 <em>enums</em>， 是一种特殊的类，用来表现一个固定 数目的常量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">  red,</span><br><span class="line">  green,</span><br><span class="line">  blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>枚举类型中的每个值都有一个 <code>index</code> getter 函数， 该函数返回该值在枚举类型定义中的位置（从 0 开始）。 例如，第一个枚举值的位置为 0， 第二个为 1.</li><li>枚举的 <code>values</code> 常量可以返回 所有的枚举值。</li></ul><p>枚举类型具有如下的限制：</p><ul><li>无法继承枚举类型、无法使用 mix in、无法实现一个枚举类型</li><li>无法显示的初始化一个枚举类型</li></ul><h2 id="Mixins-为类添加新的功能"><a href="#Mixins-为类添加新的功能" class="headerlink" title="Mixins 为类添加新的功能"></a>Mixins 为类添加新的功能</h2><p>Mixins 是一种在多类继承中重用 一个类代码的方法。使用 with 关键字后面为一个或者多个 mixin 名字来使用 mixin。 下面是示例显示了如何使用 mixin：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  a() &#123;</span><br><span class="line">    print(<span class="string">"A's a()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  b() &#123;</span><br><span class="line">    print(<span class="string">"B's b()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用with关键字，表示类C是由类A和类B混合而构成</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>= A <span class="keyword">with</span> B;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  C c = <span class="keyword">new</span> C();</span><br><span class="line">  c.a(); <span class="comment">// A's a()</span></span><br><span class="line">  c.b(); <span class="comment">// B's b()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="静态成员变量-和-静态成员方法"><a href="#静态成员变量-和-静态成员方法" class="headerlink" title="静态成员变量 和 静态成员方法"></a>静态成员变量 和 静态成员方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类的静态成员变量和静态成员方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cons</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> name = <span class="string">"zhangsan"</span>;</span><br><span class="line">  <span class="keyword">static</span> sayHello() &#123;</span><br><span class="line">    print(<span class="string">"hello, this is $&#123;Cons.name&#125;"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  Cons.sayHello(); <span class="comment">// hello, this is zhangsan</span></span><br><span class="line">  print(Cons.name); <span class="comment">// zhangsan</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p><a href="http://dart.goodev.org/guides/language/language-tour#generics%E6%B3%9B%E5%9E%8B" target="_blank" rel="noopener">http://dart.goodev.org/guides/language/language-tour#generics%E6%B3%9B%E5%9E%8B</a></p><p>使用泛型可以减少冗余的代码，<span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>泛型可以在多种类型之间定义同一个实现，在Dart中Dart 的泛型类型是固化的，在运行时有也 可以判断具体的类型。例如在运行时（甚至是成产模式） 也可以检测集合里面的对象类型：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="keyword">new</span> List&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">names.addAll([<span class="string">'Seth'</span>, <span class="string">'Kathy'</span>, <span class="string">'Lars'</span>]);</span><br><span class="line">print(names is List&lt;<span class="built_in">String</span>&gt;); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>这个跟Java中是不同的 Java 中的泛型信息是编译时的，泛型信息在运行时是不纯在的。 在 Java 中你可以测试一个对象是否为 List， 但是你无法测试一个对象是否为 List<string>。</string></p><h2 id="限制型泛型"><a href="#限制型泛型" class="headerlink" title="限制型泛型"></a>限制型泛型</h2><p><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)">使用 </span></span><code>extends</code><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>可以实现这个功能<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// T must be SomeBaseClass or one of its descendants.</span><br><span class="line">class Foo&lt;T extends SomeBaseClass&gt; &#123;...&#125;</span><br><span class="line"></span><br><span class="line">class Extender extends SomeBaseClass &#123;...&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  // It's OK to use SomeBaseClass or any of its subclasses inside &lt;&gt;.</span><br><span class="line">  var someBaseClassFoo = new Foo&lt;SomeBaseClass&gt;();</span><br><span class="line">  var extenderFoo = new Foo&lt;Extender&gt;();</span><br><span class="line"></span><br><span class="line">  // It's also OK to use no &lt;&gt; at all.</span><br><span class="line">  var foo = new Foo();</span><br><span class="line"></span><br><span class="line">  // Specifying any non-SomeBaseClass type results in a warning and, in</span><br><span class="line">  // checked mode, a runtime error.</span><br><span class="line">  // var objectFoo = new Foo&lt;Object&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h2><p>一开始，泛型只能在 Dart 类中使用。 新的语法也支持在函数和方法上使用泛型了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T first&lt;T&gt;(List&lt;T&gt; ts) &#123;</span><br><span class="line">  <span class="comment">// ...Do some initial work or error checking, then...</span></span><br><span class="line">  T tmp ?= ts[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// ...Do some additional checking or processing...</span></span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的 <code>first</code> (<code>&lt;T&gt;</code>) 泛型可以在如下地方使用 参数 <code>T</code> ：</p><ul><li>函数的返回值类型 (<code>T</code>).</li><li>参数的类型 (<code>List&lt;T&gt;</code>).</li><li>局部变量的类型 (<code>T tmp</code>).</li></ul><h1 id="库的可见性"><a href="#库的可见性" class="headerlink" title="库的可见性"></a>库的可见性</h1><ul><li><p>普通引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./util.dart'</span>;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  print(add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>as关键字 设置前缀</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:lib1/lib1.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:lib2/lib2.dart'</span> <span class="keyword">as</span> lib2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uses Element from lib1.</span></span><br><span class="line">Element element1 = Element();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uses Element from lib2.</span></span><br><span class="line">lib2.Element element2 = lib2.Element();</span><br></pre></td></tr></table></figure></li><li><p>show hide 关键字导入包的部分功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只导入foo</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:lib1/lib1.dart'</span> show foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入除了foo的所有其他部分</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:lib2/lib2.dart'</span> hide foo;</span><br></pre></td></tr></table></figure></li><li><p><span data-type="color" style="color:rgb(255, 80, 44)"><span data-type="background" style="background-color:rgb(255, 245, 245)">deferred as </span></span>懒加载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:greetings/hello.dart'</span> deferred <span class="keyword">as</span> hello;</span><br></pre></td></tr></table></figure></li></ul><h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><p><code>Dart</code>提供了类似ES7中的<code>async</code> <code>await</code>等异步操作，这种异步操作在Flutter开发中会经常遇到，比如网络或其他IO操作，文件选择等都需要用到异步的知识。<code>async</code>和<code>await</code>往往是成对出现的，如果一个方法中有耗时的操作，你需要将这个方法设置成<code>async</code>，并给其中的耗时操作加上<code>await</code>关键字，如果这个方法有返回值，你需要将返回值塞到<code>Future</code>中并返回，如下代码所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future checkVersion() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> version = <span class="keyword">await</span> lookUpVersion();</span><br><span class="line">  <span class="comment">// Do something with version</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多请见 <a href="https://segmentfault.com/a/1190000014396421" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014396421</a></p><h1 id="可调用类"><a href="#可调用类" class="headerlink" title="可调用类"></a>可调用类</h1><p>如果 Dart 类实现了 <code>call()</code> 函数则 可以当做方法来调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WannabeFunction</span> </span>&#123;</span><br><span class="line">  call(<span class="built_in">String</span> a, <span class="built_in">String</span> b, <span class="built_in">String</span> c) =&gt; <span class="string">'$a $b $c!'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> wf = <span class="keyword">new</span> WannabeFunction();</span><br><span class="line">  <span class="keyword">var</span> out = wf(<span class="string">"Hi"</span>,<span class="string">"there,"</span>,<span class="string">"gang"</span>);</span><br><span class="line">  print(<span class="string">'$out'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h1><p>使用元数据给你的代码添加其他额外信息。 元数据注解是以 <code>@</code> 字符开头，后面是一个编译时 常量(例如 <code>deprecated</code>)或者 调用一个常量构造函数。<br><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)">有三个注解所有的 Dart 代码都可以使用： </span></span><code>@deprecated</code><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)">、 </span></span><code>@override</code><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)">、 和 </span></span><code>@proxy</code></p><p>你还可以定义自己的元数据注解。 下面的示例定义了一个带有两个参数的 @todo 注解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">library todo;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">todo</span> </span>&#123;</span><br><span class="line">  final <span class="built_in">String</span> who;</span><br><span class="line">  final <span class="built_in">String</span> what;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> todo(<span class="keyword">this</span>.who, <span class="keyword">this</span>.what);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'todo.dart'</span>;</span><br><span class="line"></span><br><span class="line">@todo(<span class="string">'seth'</span>, <span class="string">'make this do something'</span>)</span><br><span class="line"><span class="keyword">void</span> doSomething() &#123;</span><br><span class="line">  print(<span class="string">'do something'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>元数据可以在 library、 class、 typedef、 type parameter、 constructor、 factory、 function、 field、 parameter、或者 variable 声明之前使用，也可以在 import 或者 export 指令之前使用。 使用反射可以在运行时获取元数据 信息。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>中文官方文档 <a href="http://dart.goodev.org/guides/language" target="_blank" rel="noopener">http://dart.goodev.org/guides/language</a></li><li><a href="https://juejin.im/post/5b5005866fb9a04fea589561#heading-14" target="_blank" rel="noopener">https://juejin.im/post/5b5005866fb9a04fea589561#heading-14</a></li><li><a href="https://juejin.im/post/5bcc8527f265da0aff17729a#heading-2" target="_blank" rel="noopener">https://juejin.im/post/5bcc8527f265da0aff17729a#heading-2</a></li><li><a href="https://segmentfault.com/a/1190000014396421" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014396421</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Dart语法基础&quot;&gt;&lt;a href=&quot;#Dart语法基础&quot; class=&quot;headerlink&quot; title=&quot;Dart语法基础&quot;&gt;&lt;/a&gt;Dart语法基础&lt;/h1
      
    
    </summary>
    
      <category term="Dart" scheme="https://xsfelvis.github.io/categories/Dart/"/>
    
    
      <category term="Dart" scheme="https://xsfelvis.github.io/tags/Dart/"/>
    
      <category term="Dart语法基础" scheme="https://xsfelvis.github.io/tags/Dart%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Flutter中消息传递</title>
    <link href="https://xsfelvis.github.io/2019/01/12/%20Flutter%E4%B8%AD%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92/"/>
    <id>https://xsfelvis.github.io/2019/01/12/ Flutter中消息传递/</id>
    <published>2019-01-11T16:00:00.000Z</published>
    <updated>2019-01-12T12:29:44.649Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Flutter中消息传递"><a href="#Flutter中消息传递" class="headerlink" title="Flutter中消息传递"></a>Flutter中消息传递</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在native开发中消息传递有多种手段，系统的广播，第三方的eventbus等，在flutter中会有哪些手段呢？本篇将会介绍</p><h1 id="Flutter中的消息传递"><a href="#Flutter中的消息传递" class="headerlink" title="Flutter中的消息传递"></a>Flutter中的消息传递</h1><h2 id="InheritedWidget"><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h2><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">InheritedWidget是Flutter中非常重要的一个功能型Widget，它可以高效的将数据在</span></span><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"><strong>Widget树中向下传递、共享</strong></span></span><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">，这在一些需要在Widget树中共享数据的场景中非常方便， 我们经常通过这样的方式，通过</span></span><code>BuildContext</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">,可以拿到</span></span><code>Theme</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">和</span></span><code>MediaQuery</code></p><blockquote><p>InheritedWidget和React中的context功能类似，和逐级传递数据相比，它们能实现组件跨级传递数据。InheritedWidget的在Widget树中数据传递方向是从上到下的，这和Notification的传递方向正好相反。</p></blockquote><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">在介绍StatefulWidget时，我们提到State对象有一个回调</span></span><code>didChangeDependencies</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">，它会在“依赖”发生变化时被Flutter Framework调用。而这个“依赖”指的就是是否使用了父widget中InheritedWidget的数据，如果使用了，则代表有依赖，如果没有使用则代表没有依赖。这种机制可以使子组件在所依赖的主题、locale等发生变化时有机会来做一些事情 </span></span>比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到状态栏的高度</span></span><br><span class="line">var statusBarHeight = MediaQuery.of(context).padding.top;</span><br><span class="line"><span class="comment">//复制合并出新的主题</span></span><br><span class="line">var copyTheme =Theme.of(context).copyWith(primaryColor: Colors.blue);</span><br></pre></td></tr></table></figure><h3 id="使用InheritedWidget"><a href="#使用InheritedWidget" class="headerlink" title="使用InheritedWidget"></a>使用<span data-type="color" style="color:rgb(74, 74, 74)"><span data-type="background" style="background-color:rgb(255, 255, 255)">InheritedWidget</span></span></h3><p>主要涉及2部分工作量</p><ul><li>创建一个继承自 InheritedWidget 的类，使用时将其插入 Widget 树</li><li>通过 BuildContext 对象提供的 inheritFromWidgetOfExactType 方法查找 Widget 树中最近的一个特定类型的 InheritedWidget 类的实例</li></ul><p>共享数据类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InheritedContext</span> <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//数据</span></span><br><span class="line">  <span class="keyword">final</span> InheritedTestModel inheritedTestModel;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//点击+号的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="title">Function</span><span class="params">()</span> increment</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//点击-号的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="title">Function</span><span class="params">()</span> reduce</span>;</span><br><span class="line"></span><br><span class="line">  InheritedContext(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.inheritedTestModel,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.increment,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.reduce,</span><br><span class="line">    <span class="meta">@required</span> Widget child,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> InheritedContext <span class="title">of</span><span class="params">(BuildContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> context.inheritFromWidgetOfExactType(InheritedContext);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//是否重建widget就取决于数据是否相同</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function">bool <span class="title">updateShouldNotify</span><span class="params">(InheritedContext oldWidget)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> inheritedTestModel != oldWidget.inheritedTestModel;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在widget中使用共享数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerWidgetB</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function">Widget <span class="title">build</span><span class="params">(BuildContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> inheritedContext = InheritedContext.of(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> inheritedTestModel = inheritedContext.inheritedTestModel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Padding(</span><br><span class="line">      padding: <span class="keyword">const</span> EdgeInsets.only(left: <span class="number">10.0</span>, top: <span class="number">10.0</span>, right: <span class="number">10.0</span>),</span><br><span class="line">      child: <span class="keyword">new</span> Text(</span><br><span class="line">        <span class="string">'当前count:$&#123;inheritedTestModel.count&#125;'</span>,</span><br><span class="line">        style: <span class="keyword">new</span> TextStyle(fontSize: <span class="number">20.0</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在树中从上向下传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="function">Widget <span class="title">build</span><span class="params">(BuildContext context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> InheritedContext(</span><br><span class="line">      inheritedTestModel: inheritedTestModel,</span><br><span class="line">      increment: _incrementCount,</span><br><span class="line">      reduce: _reduceCount,</span><br><span class="line">      child: <span class="keyword">new</span> Scaffold(</span><br><span class="line">        appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">          title: <span class="keyword">new</span> Text(<span class="string">'InheritedWidgetTest'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: <span class="keyword">new</span> Column(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            <span class="keyword">new</span> Padding(</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.only(left: <span class="number">10.0</span>, top: <span class="number">10.0</span>, right: <span class="number">10.0</span>),</span><br><span class="line">              child: <span class="keyword">new</span> Text(<span class="string">'我们常使用的\nTheme.of(context).textTheme\nMediaQuery.of(context).size等\n就是通过InheritedWidget实现的'</span>,</span><br><span class="line">                style: <span class="keyword">new</span> TextStyle(fontSize: <span class="number">20.0</span>),),</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">new</span> CustomerWidgetA(),</span><br><span class="line">            <span class="keyword">new</span> CustomerWidgetB(),</span><br><span class="line">            <span class="keyword">new</span> CustomerWidgetC(),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体代码可以查看</p><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><blockquote><p>MediaQuery.of() called with a context that does not contain a MediaQuery</p></blockquote><p>见ss <a href="https://stackoverflow.com/questions/50214338/flutter-error-mediaquery-of-called-with-a-context-that-does-not-contain-a-med" target="_blank" rel="noopener">https://stackoverflow.com/questions/50214338/flutter-error-mediaquery-of-called-with-a-context-that-does-not-contain-a-med</a><br><span data-type="color" style="color:rgb(36, 39, 41)"><span data-type="background" style="background-color:rgb(255, 255, 255)">You need a </span></span><code>MaterialApp</code><span data-type="color" style="color:rgb(36, 39, 41)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>or a <code>WidgetsApp</code><span data-type="color" style="color:rgb(36, 39, 41)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>arround your widget. They provide the <code>MediaQuery</code><span data-type="color" style="color:rgb(36, 39, 41)"><span data-type="background" style="background-color:rgb(255, 255, 255)">. When you call </span></span><code>.of(context)</code></p><h2 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h2><p>notification 跟inheritedWidget恰恰相反，是从 子节点向父节点发送消息<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">在Widget树中，每一个节点都可以分发通知，通知会沿着当前节点（context）向上传递，所有父节点都可以通过NotificationListener来监听通知，Flutter中称这种通知由子向父的传递为“通知冒泡”（Notification Bubbling）。Flutter中很多地方使用了通知，如可滚动(Scrollable) Widget中滑动时就会分发ScrollNotification，而Scrollbar正是通过监听ScrollNotification来确定滚动条位置的。</span></span></p><h3 id="使用Notification"><a href="#使用Notification" class="headerlink" title="使用Notification"></a>使用Notification</h3><ul><li>自定义通知<br><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">要继承自Notification类</span></span></li><li>分发通知<br><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">Notification有一个</span></span><code>dispatch(context)</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">方法，它是用于分发通知的，我们说过context实际上就是操作Element的一个接口，它与Element树上的节点是对应的，通知会从context对应的Element节点向上冒泡。</span></span></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerNotification</span> <span class="keyword">extends</span> <span class="title">Notification</span> </span>&#123;</span><br><span class="line">  CustomerNotification(<span class="keyword">this</span>.msg);</span><br><span class="line">  <span class="keyword">final</span> String msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotificationStudyState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">NotificationStudy</span>&gt; </span>&#123;</span><br><span class="line">  String _msg = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function">Widget <span class="title">build</span><span class="params">(BuildContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//监听通知</span></span><br><span class="line">    <span class="keyword">return</span> NotificationListener&lt;CustomerNotification&gt;(</span><br><span class="line">      onNotification: (notification) &#123;</span><br><span class="line">        setState(() &#123;</span><br><span class="line">          _msg += notification.msg + <span class="string">"  "</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">      child: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisSize: MainAxisSize.min,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line"><span class="comment">//          RaisedButton(</span></span><br><span class="line"><span class="comment">//           onPressed: () =&gt; CustomerNotification("Hello NotificationStudy").dispatch(context),</span></span><br><span class="line"><span class="comment">//           child: Text("Send Notification"),</span></span><br><span class="line"><span class="comment">//          ),</span></span><br><span class="line">            Builder(</span><br><span class="line">              builder: (context) &#123;</span><br><span class="line">                <span class="keyword">return</span> RaisedButton(</span><br><span class="line">                  <span class="comment">//按钮点击时分发通知</span></span><br><span class="line">                  onPressed: () =&gt; CustomerNotification(<span class="string">"Hello NotificationStudy"</span>).dispatch(context),</span><br><span class="line">                  child: Text(<span class="string">"Send Notification"</span>),</span><br><span class="line">                );</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">            Text(_msg)</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span data-type="color" style="color:rgb(133, 133, 133)"><span data-type="background" style="background-color:rgb(255, 255, 255)">注意：代码中注释的部分是不能正常工作的，因为这个</span></span><code>context</code><span data-type="color" style="color:rgb(133, 133, 133)"><span data-type="background" style="background-color:rgb(255, 255, 255)">是根Context，而NotificationListener是监听的子树，所以我们通过</span></span><code>Builder</code><span data-type="color" style="color:rgb(133, 133, 133)"><span data-type="background" style="background-color:rgb(255, 255, 255)">来构建RaisedButton，来获得按钮位置的context。</span></span></p><p>以上代码 参见 <a href="https://github.com/xsfelvis/learnflutter/tree/a2824a6d0db70fe3d4c92609cbd172ec7854ab3f/lib/demo6" target="_blank" rel="noopener">https://github.com/xsfelvis/learnflutter/tree/a2824a6d0db70fe3d4c92609cbd172ec7854ab3f/lib/demo6</a></p><h2 id="事件总线"><a href="#事件总线" class="headerlink" title="事件总线"></a>事件总线</h2><p>目前在已经有了一个eventbus插件</p><p><a href="https://pub.flutter-io.cn/packages/event_bus#-readme-tab-" target="_blank" rel="noopener">https://pub.flutter-io.cn/packages/event_bus#-readme-tab-</a></p><p>用法跟原生eventbus类似</p><ul><li><p>引入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:event_bus/event_bus.dart'</span>;</span><br><span class="line"></span><br><span class="line">EventBus eventBus = <span class="keyword">new</span> EventBus();</span><br></pre></td></tr></table></figure></li><li><p>监听事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eventBus.on().listen((event) &#123; </span><br><span class="line">    print(event.runtimeType);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>发送事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventBus.fire(event);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Flutter中消息传递&quot;&gt;&lt;a href=&quot;#Flutter中消息传递&quot; class=&quot;headerlink&quot; title=&quot;Flutter中消息传递&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Flutter" scheme="https://xsfelvis.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://xsfelvis.github.io/tags/Flutter/"/>
    
      <category term="Flutter消息传递" scheme="https://xsfelvis.github.io/tags/Flutter%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92/"/>
    
  </entry>
  
  <entry>
    <title>flutter中的路由</title>
    <link href="https://xsfelvis.github.io/2018/12/15/2018-12-15flutter%E4%B8%AD%E7%9A%84%E8%B7%AF%E7%94%B1/"/>
    <id>https://xsfelvis.github.io/2018/12/15/2018-12-15flutter中的路由/</id>
    <published>2018-12-15T06:42:34.365Z</published>
    <updated>2018-12-15T06:42:34.365Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>路由是native中应用的比较多，特别是组件化的工程中，更是用来解耦的利器，比较常用的有阿里的ARouter等，路由这一思想也是借鉴前端而来，比如web中页面跳转就是一个url就到了一个新的页面，Flutter既然是新一代的跨端方案，而且从RN借鉴了不少思想，路由当然也是必不可少的，本篇将了解下Flutter的路由</p><h1 id="Flutter的路由"><a href="#Flutter的路由" class="headerlink" title="Flutter的路由"></a>Flutter的路由</h1><p>在Flutter中支持所有路由场景，<span data-type="color" style="color:rgb(47, 47, 47)"><span data-type="background" style="background-color:rgb(255, 255, 255)">push、pop页面，页面间的参数传递等等。flutter里面的路由可以分成两种，</span></span></p><ul><li><span data-type="color" style="color:rgb(47, 47, 47)"><span data-type="background" style="background-color:rgb(255, 255, 255)">一种是直接注册，不能传递参数，可以称 为静态路由</span></span></li><li><span data-type="color" style="color:rgb(47, 47, 47)"><span data-type="background" style="background-color:rgb(255, 255, 255)">一种要自己构造实例，可以传递参数，可以称为 动态路由。</span></span></li></ul><h2 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h2><p>在<span data-type="color" style="color:rgb(52, 73, 94)">创建时就已经明确知道了要跳转的页面和值，</span><span data-type="color" style="color:rgb(47, 47, 47)"><span data-type="background" style="background-color:rgb(255, 255, 255)">在新建一个MD风格的App的时候，可以传入一个routes参数来定义路由。但是这里定义的路由是静态的，它不可以向下一个页面传递参数</span></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="function">Widget <span class="title">build</span><span class="params">(BuildContext context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">    title: <span class="string">'Flutter Demo'</span>,</span><br><span class="line">    theme: <span class="keyword">new</span> ThemeData(</span><br><span class="line">      primarySwatch: Colors.blue,</span><br><span class="line">    ),</span><br><span class="line">    <span class="comment">//注册路由表</span></span><br><span class="line">    routes: &#123;</span><br><span class="line">      <span class="string">"router/static_page"</span>: (context) =&gt; StaticRoute(),</span><br><span class="line">    &#125;,</span><br><span class="line">    home: <span class="keyword">new</span> MyHomePage(title: <span class="string">'Flutter Demo Home Page'</span>),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过routes这个属性注册好跳转的页面即key-value，上面的代码中 </p><p>key：router/static_page    value: StaticRouter<br>然后使用的时候使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FlatButton(</span><br><span class="line">  child: Text(<span class="string">"open static router"</span>),</span><br><span class="line">  textColor: Colors.blue,</span><br><span class="line">  onPressed: () &#123;</span><br><span class="line">    Navigator.pushNamed(context, <span class="string">"router/static_page"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p><span data-type="color" style="color:rgb(47, 47, 47)"><span data-type="background" style="background-color:rgb(255, 255, 255)">当需要向下一个页面传递参数时，要用到所谓的动态路由，自己生成页面对象，所以可以传递自己想要的参数。</span></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FlatButton(</span><br><span class="line">  child: Text(<span class="string">"open dynamic router"</span>),</span><br><span class="line">  textColor: Colors.blue,</span><br><span class="line">  onPressed: () &#123;</span><br><span class="line">    Navigator.push(context, MaterialPageRoute(</span><br><span class="line">        builder: (context) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> EchoRoute(<span class="string">"传入跳转参数"</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">    或者</span><br><span class="line">    Navigator.of（(context).push(MaterialPageRoute(</span><br><span class="line">        builder: (context) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> EchoRoute(<span class="string">"传入跳转参数"</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="点击返回"><a href="#点击返回" class="headerlink" title="点击返回"></a>点击返回</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> RaisedButton(</span><br><span class="line">  child: <span class="keyword">new</span> Text(<span class="string">"点我返回"</span>),</span><br><span class="line">  onPressed: () &#123;</span><br><span class="line">    Navigator.of(context).pop();</span><br><span class="line">  &#125;,</span><br><span class="line">  color: Colors.blue,</span><br><span class="line">  highlightColor: Colors.lightBlue,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们可以在前一个页面接受第二个页面的返回值<br>在第一个页面跳转时候加上futrue来接收<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FlatButton(</span><br><span class="line">  child: Text(<span class="string">"open dynamic router"</span>),</span><br><span class="line">  textColor: Colors.blue,</span><br><span class="line">  onPressed: () &#123;</span><br><span class="line">    Future future = Navigator.push(context,</span><br><span class="line">        MaterialPageRoute(builder: (context) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> EchoRoute(<span class="string">"传入跳转参数"</span>);</span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="comment">//接收动态页面返回时传回的值</span></span><br><span class="line">    future.then((value) &#123;</span><br><span class="line">      showDialog(</span><br><span class="line">          context: context,</span><br><span class="line">          child: <span class="keyword">new</span> AlertDialog(</span><br><span class="line">            title: <span class="keyword">new</span> Text(value),</span><br><span class="line">          ));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>在EchoRoute页面 返回时使用带参数的pop方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> RaisedButton(</span><br><span class="line">                child: <span class="keyword">new</span> Text(<span class="string">"点我返回"</span>),</span><br><span class="line">                onPressed: () &#123;</span><br><span class="line"><span class="comment">//                  Navigator.of(context).pop();</span></span><br><span class="line">                  Navigator.of(context).pop(<span class="string">"我是来自dymamic 关闭的返回值"</span>);</span><br><span class="line">                &#125;,</span><br><span class="line">                color: Colors.blue,</span><br><span class="line">                highlightColor: Colors.lightBlue,</span><br><span class="line">              )</span><br></pre></td></tr></table></figure></p><p>这样就会在关闭EchoRoute回到跳转前页面时弹出dialog收到EchoRoute传来的参数</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">Navigator的职责是负责管理Route的，管理方式就是利用一个栈不停压入弹出，当然也可以直接替换其中某一个Route。而Route作为一个管理单元，主要负责创建对应的界面，响应Navigator压入路由和弹出路由</span></span></p><p>入栈：</p><ul><li>使用Navigator.of(context).pushName(“path“)或者Navigator.pushName(context,“path“)可以进行静态路由的跳转前提是需要在route属性里面注册</li><li>使用push(Route)可以进行态路由的跳转，动态路由可以传入未知数据</li></ul><p>出栈</p><ul><li>使用pop()可以进行路由的出栈并且可以传递参数</li><li>可以使用Future接收上个页面返回的值。</li></ul><p>代码在 <a href="https://github.com/xsfelvis/learnflutter/blob/e7bd2e29c1b39c8ea19e06bfebb6e7d55b9ab42a/lib/demo4/demo4main.dart" target="_blank" rel="noopener">https://github.com/xsfelvis/learnflutter/blob/e7bd2e29c1b39c8ea19e06bfebb6e7d55b9ab42a/lib/demo4/demo4main.dart</a></p><p># </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;路由是native中应用的比较多，特别是
      
    
    </summary>
    
      <category term="Flutter" scheme="https://xsfelvis.github.io/categories/Flutter/"/>
    
    
      <category term="路由" scheme="https://xsfelvis.github.io/tags/%E8%B7%AF%E7%94%B1/"/>
    
      <category term="Flutter" scheme="https://xsfelvis.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>dio+json_serializable从网络请求到数据解析</title>
    <link href="https://xsfelvis.github.io/2018/12/08/dio+json_serializable%E8%AF%B7%E6%B1%82%E5%88%B0%E8%A7%A3%E6%9E%90%E6%95%B0%E6%8D%AE/"/>
    <id>https://xsfelvis.github.io/2018/12/08/dio+json_serializable请求到解析数据/</id>
    <published>2018-12-07T16:00:00.000Z</published>
    <updated>2018-12-08T12:01:25.280Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网络请求到数据解析是一个app必不可少的流程之一，在flutter官网中目前主要是介绍 自带的<a href="https://flutterchina.club/networking/" target="_blank" rel="noopener">Http</a>请求+<a href="https://flutterchina.club/json/" target="_blank" rel="noopener">Json解析</a> 但是也推荐了更好的网路请求到组合的方式 dio 和 json_serializable，本篇文章主要介绍这两个方式的使用，源码在结尾</p><h1 id="dio"><a href="#dio" class="headerlink" title="dio"></a>dio</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>package地址 <a href="https://pub.flutter-io.cn/packages/dio" target="_blank" rel="noopener">https://pub.flutter-io.cn/packages/dio</a>，<br>添加依赖</p><blockquote><p><span data-type="color" style="color:rgb(51, 51, 51)">dependencies:  </span><br>    <strong>dio: </strong><strong><span data-type="color" style="color:rgb(221, 17, 68)">^1.0.9</span></strong><br>支持了<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">支持Restful API、FormData、拦截器、请求取消、Cookie管理、文件上传/下载、超时等</span></span><br>Performing a <code>GET</code> request: 简单的使用如下</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Response response;</span><br><span class="line">response=await dio.get(<span class="string">"/test?id=12&amp;name=wendu"</span>)</span><br><span class="line">print(response.data.toString());</span><br><span class="line"><span class="comment">// Optionally the request above could also be done as</span></span><br><span class="line">response=await dio.get(<span class="string">"/test"</span>,data:&#123;<span class="string">"id"</span>:<span class="number">12</span>,<span class="string">"name"</span>:<span class="string">"wendu"</span>&#125;)</span><br><span class="line">print(response.data.toString());</span><br></pre></td></tr></table></figure><p>Performing a <code>POST</code> request:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response=await dio.post(<span class="string">"/test"</span>,data:&#123;<span class="string">"id"</span>:<span class="number">12</span>,<span class="string">"name"</span>:<span class="string">"wendu"</span>&#125;)</span><br></pre></td></tr></table></figure><p>Performing multiple concurrent requests:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response= await Future.wait([dio.post(<span class="string">"/info"</span>),dio.get(<span class="string">"/token"</span>)]);</span><br></pre></td></tr></table></figure><p>Downloading a file:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response=await dio.download(<span class="string">"https://www.google.cn/"</span>,<span class="string">"./xx.html"</span>)</span><br></pre></td></tr></table></figure><p>Sending FormData:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FormData formData = <span class="keyword">new</span> FormData.from(&#123;</span><br><span class="line">   <span class="string">"name"</span>: <span class="string">"wendux"</span>,</span><br><span class="line">   <span class="string">"age"</span>: <span class="number">25</span>,</span><br><span class="line">&#125;);</span><br><span class="line">response = await dio.post(<span class="string">"/info"</span>, data: formData)</span><br></pre></td></tr></table></figure><p>Uploading multiple files to server by FormData:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FormData formData = <span class="keyword">new</span> FormData.from(&#123;</span><br><span class="line">   <span class="string">"name"</span>: <span class="string">"wendux"</span>,</span><br><span class="line">   <span class="string">"age"</span>: <span class="number">25</span>,</span><br><span class="line">   <span class="string">"file1"</span>: <span class="keyword">new</span> UploadFileInfo(<span class="keyword">new</span> File(<span class="string">"./upload.txt"</span>), <span class="string">"upload1.txt"</span>),</span><br><span class="line">   <span class="comment">// upload with bytes (List&lt;int&gt;) </span></span><br><span class="line">   <span class="string">"file2"</span>: <span class="keyword">new</span> UploadFileInfo.fromBytes(utf8.encode(<span class="string">"hello world"</span>),<span class="string">"word.txt"</span>),</span><br><span class="line">   <span class="comment">// Pass multiple files within an Array </span></span><br><span class="line">   <span class="string">"files"</span>: [</span><br><span class="line">      <span class="keyword">new</span> UploadFileInfo(<span class="keyword">new</span> File(<span class="string">"./example/upload.txt"</span>), <span class="string">"upload.txt"</span>),</span><br><span class="line">      <span class="keyword">new</span> UploadFileInfo(<span class="keyword">new</span> File(<span class="string">"./example/upload.txt"</span>), <span class="string">"upload.txt"</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br><span class="line">response = await dio.post(<span class="string">"/info"</span>, data: formData)</span><br></pre></td></tr></table></figure><p>更多可以参考作者的<a href="https://juejin.im/post/5b04c954f265da0b9c10fb61" target="_blank" rel="noopener">说明文章</a>以及 <a href="https://github.com/flutterchina/dio/tree/flutter/example" target="_blank" rel="noopener">example</a></p><p>并且由于flutter原生的网络库http不支持charles抓包，这个库可以使用设置代理来达到抓包的目的，ip自己替换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dio.onHttpClientCreate = (HttpClient client) &#123;</span><br><span class="line">  client.findProxy = (uri) &#123;</span><br><span class="line">    <span class="comment">//proxy all request to localhost:8888</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"PROXY yourIP:yourPort"</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样就可抓包了。</p><h2 id="网络请求封装使用"><a href="#网络请求封装使用" class="headerlink" title="网络请求封装使用"></a>网络请求封装使用</h2><p>简单封装使我们更加容易的使用，核心代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_request</span><span class="params">(String url, Function callBack,</span></span></span><br><span class="line"><span class="function"><span class="params">      &#123;String method,</span></span></span><br><span class="line"><span class="function"><span class="params">      Map&lt;String, String&gt; params,</span></span></span><br><span class="line"><span class="function"><span class="params">      Function errorCallBack&#125;)</span> async </span>&#123;</span><br><span class="line"><span class="comment">//    dio.onHttpClientCreate = (HttpClient client) &#123;</span></span><br><span class="line"><span class="comment">//      client.findProxy = (uri) &#123;</span></span><br><span class="line"><span class="comment">//        //proxy all request to localhost:8888</span></span><br><span class="line"><span class="comment">//        return "PROXY 172.23.235.153:8888";</span></span><br><span class="line"><span class="comment">//      &#125;;</span></span><br><span class="line"><span class="comment">//    &#125;;</span></span><br><span class="line">    String errorMsg = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> statusCode;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Response response;</span><br><span class="line">      <span class="keyword">if</span> (method == GET) &#123;</span><br><span class="line">        <span class="keyword">if</span> (params != <span class="keyword">null</span> &amp;&amp; params.isNotEmpty) &#123;</span><br><span class="line">          StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"?"</span>);</span><br><span class="line">          params.forEach((key, value) &#123;</span><br><span class="line">            sb.write(<span class="string">"$key"</span> + <span class="string">"="</span> + <span class="string">"$value"</span> + <span class="string">"&amp;"</span>);</span><br><span class="line">          &#125;);</span><br><span class="line">          String paramStr = sb.toString();</span><br><span class="line">          paramStr = paramStr.substring(<span class="number">0</span>, paramStr.length - <span class="number">1</span>);</span><br><span class="line">          url += paramStr;</span><br><span class="line">        &#125;</span><br><span class="line">        response = await dio.get(url);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method == POST) &#123;</span><br><span class="line">        <span class="keyword">if</span> (params != <span class="keyword">null</span> &amp;&amp; params.isNotEmpty) &#123;</span><br><span class="line">          response = await dio.post(url, data: params);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          response = await dio.post(url);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      statusCode = response.statusCode;</span><br><span class="line">      <span class="keyword">if</span> (statusCode &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        errorMsg = <span class="string">"网络请求错误,状态码:"</span> + statusCode.toString();</span><br><span class="line">        _handError(errorCallBack, errorMsg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (callBack != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String res2Json  = json.encode(response.data);</span><br><span class="line">        Map&lt;String,dynamic&gt; map=json.decode(res2Json);</span><br><span class="line">        callBack(map[<span class="string">"data"</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (exception) &#123;</span><br><span class="line">      _handError(errorCallBack, exception.toString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>详细的可以参考源码<a href="https://github.com/xsfelvis/learnflutter/blob/047fb2c9cc08334c1adcc7b7892ebfe28a2cf13f/lib/demo3/utils/net/HttpCore.dart" target="_blank" rel="noopener">https://github.com/xsfelvis/learnflutter/blob/047fb2c9cc08334c1adcc7b7892ebfe28a2cf13f/lib/demo3/utils/net/HttpCore.dart</a></p><p>使用如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HttpCore.instance.get(Api.HOME_BANNER, (data) &#123;</span><br><span class="line">  List&lt;BannerData&gt; banners = getBannersList(data);</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    slideData = banners;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, errorCallBack: (errorMsg) &#123;</span><br><span class="line">  print(<span class="string">"error:"</span> + errorMsg);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><p>在封装网络库的的时候发现 底层 response.data[‘data’]时候当是一个<a href="ttp://www.wanandroid.com/banner/json" target="_blank" rel="noopener">jsonarray</a>时候竟然无法直接取出’data’,”Stirng not subType of Index “错误，原因是 此时拿到的不是一个json数据，没有双引号的假json数据，但是在<a href="http://www.wanandroid.com/article/list/1/json" target="_blank" rel="noopener">jsonobject</a>却可以，解决如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (callBack != <span class="keyword">null</span>) &#123;</span><br><span class="line">  String res2Json  = json.encode(response.data);</span><br><span class="line">  Map&lt;String,dynamic&gt; map=json.decode(res2Json);</span><br><span class="line">  callBack(map[<span class="string">"data"</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="json-serializable"><a href="#json-serializable" class="headerlink" title="json_serializable"></a>json_serializable</h1><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>package地址 <a href="https://pub.flutter-io.cn/packages/json_serializable" target="_blank" rel="noopener">https://pub.flutter-io.cn/packages/json_serializable</a><br>添加依赖</p><blockquote><p><span data-type="color" style="color:rgb(51, 51, 51)">dependencies:  </span><br>    <strong>json_serializable: </strong><strong><span data-type="color" style="color:rgb(221, 17, 68)">^2.0.0 </span></strong><br>dev_dependencies<br>    build_runner: ^1.1.2<br>    json_serializable: ^2.0.0</p></blockquote><p>这个是个好东西，之前的相当于json数据一个个通过key解出来（关于自带的json解析可以参考 <a href="https://juejin.im/post/5b5d782ae51d45191c7e7fb3#heading-7" target="_blank" rel="noopener">https://juejin.im/post/5b5d782ae51d45191c7e7fb3#heading-7</a>），不仅耗时而且容易出错，json_serializable 让我们直接反序列化成对象直接使用类似于Gson，而且还提供了<a href="https://caijinglong.github.io/json2dart/index_ch.html" target="_blank" rel="noopener">一个工具</a>来自动帮助我们生成代码，简单快捷而且不容易出错</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>以json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>:&#123;</span><br><span class="line">        <span class="attr">"curPage"</span>:<span class="number">2</span>,</span><br><span class="line">        <span class="attr">"datas"</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"apkLink"</span>:<span class="string">""</span>,</span><br><span class="line">                <span class="attr">"author"</span>:<span class="string">"鸿洋"</span>,</span><br><span class="line">                <span class="attr">"chapterId"</span>:<span class="number">410</span>,</span><br><span class="line">                <span class="attr">"chapterName"</span>:<span class="string">"玉刚说"</span>,</span><br><span class="line">                <span class="attr">"collect"</span>:<span class="literal">false</span>,</span><br><span class="line">                <span class="attr">"courseId"</span>:<span class="number">13</span>,</span><br><span class="line">                <span class="attr">"desc"</span>:<span class="string">""</span>,</span><br><span class="line">                <span class="attr">"envelopePic"</span>:<span class="string">""</span>,</span><br><span class="line">                <span class="attr">"fresh"</span>:<span class="literal">false</span>,</span><br><span class="line">                <span class="attr">"id"</span>:<span class="number">7604</span>,</span><br><span class="line">                <span class="attr">"link"</span>:<span class="string">"https://mp.weixin.qq.com/s/cCZKmqKrdCn63eWTbOuANw"</span>,</span><br><span class="line">                <span class="attr">"niceDate"</span>:<span class="string">"2018-12-03"</span>,</span><br><span class="line">                <span class="attr">"origin"</span>:<span class="string">""</span>,</span><br><span class="line">                <span class="attr">"projectLink"</span>:<span class="string">""</span>,</span><br><span class="line">                <span class="attr">"publishTime"</span>:<span class="number">1543830090000</span>,</span><br><span class="line">                <span class="attr">"superChapterId"</span>:<span class="number">408</span>,</span><br><span class="line">                <span class="attr">"superChapterName"</span>:<span class="string">"公众号"</span>,</span><br><span class="line">                <span class="attr">"tags"</span>:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>:<span class="string">"公众号"</span>,</span><br><span class="line">                        <span class="attr">"url"</span>:<span class="string">"/wxarticle/list/410/1"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">"title"</span>:<span class="string">"在 Retrofit 和 OkHttp 中使用网络缓存，提高访问效率"</span>,</span><br><span class="line">                <span class="attr">"type"</span>:<span class="number">0</span>,</span><br><span class="line">                <span class="attr">"userId"</span>:<span class="number">-1</span>,</span><br><span class="line">                <span class="attr">"visible"</span>:<span class="number">1</span>,</span><br><span class="line">                <span class="attr">"zan"</span>:<span class="number">0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"apkLink"</span>:<span class="string">""</span>,</span><br><span class="line">                <span class="attr">"author"</span>:<span class="string">"鸿洋"</span>,</span><br><span class="line">                <span class="attr">"chapterId"</span>:<span class="number">408</span>,</span><br><span class="line">                <span class="attr">"chapterName"</span>:<span class="string">"鸿洋"</span>,</span><br><span class="line">                <span class="attr">"collect"</span>:<span class="literal">false</span>,</span><br><span class="line">                <span class="attr">"courseId"</span>:<span class="number">13</span>,</span><br><span class="line">                <span class="attr">"desc"</span>:<span class="string">""</span>,</span><br><span class="line">                <span class="attr">"envelopePic"</span>:<span class="string">""</span>,</span><br><span class="line">                <span class="attr">"fresh"</span>:<span class="literal">false</span>,</span><br><span class="line">                <span class="attr">"id"</span>:<span class="number">7605</span>,</span><br><span class="line">                <span class="attr">"link"</span>:<span class="string">"https://mp.weixin.qq.com/s/r3AWeYafyMEc1-g8BWEHBg"</span>,</span><br><span class="line">                <span class="attr">"niceDate"</span>:<span class="string">"2018-12-03"</span>,</span><br><span class="line">                <span class="attr">"origin"</span>:<span class="string">""</span>,</span><br><span class="line">                <span class="attr">"projectLink"</span>:<span class="string">""</span>,</span><br><span class="line">                <span class="attr">"publishTime"</span>:<span class="number">1543766400000</span>,</span><br><span class="line">                <span class="attr">"superChapterId"</span>:<span class="number">408</span>,</span><br><span class="line">                <span class="attr">"superChapterName"</span>:<span class="string">"公众号"</span>,</span><br><span class="line">                <span class="attr">"tags"</span>:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>:<span class="string">"公众号"</span>,</span><br><span class="line">                        <span class="attr">"url"</span>:<span class="string">"/wxarticle/list/408/1"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">"title"</span>:<span class="string">"非 UI 线程能调用 View.invalidate()？"</span>,</span><br><span class="line">                <span class="attr">"type"</span>:<span class="number">0</span>,</span><br><span class="line">                <span class="attr">"userId"</span>:<span class="number">-1</span>,</span><br><span class="line">                <span class="attr">"visible"</span>:<span class="number">1</span>,</span><br><span class="line">                <span class="attr">"zan"</span>:<span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"offset"</span>:<span class="number">20</span>,</span><br><span class="line">        <span class="attr">"over"</span>:<span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"pageCount"</span>:<span class="number">289</span>,</span><br><span class="line">        <span class="attr">"size"</span>:<span class="number">20</span>,</span><br><span class="line">        <span class="attr">"total"</span>:<span class="number">5779</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"errorCode"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="attr">"errorMsg"</span>:<span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为例，我们首先找到实际数据信息，因为异errorcode 之类的处理已在上面的封装网络请求中处理了，这里需要关注 实际内容传递者 “data”里面的数据，将上面这个data里面的jsonObject，从data 这个key后面包括大括号一起复制到上面的代码生成工具网页里面，截图如下</p><p><img src="https://cdn.nlark.com/yuque/0/2018/png/215777/1544266913529-762efea8-b8e9-4d65-b7a1-67599f277055.png" alt="image.png | left | 747x341"></p><p>然后<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">当前项目的目录下运行</span></span><br><code>flutter packages pub run build_runner build</code></p><p>然就可以得到news.g.dart文件</p><p>然后在使用中通过获取对象属性的方式就可以直接拿到我们关注的字段了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  获取News数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_getNewsList</span><span class="params">(<span class="keyword">int</span> curpage)</span> </span>&#123;</span><br><span class="line">  var url = Api.HOME_ARTICLE + curpage.toString() + <span class="string">"/json"</span>;</span><br><span class="line">  HttpCore.instance.get(url, (data) &#123;</span><br><span class="line">    News news = News.fromJson(data);</span><br><span class="line">    List&lt;Datas&gt; newsDatas = news.datas;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      listData = newsDatas;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="自定义字段的处理"><a href="#自定义字段的处理" class="headerlink" title="自定义字段的处理"></a>自定义字段的处理</h4><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">我们可以通过JsonKey自定义参数进行注释并自定义参数来自定义各个字段。例如:是否允许字段为空等。</span></span><strong>注意，这里不加任何JsonKey默认允许空json字段。</strong><br>比如解析字段有个横线，<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">而dart中只允许字母数字下划线作为变量名。所以我们必须对它进行特殊处理。@JsonKey(name=&quot;Nicehash-CNHeavy&quot;)来解析map，通常自动生成代码的工具已经可以帮助我们解决了</span></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonKey</span>(name: <span class="string">'off-set'</span>)</span><br><span class="line"><span class="keyword">int</span> offset;</span><br></pre></td></tr></table></figure><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>效果如下图</p><p><img src="https://cdn.nlark.com/yuque/0/2018/png/215777/1544267293376-274ccea1-1b3b-457c-8150-04fd795f6909.png" alt="image.png | left | 250x515.9574468085107"></p><p>接口来自 <a href="http://www.wanandroid.com/blog/show/2" target="_blank" rel="noopener">玩Android的开放接口</a></p><p>代码在<a href="https://github.com/xsfelvis/learnflutter" target="_blank" rel="noopener"> learnflutter</a> 的demo3</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;网络请求到数据解析是一个app必不可少的
      
    
    </summary>
    
      <category term="Flutter" scheme="https://xsfelvis.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://xsfelvis.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入坑指南</title>
    <link href="https://xsfelvis.github.io/2018/12/01/Flutter%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <id>https://xsfelvis.github.io/2018/12/01/Flutter入坑指南/</id>
    <published>2018-11-30T16:00:00.000Z</published>
    <updated>2018-12-01T14:09:58.365Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是一个纯Flutter项目，主要通过实现网络请求新闻表展示以及跳转webview详情页，来初步感受了一下最近很火的Flutter</p><p><img src="https://cdn.nlark.com/yuque/0/2018/png/215777/1543666189481-c2561294-1f65-4191-b487-8a8e7675d3ba.png" alt="image.png | left | 200x348.28660436137073"></p><p>代码在 <a href="https://github.com/xsfelvis/learnflutter.git" target="_blank" rel="noopener">源码地址</a> 部分代码参考 <a href="https://github.com/zhangjianli/flutter_news" target="_blank" rel="noopener">https://github.com/zhangjianli/flutter_news</a></p><h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><p>可以参考 <a href="https://flutterchina.club/setup-macos/" target="_blank" rel="noopener">Flutter中文网</a> 我使用的是AndroidStudio，这里需要注意的是下载下来的flutter sdk 在会自动下载dart sdk 具体在 flutter/bin/cache/dark-sdk往往在导入新工程时候需要设置dart sdk 注意设置一下就好</p><h1 id="Dart"><a href="#Dart" class="headerlink" title="Dart"></a>Dart</h1><p>Flutter的开发语言采用Dart，这是一门很棒的语言，集合了现代语言的很多优点，学习了一下之后感觉有java的影子，也有es6的影子，写起来很简练,Dart有个<a href="http://dart.goodev.org/guides/language/language-tour#operators%E6%93%8D%E4%BD%9C%E7%AC%A6" target="_blank" rel="noopener">官方学习网站</a></p><h1 id="Flutter之布局"><a href="#Flutter之布局" class="headerlink" title="Flutter之布局"></a>Flutter之布局</h1><p>比如实现一个如下的布局</p><p><img src="https://cdn.nlark.com/yuque/0/2018/png/215777/1543669524555-f934cfa0-42a7-438f-ac6a-6237b9118896.png" alt="stack.png | center | 150x150"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function">Widget <span class="title">build</span><span class="params">(BuildContext context)</span> </span>&#123;</span><br><span class="line">    var stack = <span class="keyword">new</span> Stack(</span><br><span class="line">      alignment: <span class="function"><span class="keyword">const</span> <span class="title">Alignment</span><span class="params">(<span class="number">0.6</span>, <span class="number">0.6</span>)</span>,</span></span><br><span class="line"><span class="function">      children: [</span></span><br><span class="line"><span class="function">        new <span class="title">CircleAvatar</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          backgroundImage: new AssetImage(<span class="string">'images/pic.jpg'</span>)</span>,</span></span><br><span class="line"><span class="function">          radius: 100.0,</span></span><br><span class="line"><span class="function">        ),</span></span><br><span class="line"><span class="function">        new <span class="title">Container</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          decoration: new BoxDecoration(</span></span></span><br><span class="line"><span class="function"><span class="params">            color: Colors.black45,</span></span></span><br><span class="line"><span class="function"><span class="params">          )</span>,</span></span><br><span class="line"><span class="function">          child: new <span class="title">Text</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">'Mia B'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            style: new TextStyle(</span></span></span><br><span class="line"><span class="function"><span class="params">              fontSize: <span class="number">20.0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              fontWeight: FontWeight.bold,</span></span></span><br><span class="line"><span class="function"><span class="params">              color: Colors.white,</span></span></span><br><span class="line"><span class="function"><span class="params">            )</span>,</span></span><br><span class="line"><span class="function">          ),</span></span><br><span class="line"><span class="function">        ),</span></span><br><span class="line"><span class="function">      ],</span></span><br><span class="line"><span class="function">    )</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看其实挺懵逼的，</p><p>要记住一点在Flutter中一切皆为’<a href="https://flutterchina.club/widgets/layout/" target="_blank" rel="noopener">Widget</a>‘，<span data-type="color" style="color:rgb(26, 26, 26)"><span data-type="background" style="background-color:rgb(255, 255, 255)">在flutter的世界里，包括views,view controllers,layouts等在内的概念都建立在Widget之上。widget是flutter功能的抽象描述,掌握Flutter的基础就是学会使用widget开始</span></span>甚至一个padding就是一个widget，官网是按照子元素来分类的</p><ul><li>单个子元素（child）的布局，包括Container、Padding等<code>18</code>种（目前是2018年12月1日，后续我想肯定会增加的）；</li><li>多个子元素（children）的布局，包括Row、Column等<code>11</code>种；</li><li>layout helper，例如ListView.Builder，在元素多的时候，用这种方式更加的高效，类似Android的RecyclerView，有自动的回收机制。这种严格意义上不能算是一个种类，我觉得这种helper会越来越多。</li></ul><p>常见有的<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">其中常用有 </span></span><em>Container、Padding、Center、Flex、Stack、Row、Column、ListView</em><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>等</p><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="auto"><br>      <col width="auto"><br>    </colgroup><br>    <tbody><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">类型</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">特点</div><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">Container</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">只有一个子 Widget。默认充满，包含了padding、margin、color、宽高、decoration 等配置。<br>          </div><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">Padding</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">只有一个子 Widget。只用于设置Padding，常用于嵌套child，给child设置padding。<br>          </div><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">Center </div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">只有一个子 Widget。只用于居中显示，常用于嵌套child，给child设置居中。<br>          </div><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">Expanded</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">只有一个子 Widget。在 Column 和 Row 中充满。</div><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">Stack </div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">可以有多个子 Widget。 子Widget堆叠在一起。 (类似Android的 FrameLayout)</div><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">Column</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">可以有多个子 Widget。垂直布局。 (类似Android的 LinearLayout vertical)</div><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">Row</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">可以有多个子 Widget。水平布局。 (类似Android的 LinearLayout horizon)</div><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><p>这布局写起来确实很酸爽，不过统一渲染效率更高，但是掌握起来比较费事，感觉平台侧的一些成本转嫁到开发者身上，不知道后期有没有类似xml这种布局单独剥离出来的实现。</p><h2 id="widget详解"><a href="#widget详解" class="headerlink" title="widget详解"></a>widget详解</h2><p>一切皆为widget，主要分为两类 <span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">StatefulWidget(有状态)</span></span>和 <span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">StatelessWidget(无状态)</span></span></p><ul><li><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">StatefulWidget(有状态)</span></span><br><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">如果一个控件需要动态的去改变或者相应一些状态，例如点击态、色值、内容区域等，那么一般都是继承自StatefulWidget，常见的有CheckBox、AppBar、TabBar等</span></span></li><li><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">StatelessWidget(无状态)</span></span><br><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">如果一个控件自身状态不会去改变，创建了就直接显示，不会有色值、大小或者其他属性的变化，这种widget一般都是继承自StatelessWidget，常见的有Container、ScrollView等</span></span></li></ul><p>StatefulWidget和StatelessWidget如下所示</p><p><img src="https://cdn.nlark.com/yuque/0/2018/png/215777/1543671041809-a8dbbd7b-8372-4d53-9a6c-c852f3123920.png" alt="image.png | left | 747x214"></p><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">一个StatelessWidget可以用多个不同的BuildContext构建，而一个StatefulWidget会为每个BuildContext创建一个State对象</span></span></p><p>对于StatelessWidget，build方法会在如下三种情况下调用，</p><ol><li>widget第一次被插入到树中；</li><li>widget的父节点更改了配置（configuration）；</li><li>widget依赖的InheritedWidget改变了;</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frog</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">Frog</span><span class="params">(&#123; Key key &#125;)</span> : <span class="title">super</span><span class="params">(key: key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function">Widget <span class="title">build</span><span class="params">(BuildContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Container(color: <span class="function"><span class="keyword">const</span> <span class="title">Color</span><span class="params">(<span class="number">0xFF2DBD3A</span>)</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StatefulWidget的两个主要类别：</p><ul><li>在initState中创建资源，在dispose中销毁，但是不依赖于InheritedWidget或者调用setState方法，这类widget基本上用在一个应用或者页面的root；</li><li>使用setState或者依赖于InheritedWidget，这种会在生命周期中会被重建（rebuild）很多次。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YellowBird</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">YellowBird</span><span class="params">(&#123; Key key &#125;)</span> : <span class="title">super</span><span class="params">(key: key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function">_YellowBirdState <span class="title">createState</span><span class="params">()</span> </span>=&gt; <span class="keyword">new</span> _YellowBirdState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_YellowBirdState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">YellowBird</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function">Widget <span class="title">build</span><span class="params">(BuildContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Container(color: <span class="function"><span class="keyword">const</span> <span class="title">Color</span><span class="params">(<span class="number">0xFFFFE306</span>)</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p>状态有何作用呢</p><ul><li>在widget构建的时候可以被同步读取；</li><li><p>在widget的生命周期中可能会被改变。</p><h3 id="State生命周期"><a href="#State生命周期" class="headerlink" title="State生命周期"></a>State生命周期</h3><p>对应的生命周期如下</p></li><li><p>created：当State对象被创建时候，State.initState方法会被调用；</p></li><li>initialized：当State对象被创建，但还没有准备构建时，State.didChangeDependencies在这个时候会被调用；</li><li>ready：State对象已经准备好了构建，State.dispose没有被调用的时候；</li><li>defunct：State.dispose被调用后，State对象不能够被构建</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2018/png/215777/1543671683971-29e23732-0120-4cd7-a8d1-019a3ba5510b.png" alt="image.png | left | 747x391"></p><p>完整生命周期如下：</p><ul><li>创建一个State对象时，会调用StatefulWidget.createState；</li><li>和一个BuildContext相关联，可以认为被加载了（mounted）；</li><li>调用initState；</li><li>调用didChangeDependencies；</li><li>经过上述步骤，State对象被完全的初始化了，调用build；</li><li>如果有需要，会调用didUpdateWidget；</li><li>如果处在开发模式，热加载会调用reassemble；</li><li>如果它的子树（subtree）包含需要被移除的State对象，会调用deactivate；</li><li>调用dispose,State对象以后都不会被构建；</li><li>当调用了dispose,State对象处于未加载（unmounted），已经被dispose的State对象没有办法被重新加载（remount）。</li></ul><h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">当修改状态时，调用setState widget会被更新</span></span></p><h2 id="如何布局"><a href="#如何布局" class="headerlink" title="如何布局"></a>如何布局</h2><p>每个页面设计都不一样，相同页面可选择的布局方式也不一样，可以参考下<a href="https://link.juejin.im?target=https%3A%2F%2Fflutterchina.club%2Ftutorials%2Flayout%2F%23common-layout-widgets" target="_blank" rel="noopener">Flutter官方的布局教程</a>。整个过程，基本上按照拆解、组件封装、具体布局这三步来的。</p><h1 id="Flutter之网络请求"><a href="#Flutter之网络请求" class="headerlink" title="Flutter之网络请求"></a>Flutter之网络请求</h1><p>在Android开发者我们可以使用okHttp，Flutter给我们封装好了，在pubspec.yaml文件中接入网络依赖库，相当于gradle的dependency，可以在 <a href="https://pub.flutter-io.cn/flutter/packages?q=http" target="_blank" rel="noopener">包查找</a> 中找到最新版本，在pubspec.yaml接入时候主要空格就好<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  flutter:</span><br><span class="line">    sdk: flutter</span><br><span class="line"></span><br><span class="line">  json_annotation: ^2.0.0</span><br><span class="line">  flutter_webview_plugin: ^0.3.0+2</span><br><span class="line">  http: ^0.12.0</span><br><span class="line"></span><br><span class="line">  # The following adds the Cupertino Icons font to your application.</span><br><span class="line">  # Use with the CupertinoIcons class for iOS style icons.</span><br><span class="line">  cupertino_icons: ^0.1.2</span><br></pre></td></tr></table></figure></p><p>具体使用起来也比较简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsApi</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Future&lt;NewsList&gt; <span class="title">getHeadlines</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      &#123;String category: <span class="string">"general"</span>, <span class="keyword">int</span> page: <span class="number">0</span>&#125;)</span> async </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> response = await http.get(</span><br><span class="line">        <span class="string">"https://newsapi.org/v2/top-headlines?country=us&amp;apiKey=$apikey&amp;page=$page&amp;category=$category"</span>);</span><br><span class="line">    <span class="keyword">return</span> compute(parseResult, response.body);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> NewsList <span class="title">parseResult</span><span class="params">(String respond)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> NewsList.fromJson(json.decode(respond));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体可以学习官网 <a href="https://flutterchina.club/networking/" target="_blank" rel="noopener">在Flutter中发起HTTP网络请求</a></p><h1 id="Flutter之数据解析"><a href="#Flutter之数据解析" class="headerlink" title="Flutter之数据解析"></a>Flutter之数据解析</h1><p>官网也给了反序列化的方法但是感觉比较古老，就跟json一样拿到msg一个个解析，有个更好的方式直接反序列化成对象，后面使用更加快捷</p><p>首先需要添加依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  ……</span><br><span class="line">  json_annotation: ^2.0.0</span><br><span class="line">dev_dependencies:</span><br><span class="line">  ……</span><br><span class="line">  build_runner: ^1.1.2</span><br><span class="line">  json_serializable: ^2.0.0</span><br></pre></td></tr></table></figure><p>具体用法可以参考 <a href="https://juejin.im/post/5b5f00e7e51d45190571172f#heading-13" target="_blank" rel="noopener">https://juejin.im/post/5b5f00e7e51d45190571172f#heading-13</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://flutterchina.club/setup-macos/" target="_blank" rel="noopener">Flutter中文网</a></li><li><a href="https://juejin.im/post/5b09fe716fb9a07aa114a6d9" target="_blank" rel="noopener">https://juejin.im/post/5b09fe716fb9a07aa114a6d9</a></li><li><a href="https://juejin.im/post/5b5192c4e51d4519115d0d8f#heading-7" target="_blank" rel="noopener">https://juejin.im/post/5b5192c4e51d4519115d0d8f#heading-7</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文是一个纯Flutter项目，主要通过
      
    
    </summary>
    
      <category term="Flutter" scheme="https://xsfelvis.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://xsfelvis.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Gradle进阶</title>
    <link href="https://xsfelvis.github.io/2018/10/19/gradle%E8%BF%9B%E9%98%B6/"/>
    <id>https://xsfelvis.github.io/2018/10/19/gradle进阶/</id>
    <published>2018-10-18T16:00:00.000Z</published>
    <updated>2018-10-19T14:12:41.126Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="Groovy-基础"><a href="#Groovy-基础" class="headerlink" title="Groovy 基础"></a>Groovy 基础</h2><ul><li><a href="https://gradle.org/" target="_blank" rel="noopener">官网</a></li><li><a href="https://blog.csdn.net/yanbober/article/details/49047515" target="_blank" rel="noopener">Groovy脚本基础全攻略</a></li></ul><h2 id="Gradle-DSL-基础"><a href="#Gradle-DSL-基础" class="headerlink" title="Gradle DSL 基础"></a>Gradle DSL 基础</h2><p><a href="https://docs.gradle.org/current/dsl/index.html" target="_blank" rel="noopener">DSL</a></p><h2 id="Android-DSL-基础"><a href="#Android-DSL-基础" class="headerlink" title="Android DSL 基础"></a>Android DSL 基础</h2><p><a href="http://google.github.io/android-gradle-dsl/current/index.html" target="_blank" rel="noopener">ASL</a></p><h2 id="自定义插件开发"><a href="#自定义插件开发" class="headerlink" title="自定义插件开发"></a>自定义插件开发</h2><h3 id="三种方式"><a href="#三种方式" class="headerlink" title="三种方式"></a>三种方式</h3><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>Build script</td><td>把插件写在 build.gradle 文件中，一般用于简单的逻辑，只在该 build.gradle 文件中可见</td></tr><tr><td>buildSrc 项目</td><td>将插件源代码放在 rootProjectDir/buildSrc/src/main/groovy 中，只对该项目中可见，适用于逻辑较为复杂</td></tr><tr><td>独立项目</td><td>一个独立的 Groovy 和 Java 项目，可以把这个项目打包成 Jar 文件包，一个 Jar 文件包还可以包含多个插件入口，将文件包发布到托管平台上，供其他人使用。本文将着重介绍此类。</td></tr></tbody></table><p>具体从插件开发可以参考</p><ul><li><a href="https://xsfelvis.github.io/2018/06/09/%E8%AF%91%E6%96%87_Writing%20Custom%20Plugins/">Writing Custom Plugins</a></li><li><a href="http://blog.bugtags.com/2016/03/28/embrace-android-studio-gradle-plugin/" target="_blank" rel="noopener">拥抱 Android Studio 之五：Gradle 插件开发</a></li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><blockquote><p><a href="https://docs.gradle.org/current/javadoc/org/gradle/api/DomainObjectCollection.html" target="_blank" rel="noopener">NamedDomainObjectContainer</a></p></blockquote><p>使用NamedDomainObjectContainer 简称NODC 这是一个容纳object的容器,DomainObjectCollection 可以直接访问所有对象，它的特点是它的内部使用SortedSet实现的，内部对象的name是unique的，而且是按name进行排序的。通常创建NDOC的方法就是调用,调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; [NamedDomainObjectContainer] &lt;T&gt; container(Class&lt;T&gt; type)</span><br></pre></td></tr></table></figure></p><p>这里需要注意的是<code>type</code>有一个要求：必须有一个public的构造函数，接受string作为一个参数</p><p>比如在buildScript中使用一个对象就需要使用NamedDomainObjectContainer </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NamedDomainObjectContainer&lt;Book&gt; bookContainer = mProject.container(Book.class,</span><br><span class="line">               new BookFactory(mInstantiator));</span><br></pre></td></tr></table></figure><p>具体可以参看<a href="https://github.com/xsfelvis/GradlePluginStudy/blob/1c39de3500e02db7d2b9a7facd0c88d7f2e0dc8f/complexscriptdsl/src/main/java/com/dev/complexdsl/ComplexDSLPlugin.java" target="_blank" rel="noopener">构造对象</a></p><blockquote><p>获取 debug还是release</p></blockquote><ul><li>variant.name.capitalize()这个就是获取的字符串是debug 还是release</li><li>variant.buildType.name.capitalize() 获取buildType</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def preDexTask = project.tasks.findByName(&quot;preDex$&#123;variant.name.capitalize()&#125;&quot;)</span><br><span class="line">def dexTask = project.tasks.findByName(&quot;dex$&#123;variant.name.capitalize()&#125;&quot;)</span><br><span class="line">def proguardTask = project.tasks.findByName(&quot;proguard$&#123;variant.name.capitalize()&#125;&quot;)</span><br></pre></td></tr></table></figure><p>这是nuwa热修复的源码他事先定义好了这些任务，这些任务就是把字节码文件打包成dex文件的任务，上面的代码意思就是获取这些任务的名字。（就是apply plugin: ‘com.android.application’里面的任务）。从上面的代码可以看到，我们定义的任务名称分别是（preDex${variant.name.capitalize()}）（dex${variant.name.capitalize()}）（proguard${variant.name.capitalize()}）（$这个符号就是拼接字符串的意思和kotlin一样</p><h2 id="project-beforeEvaluate-project-afterEvaluate"><a href="#project-beforeEvaluate-project-afterEvaluate" class="headerlink" title="project.beforeEvaluate/project.afterEvaluate"></a>project.beforeEvaluate/project.afterEvaluate</h2><p>这里在普及一个小知识，项目中gradle执行的时候，会先解析setting.gradle,然后是build.gradle,如果想在解析build.gradle之前做点事，可以使用project.beforeEvaluate如果想在解析build.gradle之后做点事可以project.afterEvaluate。</p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="加载task"><a href="#加载task" class="headerlink" title="加载task"></a>加载task</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (!imgDirectories.empty) &#123;</span><br><span class="line">                project.task(type: ImgOptimizerTask, overwrite: true, Constants.TASK_NAME.</span><br><span class="line">                        concat(project.name.capitalize()).concat(variant.buildType.name.capitalize())) &#123;</span><br><span class="line">                    it.group = &quot;optimize&quot;</span><br><span class="line">                    it.description = &quot;Optimize $&#123;variant.buildType.name&#125; images&quot;</span><br><span class="line">                    it.imgDirs = imgDirectories</span><br><span class="line">                    it.triggerSize = ext.triggerSize</span><br><span class="line">                    it.suffix = ext.suffix</span><br><span class="line">                    it.type = ext.type</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>关于Task的创建参数 参考 <a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#N14C11" target="_blank" rel="noopener">Project</a></p><h3 id="读取列表-列表长度不定"><a href="#读取列表-列表长度不定" class="headerlink" title="读取列表 列表长度不定"></a>读取列表 列表长度不定</h3><p>比如获取一个person的列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class HelloPlugin implements Plugin&lt;Project&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void apply(Project project) &#123;</span><br><span class="line">        //创建一个容器 </span><br><span class="line">        NamedDomainObjectContainer&lt;Person&gt; persons = project.container(Person)</span><br><span class="line">        //将容器添加为extension </span><br><span class="line">        project.extensions.add(&apos;team&apos;, persons)</span><br><span class="line">        def task = project.task(&apos;showTeam&apos;) &#123;</span><br><span class="line">            group &apos;junli&apos; doLast &#123; def team1 = project.extensions.getByName(&apos;team&apos;) println team1 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加子插件"><a href="#添加子插件" class="headerlink" title="添加子插件"></a>添加子插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// apply the maven publish plugin and dynamic dependency resolve plugin to all the sub projects</span><br><span class="line">project.subprojects &#123;</span><br><span class="line">    it.plugins.apply(MavenPublishPlugin)</span><br><span class="line">    it.plugins.apply(DependencyResolvePlugin)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hook资源"><a href="#hook资源" class="headerlink" title="hook资源"></a>hook资源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">task hookAssets &#123;</span><br><span class="line">  afterEvaluate &#123;</span><br><span class="line">    tasks.findByName(&quot;packageDebug&quot;).doFirst &#123; task -&gt;</span><br><span class="line">      copy &#123;</span><br><span class="line">        from &quot;$&#123;projectDir.absolutePath&#125;/test.png&quot;</span><br><span class="line">        into &quot;$&#123;task.assets.asPath&#125;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>在 project afterEvaluate 之后找到 packageDebug task</p></li><li><p>不妨在 app 目录下放入一个 test.png，使用 copy {} 闭包，from 填入的参数为 test.png 的路径，into 填入的参数为输出的路径，也就是 assets 的路径。</p></li></ol><h3 id="install-amp-amp-launch-apk"><a href="#install-amp-amp-launch-apk" class="headerlink" title="install &amp;&amp; launch apk"></a>install &amp;&amp; launch apk</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">task installAndRun(dependsOn: &apos;assembleDebug&apos;) &#123;</span><br><span class="line">  doFirst &#123;</span><br><span class="line">    exec &#123;</span><br><span class="line">      workingDir &quot;$&#123;buildDir&#125;/outputs/apk/debug&quot;</span><br><span class="line">      commandLine &apos;adb&apos;, &apos;install&apos;, &apos;-r&apos;, &apos;app-debug.apk&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    exec &#123;</span><br><span class="line">      def path = &quot;$&#123;buildDir&#125;/intermediates/manifests/full/debug/AndroidManifest.xml&quot;</span><br><span class="line">      // xml 解析</span><br><span class="line">      def parser = new XmlParser(false, false).parse(new File(path))</span><br><span class="line">      // application 下的每一个 activity 结点</span><br><span class="line">      parser.application.activity.each &#123; activity -&gt;</span><br><span class="line">        // activity 下的每一个 intent-filter 结点</span><br><span class="line">        activity.&apos;intent-filter&apos;.each &#123; filter -&gt;</span><br><span class="line">          // intent-filter 下的 action 结点中的 @android:name 包含 android.intent.action.MAIN</span><br><span class="line">          if (filter.action.@&quot;android:name&quot;.contains(&quot;android.intent.action.MAIN&quot;)) &#123;</span><br><span class="line">            def targetActivity = activity.@&quot;android:name&quot;</span><br><span class="line">            commandLine &apos;adb&apos;, &apos;shell&apos;, &apos;am&apos;, &apos;start&apos;, &apos;-n&apos;,</span><br><span class="line">                &quot;$&#123;android.defaultConfig.applicationId&#125;/$&#123;targetActivity&#125;&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="apk变体"><a href="#apk变体" class="headerlink" title="apk变体"></a>apk变体</h3><p>根据官方文档可以知道开发者可以通过 android.applicationVariants.all 获取到当前所有的 apk 变体，该变体的类型为 ApplicationVariant，其父类 BaseVariantOutput 中含 name 字段，该字段实际上就是当前变体的名字，那么其实只需要判断该 name 字段是否包含 release 关键字即可。</p><ol><li>代码解析</li></ol><p><code>功能</code></p><p>在 app 目录下创建 pic 文件夹，并添加一个名为 test 的 png 图片，hook apk 打包流程将该图片添加入 apk 的 assets 文件夹。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class HookAssetsPlugin implements Plugin&lt;Project&gt; &#123;</span><br><span class="line">  @Override</span><br><span class="line">  void apply(Project project) &#123;</span><br><span class="line">    project.afterEvaluate &#123;</span><br><span class="line">      project.plugins.withId(&apos;com.android.application&apos;) &#123;</span><br><span class="line">        project.android.applicationVariants.all &#123; ApplicationVariant variant -&gt;</span><br><span class="line">          variant.outputs.each &#123; ApkVariantOutput variantOutput -&gt;</span><br><span class="line">            if (variantOutput.name.equalsIgnoreCase(&quot;release&quot;)) &#123;</span><br><span class="line">              variantOutput.packageApplication.doFirst &#123; PackageApplication task -&gt;</span><br><span class="line">                project.copy &#123;</span><br><span class="line">                  from &quot;$&#123;project.projectDir.absolutePath&#125;/pic/test.png&quot;</span><br><span class="line">                  into &quot;$&#123;task.assets.asPath&#125;&quot;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解析点</p></blockquote><ol><li>在 project.afterEvaluate 闭包中才能获取到当前 project 中的所有 task 。</li><li>通过 project.plugins.withId(‘com.android.application’) 确保当前 project 是 Android app project 而不是 Android library project，以此来避免无效操作</li><li>通过 project.android.applicationVariants.all 获取所有变体信息。</li><li>在日常开发中寻找 task 的方式可能更多的是使用 project.tasks.findByName(name)/project.tasks.getByName(name)</li></ol><h3 id="获取依赖配置"><a href="#获取依赖配置" class="headerlink" title="获取依赖配置"></a>获取依赖配置</h3><p><a href="https://github.com/easilycoder/EasyDependency" target="_blank" rel="noopener">EasyDenpendency</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// add the extension config</span><br><span class="line">        NamedDomainObjectContainer&lt;DependencyResolveExt&gt; dependencyResolveContainer = targetProject.container(DependencyResolveExt.class)</span><br><span class="line">        targetProject.extensions.add(&quot;dynamicDependency&quot;, dependencyResolveContainer)</span><br><span class="line"></span><br><span class="line">        targetProject.afterEvaluate &#123;</span><br><span class="line">            Map&lt;Project, DependencyResolveExt&gt; resolveExtMap = new HashMap&lt;&gt;()</span><br><span class="line">            targetProject.configurations.all &#123; Configuration configuration -&gt;</span><br><span class="line">                if (configuration.dependencies.size() == 0) &#123;</span><br><span class="line">                    return</span><br><span class="line">                &#125;</span><br><span class="line">                configuration.dependencies.all &#123; dependency -&gt;</span><br><span class="line">                    if (dependency instanceof DefaultProjectDependency) &#123;</span><br><span class="line">                        def projectName = dependency.dependencyProject.name</span><br><span class="line">                        def dependencyResolveExt = dependencyResolveContainer.find &#123;</span><br><span class="line">                            it.name == projectName</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (dependencyResolveExt != null &amp;&amp; !dependencyResolveExt.debuggable) &#123;</span><br><span class="line">                            resolveExtMap.put(dependency.dependencyProject, dependencyResolveExt)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            targetProject.configurations.all &#123;</span><br><span class="line">                resolutionStrategy &#123;</span><br><span class="line">                    dependencySubstitution &#123;</span><br><span class="line">                        resolveExtMap.each &#123; key, value -&gt;</span><br><span class="line">                            substitute project(&quot;$&#123;key.path&#125;&quot;) with module(&quot;$&#123;value.groupId&#125;:$&#123;getArtifactName(key, value.artifactId)&#125;:$&#123;value.version&#125;&quot;)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;h2 id=&quot;Groovy-基础&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="Gradle" scheme="https://xsfelvis.github.io/categories/Gradle/"/>
    
    
      <category term="Gradle" scheme="https://xsfelvis.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>上传Jcenter</title>
    <link href="https://xsfelvis.github.io/2018/10/11/Jcenter/"/>
    <id>https://xsfelvis.github.io/2018/10/11/Jcenter/</id>
    <published>2018-10-10T16:00:00.000Z</published>
    <updated>2018-10-14T06:08:06.035Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>Jcenter提供了一个方便使用自己开源库的一个平台 在Android中使用 complie引用即可，目前很多文章都是通过<code>gradle-bintray-plugin</code>这个插件，不过<code>bintray-release</code>这个插件更加人性化，本篇将记录使用这个插件如何上传到Jcenter上</p><h1 id="0x01-注册bintray-com账号"><a href="#0x01-注册bintray-com账号" class="headerlink" title="0x01 注册bintray.com账号"></a>0x01 注册bintray.com账号</h1><ul><li>Step 1</li></ul><p>官网注册账号 <a href="https://bintray.com，切记点击右边的For" target="_blank" rel="noopener">https://bintray.com，切记点击右边的For</a> an Open Source Account，个人版本<br>(企业版 加入或者创建组织才可以建立自己的仓库，比较麻烦)</p><p><img src="https://upload-images.jianshu.io/upload_images/6968064-d2afdefd754a26a2.png" alt="注册"></p><ul><li>Step 2</li></ul><p>注册完之后 进入 Edit profile 查看自己的APIKey，这是上传时候需要用到</p><h1 id="0x02-项目配置"><a href="#0x02-项目配置" class="headerlink" title="0x02 项目配置"></a>0x02 项目配置</h1><ul><li>根gradle</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &apos;com.android.tools.build:gradle:2.3.1&apos;</span><br><span class="line"></span><br><span class="line">        classpath &apos;com.novoda:bintray-release:0.8.0&apos;//添加</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        maven&#123;url &quot;https://jitpack.io&quot;&#125;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    tasks.withType(Javadoc) &#123;</span><br><span class="line">        options.addStringOption(&apos;Xdoclint:none&apos;, &apos;-quiet&apos;)</span><br><span class="line">        options.addStringOption(&apos;encoding&apos;, &apos;UTF-8&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">task clean(type: Delete) &#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//统一声明配置</span><br><span class="line">ext &#123;</span><br><span class="line">    userOrg = &apos;androidxsf&apos; //bintray.com用户名 </span><br><span class="line">    groupId = &apos;com.xsfdev&apos; //jcenter上的路径</span><br><span class="line">    uploadName = &apos;android-basiclib-apifactory&apos;</span><br><span class="line">    publishVersion = &apos;1.0.0&apos; //版本号</span><br><span class="line">    desc = &apos;Request code can be generated automatically&apos; //描述</span><br><span class="line">    website = &apos;https://github.com/HouXiaohu/androidbasiclib&apos; //网站，不重要；尽量模拟github上的地址</span><br><span class="line">    licences = [&apos;Apache-2.0&apos;] //开源协议</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需要上传的各个Module中引入</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apply plugin: &apos;com.novoda.bintray-release&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//添加</span><br><span class="line">publish &#123;</span><br><span class="line">    artifactId = &apos;complexcriptdsl&apos;</span><br><span class="line">    userOrg = rootProject.userOrg</span><br><span class="line">    groupId = rootProject.groupId</span><br><span class="line">    uploadName = rootProject.uploadName</span><br><span class="line">    publishVersion = rootProject.publishVersion</span><br><span class="line">    desc = rootProject.description</span><br><span class="line">    website = rootProject.website</span><br><span class="line">    licences = rootProject.licences</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x03-执行上传"><a href="#0x03-执行上传" class="headerlink" title="0x03 执行上传"></a>0x03 执行上传</h1><p><code>./gradlew bintrayUpload -PbintrayUser = androidxsf(你的用户名) -PbintrayKey = 1f8b6d3da641fe0f34d531c1811774c***(你的APIKey) -PdryRun = false</code></p><p>此时可以看到我们上传的项目了,你可以点击进去看该库的一些信息，但是注意此时还不能够直接被引用。</p><p>点击进去该库，按照下图，点击Add To jcenter</p><h1 id="0x04-其他"><a href="#0x04-其他" class="headerlink" title="0x04 其他"></a>0x04 其他</h1><p>你需要等待bintray的工作人员审核，审核通过会给你发送站内Message，并且Add to Jcenter那个按钮就小时了，此外你还可以根据你上传的groupId,访问该网站<code>https://jcenter.bintray.com/</code>你的groupId例如<code>https://jcenter.bintray.com/com/com.xsfdev/</code></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后总结下整个过程，其实非常简单：</p><ul><li>申请账号</li><li>引入bintray-release，在需要上传的module里面填写相关publish的信息</li><li>调用上传的命令</li><li>Add to Jcenter提交审核</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="工具" scheme="https://xsfelvis.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Jcenter" scheme="https://xsfelvis.github.io/tags/Jcenter/"/>
    
  </entry>
  
  <entry>
    <title>Spi的基本使用</title>
    <link href="https://xsfelvis.github.io/2018/06/11/spi/"/>
    <id>https://xsfelvis.github.io/2018/06/11/spi/</id>
    <published>2018-06-10T16:00:00.000Z</published>
    <updated>2018-06-11T11:20:15.907Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>什么是spi</li></ul><p>SPI （Service Provider Interface）属于<code>动态加载接口实现类</code>的的一项技术，是JDK内置的一种服务提供发现机制，使用ServiceLoader去加载接口对应的实现，这样我们就不用关注实现类，ServiceLoader会告诉我们。<a href="https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html" target="_blank" rel="noopener">官方文档</a>描述为：<code>为某个接口寻找服务的机制,类似IOC思想，将装配的控制权交给ServiceLoader。</code></p><ul><li>解决问题</li></ul><p>只提供服务接口，具体服务由其他组件实现，接口和具体实现分离（类似桥接），同时能够<code>通过系统的ServiceLoader</code>拿到这些实现类的集合，统一处理，这样在组件化中往往会带来很多便利，SPI机制可以实现不同模块之间方便的面向接口编程，拒绝了硬编码的方式，解耦效果很好</p><blockquote><p>即相当于制定标准，然后不同实现方用不同的方式实现标准供使用方使用,并且可以动态加载</p></blockquote><h1 id="在Android中如何使用"><a href="#在Android中如何使用" class="headerlink" title="在Android中如何使用"></a>在Android中如何使用</h1><p>上面说的可能比较抽象，下面将结合例子说明下在Android中的运用。</p><p>这种机制在使用起来也比较简单,使用步骤如下：</p><ul><li><p>定义接口和接口的实现类</p></li><li><p>创建resources/META-INF/services目录</p></li><li><p>在上述Service目录下，创建一个以接口名(类的全名) 命名的文件, 其内容是实现类的类名 (类的全名)。</p></li></ul><blockquote><p>在services目录下创建的文件是com.binglumeng.spidemo.IService 文件中的内容为Animal接口的实现类, 可能是com.binglumeng.spidemo.AService</p></blockquote><ul><li>在java代码中使用ServcieLoader来动态加载并调用内部方法.</li></ul><p>主工程和组件之间一些“服务”的配置</p><p><img src="http://p927u2n0k.bkt.clouddn.com/spiblog-%20%E6%A8%A1%E5%9D%97%E4%BE%9D%E8%B5%96.png" alt="示意图"></p><h2 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDisplay</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主工程和bdisplay 模块中的实现该接口</p><h2 id="创建spi描述文件"><a href="#创建spi描述文件" class="headerlink" title="创建spi描述文件"></a>创建spi描述文件</h2><p>在工程的main目录下新建目录resources/META-INF/services，<code>以服务接口名为文件名新建spi描述文件，内容为具体的服务实现类权限定名，可以有多个</code></p><p>文件结构如下</p><p><img src="http://p927u2n0k.bkt.clouddn.com/1528702141671.jpg" alt="文件结构"></p><h2 id="加载不同服务"><a href="#加载不同服务" class="headerlink" title="加载不同服务"></a>加载不同服务</h2><p>通过ServiceLoader来加载接口的不同实现类，然后会得到迭代器，在迭代器中可以拿到不同实现类全限定名，然后通过反射动态加载实例就可以调用display方法了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;Display&gt; loader = ServiceLoader.load(IDisplay.class);</span><br><span class="line">mIterator =loader.iterator(); </span><br><span class="line"><span class="keyword">while</span>(mIterator.hasNext())&#123;</span><br><span class="line">    mIterator.next().display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>感觉有点很神奇</p><blockquote><p>ServiceLoader<display> loader = ServiceLoader.load(Display.class);</display></p></blockquote><p>就可以拿到<code>Display.class</code>接口的所有实现类了, amazing！(感觉这里跟Retrift使用有点类似)下面来分析一下这个背后到底隐藏了什么</p><p>核心类 <code>ServiceLoader.java</code></p><p><img src="http://p927u2n0k.bkt.clouddn.com/Blog-ServiceLoader.png" alt="ServiceLoader"></p><p>先看下几个重要的成员变量</p><ul><li>PREFIX就是配置文件所在的包目录路径；</li><li>service就是接口名称，在我们这个例子中就是Display；</li><li>loader就是类加载器，其实最终都是通过反射加载实例；</li><li>providers就是不同实现类的缓存，key就是实现类的全限定名，value就是实现类的实例</li><li>lookupIterator就是内部类LazyIterator的实例。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">"META-INF/services/"</span>; </span><br><span class="line"><span class="comment">// The class or interface representing the service being loaded </span></span><br><span class="line"><span class="keyword">private</span> Class&lt;S&gt; service; </span><br><span class="line"><span class="comment">// The class loader used to locate, load, and instantiate providers </span></span><br><span class="line"><span class="keyword">private</span> ClassLoader loader; </span><br><span class="line"><span class="comment">// Cached providers, in instantiation order </span></span><br><span class="line"><span class="keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(); </span><br><span class="line"><span class="comment">// The current lazy-lookup iterator </span></span><br><span class="line"><span class="keyword">private</span> LazyIterator lookupIterator;</span><br></pre></td></tr></table></figure><p>之前spi加载的三个关键步骤</p><ul><li>ServiceLoader<display> loader = ServiceLoader.load(IDisplay.class);</display></li><li>mIterator =loader.iterator(); </li><li>while(mIterator.hasNext()){<br>  mIterator.next().display();<br>}</li></ul><h2 id="获取实现接口集合"><a href="#获取实现接口集合" class="headerlink" title="获取实现接口集合"></a>获取实现接口集合</h2><p>ServiceLoader提供了两个静态的load方法,如果我们没有传入类加载器，ServiceLoader会自动为我们获得一个当前线程的类加载器，最终都是调用构造函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">    ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            ClassLoader loader)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceLoader&lt;&gt;(service, loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数中有一个重要的函数<code>reload</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    providers.clear();</span><br><span class="line">    lookupIterator = <span class="keyword">new</span> LazyIterator(service, loader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LazyIterator</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.service = service;</span><br><span class="line">    <span class="keyword">this</span>.loader = loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以看到当我们load class之后并没有得到什么实现类，那么在何时加载的呢？</p><h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>那么service provider在什么地方进行加载？我们接着看第二个步骤loader.iterator(),</p><ul><li>首先会到providers中去查找有没有存在的实例，有就直接返回，没有再到LazyIterator中查找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;S&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;S&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders</span><br><span class="line">            = providers.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> lookupIterator.hasNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                <span class="keyword">return</span> knownProviders.next().getValue();</span><br><span class="line">            <span class="keyword">return</span> lookupIterator.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是返回一个迭代器。我们看下官方文档的解释,这个就是懒加载实现的地方，<br>焦点聚焦在<code>LazyIterator</code>上</p><ul><li>hasNext()</li></ul><ol><li>首先拿到配置文件名fullName,我们这个例子中是com.example.Display</li><li>通过类加载器获得所有模块的配置文件Enumeration<url> configs configs</url></li><li>依次扫描每个配置文件的内容，返回配置文件内容Iterator<string> pending，每个配置文件中可能有多个实现类的全限定名，所以pending也是个迭代器。</string></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//首先拿到配置文件名fullName</span></span><br><span class="line">            String fullName = PREFIX + service.getName();</span><br><span class="line">            <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">            configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                configs = loader.getResources(fullName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        fail(service, <span class="string">"Error locating configuration files"</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依次扫描每个配置文件的内容，返回配置文件内容Iterator&lt;String&gt; pending</span></span><br><span class="line">        pending = parse(service, configs.nextElement());</span><br><span class="line">    &#125;</span><br><span class="line">    nextName = pending.next();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips</p></blockquote><p>关于 ClassLoader.getSystemResources(fullName)可以查阅</p><ul><li><a href="http://zyjustin9.iteye.com/blog/2022654" target="_blank" rel="noopener">Java目录总结（七.路径的获取二——ClassLoader的使用）</a></li><li><a href="https://blog.csdn.net/walkerjong/article/details/13019671" target="_blank" rel="noopener">Class.getResource() 和 ClassLoader.getResource() 的区别</a></li></ul><ul><li>next()</li></ul><p>在上面hasNext()方法中拿到的nextName就是实现类的全限定名，接下来我们去看看具体实例化工作的地方next():</p><ul><li>1.首先根据nextName，Class.forName加载拿到具体实现类的class对象</li><li>2.Class.newInstance()实例化拿到具体实现类的实例对象</li><li>3.将实例对象转换service.cast为接口</li><li>4.将实例对象放到缓存中，providers.put(cn, p)，key就是实现类的全限定名，value是实例对象。</li><li>5.返回实例对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasNext()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    String cn = nextName;</span><br><span class="line">    nextName = <span class="keyword">null</span>;</span><br><span class="line">    Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//首先根据nextName，Class.forName加载拿到具体实现类的class对象</span></span><br><span class="line">        c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">"Provider "</span> + cn + <span class="string">" not found"</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">        ClassCastException cce = <span class="keyword">new</span> ClassCastException(</span><br><span class="line">                service.getCanonicalName() + <span class="string">" is not assignable from "</span> + c.getCanonicalName());</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">"Provider "</span> + cn  + <span class="string">" not a subtype"</span>, cce);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//将实例对象转换service.cast为接口</span></span><br><span class="line">        S p = service.cast(c.newInstance());</span><br><span class="line">        <span class="comment">//将实例对象放到缓存中，providers.put(cn, p)，key就是实现类的全限定名，value是实例对象</span></span><br><span class="line">        providers.put(cn, p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">        <span class="string">"Provider "</span> + cn + <span class="string">" could not be instantiated: "</span> + x, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error();          <span class="comment">// This cannot happen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Spi的优缺点</p><ul><li>优点</li></ul><p>只提供服务接口，具体服务由其他组件实现，接口和具体实现分离，同时能够通过系统的ServiceLoader拿到这些实现类的集合，统一处理。</p><ul><li>缺点</li></ul><ol><li>Java中SPI是随jar发布的，每个不同的jar都可以包含一系列的SPI配置，而Android平台上，应用在构建的时候最终会将所有的jar合并，这样很容易造成相同的SPI冲突，常见的问题是DuplicatedZipEntryException异常</li><li>读取SPI配置信息是在运行时从jar包中读取，由于apk是签过名的，在从jar中读取的时候，签名校验的耗时问题会造成性能损失</li></ol><h1 id="后续可以改进的点"><a href="#后续可以改进的点" class="headerlink" title="后续可以改进的点"></a>后续可以改进的点</h1><p>Java中使用ServiceLoader去读取SPI配置信息是在程序运行时，我们可以将这个读取配置信息提前，在编译时候就搞定，通过gradle插件，去扫描class文件，找到具体的服务类（可以通过标注来确定），然后生成新的java文件，这个文件中包含了具体的实现类。这样程序在运行时，就已经知道了所有的具体服务类，缺点就是编译时间会加长，自己需要重新写一套读取SPI信息、生成java文件等逻辑。</p><p>经过优化后，SPI已经偏离了原本的初衷，但是可以做更多的事，可以将业务服务分离，通过SPI找到业务服务入口，业务组件化，抽成单独的aar，独立成工程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;什么是spi&lt;/li&gt;
&lt;/
      
    
    </summary>
    
      <category term="spi" scheme="https://xsfelvis.github.io/categories/spi/"/>
    
    
      <category term="spi" scheme="https://xsfelvis.github.io/tags/spi/"/>
    
  </entry>
  
  <entry>
    <title>Gradle学习之基本原理</title>
    <link href="https://xsfelvis.github.io/2018/06/10/Gradle%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>https://xsfelvis.github.io/2018/06/10/Gradle基本原理/</id>
    <published>2018-06-09T16:00:00.000Z</published>
    <updated>2018-06-10T12:18:25.403Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Gradle是一个基于JVM的构建工具，目前Android Studio中建立的工程都是基于gradle进行构建的，Gradle框架是使用Groovy语言实现的，关于Groovy语言的学习将不再赘述可以参考(<a href="https://www.ibm.com/developerworks/cn/education/java/j-groovy/j-groovy.html" target="_blank" rel="noopener">精通Groovy</a>),目前很多技术领域开始使用Gradle的plugin，比如模块化、热修复、SPI的优化等等。</p><h1 id="两个最重要的概念-Projetc和Tasks"><a href="#两个最重要的概念-Projetc和Tasks" class="headerlink" title="两个最重要的概念 Projetc和Tasks"></a>两个最重要的概念 Projetc和Tasks</h1><p>这是Gradle中最重要的两个概念,每次构建至少由一个project构成，一个project由一到多个task构成。<code>项目结构中的每个build.gradle文件代表一个project</code>，在这编译脚本文件中可以定义一系列的task；task 本质上又是由一组被顺序执行的<code>Action</code>对象构成，Action其实是一段代码块，类似于Java中的方法。</p><h1 id="Gradle-构建生命周期"><a href="#Gradle-构建生命周期" class="headerlink" title="Gradle 构建生命周期"></a>Gradle 构建生命周期</h1><h2 id="三个阶段"><a href="#三个阶段" class="headerlink" title="三个阶段"></a>三个阶段</h2><p>每次构建的执行本质上是执行一系列的task，并且某些task还需要依赖其他task，这些task的依赖关系都是在构建阶段确定的。每次构建分为3个阶段(<a href="https://docs.gradle.org/current/userguide/build_lifecycle.html#sec:build_phases" target="_blank" rel="noopener">Build phases 文档 </a>)</p><ul><li>Initialization: 初始化阶段</li></ul><p>这是创建Project阶段，构建工具根据每个build.gradle文件创建出一个Project实例。初始化阶段会执行项目根目录下的settings.gradle文件，来分析哪些项目参与构建。</p><ul><li>Configuration:配置阶段</li></ul><p>这个阶段，通过执行构建脚本来为每个project创建并配置Task。配置阶段会去加载所有参与构建的项目的build.gradle文件，会将每个build.gradle文件实例化为一个Gradle的project对象。然后分析project之间的依赖关系，下载依赖文件，分析project下的task之间的依赖关系。</p><ul><li>Execution:执行阶段</li></ul><p>这是Task真正被执行的阶段，Gradle会根据依赖关系决定哪些Task需要被执行，以及执行的先后顺序。task是Gradle中的最小执行单元，我们所有的构建，编译，打包，debug，test等都是执行了某一个task，一个project可以有多个task，task之间可以互相依赖。例如我有两个task，taskA和taskB，指定taskA依赖taskB，然后执行taskA，这时会先去执行taskB，taskB执行完毕后在执行taskA。在AS右侧的Gradle按钮中可以看到这一些列的task</p><h2 id="监听生命周期"><a href="#监听生命周期" class="headerlink" title="监听生命周期"></a>监听生命周期</h2><p>在gradle的构建过程中，gradle为我们提供了钩子，帮助我们针对项目的需求定制构建的逻辑，如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/19/163781a2edc24703?imageslim" alt="监听生命周期"></p><p>要监听这些生命周期，主要有两种方式：</p><ul><li>添加监听器</li><li>使用钩子的配置块</li></ul><p>关于可用的钩子可以参考Gradle和Project中的定义，常用的钩子包括：</p><blockquote><p>Gradle</p></blockquote><ul><li>beforeProject()/afterProject()<br>等同于Project中的beforeEvaluate和afterEvaluate</li></ul><ul><li>settingsEvaluated()<br>settings脚本被执行完毕，Settings对象配置完毕</li></ul><ul><li>projectsLoaded()<br>所有参与构建的项目都从settings中创建完毕</li></ul><ul><li>projectsEvaluated()<br>所有参与构建的项目都已经被评估完</li></ul><blockquote><p>TaskExecutionGraph</p></blockquote><ul><li>whenReady（）<br>task图生成。所有需要被执行的task已经task之间的依赖关系都已经确立</li></ul><blockquote><p>Project</p></blockquote><ul><li>beforeEvaluate（）</li><li>afterEvaluate（）</li></ul><h1 id="三个重要的gradle文件"><a href="#三个重要的gradle文件" class="headerlink" title="三个重要的gradle文件"></a>三个重要的gradle文件</h1><p>Gradle项目有3个重要的文件需要深入理解：</p><ul><li>项目根目录的 build.gradle </li></ul><p>项目根目录的 build.gradle 文件用来配置针对所有模块的一些属性。它默认包含2个代码块：buildscript{…}和allprojects{…}。前者用于配置构建脚本所用到的代码库和依赖关系，后者用于定义所有模块需要用到的一些公共属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:2.3.2'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">clean</span><span class="params">(type: Delete)</span> </span>&#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>settings.gradle </li></ul><p>settings.gradle 文件会在构建的 initialization 阶段被执行，它用于告诉构建系统哪些模块需要包含到构建过程中。对于单模块项目， settings.gradle 文件不是必需的。对于多模块项目，如果没有该文件，构建系统就不能知道该用到哪些模块。</p><ul><li>模块目录的 build.gradle</li></ul><p>模块级配置文件 build.gradle 针对每个moudle 的配置，如果这里的定义的选项和顶层 build.gradle定义的相同。它有3个重要的代码块：plugin，android 和 dependencies。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.csdn.net/zhaoyanjun6/article/details/77678577#android-gradle-%E7%9A%84-project-%E5%92%8C-tasks" target="_blank" rel="noopener">https://blog.csdn.net/zhaoyanjun6/article/details/77678577#android-gradle-%E7%9A%84-project-%E5%92%8C-tasks</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Gradle是一个基于JVM的构建工具，
      
    
    </summary>
    
      <category term="Gradle" scheme="https://xsfelvis.github.io/categories/Gradle/"/>
    
    
      <category term="Gradle" scheme="https://xsfelvis.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Gradle在Android中的常用点</title>
    <link href="https://xsfelvis.github.io/2018/06/10/Gradle%E5%9C%A8Android%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%82%B9/"/>
    <id>https://xsfelvis.github.io/2018/06/10/Gradle在Android中常用点/</id>
    <published>2018-06-09T16:00:00.000Z</published>
    <updated>2018-06-10T14:25:59.220Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本篇主要介绍Gradle在Android开发中的一些常用的技巧</p><h1 id="设置编译类型"><a href="#设置编译类型" class="headerlink" title="设置编译类型"></a>设置编译类型</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android&#123;</span><br><span class="line"></span><br><span class="line">  buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">true</span>  <span class="comment">//打开混淆</span></span><br><span class="line">            <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        debug </span>&#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span> <span class="comment">//关闭混淆</span></span><br><span class="line">            <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"> &#125;</span></span><br></pre></td></tr></table></figure><p>通常我们需要给QA打出一个带调试功能的release包，这时就可以在这个里面加上新的type</p><h1 id="productFlavors-多渠道打包"><a href="#productFlavors-多渠道打包" class="headerlink" title="productFlavors 多渠道打包"></a>productFlavors 多渠道打包</h1><p>AndroidManifest.xml 里设置动态渠道变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;meta-data</span><br><span class="line">android:name=<span class="string">"UMENG_CHANNEL"</span></span><br><span class="line">android:value=<span class="string">"$&#123;UMENG_CHANNEL_VALUE&#125;"</span>/&gt;</span><br></pre></td></tr></table></figure><p>在 build.gradle 设置 productFlavors , 这里假定我们需要打包的渠道为酷安市场、360、小米、百度、豌豆荚。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">android &#123;  </span><br><span class="line"></span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        kuan &#123;</span><br><span class="line">            manifestPlaceholders = [UMENG_CHANNEL_VALUE: <span class="string">"kuan"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        xiaomi &#123;</span><br><span class="line">            manifestPlaceholders = [UMENG_CHANNEL_VALUE: <span class="string">"xiaomi"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        qh360 &#123;</span><br><span class="line">            manifestPlaceholders = [UMENG_CHANNEL_VALUE: <span class="string">"qh360"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        baidu &#123;</span><br><span class="line">            manifestPlaceholders = [UMENG_CHANNEL_VALUE: <span class="string">"baidu"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        wandoujia &#123;</span><br><span class="line">            manifestPlaceholders = [UMENG_CHANNEL_VALUE: <span class="string">"wandoujia"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者批量修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android &#123;  </span><br><span class="line"></span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        kuan &#123;&#125;</span><br><span class="line">        xiaomi &#123;&#125;</span><br><span class="line">        qh360 &#123;&#125;</span><br><span class="line">        baidu &#123;&#125;</span><br><span class="line">        wandoujia &#123;&#125;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    productFlavors.all &#123; </span><br><span class="line">        flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name] </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多渠道设置包名"><a href="#多渠道设置包名" class="headerlink" title="多渠道设置包名"></a>多渠道设置包名</h1><p>有时候我们需要分渠道设置 applicationId 、友盟的 appkey 、友盟渠道号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">productFlavors &#123;</span><br><span class="line">        google &#123;</span><br><span class="line">            applicationId <span class="string">"com.wifi.cool"</span></span><br><span class="line">            manifestPlaceholders = [                </span><br><span class="line">                    UMENG_APPKEY_VALUE : <span class="string">"456789456789"</span>,</span><br><span class="line">                    UMENG_CHANNEL_VALUE: <span class="string">"google"</span>,            </span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        baidu&#123;</span><br><span class="line">            applicationId <span class="string">'com.wifi.hacker'</span></span><br><span class="line">            manifestPlaceholders = [</span><br><span class="line">                    UMENG_APPKEY_VALUE     : <span class="string">"123456789789"</span>,</span><br><span class="line">                    UMENG_CHANNEL_VALUE    : <span class="string">"baidu"</span>,          </span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="Signing-签名"><a href="#Signing-签名" class="headerlink" title="Signing 签名"></a>Signing 签名</h1><p>在 android 标签下添加 signingConfigs 标签，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        config &#123;</span><br><span class="line">            keyAlias <span class="string">'yiba'</span></span><br><span class="line">            keyPassword <span class="string">'123456'</span></span><br><span class="line">            <span class="function">storeFile <span class="title">file</span><span class="params">(<span class="string">'C:/work/Key.jks'</span>)</span></span></span><br><span class="line"><span class="function">            storePassword '1234567'</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"> &#125;</span></span><br></pre></td></tr></table></figure><p>可以在release 和 debug包中定义签名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        config &#123;</span><br><span class="line">            keyAlias <span class="string">'yiba'</span></span><br><span class="line">            keyPassword <span class="string">'123456'</span></span><br><span class="line">            <span class="function">storeFile <span class="title">file</span><span class="params">(<span class="string">'C:/work/Key.jks'</span>)</span></span></span><br><span class="line"><span class="function">            storePassword '1234567'</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    buildTypes </span>&#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class="line"><span class="function">            signingConfig signingConfigs.config</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        debug </span>&#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class="line"><span class="function">            signingConfig signingConfigs.config</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h1><h2 id="依赖jar包"><a href="#依赖jar包" class="headerlink" title="依赖jar包"></a>依赖jar包</h2><ul><li>1、把 jar 包放在 libs 目录下</li><li>2、在 build.gradle 中添加依赖</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">   <span class="function">compile <span class="title">files</span><span class="params">(<span class="string">'libs/xxx.jar'</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="依赖aar"><a href="#依赖aar" class="headerlink" title="依赖aar"></a>依赖aar</h2><ul><li>1、把 aar 包放到 libs 目录下</li><li>2、在 build.gradle 中添加依赖</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    flatDir &#123;</span><br><span class="line">        dirs <span class="string">'libs'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile(name:<span class="string">'YibaAnalytics-release'</span>, ext:<span class="string">'aar'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要是aar需要被多个module依赖时候，我们可以在项目的根目录创建一个目录，比如叫 aar 目录，然后把我们的 aar 包放进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> flatDir &#123;</span><br><span class="line">     dirs <span class="string">'../aar'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排除依赖兼容包"><a href="#排除依赖兼容包" class="headerlink" title="排除依赖兼容包"></a>排除依赖兼容包</h2><p>有的时候，我们所依赖的项目/模块会引入多个传递性依赖。而其中部分的传递性依赖我们是不需要的，这时候可以使用exclude排除部分的传递性依赖，如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compile(<span class="string">'com.google.firebase:firebase-ads:11.0.4'</span>, &#123;</span><br><span class="line">      exclude group: <span class="string">'com.android.support'</span>   <span class="comment">//排除v7 , v4 包</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="强制使用指定的依赖版本"><a href="#强制使用指定的依赖版本" class="headerlink" title="强制使用指定的依赖版本"></a>强制使用指定的依赖版本</h2><p>Gradle通过选择依赖关系图中找到的最新版本来解决任何依赖版本冲突。 可是有的时候，某些项目会需要使用一个较老的版本号作为依赖。这时候我们可以强制指定某一个版本。例如：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">'org.apache.httpcomponents:httpclient:4.5.4'</span></span><br><span class="line">    <span class="comment">// 假设commons-codec的最新版本是1.10</span></span><br><span class="line">    implementation(<span class="string">'commons-codec:commons-codec:1.9'</span>) &#123;</span><br><span class="line">        force = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="禁止传递性依赖"><a href="#禁止传递性依赖" class="headerlink" title="禁止传递性依赖"></a>禁止传递性依赖</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation(<span class="string">'com.google.guava:guava:23.0'</span>) &#123;</span><br><span class="line">        transitive = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码依赖"><a href="#源码依赖" class="headerlink" title="源码依赖"></a>源码依赖</h2><p>要是我们自己工程下的module直接依赖进来即可，有时候需要从别的路径下依赖module源码</p><ul><li>1、将对应的库的源码down下来，记录下放置的路径</li><li>2、在setting.gradle文件中，进行库的源码引入 (这里以项目外同级目录)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//新增依赖</span></span><br><span class="line">include <span class="string">':outmodule'</span></span><br><span class="line">project(<span class="string">':outmodule'</span>).projectDir = <span class="keyword">new</span> File(settingsDir, <span class="string">'../Sdk/Sdk-Android/product/outmodule'</span>)</span><br></pre></td></tr></table></figure><p>Tips：</p><p>若是主工程使用了Flavor这里也要使用对应的Flavor</p><h2 id="全局统一信息配置"><a href="#全局统一信息配置" class="headerlink" title="全局统一信息配置"></a>全局统一信息配置</h2><p>有时候多个moudle需要依赖不同的版本，有时候就会出现一些编译异常，而且零散的版本号也是不好管理的，如：compileSdkVersion、buildToolsVersion、androidTestCompile 等。</p><h3 id="分类属性配置"><a href="#分类属性配置" class="headerlink" title="分类属性配置"></a>分类属性配置</h3><ul><li>在项目的根目录创建一个gradle配置文件config.gradle，项目中所有的依赖只要在这个文件中统一配置即可。格式如下(内容根据需要进行修改)：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">    </span><br><span class="line">    compileSdkVersion: <span class="number">24</span>,</span><br><span class="line">    buildToolsVersion: <span class="string">"24.0.2"</span>,</span><br><span class="line">    applicationId    : <span class="string">"com.carme.carmerchant"</span>,</span><br><span class="line">    minSdkVersion    : <span class="number">15</span>,</span><br><span class="line">    targetSdkVersion : <span class="number">22</span>,</span><br><span class="line">    versionCode      : <span class="number">3</span>,</span><br><span class="line">    versionName      : <span class="string">"1.0.3"</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    dependencies = [</span><br><span class="line">            <span class="string">"test"</span>                  : <span class="string">"junit:junit:4.12"</span>,</span><br><span class="line">            <span class="string">"appcompat-v7"</span>          : <span class="string">"com.android.support:appcompat-v7:25.0.0"</span>,</span><br><span class="line">            <span class="string">"support-v4"</span>            : <span class="string">"com.android.support:support-v4:25.0.0"</span>,</span><br><span class="line">            <span class="string">"support_design"</span>        : <span class="string">"com.android.support:design:25.0.0"</span>,</span><br><span class="line">            <span class="string">"rxjava"</span>                : <span class="string">"io.reactivex:rxjava:1.2.0"</span>,</span><br><span class="line">            <span class="string">"rxandroid"</span>             : <span class="string">"io.reactivex:rxandroid:1.2.1"</span>,</span><br><span class="line">            <span class="string">"retrofit"</span>              : <span class="string">"com.squareup.retrofit2:retrofit:2.1.0"</span>,</span><br><span class="line">            <span class="string">"converter-gson"</span>        : <span class="string">"com.squareup.retrofit2:converter-gson:2.1.0"</span>,</span><br><span class="line">            <span class="string">"adapter-rxjava"</span>        : <span class="string">"com.squareup.retrofit2:adapter-rxjava:2.1.0"</span>,</span><br><span class="line">            <span class="string">"multidex"</span>              : <span class="string">"com.android.support:multidex:1.0.1"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其次在根目录的build.gradle文件中添加内容（apply from:”config.gradle”），所有的module都可以从这个（config.gradle）配置文件里读取公共参数。</li><li>在各个module目录下的build.gradle文件中使用如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android &#123;  </span><br><span class="line">      compileSdkVersion rootProject .ext.android.compileSdkVersion</span><br><span class="line">      buildToolsVersion rootProject .ext.android.buildToolsVersion</span><br><span class="line">      defaultConfig &#123;</span><br><span class="line">          applicationId rootProject .ext.android.applicationId</span><br><span class="line">          minSdkVersion rootProject .ext.android.minSdkVersion</span><br><span class="line">          targetSdkVersion rootProject .ext.android.targetSdkVersion</span><br><span class="line">          versionCode rootProject .ext.android.versionCode</span><br><span class="line">          versionName rootProject .ext.android.versionName</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      &#125;  </span><br><span class="line">      dependencies &#123;</span><br><span class="line">          ...</span><br><span class="line">          compile rootProject .ext.dependencies[ <span class="string">"design"</span>]</span><br><span class="line">          compile rootProject .ext.dependencies[ <span class="string">"appcompat-v7"</span>]</span><br><span class="line">          compile rootProject .ext.dependencies[ <span class="string">"recyclerview-v7"</span>]</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h1 id="依赖关系解析"><a href="#依赖关系解析" class="headerlink" title="依赖关系解析"></a>依赖关系解析</h1><h2 id="使用依赖关系解析规则"><a href="#使用依赖关系解析规则" class="headerlink" title="使用依赖关系解析规则"></a>使用依赖关系解析规则</h2><p>依赖关系解析规则提供了一种非常强大的方法来控制依赖关系解析过程，并可用于实现依赖管理中的各种高级模式。比如：</p><ul><li>统一构件组的版本</li></ul><p>很多时候我们依赖一个公司的库会包含多个module，这些module一般都是统一构建、打包和发布的，具备相同的版本号。这个时候我们可以通过控制依赖关系的解析过程做到版本号统一。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy.eachDependency &#123; DependencyResolveDetails details -&gt;</span><br><span class="line">    <span class="keyword">if</span> (details.requested.group == <span class="string">'org.gradle'</span>) &#123;</span><br><span class="line">        details.useVersion <span class="string">'1.4'</span></span><br><span class="line">        details.because <span class="string">'API breakage in higher versions'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>处理自定义的版本scheme</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy.eachDependency &#123; DependencyResolveDetails details -&gt;</span><br><span class="line">        <span class="keyword">if</span> (details.requested.version == <span class="string">'default'</span>) &#123;</span><br><span class="line">            <span class="keyword">def</span> version = findDefaultVersionInCatalog(details.requested.group, details.requested.name)</span><br><span class="line">            details.useVersion version.version</span><br><span class="line">            details.because version.because</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> findDefaultVersionInCatalog(String group, String name) &#123;</span><br><span class="line">    <span class="comment">//some custom logic that resolves the default version into a specific version</span></span><br><span class="line">    [<span class="string">version:</span> <span class="string">"1.0"</span>, <span class="string">because:</span> <span class="string">'tested by QA'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于更多依赖关系解析规则的使用实例可以参考gradle的API中的 <a href="https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_blank" rel="noopener">ResolutionStrategy</a></p><ul><li>使用依赖关系的替代规则</li></ul><p>依赖关系的替换规则和上面的依赖关系解析规则有点相似。实际上，依赖关系解析规则的许多功能可以通过依赖关系替换规则来实现。依赖关系的替换规则允许项目依赖（Project Dependency）和模块依赖（Module Dependency）被指定的替换规则透明地替换。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 使用项目依赖替换模块依赖</span></span><br><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy.dependencySubstitution &#123;</span><br><span class="line">        substitute module(<span class="string">"org.utils:api"</span>) with project(<span class="string">":api"</span>) because <span class="string">"we work with the unreleased development version"</span></span><br><span class="line">        substitute module(<span class="string">"org.utils:util:2.5"</span>) with project(<span class="string">":util"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用模块依赖替换项目依赖</span></span><br><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy.dependencySubstitution &#123;</span><br><span class="line">        substitute project(<span class="string">":api"</span>) with module(<span class="string">"org.utils:api:1.3"</span>) because <span class="string">"we use a stable version of utils"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多可以查看官方的文档<a href="https://docs.gradle.org/current/userguide/customizing_dependency_resolution_behavior.html#sec:dependency_substitution_rules" target="_blank" rel="noopener">Customizing Dependency Resolution Behavior</a></p><h1 id="SourceSet"><a href="#SourceSet" class="headerlink" title="SourceSet"></a>SourceSet</h1><p>SourceSet 可以定义项目结构，也可以修改项目结构。Java插件默认实现了两个SourceSet，main 和 test。每个 SourceSet 都提供了一系列的属性，通过这些属性，可以定义该 SourceSet 所包含的源文件。比如，java.srcDirs，resources.srcDirs 。Java 插件中定义的其他任务，就根据 main 和 test 的这两个 SourceSet 的定义来寻找产品代码和测试代码等。</p><h2 id="SourceSet-定义源码目录"><a href="#SourceSet-定义源码目录" class="headerlink" title="SourceSet 定义源码目录"></a>SourceSet 定义源码目录</h2><p>在 Android 项目中，我们可以在 src/main/java 目录新建 Java 文件，现在我们在src目录下，新建一个test目录，发现不能在该目录下新建java文件，这是由于在 Gradle 中 SourceSet 默认定义的源码文件路径是src/main/java , 其他的文件下下面的源码我们自然无法访问。解决这个问题也很简单，我们需要在 SourceSet 中增加一个源码路径即可。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            java &#123;</span><br><span class="line">                srcDir <span class="string">'src/test1'</span> <span class="comment">//指定源码目</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 或者按照如下的方式写也可以</span></span><br><span class="line">            <span class="comment">//java.srcDirs( 'src/test1' , 'src/test2' ,'src/test3' )</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SourceSet-定义资源目录"><a href="#SourceSet-定义资源目录" class="headerlink" title="SourceSet 定义资源目录"></a>SourceSet 定义资源目录</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            java.srcDirs(<span class="string">'src/test1/java'</span>)  <span class="comment">//定义java 源代码</span></span><br><span class="line">            res.srcDirs(<span class="string">'src/test1/res'</span>)    <span class="comment">//定义资源目录（layout , drawable,values）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SourceSet-实现-layout-分包"><a href="#SourceSet-实现-layout-分包" class="headerlink" title="SourceSet 实现 layout 分包"></a>SourceSet 实现 layout 分包</h2><p>对于一个大项目来说，页面太多，布局文件就很多，有时在众多布局文件中找某个模块的布局文件，很是痛苦，为了解决这个问题，我们可以在创建多个 layout 目录，不同模块的布局文件放在不同的 layout 目录中，这样查找起来，就容易很多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            res.srcDirs <span class="string">'src/main/res/layouts/login'</span>  <span class="comment">//定义登录布局目录</span></span><br><span class="line">            res.srcDirs <span class="string">'src/main/res/layouts/register'</span>  <span class="comment">//定义注册布局目录</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SourceSet-定义-AndroidManifest-文件"><a href="#SourceSet-定义-AndroidManifest-文件" class="headerlink" title="SourceSet 定义 AndroidManifest 文件"></a>SourceSet 定义 AndroidManifest 文件</h2><p>在组件化开发中, 我们需要针对 debug 与 release 模式下, 指定不同的 Manifest 文件, 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    def appDebug = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class="line"><span class="function">            appDebug </span>= <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        debug &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class="line"><span class="function">            appDebug </span>= <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            <span class="keyword">if</span> (appDebug) &#123;</span><br><span class="line">                manifest.srcFile <span class="string">'src/test1/AndroidManifest.xml'</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                manifest.srcFile <span class="string">'src/main/AndroidManifest.xml'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="buildConfigField自定义配置"><a href="#buildConfigField自定义配置" class="headerlink" title="buildConfigField自定义配置"></a>buildConfigField自定义配置</h1><p>实际开发中服务器可能有正式环境和测试环境，gradle可以通过buildConfigField来配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sdkA &#123;</span><br><span class="line">            buildConfigField ‘String’, ‘API_HOST’, <span class="string">"\"http:api.test.com\""</span><span class="comment">//API Host</span></span><br><span class="line">            buildConfigField <span class="string">'String'</span>,   <span class="string">'LANG'</span>, <span class="string">'"en-US"'</span></span><br><span class="line">            buildConfigField <span class="string">'String'</span>,   <span class="string">'MAP'</span>, <span class="string">'"google"'</span></span><br><span class="line">            buildConfigField <span class="string">'String'</span>,   <span class="string">'COORDINATE_SYSTEM'</span>, <span class="string">'"WGS_84"'</span></span><br><span class="line">            buildConfigField <span class="string">'int'</span>,      <span class="string">'COORDINATE_TYPE'</span>, <span class="string">'4'</span></span><br><span class="line">            buildConfigField <span class="string">'String[]'</span>, <span class="string">'SUPPORTED_LANGS'</span>, <span class="string">'&#123;LANG&#125;'</span></span><br><span class="line">            buildConfigField <span class="string">'String'</span>,   <span class="string">'CONSUMER_HOTLINE'</span>, </span><br><span class="line">            dimension <span class="string">"lang"</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>然后通过BuildConfig可以获取这些属性，从而做些差异化的配置等等</p><h1 id="打包更改包名"><a href="#打包更改包名" class="headerlink" title="打包更改包名"></a>打包更改包名</h1><p>项目的build.gradle</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line"> ……</span><br><span class="line"><span class="comment">//打包命名</span></span><br><span class="line">    applicationVariants.all &#123;</span><br><span class="line">        variant -&gt;</span><br><span class="line">            variant.outputs.each &#123;</span><br><span class="line">                output -&gt;</span><br><span class="line">                    <span class="keyword">if</span> (variant.buildType.name == <span class="string">'release'</span>) &#123;</span><br><span class="line">                        variant.mergedFlavor.versionCode = getVersionCode(<span class="keyword">false</span>)</span><br><span class="line">                        variant.mergedFlavor.versionName = getVersionName(<span class="keyword">false</span>)</span><br><span class="line">                        <span class="comment">// release</span></span><br><span class="line">                        def apkName = <span class="string">"$&#123;project.getName()&#125;_$&#123;variant.flavorName&#125;_$&#123;buildType.name&#125;_v$&#123;variant.versionCode&#125;.apk"</span>;</span><br><span class="line">                        output.outputFile = <span class="keyword">new</span> File(output.outputFile.parent, apkName);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        variant.mergedFlavor.versionCode = getVersionCode(<span class="keyword">true</span>)</span><br><span class="line">                        variant.mergedFlavor.versionName = getVersionName(<span class="keyword">true</span>)</span><br><span class="line">                        <span class="comment">// debug</span></span><br><span class="line">                        def apkName = <span class="string">"$&#123;project.getName()&#125;_$&#123;buildType.name&#125;.apk"</span>;</span><br><span class="line">                        output.outputFile = <span class="keyword">new</span> File(output.outputFile.parent, apkName);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 version code</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> def <span class="title">getVersionCode</span><span class="params">(<span class="keyword">boolean</span> isDebug)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isDebug) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(<span class="keyword">new</span> Date().format(<span class="string">"yyMMddHHmm"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getRevisionNumber()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 version name</span></span><br><span class="line"><span class="function">def <span class="title">getVersionName</span><span class="params">(<span class="keyword">boolean</span> isDebug)</span> </span>&#123;</span><br><span class="line">    String version = appConfig.appmajor +</span><br><span class="line">            <span class="string">'.'</span> + appConfig.appminor +</span><br><span class="line">            <span class="string">'.'</span> + getRevisionNumber()</span><br><span class="line">    String today = <span class="keyword">new</span> Date().format(<span class="string">'yyMMdd'</span>)</span><br><span class="line">    String time = <span class="keyword">new</span> Date().format(<span class="string">'HHmmss'</span>)</span><br><span class="line">    <span class="keyword">if</span> (isDebug) &#123;</span><br><span class="line">        <span class="keyword">return</span> version + <span class="string">".$today.$time."</span> + getRevisionDescription()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> version + <span class="string">".$today."</span> + getRevisionDescription()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.csdn.net/zhaoyanjun6/article/details/77678577#buildtypes-%E5%AE%9A%E4%B9%89%E4%BA%86%E7%BC%96%E8%AF%91%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener">https://blog.csdn.net/zhaoyanjun6/article/details/77678577#buildtypes-%E5%AE%9A%E4%B9%89%E4%BA%86%E7%BC%96%E8%AF%91%E7%B1%BB%E5%9E%8B</a></li><li><a href="https://juejin.im/post/5b000522f265da0b7f44d1c7" target="_blank" rel="noopener">https://juejin.im/post/5b000522f265da0b7f44d1c7</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;本篇主要介绍Gradle在Android
      
    
    </summary>
    
      <category term="Gradle" scheme="https://xsfelvis.github.io/categories/Gradle/"/>
    
    
      <category term="Gradle" scheme="https://xsfelvis.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Writing Custom Plugins[译]</title>
    <link href="https://xsfelvis.github.io/2018/06/09/%E8%AF%91%E6%96%87_Writing%20Custom%20Plugins/"/>
    <id>https://xsfelvis.github.io/2018/06/09/译文_Writing Custom Plugins/</id>
    <published>2018-06-08T16:00:00.000Z</published>
    <updated>2018-06-09T13:28:47.469Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h1><p>Packaging a plugin<br>Writing a simple plugin<br>Making the plugin configurable<br>Working with files in custom tasks and plugins<br>Mapping extension properties to task properties<br>A standalone project<br>Providing a configuration DSL for the plugin</p><p>一个Gradle 插件可以将build逻辑的复用片段打包在一起，我们可以将他们应用在不同的项目之中。Gradle 允许我们实现我们自定义的插件，因此你可可以复用你的build逻辑并且分享给其他人</p><p>理论上你可以使用你喜欢的任何语言实现一个Gradle 插件，前提它们可以最后编译为字节码。在我们的例子中，我们使用Groovy作为实现语言。Groovy，Java或者Kotlin都是实现插件语言的好的选择，Gradle API 已经被设计的可以很好地兼容这些语言的。总的来说，一个由Java或者Kotlin实现的插件，将比Groovy实现的更加通俗易懂,</p><h1 id="Packaging-a-plugin"><a href="#Packaging-a-plugin" class="headerlink" title="Packaging a plugin"></a>Packaging a plugin</h1><p>以下的一些地方可以防止插件的代码</p><h2 id="Build-script"><a href="#Build-script" class="headerlink" title="Build script"></a>Build script</h2><p>你可以直接在build script中直接包含插件源码，这种做法有个优势就是可以自动的编译，并且添加到build script的classpath中。然后，这个插件在外部不可见，因此你不能在该build之外复用这个插件</p><h2 id="buildSrc-project"><a href="#buildSrc-project" class="headerlink" title="buildSrc project"></a>buildSrc project</h2><p>你可以把插件代码放在<code>rootProjectDir/buildSrc/src/main/groovy</code>目录下,Gradle将处理好编译和测试插件，并且让它在build script的路径下可用。这个插件在当前项目build内的build script中都是可见的，然而在其他项目中build中还是不可见的，因此你还是不能在本项目之外的复用该插件</p><p>你可在参考 <a href="https://docs.gradle.org/current/userguide/organizing_gradle_projects.html" target="_blank" rel="noopener">Organizing Gradle Project</a>了解更多 buildSrc 项目使用的细节</p><h2 id="Standalone-project"><a href="#Standalone-project" class="headerlink" title="Standalone project"></a>Standalone project</h2><p>你可以为你的插件创建一个独立的工程。这个工程可以创建和发布JAR文件，这个jia文件可以在多个项目的build中被使用，总而言之，这个jar文件可以包含一些插件，或者绑定一些相关的task</p><p>在我们的例子中,为了使得事情比较简单，我们将在build script使用插件，，然后我们将学习如何创建一个standalone project的插件</p><h1 id="Writing-a-simple-plugin"><a href="#Writing-a-simple-plugin" class="headerlink" title="Writing a simple plugin"></a>Writing a simple plugin</h1><p>创建一个Gradle插件，首先需要实现<code>Plugin</code>接口，实现<code>Plugin.apply(T)</code>方法。其中project对象作为一个参数，这样插件就可以配置它。下面的飞马包含了一个hello world插件，给project添加了一个<code>hello</code>task</p><p><strong>Example: A custom plugin</strong><br><em>build.gradle</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">        project.task(<span class="string">'hello'</span>) &#123;</span><br><span class="line">            doLast &#123;</span><br><span class="line">                println <span class="string">'Hello from the GreetingPlugin'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the plugin</span></span><br><span class="line">apply plugin: GreetingPlugin</span><br></pre></td></tr></table></figure><p><strong>Output of gradle -q hello</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; gradle -q hello</span><br><span class="line">Hello from the GreetingPlugin</span><br></pre></td></tr></table></figure><p>我们需要明白的是一个插件是在被应用进的projetc来创建插件的实例，也需要明白插件是一个泛型。在上面例子里，接受一个Project类型作为一个参数。一个插件也可一件接受<code>Setting</code>类型的参数，这种插件我们可以把它应用到settin script脚本中;或者接受<code>Gradle</code>类型的插件参数,这种插件我们可以应用到script脚本初始化中</p><h1 id="Making-the-plugin-configurable"><a href="#Making-the-plugin-configurable" class="headerlink" title="Making the plugin configurable"></a>Making the plugin configurable</h1><p>大多数插件需要从build script中获取一些配置，一种方案就是使用<code>extension objects</code>. Gradle <code>Project</code>和<code>ExtensionContainer</code>对象具有联系，这个对象包含了这个插件应用到project的setting和属性。你可以通过添加扩展对象到这个容器来给你的插件提供配置。一个扩展对象就是一个简单的Java Bean兼容类。Groovy是一个很好的语言选择，是实现来扩展对象，这是由于普通老的Groovy对象包含了所有的setter和getter方法，当然Java和Kotlin也是其他好的选择.</p><p>让我们给project添加一个简单的扩展对象，在这里我们给project添加一个<code>greeting</code>扩展对象。</p><p><strong>Example: A custom plugin extension</strong></p><p><em>build.gradle</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPluginExtension</span> </span>&#123;</span><br><span class="line">    String message = <span class="string">'Hello from GreetingPlugin'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Add the 'greeting' extension object</span></span><br><span class="line">        def extension = project.extensions.create(<span class="string">'greeting'</span>, GreetingPluginExtension)</span><br><span class="line">        <span class="comment">// Add a task that uses configuration from the extension object</span></span><br><span class="line">        project.task(<span class="string">'hello'</span>) &#123;</span><br><span class="line">            doLast &#123;</span><br><span class="line">                println extension.message</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: GreetingPlugin</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the extension</span></span><br><span class="line">greeting.message = <span class="string">'Hi from Gradle'</span></span><br></pre></td></tr></table></figure><p><em>Output of gradle -q hello</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; gradle -q hello</span><br><span class="line">Hi from Gradle</span><br></pre></td></tr></table></figure><p>在这个例子中,<code>GreetingPluginExtension</code>是一个普通的旧Groovy对象，它带有一个名为message的属性，这个扩展以<code>greeting</code>的名字加载到插件列表中。这个对象然后在Project中就变得可用</p><p>通常情况下，你需要在一个插件里面配置对个相关属性，Gradle为每个扩展对象添加了闭环配置对象，因而你可以将这些设置分组在一起，下面的例子将要向你展示运作的方式</p><p><strong>Example: A custom plugin with configuration closure</strong><br><em>build.gradle</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPluginExtension</span> </span>&#123;</span><br><span class="line">    String message</span><br><span class="line">    String greeter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">        def extension = project.extensions.create(<span class="string">'greeting'</span>, GreetingPluginExtension)</span><br><span class="line">        project.task(<span class="string">'hello'</span>) &#123;</span><br><span class="line">            doLast &#123;</span><br><span class="line">                println <span class="string">"$&#123;extension.message&#125; from $&#123;extension.greeter&#125;"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: GreetingPlugin</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the extension using a DSL block</span></span><br><span class="line">greeting &#123;</span><br><span class="line">    message = <span class="string">'Hi'</span></span><br><span class="line">    greeter = <span class="string">'Gradle'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Output of gradle -q hello</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; gradle -q hello</span><br><span class="line">Hi from Gradle</span><br></pre></td></tr></table></figure><p>在这个例子中，一些设置可以通过<code>greeting</code>闭包归为一类，在build script中的闭包块name需要和扩展对象名称保持一致。然后当闭包被执行，在扩展对象里面的属性将通过Groovy闭包代理的特性被映射为变量</p><h1 id="Working-with-files-in-custom-tasks-and-plugins"><a href="#Working-with-files-in-custom-tasks-and-plugins" class="headerlink" title="Working with files in custom tasks and plugins"></a>Working with files in custom tasks and plugins</h1><p>当我们开发自定义task和插件的时候，当接受文件位置的输入配置时候需要十分的灵活，要到这个点，您可以利用Project.file（java.lang.Object）方法尽可能晚地解析文件的值。</p><p><strong>Example: Evaluating file properties lazily</strong></p><p><em>build.gradle</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingToFileTask</span> <span class="keyword">extends</span> <span class="title">DefaultTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    def destination</span><br><span class="line"></span><br><span class="line">    <span class="function">File <span class="title">getDestination</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        project.file(destination)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TaskAction</span></span><br><span class="line">    <span class="function">def <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        def file = getDestination()</span><br><span class="line">        file.parentFile.mkdirs()</span><br><span class="line">        file.write <span class="string">'Hello!'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">greet</span><span class="params">(type: GreetingToFileTask)</span> </span>&#123;</span><br><span class="line">    destination = &#123; project.greetingFile &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">sayGreeting</span><span class="params">(dependsOn: greet)</span> </span>&#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        <span class="function">println <span class="title">file</span><span class="params">(greetingFile)</span>.text</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">ext.greetingFile </span>= <span class="string">"$buildDir/hello.txt"</span></span><br></pre></td></tr></table></figure><p><em>Output of gradle -q sayGreeting</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; gradle -q sayGreeting</span><br><span class="line">Hello!</span><br></pre></td></tr></table></figure><p>在这个例子中，我们配置了<code>greet</code> Task的<code>destination</code>属性作为了闭环，并在最后转换为File对象进行评通过Project.file（java.lang.Object）方法对闭包的返回值估。在这个例子中你可以看到，我们设置<code>greetingFile</code>属性，在我们已经为task配置属性之后。这种evaluation的懒加载是文件设置属性可以接受任何值的一个关键的好处,然后在读取属性时解析该值。</p><h1 id="Mapping-extension-properties-to-task-properties"><a href="#Mapping-extension-properties-to-task-properties" class="headerlink" title="Mapping extension properties to task properties"></a>Mapping extension properties to task properties</h1><p>build script通过扩展获取用户的输入，并且将它映射到输入输出属性是自定义task的最佳实践。最终用户只需要通过扩展定义的暴露出来的DSL进行交互即可。命令逻辑隐藏在插件实现中。</p><p>在build script中申明的扩展以及扩展属性和自定义任务属性之间的映射发生在构建生命周期的Gradle配置阶段。为了避免evaluation顺序的问题，必须在excution阶段解决映射属性的实际值。（更多信息请参看 <a href="https://docs.gradle.org/current/userguide/build_lifecycle.html#sec:build_phases" target="_blank" rel="noopener">the section called “Build phases”</a>）.Gradle的API提供了用于表示应该进行延迟evaluate的属性的类型，例如在执行期（参阅<a href="https://docs.gradle.org/current/userguide/lazy_configuration.html" target="_blank" rel="noopener">延迟配置</a>），下面的例子演示了将扩展属性映射到任务属性类型的用法</p><p><strong>Example: Mapping extension properties to task properties</strong><br><em>build.gradle</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">        def extension = project.extensions.create(<span class="string">'greeting'</span>, GreetingPluginExtension, project)</span><br><span class="line">        project.tasks.create(<span class="string">'hello'</span>, Greeting) &#123;</span><br><span class="line">            message = extension.message</span><br><span class="line">            outputFiles = extension.outputFiles</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPluginExtension</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Property&lt;String&gt; message</span><br><span class="line">    <span class="keyword">final</span> ConfigurableFileCollection outputFiles</span><br><span class="line"></span><br><span class="line">    GreetingPluginExtension(Project project) &#123;</span><br><span class="line">        message = project.objects.property(String)</span><br><span class="line">        message.set(<span class="string">'Hello from GreetingPlugin'</span>)</span><br><span class="line">        outputFiles = project.layout.configurableFiles()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setOutputFiles</span><span class="params">(FileCollection outputFiles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.outputFiles.setFrom(outputFiles)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">DefaultTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Property&lt;String&gt; message = project.objects.property(String)</span><br><span class="line">    <span class="keyword">final</span> ConfigurableFileCollection outputFiles = project.layout.configurableFiles()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setOutputFiles</span><span class="params">(FileCollection outputFiles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.outputFiles.setFrom(outputFiles)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TaskAction</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        outputFiles.each &#123;</span><br><span class="line">            logger.quiet <span class="string">"Writing message 'Hi from Gradle' to file"</span></span><br><span class="line">            it.text = message.get()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: GreetingPlugin</span><br><span class="line"></span><br><span class="line">greeting &#123;</span><br><span class="line">    message = <span class="string">'Hi from Gradle'</span></span><br><span class="line">    outputFiles = layout.files(<span class="string">'a.txt'</span>, <span class="string">'b.txt'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Note: The code for this example can be found at samples/userguide/tasks/mapExtensionPropertiesToTaskProperties in the ‘-all’ distribution of Gradle.</p></blockquote><p><em>Output of gradle -q hello</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; gradle -q hello</span><br><span class="line">Writing message <span class="string">'Hi from Gradle'</span> to file</span><br><span class="line">Writing message <span class="string">'Hi from Gradle'</span> to file</span><br></pre></td></tr></table></figure><h1 id="A-standalone-project"><a href="#A-standalone-project" class="headerlink" title="A standalone project"></a>A standalone project</h1><p>现在，我们将把插件移到一个独立的project中，这样我们就可以发布并公用这个插件。这个project是个可以生成包含插件class的Jar文件的简单Groovy Project。下面这个project的简单build script，apply了Groovy插件，并且添加了gradle api的依赖</p><p><strong>Example: A build for a custom plugin</strong></p><p><em>build.gradle</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pply plugin: <span class="string">'groovy'</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="function">compile <span class="title">gradleApi</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    compile <span class="title">localGroovy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>Note: The code for this example can be found at samples/customPlugin/plugin in the ‘-all’ distribution of Gradle.</p></blockquote><p>因此Gradle如何发现实现的插件呢？答案是你需要在<code>META-INF/gradle-plugins</code>目录下提供一个匹配你插件id的属性<br><strong>Example: Wiring for a custom plugin</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- src/main/resources/META-INF/gradle-plugins/org.samples.greeting.properties</span><br><span class="line">  |</span><br><span class="line">  -  implementation-<span class="class"><span class="keyword">class</span></span>=org.gradle.GreetingPlugin</span><br></pre></td></tr></table></figure></p><p>需要注意的是，属性文件名与插件标识匹配，并放置在资源文件夹中，而实现类属性标识插件实现类。</p><h2 id="Creating-a-plugin-id"><a href="#Creating-a-plugin-id" class="headerlink" title="Creating a plugin id"></a>Creating a plugin id</h2><p>插件ID以类似于Java软件包的方式被完全限定（即反向域名）。这有助于避免冲突，并提供了一种将类似所有权的插件分组的方法。</p><p>您的插件ID应该是反映名称空间的组件的组合（指向您或您的组织的合理指针）以及它提供的插件的名称。例如，如果您有一个名为“foo”的Github帐户，并且您的插件名为“bar”，则合适的插件ID可能是com.github.foo.bar。同样，如果插件是在baz组织开发的，插件ID可能是org.baz.bar。</p><p>插件id应该按照以下规则：</p><ul><li>可以包含任何字母数字字符，’.’和’ - ‘。</li><li>必须包含至少一个’.’将名称空间与插件名称分开的字符。</li><li>通常对名称空间使用小写反向域名约定。</li><li>通常在名称中只使用小写字符</li><li>不要使用 org.gradle和com.gradleware命名空间</li><li>无法以’.’开始或结束</li><li>不能包含连续的’.’字符（即’..’）</li></ul><p>尽管插件ID和包名称之间存在传统的相似性，但包名通常比插件ID所需的更详细。例如，将“gradle”添加为插件ID的组件似乎是合理的，但由于插件ID仅用于Gradle插件，这将是多余的。一般而言，标识所有权和名称的名称空间都是良好的插件标识所需的</p><h2 id="Publishing-your-plugin"><a href="#Publishing-your-plugin" class="headerlink" title="Publishing your plugin"></a>Publishing your plugin</h2><p>如果您在公司内部发布您的插件以供您的组织使用，可以像发布其他任何代码工件一样发布它。关于发布工件，请参阅<a href="https://docs.gradle.org/current/userguide/publishing_ivy.html" target="_blank" rel="noopener">lvy</a>和<a href="https://docs.gradle.org/current/userguide/publishing_maven.html" target="_blank" rel="noopener">maven</a>章节。</p><p>如果您有兴趣发布您的插件以供更广泛的Gradle社区使用，您可以将其发布到<a href="https://plugins.gradle.org/docs/submit?_ga=2.115105858.438770069.1528507228-204910210.1513922382" target="_blank" rel="noopener">Gradle plugin portal. </a>。该网站提供搜索和收集Gradle社区贡献插件的信息的能力。请参阅<a href="https://plugins.gradle.org/?_ga=2.115105858.438770069.1528507228-204910210.1513922382" target="_blank" rel="noopener">此处</a>的说明，了解如何使您的插件在本网站上可用。</p><h2 id="Using-your-plugin-in-another-project"><a href="#Using-your-plugin-in-another-project" class="headerlink" title="Using your plugin in another project"></a>Using your plugin in another project</h2><p>要在构建脚本中使用插件，需要将插件类添加到构建脚本的类路径中。为此，请使用“buildscript {}”块，如<a href="https://docs.gradle.org/current/userguide/plugins.html#sec:applying_plugins_buildscript" target="_blank" rel="noopener">“Applying plugins with the buildscript block”</a>. 一节中所述。以下示例显示了当包含该插件的JAR已发布到本地存储库时，您需要这样做：</p><p><strong>Example: Using a custom plugin in another project</strong><br><em>build.gradle</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            <span class="function">url <span class="title">uri</span><span class="params">(<span class="string">'../repo'</span>)</span></span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    dependencies </span>&#123;</span><br><span class="line">        classpath group: <span class="string">'org.gradle'</span>, name: <span class="string">'customPlugin'</span>,</span><br><span class="line">                  version: <span class="string">'1.0-SNAPSHOT'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">apply plugin: <span class="string">'org.samples.greeting'</span></span><br></pre></td></tr></table></figure><p>或者，如果您的插件已发布到插件门户，则可以使用孵化插件DSL（请参阅“<a href="https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block" target="_blank" rel="noopener">使用插件DSL应用插件</a>”一节）来应用该插件：</p><p><strong>Example: Applying a community plugin with the plugins DSL</strong><br><em>build.gradle</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'com.jfrog.bintray'</span> version <span class="string">'0.4.1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Providing-a-configuration-DSL-for-the-plugin"><a href="#Providing-a-configuration-DSL-for-the-plugin" class="headerlink" title="Providing a configuration DSL for the plugin"></a>Providing a configuration DSL for the plugin</h1><p>正如我们上面看到的，您可以使用扩展对象为您的插件提供配置。使用扩展对象还扩展了Gradle DSL以为该插件添加项目属性和DSL块。扩展对象只是一个常规对象，因此您可以通过向扩展对象添加属性和方法来提供嵌套在此块中的DSL元素。Gradle提供了一些便利来帮助为插件创建一个行为良好的DSL。</p><h2 id="Nested-DSL-elements"><a href="#Nested-DSL-elements" class="headerlink" title="Nested DSL elements"></a>Nested DSL elements</h2><p>当Gradle创建任务或扩展对象时，Gradle修饰实现类以混合DSL支持。要创建一个嵌套的DSL元素，可以使用ObjectFactory类型来创建具有类似修饰的对象。然后，可以通过插件扩展的属性和方法使这些修饰对象可见。</p><p><strong>Example: Nested DSL elements</strong></p><p><em>build.gradle</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPluginExtension</span> </span>&#123;</span><br><span class="line">    String message</span><br><span class="line">    <span class="keyword">final</span> Person greeter</span><br><span class="line"></span><br><span class="line">    <span class="meta">@javax</span>.inject.Inject</span><br><span class="line">    GreetingPluginExtension(ObjectFactory objectFactory) &#123;</span><br><span class="line">        <span class="comment">// Create a Person instance</span></span><br><span class="line">        greeter = objectFactory.newInstance(Person)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">greeter</span><span class="params">(Action&lt;? <span class="keyword">super</span> Person&gt; action)</span> </span>&#123;</span><br><span class="line">        action.execute(greeter)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create the extension, passing in an ObjectFactory for it to use</span></span><br><span class="line">        def extension = project.extensions.create(<span class="string">'greeting'</span>, GreetingPluginExtension, project.objects)</span><br><span class="line">        project.task(<span class="string">'hello'</span>) &#123;</span><br><span class="line">            doLast &#123;</span><br><span class="line">                println <span class="string">"$&#123;extension.message&#125; from $&#123;extension.greeter.name&#125;"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: GreetingPlugin</span><br><span class="line"></span><br><span class="line">greeting &#123;</span><br><span class="line">    message = <span class="string">'Hi'</span></span><br><span class="line">    greeter &#123;</span><br><span class="line">        name = <span class="string">'Gradle'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Output of gradle -q hello</span><br><span class="line"></span><br><span class="line">&gt; gradle -q hello</span><br><span class="line">Hi from Gradle</span><br></pre></td></tr></table></figure><p>在这个例子中，插件通过其构造函数将项目的ObjectFactory传递给扩展对象。构造函数使用它创建一个嵌套对象，并通过greeter属性使该对象可供DSL使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Table-of-Contents&quot;&gt;&lt;a href=&quot;#Table-of-Contents&quot; class=&quot;headerlink&quot; title=&quot;Table of
      
    
    </summary>
    
      <category term="Gradle" scheme="https://xsfelvis.github.io/categories/Gradle/"/>
    
    
      <category term="Gradle" scheme="https://xsfelvis.github.io/tags/Gradle/"/>
    
      <category term="翻译" scheme="https://xsfelvis.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>谈谈APT和JavaPoet的一些使用技巧和要点</title>
    <link href="https://xsfelvis.github.io/2018/06/06/%E8%B0%88%E8%B0%88APT%E5%92%8CJavaPoet%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/"/>
    <id>https://xsfelvis.github.io/2018/06/06/谈谈APT和JavaPoet的一些技巧/</id>
    <published>2018-06-05T16:00:00.000Z</published>
    <updated>2018-06-06T15:28:38.868Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>APT+JavaPoet 是一把利剑，可以将很多模板代码在编译期间直接生成，即通过注解收集信息，然后将这些信息形成一些固定代码；特别是在写框架的时候，可以将一些“脏活、累活”通过这种方式处理掉，然后提供给用户一个干净的API接口使用，目前常用在</p><ul><li>路由 如<a href="https://github.com/alibaba/ARouter" target="_blank" rel="noopener">ARouter</a></li><li>ButterKnife、Dagger等</li><li>JsBridge (Hanlder或者Actioon)</li><li><p>权限<br>如 <a href="https://github.com/hongyangAndroid/MPermissions" target="_blank" rel="noopener">MPermissions</a>、<a href="https://github.com/permissions-dispatcher/PermissionsDispatcher" target="_blank" rel="noopener">PermissionsDispatcher</a></p></li><li><p>工厂模式相关 <a href="https://race604.com/annotation-processing/" target="_blank" rel="noopener">工厂模式简化</a> </p></li></ul><p>一些复杂类型的Adapter 等等，这些都可以找到相关的开源库</p><p>关于APT+JavePoet要是不熟悉的话建议先看看我之前的注解系列</p><p>注解系列</p><ul><li><a href="https://xsfelvis.github.io/2017/01/06/%E6%B3%A8%E8%A7%A3%E5%9F%BA%E7%A1%80/">注解基础</a></li><li><a href="https://xsfelvis.github.io/2017/04/07/%E7%BC%96%E8%AF%91%E6%9C%9F%E6%B3%A8%E8%A7%A3%E4%B9%8BAPT/">编译期注解处理之APT</a></li><li><a href="https://xsfelvis.github.io/2017/03/12/%E7%BC%96%E8%AF%91%E6%9C%9F%E6%B3%A8%E8%A7%A3%E4%B9%8BJavaPoet/">JavaPoet</a></li></ul><p><a href="https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%A6%82%E8%BF%B0/#more">ARouter解析</a></p><h1 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h1><h2 id="老生常谈的面向接口编程"><a href="#老生常谈的面向接口编程" class="headerlink" title="老生常谈的面向接口编程"></a>老生常谈的面向接口编程</h2><p>比如在<a href="https://github.com/hongyangAndroid/MPermissions" target="_blank" rel="noopener">MPermissions</a>中，提供了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PermissionProxy</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">grant</span><span class="params">(T source, <span class="keyword">int</span> requestCode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">denied</span><span class="params">(T source, <span class="keyword">int</span> requestCode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rationale</span><span class="params">(T source, <span class="keyword">int</span> requestCode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">needShowRationale</span><span class="params">(<span class="keyword">int</span> requestCode)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后APT生成的代码实现该接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span>$$<span class="title">PermissionProxy</span> <span class="keyword">implements</span> <span class="title">PermissionProxy</span>&lt;<span class="title">MainActivity</span>&gt; </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际逻辑操作中直接使用该接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldShowRequestPermissionRationale</span><span class="params">(Activity activity, String permission, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//核心逻辑只关注接口</span></span><br><span class="line">        PermissionProxy proxy = findPermissionProxy(activity);</span><br><span class="line">        <span class="keyword">if</span> (!proxy.needShowRationale(requestCode)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (ActivityCompat.shouldShowRequestPermissionRationale(activity,</span><br><span class="line">                permission)) &#123;</span><br><span class="line">            proxy.rationale(activity, requestCode);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ARouter(<a href="https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%A6%82%E8%BF%B0/#more">Arouter解析</a>)中也有这种处理的方式，比如IRouteGroup<br>LogisticsCenter#completion</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();</span><br><span class="line">iGroupInstance.loadInto(Warehouse.routes);</span><br><span class="line">Warehouse.groupsIndex.remove(postcard.getGroup());</span><br></pre></td></tr></table></figure><p>思想一样这里就不展开赘述了</p><h2 id="信息注入分离"><a href="#信息注入分离" class="headerlink" title="信息注入分离"></a>信息注入分离</h2><p>比如在ARouter中有一个<code>仓库</code>WearHouse类里面就是一些空壳容器，用来盛放路由的元信息，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Warehouse</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Cache route and metas</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; groupsIndex = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, RouteMeta&gt; routes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache provider</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Class, IProvider&gt; providers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, RouteMeta&gt; providersIndex = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache interceptor</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; interceptorsIndex = <span class="keyword">new</span> UniqueKeyTreeMap&lt;&gt;(<span class="string">"More than one interceptors use same priority [%s]"</span>);</span><br><span class="line">    <span class="keyword">static</span> List&lt;IInterceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道具体的信息是在注解之中，APT+JavaPoet负责将信息收集，在ARouter中体现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ARouter</span>$$<span class="title">Group</span>$$<span class="title">service</span> <span class="keyword">implements</span> <span class="title">IRouteGroup</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadInto</span><span class="params">(Map&lt;String, RouteMeta&gt; atlas)</span> </span>&#123;</span><br><span class="line">    atlas.put(<span class="string">"/service/hello"</span>, RouteMeta.build(RouteType.PROVIDER, HelloServiceImpl.class, <span class="string">"/service/hello"</span>, <span class="string">"service"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">"/service/json"</span>, RouteMeta.build(RouteType.PROVIDER, JsonServiceImpl.class, <span class="string">"/service/json"</span>, <span class="string">"service"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">"/service/single"</span>, RouteMeta.build(RouteType.PROVIDER, SingleService.class, <span class="string">"/service/single"</span>, <span class="string">"service"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出只有一个接受注入的信息的函数,然后在实际逻辑处理中,将此处的信息load到WareHouse中对应map</p><p>LogisticsCenter#completion</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();</span><br><span class="line">iGroupInstance.loadInto(Warehouse.routes);</span><br><span class="line">Warehouse.groupsIndex.remove(postcard.getGroup());</span><br></pre></td></tr></table></figure><p>干净清爽</p><h2 id="常用的JavaPoet"><a href="#常用的JavaPoet" class="headerlink" title="常用的JavaPoet"></a>常用的JavaPoet</h2><p>基本操作可以查看官方文档<a href="https://github.com/square/javapoet" target="_blank" rel="noopener">JavaPoet</a> 这里讲一下一些难点所在不过一般都是纠结在 获取类、接口、Map、带泛型的Map，下面将一一说明</p><h3 id="获取类"><a href="#获取类" class="headerlink" title="获取类"></a>获取类</h3><p>有两种方式</p><ul><li><p>ClassName.bestGuess(“类全名称”) 返回ClassName对象，这里的类全名称表示的类必须要存在，会自动导入相应的包</p></li><li><p>ClassName.get(“包名”，”类名”) 返回ClassName对象，不检查该类是否存在</p></li></ul><p>因此需要注意获取类全名的类在以后重构时候<code>改名类名</code>或者<code>移动了位置</code>需要对应修改这里</p><h3 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h3><ul><li>$L 字面常量（Literals）</li><li>$S 字符串常量（String）</li><li>$T 类型(Types)<br>该占位符最大特点就是会自动导包</li><li>$N 命名(Names),通常指我们自己生成的方法名或者变量名等等</li></ul><h3 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a>复杂类型</h3><p>稍微复杂点的类型 比如泛型 、Map之类的，需要了解下JavaPoet定义的几种专门描述类型的类</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/26/1639c8621da268bc?imageView2/0/w/1280/h/960/ignore-error/1" alt="复杂类型"></p><p>常见的有</p><table><thead><tr><th>分类</th><th>生成的类型</th><th>JavaPoet 写法</th><th>也可以这么写 （等效的 Java 写法）</th></tr></thead><tbody><tr><td>内置类型</td><td>int</td><td>TypeName.INT</td><td>int.class</td></tr><tr><td>数组类型</td><td>int[]</td><td>ArrayTypeName.of(int.class)</td><td>int[].class</td></tr><tr><td>需要引入包名的类型</td><td>java.io.File</td><td>ClassName.get(“java.io”, “File”)</td><td>java.io.File.class</td></tr><tr><td>参数化类型 （ParameterizedType</td><td>List</td><td>ParameterizedTypeName.get(List.class, String.class)</td><td>-</td></tr><tr><td>类型变量  （WildcardType） 用于声明泛型</td><td>T</td><td>TypeVariableName.get(“T”)</td><td>-</td></tr><tr><td>通配符类型</td><td>? extends String</td><td>WildcardTypeName.subtypeOf(String.class)</td><td>-</td></tr></tbody></table><p>通过ARouter中的一段代码，就可以解释的很清楚</p><p>RouterProcessor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数化类型 Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt;</span></span><br><span class="line">ParameterizedTypeName inputMapTypeOfRoot = ParameterizedTypeName.get(</span><br><span class="line">            ClassName.get(Map.class),</span><br><span class="line">            ClassName.get(String.class),</span><br><span class="line">            ParameterizedTypeName.get(</span><br><span class="line">                    ClassName.get(Class.class),</span><br><span class="line">                    WildcardTypeName.subtypeOf(ClassName.get(type_IRouteGroup))</span><br><span class="line">            )</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line"><span class="comment">//参数化类型 Map&lt;String, RouteMeta&gt;</span></span><br><span class="line">ParameterizedTypeName inputMapTypeOfGroup = ParameterizedTypeName.get(</span><br><span class="line">            ClassName.get(Map.class),</span><br><span class="line">            ClassName.get(String.class),</span><br><span class="line">            ClassName.get(RouteMeta.class)</span><br><span class="line">    );        </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *Build input param name.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ParameterSpec rootParamSpec = ParameterSpec.builder(inputMapTypeOfRoot, <span class="string">"routes"</span>).build();</span><br><span class="line">    ParameterSpec groupParamSpec = ParameterSpec.builder(inputMapTypeOfGroup, <span class="string">"atlas"</span>).build();</span><br></pre></td></tr></table></figure><p>生成代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ARouter</span>$$<span class="title">Root</span>$$<span class="title">app</span> <span class="keyword">implements</span> <span class="title">IRouteRoot</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadInto</span><span class="params">(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes)</span> </span>&#123;</span><br><span class="line">    routes.put(<span class="string">"service"</span>, ARouter$$Group$$service.class);</span><br><span class="line">    routes.put(<span class="string">"test"</span>, ARouter$$Group$$test.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ARouter</span>$$<span class="title">Group</span>$$<span class="title">service</span> <span class="keyword">implements</span> <span class="title">IRouteGroup</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadInto</span><span class="params">(Map&lt;String, RouteMeta&gt; atlas)</span> </span>&#123;</span><br><span class="line">    atlas.put(<span class="string">"/service/hello"</span>, RouteMeta.build(RouteType.PROVIDER, HelloServiceImpl.class, <span class="string">"/service/hello"</span>, <span class="string">"service"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">"/service/json"</span>, RouteMeta.build(RouteType.PROVIDER, JsonServiceImpl.class, <span class="string">"/service/json"</span>, <span class="string">"service"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">"/service/single"</span>, RouteMeta.build(RouteType.PROVIDER, SingleService.class, <span class="string">"/service/single"</span>, <span class="string">"service"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者直接先把你需要的泛型都写出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ClassName java_lang_Class = ClassName.get(Class.class);</span><br><span class="line">        <span class="keyword">final</span> ClassName java_util_Collections = ClassName.get(<span class="string">"java.util"</span>, <span class="string">"Collections"</span>);</span><br><span class="line">        <span class="keyword">final</span> ClassName java_util_Map = ClassName.get(<span class="string">"java.util"</span>, <span class="string">"Map"</span>);</span><br><span class="line">        <span class="keyword">final</span> ClassName java_util_Set = ClassName.get(<span class="string">"java.util"</span>, <span class="string">"Set"</span>);</span><br><span class="line">        <span class="keyword">final</span> ClassName java_util_LinkedHashMap = ClassName.get(<span class="string">"java.util"</span>, <span class="string">"LinkedHashMap"</span>);</span><br><span class="line">        <span class="keyword">final</span> ClassName java_util_LinkedHashSet = ClassName.get(<span class="string">"java.util"</span>, <span class="string">"LinkedHashSet"</span>);</span><br><span class="line">        <span class="keyword">final</span> ClassName instantiator = ClassName.get(<span class="string">"java.util.concurrent"</span>, <span class="string">"Callable"</span>);</span><br><span class="line">        <span class="keyword">final</span> TypeName classOfAny = ParameterizedTypeName.get(java_lang_Class, any);</span><br><span class="line">        <span class="keyword">final</span> TypeName instantiatorOfAny = ParameterizedTypeName.get(instantiator, any);</span><br><span class="line">        <span class="keyword">final</span> TypeName instantiatorOfP = ParameterizedTypeName.get(instantiator, p);</span><br><span class="line">        <span class="keyword">final</span> TypeName classOfS = ParameterizedTypeName.get(java_lang_Class, s);</span><br><span class="line">        <span class="keyword">final</span> TypeName classOfP = ParameterizedTypeName.get(java_lang_Class, p);</span><br><span class="line">        <span class="keyword">final</span> TypeName classOfSubTypeOfS = ParameterizedTypeName.get(java_lang_Class, subTypeOfS);</span><br><span class="line">        <span class="keyword">final</span> TypeName setOfClass = ParameterizedTypeName.get(java_util_Set, classOfAny);</span><br><span class="line">        <span class="keyword">final</span> TypeName setOfClassOfSubTypeOfS = ParameterizedTypeName.get(java_util_Set, classOfSubTypeOfS);</span><br><span class="line">        <span class="keyword">final</span> TypeName linkedHashSetOfClass = ParameterizedTypeName.get(java_util_LinkedHashSet, classOfAny);</span><br><span class="line">        <span class="keyword">final</span> TypeName mapOfClassToSetOfClass = ParameterizedTypeName.get(java_util_Map, classOfAny, setOfClass);</span><br><span class="line">        <span class="keyword">final</span> TypeName mapOfClassToInstantiator = ParameterizedTypeName.get(java_util_Map, classOfAny, instantiatorOfAny);</span><br><span class="line">        <span class="keyword">final</span> TypeName linkedHashMapOfClassToSetOfClass = ParameterizedTypeName.get(java_util_LinkedHashMap, classOfAny, setOfClass);</span><br><span class="line">        <span class="keyword">final</span> TypeName linkedHashMapOfClassToInstantializer = ParameterizedTypeName.get(java_util_LinkedHashMap, classOfAny, instantiatorOfAny);</span><br></pre></td></tr></table></figure><p>然后在需要时直接拿到即可,这里是作为一个变量(Field使用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.addField(FieldSpec.builder(mapOfClassToSetOfClass, <span class="string">"sServices"</span>)</span><br><span class="line">                        .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)</span><br><span class="line">                        .initializer(<span class="string">"new $T()"</span>, linkedHashMapOfClassToSetOfClass)</span><br><span class="line">                        .build())</span><br><span class="line">                        </span><br><span class="line">.addField(FieldSpec.builder(mapOfClassToInstantiator, <span class="string">"sInstantiators"</span>)</span><br><span class="line">                        .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)</span><br><span class="line">                        .initializer(<span class="string">"new $T()"</span>, linkedHashMapOfClassToInstantializer)</span><br><span class="line">                        .build())</span><br></pre></td></tr></table></figure><h1 id="要点分析"><a href="#要点分析" class="headerlink" title="要点分析"></a>要点分析</h1><h2 id="Element和TypeMirror"><a href="#Element和TypeMirror" class="headerlink" title="Element和TypeMirror"></a>Element和TypeMirror</h2><p>这个点还是非常重要的，我们的java代码在对于APT处理时只不过各种的Element的结构化文本，当我们需要进行细致的逻辑判断时候，比如是否是某个类的子类，就需要操作他们了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.example;    // PackageElement</span><br><span class="line"></span><br><span class="line">public class Test &#123;        // TypeElement</span><br><span class="line"></span><br><span class="line">    private int a;      // VariableElement</span><br><span class="line">    private Test other;  // VariableElement</span><br><span class="line"></span><br><span class="line">    public Test () &#123;&#125;    // ExecuteableElement</span><br><span class="line">    public void setA (  // ExecuteableElement</span><br><span class="line">                     int newA   // TypeElement</span><br><span class="line">                     ) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Element</code>代表java源文件中的程序构建元素，例如包、类、方法等。Element接口有5个子类。</p><table><thead><tr><th>PackageElement</th><th>表示一个包程序元素，可以获取到包名等</th></tr></thead><tbody><tr><td>TypeParameterElement</td><td>表示一般类、接口、方法或构造方法元素的泛型参数</td></tr><tr><td>TypeElement</td><td>表示一个类或接口程序元素</td></tr><tr><td>VariableElement</td><td>表示一个字段、enum 常量、方法或构造方法参数、局部变量或异常参数</td></tr><tr><td>ExecutableElement</td><td>表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注解类型元素</td></tr></tbody></table><p>开发中Element可根据实际情况强转为以上5种中的一种</p><ul><li>当你有一个注解是以@Target(ElementType.METHOD)定义时，表示该注解只能修饰方法。<br>那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、方法名、参数类型、返回值,如何做？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//@Target(ElementType.METHOD)修饰</span></span><br><span class="line"><span class="keyword">for</span> (Element element : roundEnv.getElementsAnnotatedWith(Inject.class)) &#123;</span><br><span class="line">    <span class="comment">//对于Element直接强转</span></span><br><span class="line">    ExecutableElement executableElement = (ExecutableElement) element;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非对应的Element，通过getEnclosingElement转换获取</span></span><br><span class="line">    TypeElement classElement = (TypeElement) element</span><br><span class="line">                .getEnclosingElement();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当(ExecutableElement) element成立时，使用(PackageElement) element</span></span><br><span class="line">    <span class="comment">//            .getEnclosingElement();将报错。</span></span><br><span class="line">    <span class="comment">//需要使用elementUtils来获取</span></span><br><span class="line">    Elements elementUtils = processingEnv.getElementUtils();</span><br><span class="line">    PackageElement packageElement = elementUtils.getPackageOf(classElement);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全类名</span></span><br><span class="line">    String fullClassName = classElement.getQualifiedName().toString();</span><br><span class="line">    <span class="comment">//类名</span></span><br><span class="line">    String className = classElement.getSimpleName().toString();</span><br><span class="line">    <span class="comment">//包名</span></span><br><span class="line">    String packageName = packageElement.getQualifiedName().toString();</span><br><span class="line">    <span class="comment">//方法名</span></span><br><span class="line">    String methodName = executableElement.getSimpleName().toString();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取得方法参数列表</span></span><br><span class="line">    List&lt;? extends VariableElement&gt; methodParameters = executableElement.getParameters();</span><br><span class="line">    <span class="comment">//参数类型列表</span></span><br><span class="line">    List&lt;String&gt; types = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (VariableElement variableElement : methodParameters) &#123;</span><br><span class="line">        TypeMirror methodParameterType = variableElement.asType();</span><br><span class="line">        <span class="keyword">if</span> (methodParameterType <span class="keyword">instanceof</span> TypeVariable) &#123;</span><br><span class="line">            TypeVariable typeVariable = (TypeVariable) methodParameterType;</span><br><span class="line">            methodParameterType = typeVariable.getUpperBound();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//参数名</span></span><br><span class="line">        String parameterName = variableElement.getSimpleName().toString();</span><br><span class="line">        <span class="comment">//参数类型</span></span><br><span class="line">        String parameteKind = methodParameterType.toString();</span><br><span class="line">        types.add(methodParameterType.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当你有一个注解是以@Target(ElementType.FIELD)定义时，表示该注解只能修饰属性、类成员。那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、类成员类型、类成员名,如何获取?</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Element element : roundEnv.getElementsAnnotatedWith(IdProperty.class)) &#123;</span><br><span class="line">    <span class="comment">//ElementType.FIELD注解可以直接强转VariableElement</span></span><br><span class="line">    VariableElement variableElement = (VariableElement) element;</span><br><span class="line">    <span class="comment">//非对应的Element，通过getEnclosingElement转换获取</span></span><br><span class="line">    TypeElement classElement = (TypeElement) element</span><br><span class="line">            .getEnclosingElement();</span><br><span class="line">    PackageElement packageElement = elementUtils.getPackageOf(classElement);</span><br><span class="line">    <span class="comment">//类名</span></span><br><span class="line">    String className = classElement.getSimpleName().toString();</span><br><span class="line">    <span class="comment">//包名</span></span><br><span class="line">    String packageName = packageElement.getQualifiedName().toString();</span><br><span class="line">    <span class="comment">//类成员名</span></span><br><span class="line">    String variableName = variableElement.getSimpleName().toString();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类成员类型</span></span><br><span class="line">    TypeMirror typeMirror = variableElement.asType();</span><br><span class="line">    String type = typeMirror.toString();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当你有一个注解是以@Target(ElementType.TYPE)定义时，表示该注解只能修饰类、接口、枚举。那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、全类名、父类，如何获取？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Element element : roundEnv.getElementsAnnotatedWith(xxx.class)) &#123;</span><br><span class="line">    <span class="comment">//ElementType.TYPE注解可以直接强转TypeElement</span></span><br><span class="line">    TypeElement classElement = (TypeElement) element;</span><br><span class="line">    <span class="comment">//非对应的Element，通过getEnclosingElement转换获取</span></span><br><span class="line">    PackageElement packageElement = (PackageElement) element</span><br><span class="line">                .getEnclosingElement();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全类名</span></span><br><span class="line">    String fullClassName = classElement.getQualifiedName().toString();</span><br><span class="line">    <span class="comment">//类名</span></span><br><span class="line">    String className = classElement.getSimpleName().toString();</span><br><span class="line">    <span class="comment">//包名</span></span><br><span class="line">    String packageName = packageElement.getQualifiedName().toString();</span><br><span class="line">    <span class="comment">//父类名</span></span><br><span class="line">    String superClassName = classElement.getSuperclass().toString();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Element代表的是源代码。TypeElement代表的是源代码中的类型元素，例如类。然而，TypeElement并不包含类本身的信息。你可以从TypeElement中获取类的名字，但是你获取不到类的信息，例如它的父类。这种信息需要通过TypeMirror获取。<code>TypeMirror</code>用与描述Java程序中元素的信息，即Elment的元信息。通过通过<code>Element.asType()</code>接口可以获取Element的TypeMirror，结构比较复杂<br><img src="https://blog-10039692.file.myqcloud.com/1508900053643_8070_1508900092231.png" alt="typemirror"></p><p>常用的TypeMirror，如下</p><table><thead><tr><th>PrimitiveType</th><th>原始数据类型，boolean,byte,short int,long,float,char,double</th></tr></thead><tbody><tr><td>ReferenceType</td><td>引用类型</td></tr><tr><td>ArrayType</td><td>数组类型</td></tr><tr><td>DeclaredType</td><td>声明的类型，例如类、接口、枚举、注解类型</td></tr><tr><td>AnnotationType</td><td>注解类型</td></tr><tr><td>ClassType</td><td>类类型</td></tr><tr><td>EnumType</td><td>枚举类型</td></tr><tr><td>InterfaceType</td><td>接口类型</td></tr><tr><td>TypeVariable</td><td>类型变量类型</td></tr><tr><td>VoidType</td><td>void 类型</td></tr><tr><td>WildcardType</td><td>通配符类型</td></tr></tbody></table><p>当TypeMirror是DeclaredType或者TypeVariable时，TypeMirror可以转化成Element:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element element = processingEviroment.getTypeUtils().asElement(typeMirror);</span><br></pre></td></tr></table></figure><p>在ARouter中 为了区分是否是某个类的子类使用到了TypeMirro</p><p>RouterProcessor # parseRoutes</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> TypeMirror type_Activity = elements.getTypeElement(ACTIVITY).asType();</span><br><span class="line">            TypeMirror type_Service = elements.getTypeElement(SERVICE).asType();</span><br><span class="line">            TypeMirror fragmentTm = elements.getTypeElement(FRAGMENT).asType();</span><br><span class="line">            TypeMirror fragmentTmV4 = elements.getTypeElement(Consts.FRAGMENT_V4).asType();</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> (types.isSubtype(tm, type_Activity)) &#123;                 <span class="comment">// Activity</span></span><br><span class="line">                    ……</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (types.isSubtype(tm, iProvider)) &#123;         <span class="comment">// IProvider</span></span><br><span class="line">                ……</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (types.isSubtype(tm, fragmentTm) || types.isSubtype(tm, fragmentTmV4)) &#123;</span><br><span class="line">                 ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ul><li>使用Messager</li></ul><p><code>Messager</code>提供给注解处理器一个报告错误、警告以及提示信息的途径。它不是注解处理器开发者的日志工具，而是用来写一些信息给使用此注解器的第三方开发者的。<br>在官方文档中描述了消息的不同级别中非常重要的是Kind.ERROR，因为这种类型的信息用来表示我们的注解处理器处理失败了。很有可能是第三方开发者错误的使用了注解。这个概念和传统的Java应用有点不一样，在传统Java应用中我们可能就抛出一个异常Exception。如果你在process()中抛出一个异常，那么运行注解处理器的JVM将会崩溃（就像其他Java应用一样），使用我们注解处理器第三方开发者将会从javac中得到非常难懂的出错信息，因为它包含注解处理器的堆栈跟踪（Stacktace）信息。因此，注解处理器就有一个Messager类，它能够打印非常优美的错误信息。除此之外，你还可以连接到出错的元素。在像现在的IDE（集成开发环境）中，第三方开发者可以直接点击错误信息，IDE将会直接跳转到第三方开发者项目的出错的源文件的相应的行。<br>因此我们通常封装一个Logger去打印关键点，具体可以参考ARouter的<a href="https://github.com/alibaba/ARouter/blob/master/arouter-compiler/src/main/java/com/alibaba/android/arouter/compiler/utils/Logger.java" target="_blank" rel="noopener">Logger</a></p><ul><li>断点调试</li></ul><p>(1) 在项目的根目录下的gradle.properties文件中，新增如下配置：</p><blockquote><p>org.gradle.jvmargs=-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005<br>org.gradle.daemon=true</p></blockquote><p>(2)新建remote debugger</p><p>注意新建remoteDebuger的名称一定要是AnnotationProcessor<br><img src="https://blog-10039692.file.myqcloud.com/1508900731628_7034_1508900770128.png" alt=""></p><p><img src="https://blog-10039692.file.myqcloud.com/1508900743976_6437_1508900782462.png" alt=""><br>(3)Debug AnnotationProcessor<br><img src="https://blog-10039692.file.myqcloud.com/1508900753173_3782_1508900791654.png" alt=""></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>APT + JavaPoet 固然比较强大，但是也有其局限性，比如它无法扫描 AAR、JAR包，在一些大型app上分模块最终以jar包形式提供的话，就不能扫描到注解了，那这时就需要借助于更为强大的技术了，可以通过自定义Gradle Plugin + JavaAssist在dex之前扫描class方式去生成我们想要的代码,这是后话了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.im/entry/58fefebf8d6d810058a610de/" target="_blank" rel="noopener">https://juejin.im/entry/58fefebf8d6d810058a610de/</a></li><li><a href="https://cloud.tencent.com/developer/article/1006210" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1006210</a></li><li><a href="https://race604.com/annotation-processing/" target="_blank" rel="noopener">https://race604.com/annotation-processing/</a></li><li><a href="https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/" target="_blank" rel="noopener">https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;APT+JavaPoet 是一把利剑，可
      
    
    </summary>
    
      <category term="注解" scheme="https://xsfelvis.github.io/categories/%E6%B3%A8%E8%A7%A3/"/>
    
    
      <category term="APT" scheme="https://xsfelvis.github.io/tags/APT/"/>
    
      <category term="JavaPoet" scheme="https://xsfelvis.github.io/tags/JavaPoet/"/>
    
  </entry>
  
</feed>
