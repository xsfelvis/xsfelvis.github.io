<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>渡口一艘船</title>
  
  <subtitle>不积跬步，无以至千里；不积小流，无以成江海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xsfelvis.github.io/"/>
  <updated>2018-06-06T06:08:45.791Z</updated>
  <id>https://xsfelvis.github.io/</id>
  
  <author>
    <name>云来</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ARouter解析之URL跳转</title>
    <link href="https://xsfelvis.github.io/2018/06/06/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8BURL%E8%B7%B3%E8%BD%AC/"/>
    <id>https://xsfelvis.github.io/2018/06/06/ARouter解析之URL跳转/</id>
    <published>2018-06-05T16:00:00.000Z</published>
    <updated>2018-06-06T06:08:45.791Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="ARouter解析之URL跳转"><a href="#ARouter解析之URL跳转" class="headerlink" title="ARouter解析之URL跳转"></a>ARouter解析之URL跳转</h1><p>在ARouter Demo中，点击通过URL跳转，会通过WebView加载html</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance()</span><br><span class="line">        .build(<span class="string">"/test/webview"</span>)</span><br><span class="line">        .withString(<span class="string">"url"</span>, <span class="string">"file:///android_asset/schame-test.html"</span>)</span><br><span class="line">        .navigation();</span><br></pre></td></tr></table></figure><p> <img src="https://upload-images.jianshu.io/upload_images/2608779-5104d9c50fcb0553.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340" alt=""></p><h2 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h2><p>通常webview上的url跳转会给webview设置一个<code>webviewClient</code>，然后通过shouldOverrideUrlLoading方法，在方法中构造intent进行跳转，简单示意如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">webview.setWebViewClient(<span class="keyword">new</span> WebViewClient()&#123;    </span><br><span class="line"><span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span> (url != <span class="keyword">null</span> &amp;&amp; url.contains(<span class="string">"arouter"</span>))&#123;    </span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(TestWebview.<span class="keyword">this</span>, Test1Activity.class);    </span><br><span class="line">        startActivity(intent);    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.shouldOverrideUrlLoading(view, url);    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种做法往往会有很多缺陷</p><ol><li>硬编码，业务复杂时候webview变得很臃肿，耦合严重不利于维护</li><li>当外不应用打开链接需要跳转到我们的App某个Activity中时候，此时就不在自己App的webview环境中，这样就无法满足跳转需求的，因此这种方式也不够强大</li></ol><p>ARouter就是通过<code>注册一个没有UI的界面</code>作为跳板来统一处理,scheme是arouter的跳转请求。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">".SchemeFilterActivity"</span>&gt;</span><br><span class="line">    &lt;!-- Schame --&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;data</span><br><span class="line">            android:host=<span class="string">"m.aliyun.com"</span></span><br><span class="line">            android:scheme=<span class="string">"arouter"</span>/&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">"android.intent.action.VIEW"</span>/&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"android.intent.category.BROWSABLE"</span>/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">    &lt;!-- App Links --&gt;</span><br><span class="line">    &lt;intent-filter android:autoVerify=<span class="string">"true"</span>&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">"android.intent.action.VIEW"</span>/&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"android.intent.category.BROWSABLE"</span>/&gt;</span><br><span class="line">        &lt;data</span><br><span class="line">            android:host=<span class="string">"m.aliyun.com"</span></span><br><span class="line">            android:scheme=<span class="string">"http"</span>/&gt;</span><br><span class="line">        &lt;data</span><br><span class="line">            android:host=<span class="string">"m.aliyun.com"</span></span><br><span class="line">            android:scheme=<span class="string">"https"</span>/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><p>在清单文件中注册了SchemeFilterActivity这个activity</p><ul><li>scheme就是arouter, </li><li>host就是m.aliyun.com，</li><li>其中有个category是 android.intent.category.BROWSABLE，</li></ul><p>其中 <code>android.intent.category.BROWSABLE</code>就是让浏览器可以打这个Actvity，当然要符合host和scheme,这样就可以在WebView中跳转SchemeFilterActivity这个界面了。</p><p>这种方式的优点：</p><ol><li><p>首先是页面跳转的灵活性，<br>比如需要和H5中进行通信，H5需要跳转到App本地的页面，Native和H5只需要统一一个path文档即可，H5可以通过path构造一个url就可以实现跳转到对应页面的功能，很类似浏览器，实现很好的解耦</p></li><li><p>更加的安全<br>相比较于隐式的intent，每一个从外面跳转进来的页面都需要注册上intent-filter，每个页面都需要设置export=true，也就是需要让每一个页面都可以导出，在外部可以访问到。这样做会带来非常严重的安全风险，就像是一个房子有十个门还是只有一个门，看门的成本是不同的。而现在使用的这种场景只需要对外暴露出一个activity，然后在这个activity中注册一个intent-filter，这样之后所有的外部路由请求都会经过这唯一的门，然后在这个activity中获取到URL并将其交给ARouter，剩下的就由路由框架做分发了。</p></li><li><p>携带参数注入<br>另外一个好处就是隐式intent跳转无法将参数自动注入，ARouter可以在url中携带参数然后自动注入</p></li></ol><p>这里也需要H5链接需要按照<code>约定的scheme来</code>，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>跳转测试<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>自定义Scheme[通常来说都是这样的]<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"arouter://m.aliyun.com/test/activity1"</span>&gt;</span>arouter://m.aliyun.com/test/activity1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"arouter://m.aliyun.com/test/activity1?url=https%3a%2f%2fm.abc.com%3fa%3db%26c%3dd"</span>&gt;</span>测试URL Encode情况<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"arouter://m.aliyun.com/test/activity1?name=alex&amp;age=18&amp;boy=true&amp;high=180&amp;obj=%7b%22name%22%3a%22jack%22%2c%22id%22%3a666%7d"</span>&gt;</span>arouter://m.aliyun.com/test/activity1?name=alex&amp;age=18&amp;boy=true&amp;high=180&amp;obj=&#123;"name":"jack","id":"666"&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"arouter://m.aliyun.com/test/activity2"</span>&gt;</span>arouter://m.aliyun.com/test/activity2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"arouter://m.aliyun.com/test/activity2?key1=value1"</span>&gt;</span>arouter://m.aliyun.com/test/activity2?key1=value1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"arouter://m.aliyun.com/test/activity3?name=alex&amp;age=18&amp;boy=true&amp;high=180"</span>&gt;</span>arouter://m.aliyun.com/test/activity3?name=alex&amp;age=18&amp;boy=true&amp;high=180<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>App Links[防止被App屏蔽]<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://m.aliyun.com/test/activity1"</span>&gt;</span>http://m.aliyun.com/test/activity1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://m.aliyun.com/test/activity2"</span>&gt;</span>http://m.aliyun.com/test/activity2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="URL中转SchemeFilterActivity"><a href="#URL中转SchemeFilterActivity" class="headerlink" title="URL中转SchemeFilterActivity"></a>URL中转SchemeFilterActivity</h2><p>点击url之后通过清单文件的匹配intent-filter中的data, action, category的标签，其中category匹配任意一个即可。接着就来到SchemeFilterActivity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchemeFilterActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        直接通过ARouter处理外部Uri</span></span><br><span class="line">        Uri uri = getIntent().getData();</span><br><span class="line">        ARouter.getInstance().build(uri).navigation(<span class="keyword">this</span>, <span class="keyword">new</span> NavCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onArrival</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">                finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续处理就跟之前路由逻辑一致了,这里就不赘述了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;ARouter解析之URL跳转&quot;&gt;&lt;a href=&quot;#ARouter解析之URL跳转&quot; class=&quot;headerlink&quot; title=&quot;ARouter解析之UR
      
    
    </summary>
    
      <category term="开源学习" scheme="https://xsfelvis.github.io/categories/%E5%BC%80%E6%BA%90%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ARouter" scheme="https://xsfelvis.github.io/tags/ARouter/"/>
    
      <category term="路由" scheme="https://xsfelvis.github.io/tags/%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>谈谈APT和JavaPoet的一些使用技巧</title>
    <link href="https://xsfelvis.github.io/2018/06/06/%E8%B0%88%E8%B0%88APT%E5%92%8CJavaPoet%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/"/>
    <id>https://xsfelvis.github.io/2018/06/06/谈谈APT和JavaPoet的一些技巧/</id>
    <published>2018-06-05T16:00:00.000Z</published>
    <updated>2018-06-06T06:51:44.236Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="ING"><a href="#ING" class="headerlink" title="ING"></a>ING</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;ING&quot;&gt;&lt;a href=&quot;#ING&quot; class=&quot;headerlink&quot; title=&quot;ING&quot;&gt;&lt;/a&gt;ING&lt;/h1&gt;
      
    
    </summary>
    
      <category term="注解" scheme="https://xsfelvis.github.io/categories/%E6%B3%A8%E8%A7%A3/"/>
    
    
      <category term="JavaPoet" scheme="https://xsfelvis.github.io/tags/JavaPoet/"/>
    
      <category term="APT" scheme="https://xsfelvis.github.io/tags/APT/"/>
    
  </entry>
  
  <entry>
    <title>ARouter解析(1)</title>
    <link href="https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%A6%82%E8%BF%B0/"/>
    <id>https://xsfelvis.github.io/2018/06/05/ARouter解析之概述/</id>
    <published>2018-06-04T16:00:00.000Z</published>
    <updated>2018-06-05T10:02:12.606Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这个库非常值得学习，里面涉及到的技术和编程思想都是不错的</p><ol><li>APT 编译器注解处理技术</li><li>scheme url的统一管理跳转的方案</li><li>‘服务’的解耦（接口设计）与获取(反射)</li><li>IoC与依赖注入(服务和参数由框架进行自动赋值)</li><li>拦截器思想 （AOP的设计思想）</li><li>多线程处理技术</li><li>降级策略</li><li>分组加载策略</li><li>友好的api设计</li></ol><h1 id="整体设计如下"><a href="#整体设计如下" class="headerlink" title="整体设计如下"></a>整体设计如下</h1><p><img src="http://p927u2n0k.bkt.clouddn.com/ARouter.png" alt="ARoute"></p><p>使用原作者的抽象图，整个ARouter架构如下:</p><p><img src="https://yqfile.alicdn.com/37b723fb660fdfcf7cdc09c194c88a8073d8272d.png" alt="阿里开源"></p><p><img src="https://yqfile.alicdn.com/e4d3ec6020479ef2043cfd7e10cfaf33254ac309.png" alt="阿里开源"></p><p>其实在Android原生跳转主要是通过intent，主要分为显式和隐式跳转，显示跳转直接导致类之间的耦合，而隐式跳转需要在清单文件中申明，在多模块协作中比较困难,而且二者最终都会调用startActivity，这个环节我们就无法控制了，而ARouter路由可以在跳转中进行如同拦截,跳转失败进行降级的操作。</p><p>下面将分几篇介绍这个开源库</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;这个库非常值得学习，里面涉及到的技术和编
      
    
    </summary>
    
      <category term="开源学习" scheme="https://xsfelvis.github.io/categories/%E5%BC%80%E6%BA%90%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ARouter" scheme="https://xsfelvis.github.io/tags/ARouter/"/>
    
      <category term="路由" scheme="https://xsfelvis.github.io/tags/%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>ARouter解析之路由的秘密</title>
    <link href="https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8B%E8%B7%AF%E7%94%B1%E7%9A%84%E7%A7%98%E5%AF%86/"/>
    <id>https://xsfelvis.github.io/2018/06/05/ARouter解析之路由的秘密/</id>
    <published>2018-06-04T16:00:00.000Z</published>
    <updated>2018-06-06T06:09:59.506Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本篇主要介绍ARouter如何进行路由的，比如Activity、Fragment、服务等</p><h1 id="路由的秘密"><a href="#路由的秘密" class="headerlink" title="路由的秘密"></a>路由的秘密</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>初始化路由之后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARouter.init(mApplication);</span><br></pre></td></tr></table></figure><p>在需要支持页面路由的页面上添加注解(至少两级)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Route</span>(path = <span class="string">"/test/activity2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2Activity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span></span><br></pre></td></tr></table></figure><p>在路由时候通过建造者模式构建参数，<code>路由页面</code>分为以下几种</p><h3 id="路由页面"><a href="#路由页面" class="headerlink" title="路由页面"></a>路由页面</h3><ul><li>普通跳转</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance()</span><br><span class="line">        .build(<span class="string">"/test/activity2"</span>)</span><br><span class="line">        .navigation();</span><br></pre></td></tr></table></figure><ul><li>带参数跳转</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance()</span><br><span class="line">    .build(<span class="string">"/test/activity2"</span>)</span><br><span class="line">    .withString(<span class="string">"key1"</span>, <span class="string">"value1"</span>)</span><br><span class="line">    .navigation();</span><br></pre></td></tr></table></figure><p>其中ARouter提供了丰富的参数类型主要有基本类型、Object、Parceable等，核心原理也是通过Bundle携带传递</p><ul><li>startActivityForResult</li></ul><p>比如在TestActivity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance().build(<span class="string">"/test/activity2"</span>)</span><br><span class="line">                     .withString(<span class="string">"key1"</span>, <span class="string">"value1"</span>)</span><br><span class="line">                     .navigation(<span class="keyword">this</span>, <span class="number">999</span>);</span><br></pre></td></tr></table></figure><p>然后在TestActivity中 使用onActivityResult得到数据进行处理，这里跟普通过程一样</p><ul><li>带回调路由</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance().build(<span class="string">"/xxx/xxx"</span>).navigation(<span class="keyword">this</span>, <span class="keyword">new</span> NavCallback() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFound</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">                       Log.d(<span class="string">"ARouter"</span>, <span class="string">"找到了"</span>);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLost</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">                       Log.d(<span class="string">"ARouter"</span>, <span class="string">"找不到了"</span>);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onArrival</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">                       Log.d(<span class="string">"ARouter"</span>, <span class="string">"跳转完了"</span>);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInterrupt</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">                       Log.d(<span class="string">"ARouter"</span>, <span class="string">"被拦截了"</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br></pre></td></tr></table></figure><h3 id="路由Fragment"><a href="#路由Fragment" class="headerlink" title="路由Fragment"></a>路由Fragment</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Fragment fragment = (Fragment) ARouter.getInstance()</span><br><span class="line">                    .build(<span class="string">"/test/fragment"</span>)</span><br><span class="line">                    .navigation();</span><br></pre></td></tr></table></figure><h3 id="路由服务"><a href="#路由服务" class="headerlink" title="路由服务"></a>路由服务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance()</span><br><span class="line">        .navigation(SingleService.class)</span><br><span class="line">        .sayHello(<span class="string">"Mike"</span>);</span><br></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>可以看出路由到页面 分为三步</p><ul><li>build 构建 信息邮票(PostCard)</li></ul><p>_ARouter # build</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Build postcard by path and default group</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Postcard <span class="title">build</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(path)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(Consts.TAG + <span class="string">"Parameter is invalid!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != pService) &#123;</span><br><span class="line">            path = pService.forString(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(path, extractGroup(path));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>WithXXX 路由参数</p></li><li><p>navagation 导航</p></li></ul><p>_ARouter # navagation</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">navigation</span><span class="params">(Context mContext, Postcard postcard, <span class="keyword">int</span> requestCode, NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _ARouter.getInstance().navigation(mContext, postcard, requestCode, callback);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面将按照上面的提到三个核心过程进行分析</p><ul><li>通过path构建路由信息</li></ul><p>build是在构建路由信息邮票”PostCard”,从名字看来这就是一张路由邮票，跟网络路由协议传递携带的信息作用一样,通过ARouter这个门面类(Facade)调用实际操控着_ARouter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Build postcard by path and default group</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Postcard <span class="title">build</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">      ……</span><br><span class="line">    <span class="comment">//路径扩展</span></span><br><span class="line">    PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != pService) &#123;</span><br><span class="line">        path = pService.forString(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> build(path, extractGroup(path));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也体现了作者设计这套框架的扩展性能，这个<code>PathReplaceService</code>就是让使用者自己可以给path添加扩展。extractGroup就是根据path(/test/activity2)提取group(test)，这里就是默认第一个/隔断的字符串，通过这些信息<code>初步</code>构造路由信息，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> Postcard <span class="title">build</span><span class="params">(String path, String group)</span> </span>&#123;</span><br><span class="line">       ……</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Postcard(path, group);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一个具有 <code>path</code>和<code>group</code>简单信息的PostCard对象就被构造出来了</p><ul><li>携带参数</li></ul><p>由于是Builder模式，此时构造出postcard之后之后的<code>.WithXXX</code>实际上实在给PostCard对象填充信息，PostCard对象的Bundle来承载这些信息，<br>其中 序列化对象<code>SerializationService</code>转成json存到Bundle中<br>通过这一步PostCard这个<code>邮票</code>信息进一步丰满了</p><ul><li>navigation 导航</li></ul><p>得到PostCard对象之后回去调用postCard对象的navigation对象,调用函数链如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PostCard（Arouter.getInstance.build("test/activity2")）——&gt;PostCard#navigation——&gt;ARouter#navigation</span><br><span class="line">——&gt;_ARouter#navigation`</span><br></pre></td></tr></table></figure><h4 id="ARouter-navigation"><a href="#ARouter-navigation" class="headerlink" title="_ARouter#navigation"></a>_ARouter#navigation</h4><p>来到了核心函数 <code>_ARouter#navigation</code>函数中,这个函数其实是核心路由逻辑的第一道大门,我们越来越接近真相了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">navigation</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="keyword">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//完善postCard 核心信息,主要是跳转路径 后面会详细分析</span></span><br><span class="line">        LogisticsCenter.completion(postcard);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoRouteFoundException ex) &#123;</span><br><span class="line">        <span class="comment">// 未找到页面的降级处理策略</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">            <span class="comment">//自定义回调高于系统</span></span><br><span class="line">            callback.onLost(postcard);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// No callback for this invoke, then we use the global degrade service.</span></span><br><span class="line">            <span class="comment">//没有自定义回调才使用系统onLost</span></span><br><span class="line">            DegradeService degradeService = ARouter.getInstance().navigation(DegradeService.class);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != degradeService) &#123;</span><br><span class="line">                degradeService.onLost(context, postcard);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">        <span class="comment">//onFound回调</span></span><br><span class="line">        callback.onFound(postcard);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!postcard.isGreenChannel()) &#123;   <span class="comment">// It must be run in async thread, maybe interceptor cost too mush time made ANR.</span></span><br><span class="line">        <span class="comment">//非绿色通道检查拦截器</span></span><br><span class="line">        interceptorService.doInterceptions(postcard, <span class="keyword">new</span> InterceptorCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onContinue</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//真正核心导航逻辑</span></span><br><span class="line">            _navigation(context, postcard, requestCode, callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInterrupt</span><span class="params">(Throwable exception)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">                    callback.onInterrupt(postcard);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//真正核心导航逻辑</span></span><br><span class="line">        <span class="keyword">return</span> _navigation(context, postcard, requestCode, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法较长 主要分为以下四步</p><ol><li>首先调用LogisticsCenter.completion完成postcard的补充</li><li>NavigationCallBack的处理</li><li>拦截器Interceptions的处理</li><li>开始路由导航</li></ol><p>路由导航之前如何将之前获取的postcard信息进行完善?<br>ARouter.getInstance() .build(“/test/activity2”)时已经返回了一个postcard对象，那么要完善那些信息呢？其实我们可以看出，postcard中只有path和group的信息，目标页面是什么还不明确，因此需要进一步完善信息，核心函数就是上面的LogisticsCenter.completion，这样就体现了框架的重要性，脏活累活交给框架层面，而跟用户打交道的永远都是那么的简洁。</p><h4 id="ARouter-navigationObject-navigation"><a href="#ARouter-navigationObject-navigation" class="headerlink" title="_ARouter#navigationObject navigation("></a>_ARouter#navigationObject navigation(</h4><p>最后会来到_ARouter#navigationObject navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback)）</p><p>这个函数负责最终的页面跳转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">_navigation</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="keyword">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Context currentContext = <span class="keyword">null</span> == context ? mContext : context;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (postcard.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> ACTIVITY:</span><br><span class="line">                <span class="comment">// Build intent</span></span><br><span class="line">                <span class="keyword">final</span> Intent intent = <span class="keyword">new</span> Intent(currentContext, postcard.getDestination());</span><br><span class="line">                intent.putExtras(postcard.getExtras());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Set flags.</span></span><br><span class="line">                <span class="keyword">int</span> flags = postcard.getFlags();</span><br><span class="line">                <span class="keyword">if</span> (-<span class="number">1</span> != flags) &#123;</span><br><span class="line">                    intent.setFlags(flags);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(currentContext <span class="keyword">instanceof</span> Activity)) &#123;    <span class="comment">// Non activity, need less one flag.</span></span><br><span class="line">                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Navigation in main looper.</span></span><br><span class="line">                <span class="keyword">new</span> Handler(Looper.getMainLooper()).post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (requestCode &gt; <span class="number">0</span>) &#123;  <span class="comment">// Need start for result</span></span><br><span class="line">                            ActivityCompat.startActivityForResult((Activity) currentContext, intent, requestCode, postcard.getOptionsBundle());</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            ActivityCompat.startActivity(currentContext, intent, postcard.getOptionsBundle());</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> ((-<span class="number">1</span> != postcard.getEnterAnim() &amp;&amp; -<span class="number">1</span> != postcard.getExitAnim()) &amp;&amp; currentContext <span class="keyword">instanceof</span> Activity) &#123;    <span class="comment">// Old version.</span></span><br><span class="line">                            ((Activity) currentContext).overridePendingTransition(postcard.getEnterAnim(), postcard.getExitAnim());</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123; <span class="comment">// Navigation over.</span></span><br><span class="line">                            callback.onArrival(postcard);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PROVIDER:</span><br><span class="line">                <span class="keyword">return</span> postcard.getProvider();</span><br><span class="line">            <span class="keyword">case</span> BOARDCAST:</span><br><span class="line">            <span class="keyword">case</span> CONTENT_PROVIDER:</span><br><span class="line">            <span class="keyword">case</span> FRAGMENT:</span><br><span class="line">                Class fragmentMeta = postcard.getDestination();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object instance = fragmentMeta.getConstructor().newInstance();</span><br><span class="line">                    <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> Fragment) &#123;</span><br><span class="line">                        ((Fragment) instance).setArguments(postcard.getExtras());</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> android.support.v4.app.Fragment) &#123;</span><br><span class="line">                        ((android.support.v4.app.Fragment) instance).setArguments(postcard.getExtras());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> instance;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    logger.error(Consts.TAG, <span class="string">"Fetch fragment instance error, "</span> + TextUtils.formatStackTrace(ex.getStackTrace()));</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> METHOD:</span><br><span class="line">            <span class="keyword">case</span> SERVICE:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>Activity</li></ul><p>来到ACTIVITY分支，从postcard中拿到目标页面TestActivity.class然后组成intent，然后putExtras，如果是startActivityForResult,这里面就有参数。如果context不是activity，那么就需要另起一个栈Intent.FLAG_ACTIVITY_NEW_TASK进行activity的展示。接下来通过handler发送启动activity的任务。终于找到了熟悉的ActivityCompat.startActivity和ActivityCompat.startActivityForResult，</p><ul><li>Fragment</li></ul><p>通过postcard拿到目标页面的Fragment Class，然后实例化这个，还需要兼容fragment，设置Arguments参数之后返回这个Fragment实例</p><ul><li>Provider</li></ul><p>这个是用来提供服务的，由于在 完善postCard 核心信息,<code>LogisticsCenter.completion(postcard);</code>中已经将provider实例化了，这里直接直接get出来就好。后面将会分析<code>LogisticsCenter.completion(postcard)</code>具体做了哪些工作</p><h4 id="LogisticsCenter-completion-postcard"><a href="#LogisticsCenter-completion-postcard" class="headerlink" title="LogisticsCenter.completion(postcard)"></a>LogisticsCenter.completion(postcard)</h4><p>这个函数就是完善PostCard信息的，postcard是路由信息的容器，到这个函数时候postcard中只有path和group的信息，目标页面是什么还不知道，LogisticsCenter.completion就是填充剩余的关键信息的，b并且是通过<code>按需加载的</code>,十分重要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">completion</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="comment">//从仓库WareHouse中获取路由元数据，即一些路由基本的数据</span></span><br><span class="line">    RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == routeMeta) &#123;    <span class="comment">// Maybe its does't exist, or didn't load.</span></span><br><span class="line">        Class&lt;? extends IRouteGroup&gt; groupMeta = Warehouse.groupsIndex.get(postcard.getGroup());  <span class="comment">// Load route meta.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == groupMeta) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoRouteFoundException(TAG + <span class="string">"There is no route match the path ["</span> + postcard.getPath() + <span class="string">"], in group ["</span> + postcard.getGroup() + <span class="string">"]"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Load route and cache it into memory, then delete from metas.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ……</span><br><span class="line">                <span class="comment">//将信息加载进Warehouse.routes中</span></span><br><span class="line">                IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();</span><br><span class="line">                iGroupInstance.loadInto(Warehouse.routes);</span><br><span class="line">                Warehouse.groupsIndex.remove(postcard.getGroup());</span><br><span class="line">                ……</span><br><span class="line">            &#125; </span><br><span class="line">            ……</span><br><span class="line">            <span class="comment">//经过上面的处理后，此时可以获取到对应path下的routeMeta，调用本身</span></span><br><span class="line">            completion(postcard);   <span class="comment">// Reload</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//正常获取到routeMeta填充postCard信息</span></span><br><span class="line">        postcard.setDestination(routeMeta.getDestination());</span><br><span class="line">        postcard.setType(routeMeta.getType());</span><br><span class="line">        postcard.setPriority(routeMeta.getPriority());</span><br><span class="line">        postcard.setExtra(routeMeta.getExtra());</span><br><span class="line"></span><br><span class="line">        Uri rawUri = postcard.getUri();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != rawUri) &#123;   <span class="comment">// Try to set params into bundle.</span></span><br><span class="line">            Map&lt;String, String&gt; resultMap = TextUtils.splitQueryParameters(rawUri);</span><br><span class="line">            Map&lt;String, Integer&gt; paramsType = routeMeta.getParamsType();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (MapUtils.isNotEmpty(paramsType)) &#123;</span><br><span class="line">                <span class="comment">// Set value by its type, just for params which annotation by @Param</span></span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; params : paramsType.entrySet()) &#123;</span><br><span class="line">                    setValue(postcard,</span><br><span class="line">                            params.getValue(),</span><br><span class="line">                            params.getKey(),</span><br><span class="line">                            resultMap.get(params.getKey()));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Save params name which need auto inject.</span></span><br><span class="line">                postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(<span class="keyword">new</span> String[]&#123;&#125;));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Save raw uri</span></span><br><span class="line">            postcard.withString(ARouter.RAW_URI, rawUri.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (routeMeta.getType()) &#123;</span><br><span class="line">            <span class="comment">//完成信息的同时顺便把"服务实例化"，fragment置为无须过滤的绿色通道</span></span><br><span class="line">            <span class="keyword">case</span> PROVIDER:  <span class="comment">// if the route is provider, should find its instance</span></span><br><span class="line">                <span class="comment">// Its provider, so it must implement IProvider</span></span><br><span class="line">                Class&lt;? extends IProvider&gt; providerMeta = (Class&lt;? extends IProvider&gt;) routeMeta.getDestination();</span><br><span class="line">                IProvider instance = Warehouse.providers.get(providerMeta);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123; <span class="comment">// There's no instance of this provider</span></span><br><span class="line">                    IProvider provider;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        provider = providerMeta.getConstructor().newInstance();</span><br><span class="line">                        provider.init(mContext);</span><br><span class="line">                        Warehouse.providers.put(providerMeta, provider);</span><br><span class="line">                        instance = provider;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(<span class="string">"Init provider failed! "</span> + e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                postcard.setProvider(instance);</span><br><span class="line">                postcard.greenChannel();    <span class="comment">// Provider should skip all of interceptors</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FRAGMENT:</span><br><span class="line">                postcard.greenChannel();    <span class="comment">// Fragment needn't interceptors</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程图如下<br><img src="http://p927u2n0k.bkt.clouddn.com/arouter-complete.png" alt="arouter-complete"></p><p>这个有一个关键点 WearHouse</p><ul><li>仓库查找页面节点</li></ul><p>首先根据路径信息到WareHouse仓库中查找路由节点信息，其实就是几个map，包含节点、拦截器和组别等信息<br><code>RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());</code><br>一开始是没有这个节点信息的，所以需要到WareHouse.groupsIndex中找到组别的信息，这里体现了之前提到的<code>分组加载的策略</code>，这里对应的是test这一组<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;? extends IRouteGroup&gt; groupMeta = Warehouse.groupsIndex.get(postcard.getGroup());  <span class="comment">// Load route meta.</span></span><br></pre></td></tr></table></figure></p><p>然后通过反射的方式加载这一组类别的映射关系，就是前面提到的按需加载，然后从仓库中删除这个组别信息节点，防止重复加载</p><pre><code class="java">IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();            iGroupInstance.loadInto(Warehouse.routes);    Warehouse.groupsIndex.remove(postcard.getGroup());</code></pre><p>其中编译期间已经组成了RouteMeta这个节点信息，包含有目标页面、类型、路径、组别、参数、优先级等信息。可以看到生成之后的信息表并没有直接加载到内存中，而是在第一次访问该组内一个页面时才去加载该组的信息，然后该groupindex移除，防止重复加载</p><p>生成的<code>ARouter$$Group$$test</code></p><p><img src="https://upload-images.jianshu.io/upload_images/2608779-20192e96ae6f869f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="test组"></p><ul><li>填充信息</li></ul><p>当第一次没有查找到路由节点之后，要到组别中找到路由信息 load到warehouse中，再次调用本身<code>completion(postcard)</code>函数.然后执行到else中填充路由信息</p><ul><li>一些初始化</li></ul><p>填充玩信息后，将”服务”实例化，方便后面直接获取，并且将“服务”和fragment设置为绿色通道无需检查，感觉是由于二者本身需要返回一个实例，回调接口NavCallBack只能回调PostCard信息，而且二者近似服务性质，因而不如直接给个绿色通道来的直接。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>路由之间跳转到的分析到此基本上告一段落了，其中众多信息都在PostCard中不断完善，然后在LogisticsCenter.completion进行完全填充，更重要的是整体架构关注点分离的设计是非常棒的，编译期间映射信息都下沉到LogisticsCenter与用户层打交道的API都通过ARouter这个门面友好的暴露给用户，我们平时在开发设计中也可以这样学习一下</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;本篇主要介绍ARouter如何进行路由的
      
    
    </summary>
    
      <category term="开源学习" scheme="https://xsfelvis.github.io/categories/%E5%BC%80%E6%BA%90%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ARouter" scheme="https://xsfelvis.github.io/tags/ARouter/"/>
    
      <category term="路由" scheme="https://xsfelvis.github.io/tags/%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>clean架构</title>
    <link href="https://xsfelvis.github.io/2018/05/18/%E5%85%B3%E4%BA%8Eclean%E6%9E%B6%E6%9E%84%E5%9C%A8android%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://xsfelvis.github.io/2018/05/18/关于clean架构在android中的应用/</id>
    <published>2018-05-17T16:00:00.000Z</published>
    <updated>2018-06-06T06:13:38.572Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="1、clean架构简介"><a href="#1、clean架构简介" class="headerlink" title="1、clean架构简介"></a>1、clean架构简介</h2><p>clean架构相信大家早有耳闻，毕竟是Bob大叔的心血之作，最近又把<a href="http://five.agency/blog/android/" target="_blank" rel="noopener">http://five.agency/blog/android/</a> 几篇关于clean 架构的文章拿出来读读加深了对该架构的一些理解。clean架构又称“洋葱架构”，这个是由于它的架构示意图得名的<br><img src="https://user-gold-cdn.xitu.io/2018/5/15/16364599d2727324?w=896&amp;h=472&amp;f=png&amp;s=104636" alt="" title="image.png"><br>删除一些android项目中使用不到的东西加上我们使用的东西看起来如下图</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/15/16364599d36a65e7?w=892&amp;h=467&amp;f=png&amp;s=96377" alt="" title="image.png"></p><h2 id="2、核心概念"><a href="#2、核心概念" class="headerlink" title="2、核心概念"></a>2、核心概念</h2><p>从最抽象的核心到细节的边缘</p><h3 id="Entities"><a href="#Entities" class="headerlink" title="Entities"></a>Entities</h3><ul><li><p>Entities，<br>即<strong>Domain 对象</strong>或业务对象，是App的核心。 它们代表了APP的主要功能， 它们包含业务逻辑， 他们不会与外在世界的细节进行互动。</p></li><li><p>Use case，<br>又名interactors（交互器），又名business services，是Entities的扩展，是业务逻辑的延伸，也就是说。 它们包含的逻辑不仅限于一个实体，而是处理更多的实体。</p></li></ul><h3 id="Repositories"><a href="#Repositories" class="headerlink" title="Repositories"></a>Repositories</h3><p>Repositories用于持久化Entities。 就这么简单。 它们被定义为接口并用作想要对Entities执行CRUD操作的用例的输出端口。</p><h3 id="Presenters"><a href="#Presenters" class="headerlink" title="Presenters"></a>Presenters</h3><p>如果你熟悉MVP模式，Presenters就会做你期望他们做的事情。 他们处理用户交互，调用适当的业务逻辑，并将数据发送到UI进行渲染。 这里通常有不同类型之间的映射<br>大概这几个概念可以帮助我们更好的理解clean 架构，但是核心一点就是越在洋葱里面越是抽象。</p><h2 id="3、clean-架构的核心规则"><a href="#3、clean-架构的核心规则" class="headerlink" title="3、clean 架构的核心规则"></a>3、clean 架构的核心规则</h2><p>首先需要掌握涉及的领域，原文称作“Master of your domain”，就是说当你打开你的工程，除去技术相关，你就应该从宏观上知晓你的app是做什么的，而不要沉浸到细节之中” 为啥需要我们站在这个高度去看待自己的项目呢，因为这也是clean核心所在，该架构越往洋葱里面抽象度越来越高，都是业务逻辑的高度抽象，即”内层包含业务逻辑、外层包含实现细节”</p><p>继而给出了设计出这样特性的clean架构需要具备的技术点</p><p>（1）Dependency rule（依赖原则）</p><p>（2）Abstraction（抽象）</p><p>（3）Communication between layers（层之间的通信）</p><p>下面将一一介绍</p><h3 id="3-1-Dependency-rule（依赖原则）"><a href="#3-1-Dependency-rule（依赖原则）" class="headerlink" title="3.1 Dependency rule（依赖原则）"></a>3.1 Dependency rule（依赖原则）</h3><p>从最开始的第一幅我们就可以看出箭头是”依赖”,即 外层看到并了解内层，但是内层既看不到也不知道外层，结合前面所强调的 内层包含业务逻辑（抽象），外层包含实现细节。 结合依赖关系规则，业务逻辑既看不到，也不知道实现细节。 通常我们可以通过放在不同的module中去来调整它们之间的依赖关系<br><img src="https://user-gold-cdn.xitu.io/2018/5/15/16364599d4727672?w=456&amp;h=405&amp;f=png&amp;s=64878" alt="" title="image.png"></p><h3 id="3-2-Abstraction（抽象）"><a href="#3-2-Abstraction（抽象）" class="headerlink" title="3.2 Abstraction（抽象）"></a>3.2 Abstraction（抽象）</h3><p>之前也说过当你走向图的中间时，东西变得更加抽象。 这是有道理的：抽象往往比细节更加稳定，就像搭积木一样根基越稳越好。</p><p>举个例子比如我们可以将抽象接口定义为“加载网络图片”并将其放入内层，业务逻辑就可以使用它来显示图片。 另一方面，我们可以通过实现改接口调用具体的图片加载库glide或者Picasso，然后将该实现放入外层。业务逻辑可以使用加载图片功能而无需知道实现细节的任何内容。这样抵御了变化的风险，日后换成什么方式加载图片，洋葱内部的抽象业务逻辑是不会感知到的</p><h3 id="3-3-Communication-between-layers（层之间的通信）"><a href="#3-3-Communication-between-layers（层之间的通信）" class="headerlink" title="3.3 Communication between layers（层之间的通信）"></a>3.3 Communication between layers（层之间的通信）</h3><p>既然已经划分好了层，分离了内容，将业务逻辑放在应用程序的架构中心和架构边缘的实现细节中，一切看起来都很棒。 但是你可能很快遇到了一个有趣的问题。<br>如果你的UI是一个实现细节，那么internet也是一个实现细节，业务逻辑介于两者之间，<strong>我们如何从internet获取数据，通过业务逻辑传递它，然后将其发送到屏幕？</strong><br>组合和继承的就要发挥功效了</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/15/16364599d7039681?w=665&amp;h=447&amp;f=png&amp;s=107878" alt="" title="image.png"></p><h2 id="4、实践"><a href="#4、实践" class="headerlink" title="4、实践"></a>4、实践</h2><p>下面用代码示意一下，以RSS Reader 为例我们的用户应该能够管理他们的RSS提要订阅，从提要中获取文章并阅读它们。这里是数据流问题，用例介于表示层和数据层之间。 我们如何建立层之间的沟通？ 记住那些输入和输出端口？<br><img src="https://user-gold-cdn.xitu.io/2018/5/15/16364599d7eca624?w=888&amp;h=466&amp;f=png&amp;s=49877" alt="" title="image.png"></p><p>从上图可以看出我们的 Use Case必须实现输入端口（接口）。 Presenter在 Use Case上调用方法，数据流向 Use Case（feedId）。 Use Case映射feedId提供文章并希望将它们发送回表示层。 它有一个对输出端口（回调）的引用，因为输出端口是在同一层定义的，因此它调用了一个方法。 因此，数据发送到输出端口 - Presenter。</p><p>让我们从domain层开始，创建我们的核心业务模型和逻辑。</p><p>我们的商业模式非常简单：</p><ul><li>Feed - 持有RSS提要相关数据，如网址，缩略图网址，标题和说明</li><li>Article -保存文章相关数据，如文章标题，网址和发布日期</li></ul><p>我们的逻辑，我们将使用UseCases。 他们在简洁的类中封装了小部分业务逻辑。 他们都将实施通用的UseCase 契约接口：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UseCase</span>&lt;<span class="title">P</span>, <span class="title">R</span>&gt;</span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span>&lt;<span class="title">R</span>&gt;</span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(R return)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span></span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(P parameter, Callback&lt;R&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"> callback)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CompletableUseCase</span>&lt;<span class="title">P</span>&gt;</span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span></span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(P parameter, Callback callback)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UseCase接口是输入端口，Callback接口是输出端口，GetFeedArticlesUseCase实现如下  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetFeedArticlesUseCase</span> <span class="keyword">implements</span> <span class="title">UseCase</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">Integer</span>, <span class="title">List</span>&lt;<span class="title">Article</span>&gt;&gt;</span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> FeedRepository feedRepository;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Integer feedId, <span class="keyword">final</span> Callback&lt;List&lt;Article&gt;&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"> callback)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> callback.onSuccess(feedRepository.getFeedArticles(feedId));</span><br><span class="line"> &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable throwable) &#123;</span><br><span class="line"> callback.onError(throwable);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>然后到洋葱外面的UI实现，View有一个简单的契约类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">showArticles</span><span class="params">(List&lt;ArticleViewModel&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"> feedArticles)</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">showErrorMessage</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">showLoadingIndicator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该视图的Presenter具有非常简单的显示逻辑。 它获取文章，将它们映射到view odels并传递到View，再看下FeedArticlesPresenter：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeedArticlesPresenter</span> <span class="keyword">implements</span> <span class="title">UseCase</span>.<span class="title">Callback</span>&lt;<span class="title">List</span>&lt;<span class="title">Article</span>&gt;&gt;</span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> GetFeedArticlesUseCase getFeedArticlesUseCase;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> ViewModeMapper viewModelMapper;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fetchFeedItems</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> feedId)</span> </span>&#123;</span><br><span class="line"> getFeedArticlesUseCase.execute(feedId, <span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">final</span> List&lt;Article&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"> articles)</span> </span>&#123;</span><br><span class="line"> getView().showArticles(viewModelMapper.mapArticlesToViewModels(articles));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="keyword">final</span> Throwable throwable)</span> </span>&#123;</span><br><span class="line"> getView().showErrorMessage();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>到这里可以看出FeedArticlesPresenter实现了Callback接口，并将其自身传递给use case，它实际上是use case的输出端口，并以这种方式关闭了数据流</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/15/16364599d8d3d3ff?w=892&amp;h=472&amp;f=png&amp;s=76180" alt="" title="image.png"></p><p>谷歌架构项目上也有个 <a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean/" target="_blank" rel="noopener">todo-mvp-clean</a>分支可以看下具体玩法。</p><h2 id="5、小结"><a href="#5、小结" class="headerlink" title="5、小结"></a>5、小结</h2><p>这个跟设计模式中依赖倒置和接口隔离有着密不可分的关系，通过依赖倒置，只依赖于抽象而不是细节，将细节的实现倒置到实现类中，这样洋葱的核心就是清清爽爽的业务逻辑（抽象）；</p><p>通常一个良好的架构一般需要满足以下几点：</p><ol><li>Satisfy a multitude of stakeholders.（满足各方利益者）</li><li>Encourage separation of concerns.（鼓励的关注点分离）</li><li>Run away from the real world (Android, DB, Internet…).即高度的抽象</li><li>Enable your components to be testable.（使您的组件成为可测试的）</li></ol><p>但是一个架构往往针对特定的场景，架构也是需要慢慢演进的，比如后面的模块化、插件化等等都是业务发展到一定程度，当前架构的弊端慢慢的凸显需要更新。但不管如何变化，一些核心基本点还是相伴相随，比如依赖翻转、面向接口编程、关注点分离等都是我们需要点亮的技能点之一。</p><p>##参考</p><p>1、<a href="http://five.agency/blog/android/" target="_blank" rel="noopener">http://five.agency/blog/android/</a><br>2、<a href="http://five.agency/android-architecture-part-1-every-new-beginning-is-hard/" target="_blank" rel="noopener">http://five.agency/android-architecture-part-1-every-new-beginning-is-hard/</a><br>3、<a href="http://five.agency/android-architecture-part-2-clean-architecture/" target="_blank" rel="noopener">http://five.agency/android-architecture-part-2-clean-architecture/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;1、clean架构简介&quot;&gt;&lt;a href=&quot;#1、clean架构简介&quot; class=&quot;headerlink&quot; title=&quot;1、clean架构简介&quot;&gt;&lt;/a&gt;1、c
      
    
    </summary>
    
      <category term="架构" scheme="https://xsfelvis.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="clean" scheme="https://xsfelvis.github.io/tags/clean/"/>
    
  </entry>
  
  <entry>
    <title>几个权限库分析</title>
    <link href="https://xsfelvis.github.io/2018/04/21/%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%902%20%E5%87%A0%E4%B8%AA%E6%9D%83%E9%99%90%E5%BA%93%E5%88%86%E6%9E%90/"/>
    <id>https://xsfelvis.github.io/2018/04/21/动态权限2 几个权限库分析/</id>
    <published>2018-04-20T16:00:00.000Z</published>
    <updated>2018-06-06T06:36:28.745Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>权限系列</p><ul><li><a href="https://xsfelvis.github.io/2018/04/06/%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%901/">动态权限基础</a></li><li><a href="https://xsfelvis.github.io/2018/04/21/%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%902%20%E5%87%A0%E4%B8%AA%E6%9D%83%E9%99%90%E5%BA%93%E5%88%86%E6%9E%90/">几个权限库分析</a></li></ul><p>有比较多的权限库,由浅入深先看简单的开开胃</p><h2 id="1、PermissionGen"><a href="#1、PermissionGen" class="headerlink" title="1、PermissionGen"></a>1、PermissionGen</h2><p><a href="https://github.com/lovedise/PermissionGen" target="_blank" rel="noopener">PermissionGen</a>  </p><p>该库比较早 看提交是3年前了 通过看该库的readme可以了解这个库的使用方式，通过链式调用比较易于配置</p><p>核心类图如下：<br><img src="https://user-gold-cdn.xitu.io/2018/5/15/16364446c046e010" alt="" title="image.png"></p><p>将权限涉及到核心api封装到框架之中，干掉冗余函数，使用者只关心功能函数即可。</p><p>涉及到的比较核心的一个点就是，<code>通过注解的方式直接回调权限成功、失败的函数</code></p><p>When it succeeded in obtaining permission</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PermissionSuccess</span>(requestCode = <span class="number">100</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">Toast.makeText(<span class="keyword">this</span>, <span class="string">"Contact permission is granted"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When it failed in obtaining permission</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PermissionFail</span>(requestCode = <span class="number">100</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFailSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">Toast.makeText(<span class="keyword">this</span>, <span class="string">"Contact permission is not granted"</span>, t.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心的处理逻辑在<code>PermissionGen\#requestPermissions\(Object object, int requestCode, String\[\] permissions\)</code>中，最终通过反射调取 PermissionFail和PermissionSucess注解的函数</p><p>通过这种方式干掉了冗余代码，让用户专注于业务的开发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">requestPermissions</span><span class="params">(Object object, <span class="keyword">int</span> requestCode, String[] permissions)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!Utils.isOverMarshmallow()) &#123;</span><br><span class="line">      doExecuteSuccess(object, requestCode);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; deniedPermissions = Utils.findDeniedPermissions(getActivity(object), permissions);</span><br><span class="line">    <span class="keyword">if</span>(deniedPermissions.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(object <span class="keyword">instanceof</span> Activity)&#123;</span><br><span class="line">        ((Activity)object).requestPermissions(deniedPermissions.toArray(<span class="keyword">new</span> String[deniedPermissions.size()]), requestCode);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(object <span class="keyword">instanceof</span> Fragment)&#123;</span><br><span class="line">        ((Fragment)object).requestPermissions(deniedPermissions.toArray(<span class="keyword">new</span> String[deniedPermissions.size()]), requestCode);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(object.getClass().getName() + <span class="string">" is not supported"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      doExecuteSuccess(object, requestCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executeMethod</span><span class="params">(Object activity, Method executeMethod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(executeMethod != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!executeMethod.isAccessible()) executeMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        executeMethod.invoke(activity, <span class="keyword">null</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出反射函数只能无参函数 其中拿到activity或者fragment的注解方法在Utils的方法中，这里可以学习一下反射的一些用法，比如查找对应注解的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;A extends Annotation&gt; <span class="function">Method <span class="title">findMethodWithRequestCode</span><span class="params">(Class clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;A&gt; annotation, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Method method : clazz.getDeclaredMethods())&#123;</span><br><span class="line">      <span class="keyword">if</span>(method.isAnnotationPresent(annotation))&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEqualRequestCodeFromAnntation(method, annotation, requestCode))&#123;</span><br><span class="line">          <span class="keyword">return</span> method;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>###小结：</p><p>这个库比较简单有一些优缺点：<br>优点：初步封装了权限的核心函数的，省去了冗余代码；可以学习反射的一些用法</p><p>缺点：</p><p>（1）大量使用反射（可以使用apt），</p><p>（2）api设计不是很合理</p><p> 链式调用往往是平级调用方法，但是现在这个明显是有先后顺序的，一不留神容易写错</p><h2 id="2、MPermissions"><a href="#2、MPermissions" class="headerlink" title="2、MPermissions"></a>2、MPermissions</h2><p><a href="https://github.com/hongyangAndroid/MPermissions" target="_blank" rel="noopener">MPermissions</a></p><p>这个是鸿洋在PermissionGen基础上做了一些优化，作者说是使用apt解决了运行时反射的问题，优化了对外提供的api，因为申请只需要三个参数，抛弃了使用原本类库的单例的方式，直接一个几个静态方法，简单整洁暴力。</p><p>看了一下代码，主要是核心类MPermissions操作接口，间接操作实现该接口的APT生成类(依赖翻转，面向接口编程)</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/15/16364446c11d972d" alt="" title="image.png"></p><p>可以学习的一些点：</p><h4 id="2-1-APT-编译前找不到类"><a href="#2-1-APT-编译前找不到类" class="headerlink" title="2.1 APT 编译前找不到类"></a>2.1 APT 编译前找不到类</h4><p>面向接口编程，APT代码生成代码实现这个接口就可以，</p><p>权限类的核心能力通过接口提供</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PermissionProxy</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">grant</span><span class="params">(T source, <span class="keyword">int</span> requestCode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">denied</span><span class="params">(T source, <span class="keyword">int</span> requestCode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rationale</span><span class="params">(T source, <span class="keyword">int</span> requestCode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">needShowRationale</span><span class="params">(<span class="keyword">int</span> requestCode)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>功能类跟接口层交互即可</p><h4 id="2-2-APT技术"><a href="#2-2-APT技术" class="headerlink" title="2.2 APT技术"></a>2.2 APT技术</h4><p>通过APT生成一些重复的模板代码非常有用，关于APT技术在之前的博客多有提及就不再赘述了。<br>不过APT也有它的弊端就是APT 的工作原理是在编译 class 时，通过 Annotation 生成源代码，而在 Android 构建的过程中，像 滴滴出行乘客端 这样的集成方式，所有的模块都是 AAR 的方式来集成构建的，没有机会去同时编译所有的 class，这时候就需要新的手段来生成代码了，比如构建gradle的task在编译前扫描全局结合javapoet生成代码，在这个库里可以学习一下apt processor的异常处理有助于我们定位代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void error(Element element, String message, Object... args) &#123;</span><br><span class="line">    if (args.length &gt; 0) &#123;</span><br><span class="line">        message = String.format(message, args);</span><br><span class="line">    &#125;</span><br><span class="line">    processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, message, element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###小结</p><p>作者仅仅是通过APT生成了模板代码，但是还是使用到反射生成实现代理接口的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> PermissionProxy <span class="title">findPermissionProxy</span><span class="params">(Object activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class clazz = activity.getClass();</span><br><span class="line">        Class injectorClazz = Class.forName(clazz.getName() + SUFFIX);</span><br><span class="line">        <span class="keyword">return</span> (PermissionProxy) injectorClazz.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(String.format(<span class="string">"can not find %s , something when compiler."</span>, activity.getClass().getSimpleName() + SUFFIX));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个APT代理的思想还是值得我们去借鉴的</p><h2 id="3、PermissionsDispatcher"><a href="#3、PermissionsDispatcher" class="headerlink" title="3、PermissionsDispatcher"></a>3、PermissionsDispatcher</h2><p>这个库目前有7726个start，而且有自己的<a href="https://permissions-dispatcher.github.io/PermissionsDispatcher/" target="_blank" rel="noopener">网站</a>指导说明，俨然是动态权限三方库的一哥，看来这个库需要好好分析一下</p><p>从官方这个库使用起来也非常简单，仔细看了下代码发现大同小异，跟前面两个库使用的方式很像，通过注解的方式标记 权限申请成功、权限事情失败、权限弹窗说明等函数调用，唯一多的是：</p><p>1、需要使用动态权的 <code>Activity</code> or <code>Fragment</code>(we support both) to handle permissions加上RuntimePermissions注解</p><p>这个库更多是将所有的逻辑处理放在了权限生成类 xxxPermissionDispatcher类，（生成代码承担了很多的逻辑处理）而不像MPermission库中仅仅将用户使用的功能代码，比如权限成功、失败之类的函数规整到生成类中，核心逻辑还是通过开发者自己代码处理，这样更容易写这个库，用户阅读代码也比较方便</p><p>个人更加倾向于 MPermission</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;权限系列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://xsfelvis.github.io/2018/04/06/%E5%8A%A8%E6%80%81%E6%
      
    
    </summary>
    
      <category term="开源学习" scheme="https://xsfelvis.github.io/categories/%E5%BC%80%E6%BA%90%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="权限" scheme="https://xsfelvis.github.io/tags/%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>动态权限</title>
    <link href="https://xsfelvis.github.io/2018/04/06/%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%901/"/>
    <id>https://xsfelvis.github.io/2018/04/06/动态权限1/</id>
    <published>2018-04-05T16:00:00.000Z</published>
    <updated>2018-06-05T09:53:56.166Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>权限系列</p><ul><li><a href="https://xsfelvis.github.io/2018/04/06/%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%901/">动态权限基础</a></li><li><a href="https://xsfelvis.github.io/2018/04/21/%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%902%20%E5%87%A0%E4%B8%AA%E6%9D%83%E9%99%90%E5%BA%93%E5%88%86%E6%9E%90/">几个权限库分析</a></li></ul><h2 id="1、在给app升级动态权限之前需要注意搞清楚一下几个概念"><a href="#1、在给app升级动态权限之前需要注意搞清楚一下几个概念" class="headerlink" title="1、在给app升级动态权限之前需要注意搞清楚一下几个概念"></a>1、在给app升级动态权限之前需要注意搞清楚一下几个概念</h2><h3 id="1-1、版本号对应的api等级"><a href="#1-1、版本号对应的api等级" class="headerlink" title="1.1、版本号对应的api等级"></a>1.1、版本号对应的api等级</h3><p>查阅官网可以看出</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/15/16364387f6eeb9fc?w=1714&amp;h=1262&amp;f=png&amp;s=192923" alt=""></p><h3 id="1-2、minSdkVersion、targetSdkVersion和-compileSdkVersion"><a href="#1-2、minSdkVersion、targetSdkVersion和-compileSdkVersion" class="headerlink" title="1.2、minSdkVersion、targetSdkVersion和 compileSdkVersion"></a>1.2、minSdkVersion、targetSdkVersion和 compileSdkVersion</h3><p>这几个属性通常在gradle defaultConfig中去配置，作用如下</p><p>（1）minSdkVersion<br>指明应用程序运行所需的最小API level，如果系统的API level低于minSdkVersion设定的值，那么android系统会阻止用户安装这个应用，如果不指明的话，默认是1，如果指明这个属性，并在项目中使用了改与这个API level的API的话，那么将会在编译时报错。<br>可见该属性不仅在程序安装时起作用，而且会在项目构建时起作用</p><p>（2）targetSdkVersion</p><p>指明应用程序目标API level的一个整数，如果不设置就默认和minSdkVersion相同。这个属性通知系统，已经针对这个目标版本测试过程序，系统不必使用兼容模式来让你的应用程序向前兼容这个目标版本。<br>如果targetSdkVersion为19（对应为Android4.4），应用运行时，最高只能使用API 19的新特性。即使代码中使用了API 23的新特性，实际运行时，也不会使用该新特性；<br>可见targetSdkVersion这个属性是在程序运行时期起作用的，系统根据这个属性决定要不要以兼容模式运行这个程序<br>例如，Android6.0系统增加了动态权限机制，如果为了追时髦，盲目把你的targetSDKVersion设置为23(6.0)，那么在需要使用权限的地方将会出现异常。为此，在你做好动态权限申请之前，为保障APP正常运行，你需要将目标版本设置低于23。</p><p>（3）complieSdkVersion</p><p>compileSdkVersion仅仅是告诉Gradle使用哪个版本的SDK编译应用，不会被包含到apk中，完全不影响应用的运行结果；虽然没有影响但是</p><p>即 ：compileSDKVersion是和编译器打交道的，而minSDKVersion和targetSDKVersion是和系统打交道的。</p><h2 id="2、如何升级app的动态权限"><a href="#2、如何升级app的动态权限" class="headerlink" title="2、如何升级app的动态权限"></a>2、如何升级app的动态权限</h2><p>首先需要了解动态权限这个概念</p><h3 id="2-1-动态权限"><a href="#2-1-动态权限" class="headerlink" title="2.1 动态权限"></a>2.1 动态权限</h3><p>这个是在android 6.0提出的，从该版本开始，用户实在运行时而不是应用安装时授予或者撤销应用权限，对应API23,这个版本最重要的变化就是权限动态管理，任何未被授予权限的逻辑都可能引起后续运行的崩溃，可以通过adb 工具从命令行获取权限</p><p>按组列出权限和状态： </p><blockquote><p>$ adb shell pm list permissions -d -g</p></blockquote><p>授予或撤销一项或多项权限：</p><blockquote><p>$ adb shell pm [grant|revoke] <permission-name> …</permission-name></p></blockquote><p>6.0之前的权限在AndroidMenifest声明之后即可获取所有权限，这样会造成用户会默默忍受一些不必要的权限，特别是通讯录，位置短信之类的比较敏感的权限，在6.0之后我们只有在需要权限的时候才会向用户请求，用户可以选择拒绝，新的机制较好的保护的用户的隐私。<br>谷歌将权限分为两大类<br>Normal Permissions<br>这类权限一般不涉及用户隐私是不需要用户进行授权的，比如网络访问、蓝牙（详细权限见附录）<br>Dangenerous Permission<br>这类涉及到用户隐私，需要用户进行授权，比如读取sdcard、开启照相机、访问通讯录等，其中危险权限是分组的，用户之前如果已经选择通过该组某个危险权限，主要有以下几组（详细权限见附录）</p><ol><li>身体传感器</li><li>日历 摄像头</li><li>通讯录</li><li>地理位置</li><li>麦克风</li><li>电话</li><li>短信</li><li>存储空间  </li></ol><h3 id="2-2-权限相关API"><a href="#2-2-权限相关API" class="headerlink" title="2.2 权限相关API"></a>2.2 权限相关API</h3><p>为了方便开发者实现权限管理，谷歌给出下面4个API</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/15/1636438febbcbeb9?w=894&amp;h=494&amp;f=png&amp;s=66186" alt=""></p><p>一般权限检查需要以下三个步骤配合</p><p>1、检查权限是否授予</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Activity.java</span><br><span class="line">&gt; public int checkSelfPermission(permission)</span><br></pre></td></tr></table></figure><p>这个是在ContextCompat类中用来判断是否app已经获取到某一个权限的使用权。如果返回android.content.pm.PackageManager#PERMISSION_GRANTED，则说明app被授予权限，如果返回android.content.pm.PackageManager#PERMISSION_DENIED 则说明权限被禁止授予</p><p>2、申请权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Activity.java</span><br><span class="line">public final void requestPermissions( new String[permission1,permission2,...], requestCode)</span><br></pre></td></tr></table></figure><p>这个是在ActivityCompat类以及FragmentCompat类中用来申请权限的方法</p><p>3、权限回调<br>用户在系统弹窗里面选择以后结果会通过Activity的onRequestPermissionsResult<br>方法回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults)</span><br><span class="line">&#123;</span><br><span class="line">    //继续执行逻辑或者提示权限获取失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些方法可以封装在BaseActvity中</p><p>4、是否显示权限对话框<br>这个是作为辅助类</p><blockquote><p>public static boolean shouldShowRequestPermissionRationale(@NonNull Activity activity, @NonNull String permission)<br>这个是在ActivityCompat类以及FragmentCompat类中用来判断是否显示权限询问对话框。在权限申请的过程中，如果用户选择允许权限使用或者在拒绝的同时又勾选了不再询问对话框，这2种情况下该api就会返回false，表示不再弹出权限询问对话框，其中授权弹窗是不支持自定义的</p></blockquote><p>这个辅助函数十分重要，当动态权限申请时候如果用户如果用户勾选了“不再询问”，那么在执行requestPermissions( )后，onRequestPermissionsResult( )会永远返回PERMISSION_DENIED，这样应用原本的操作将永远无法执行，这是我们不希望看到的</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/15/163643a25ce67cd9?w=1010&amp;h=766&amp;f=png&amp;s=122723" alt=""><br>谷歌还是给我们留了一手，就是<br>shouldShowRequestPermissionRationale，如果返回true，应用应该弹出dialog说明申请权限的缘由比如下面这种</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/15/163643a66ad3eb69?w=1100&amp;h=522&amp;f=png&amp;s=49564" alt=""></p><p>其中第一次申请权限时候该函数默认返回false，无需告知用户申请该权限的理由;当第一次申请被拒绝，再次申请时该函数会返回true，并且弹出的系统dialog上会有一个选择“不再询问”，要是用户勾选了该选项，则以后该函数一直会返回false。</p><h3 id="2-3-如何适配"><a href="#2-3-如何适配" class="headerlink" title="2.3 如何适配"></a>2.3 如何适配</h3><p>如果项目的targetSdkVersion &lt; 23 运行在android 6.0及以上的系统上，会默认给与AndroidManifest.xml中申请的权限，是不是这样就万事大吉了呢？显然是想多了，如果用户在应用的权限页面手动回收权限，将会导致应用crash</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/15/163643b31c161434?w=1064&amp;h=1200&amp;f=png&amp;s=235446" alt=""></p><p>虽然系统提醒了用户，但是还是要取决用户心情，因此稳妥的适配动态还是有必要的事情。</p><p>首先targetSdkVersion小于23的应用默认授予了所申请的所有权限，所以如果你以前的APP设置的targetSdkVersion低于23，也能正常使用。等于或者大于23，则必须 request permission,否则会崩溃闪退。<br>下面将大致阐述一下升级动态权限步骤</p><p>（1）声明目标版本sdk<br>修改build.gradle中targetSdkVersion为23以上</p><p>（2）检查权限申请地方并request权限<br>在我们需要使用到权限的地方，检查是否已经拥有权限，比如读写外置SD卡权限，我们在写入之前检车是否有权限，没有权限则申请权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void requestContactPermission() &#123;</span><br><span class="line">        if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_CONTACTS)</span><br><span class="line">                != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            //申请 WRITE_CONTACTS 权限</span><br><span class="line">            ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.WRITE_CONTACTS&#125;,</span><br><span class="line">                    REQUEST_CODE_WRITE_CONTACTS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"> ```  </span><br><span class="line"></span><br><span class="line">（3）响应用户权限回调</span><br><span class="line"></span><br><span class="line">用户可以选择allow或者deny，可能deny。回调onRequestPermissionsResult方法, 该方法类似于onActivityResult。如果是fragment，最好是使用父fragment，但不是使用ActivityCompat。建议使用getParentFragment().requestPermissions方法。  </span><br><span class="line"></span><br><span class="line">（4）根据requestCode和grandResult（授权结果）做相应处理</span><br></pre></td></tr></table></figure><p>private void handleGrantResults(int requestCode, int[] grantResults) {<br>      if (requestCode == WRITE_EXTERNAL_STORAGE_REQUEST_CODE) {<br>          if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {<br>              // Permission Granted 获得权限后执行xxx<br>          } else {<br>              // Permission Denied 拒绝后xx的操作。<br>          }<br>      }<br>  }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 3、后话</span><br><span class="line"></span><br><span class="line">### 3.1、权限申请如果用户拒绝怎么处理</span><br><span class="line">如果用户拒绝了核心权限一次，下次再次申请会出现不再提醒的选项，要是选择不再提醒，核心权限不给获取一些功能就无法使用，你可以选择直接退出应用，或者可以优雅点，我们自己检测一下是否拒绝了两次或者以上，自己给个提示向用户做一个交互</span><br></pre></td></tr></table></figure></p><p>private void handleContactPermission() {<br>        if (Integer.parseInt(Build.VERSION.SDK)&gt;=23) {<br>            int hasWriteContactsPermission = checkSelfPermission(Manifest.permission.WRITE_CONTACTS);<br>            if (hasWriteContactsPermission != PackageManager.PERMISSION_GRANTED) {<br>                if (!shouldShowRequestPermissionRationale(Manifest.permission.WRITE_CONTACTS)) {<br>                    showMessageOKCancel(“You need to allow access to Contacts”,<br>                            new DialogInterface.OnClickListener() {<br>                                @Override<br>                                public void onClick(DialogInterface dialog, int which) {<br>                                    requestContactPermission();//确定后申请权限。<br>                                }<br>                            });<br>                    return;<br>                }<br>                requestContactPermission();//没有权限的话，申请。<br>            }<br>        }<br>```<br>或者记录用户勾选了不再询问<br>Google提供了一个非常好的思路，详见EasyPermissions .<br>EasyPermissions并没有存储上一次shouldShowRequestPermissionRationale( )的返回值，而是在申请权限被拒后调用shouldShowRequestPermissionRationale( )方法，如果此时返回false则说明用户勾选了“不再询问”。</p><p>两种方式都可以作为参考方式。</p><h3 id="3-2-取消支持Apache-http-客户端"><a href="#3-2-取消支持Apache-http-客户端" class="headerlink" title="3.2 取消支持Apache http 客户端"></a>3.2 取消支持Apache http 客户端</h3><p>Android 6.0 版移除了对 Apache HTTP 客户端的支持。如果您的应用使用该客户端，并以 Android 2.3（API 级别 9）或更高版本为目标平台，请改用HttpURLConnection 类。此 API 效率更高，因为它可以通过透明压缩和响应缓存减少网络使用，并可最大限度降低耗电量。要继续使用 Apache HTTP API，您必须先在 build.gradle 文件中声明以下编译时依赖项：<br>  android {<br>      useLibrary ‘org.apache.http.legacy’<br>  }</p><h3 id="3-3-升级到7-0-api-24及以上"><a href="#3-3-升级到7-0-api-24及以上" class="headerlink" title="3.3 升级到7.0 api 24及以上"></a>3.3 升级到7.0 api 24及以上</h3><p>对于面向 Android 7.0 的应用，Android 框架执行的 StrictMode API 政策禁止在您的应用外部公开 file:// URI。如果一项包含文件 URI 的 intent 离开您的应用，则应用出现故障，并出现 FileUriExposedException 异常，常见的是访问升级下载到内部sd卡，访问手机相册等。<br>网上有很多解决方案</p><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote><p>Normal Permissions</p></blockquote><p>ACCESS_LOCATION_EXTRA_COMMANDS</p><p>ACCESS_NETWORK_STATE</p><p>ACCESS_NOTIFICATION_POLICY</p><p>ACCESS_WIFI_STATE</p><p>BLUETOOTH</p><p>BLUETOOTH_ADMIN</p><p>BROADCAST_STICKY</p><p>CHANGE_NETWORK_STATE</p><p>CHANGE_WIFI_MULTICAST_STATE</p><p>CHANGE_WIFI_STATE</p><p>DISABLE_KEYGUARD</p><p>EXPAND_STATUS_BAR</p><p>GET_PACKAGE_SIZE</p><p>INSTALL_SHORTCUT</p><p>INTERNET</p><p>KILL_BACKGROUND_PROCESSES</p><p>MODIFY_AUDIO_SETTINGS</p><p>NFC</p><p>READ_SYNC_SETTINGS</p><p>READ_SYNC_STATS</p><p>RECEIVE_BOOT_COMPLETED</p><p>REORDER_TASKS</p><p>REQUEST_INSTALL_PACKAGES</p><p>SET_ALARM</p><p>SET_TIME_ZONE</p><p>SET_WALLPAPER</p><p>SET_WALLPAPER_HINTS</p><p>TRANSMIT_IR</p><p>UNINSTALL_SHORTCUT</p><p>USE_FINGERPRINT</p><p>VIBRATE</p><p>WAKE_LOCK</p><p>WRITE_SYNC_SETTINGS</p><blockquote><p>Dangenerous Permission</p></blockquote><p>group:android.permission-group.CONTACTS<br>  permission:android.permission.WRITE_CONTACTS<br>  permission:android.permission.GET_ACCOUNTS<br>  permission:android.permission.READ_CONTACTS</p><p>group:android.permission-group.PHONE<br>  permission:android.permission.READ_CALL_LOG<br>  permission:android.permission.READ_PHONE_STATE<br>  permission:android.permission.CALL_PHONE<br>  permission:android.permission.WRITE_CALL_LOG<br>  permission:android.permission.USE_SIP<br>  permission:android.permission.PROCESS_OUTGOING_CALLS<br>  permission:com.android.voicemail.permission.ADD_VOICEMAIL</p><p>group:android.permission-group.CALENDAR<br>  permission:android.permission.READ_CALENDAR<br>  permission:android.permission.WRITE_CALENDAR</p><p>group:android.permission-group.CAMERA<br>  permission:android.permission.CAMERA</p><p>group:android.permission-group.SENSORS<br>  permission:android.permission.BODY_SENSORS</p><p>group:android.permission-group.LOCATION<br>  permission:android.permission.ACCESS_FINE_LOCATION<br>  permission:android.permission.ACCESS_COARSE_LOCATION</p><p>group:android.permission-group.STORAGE<br>  permission:android.permission.READ_EXTERNAL_STORAGE<br>  permission:android.permission.WRITE_EXTERNAL_STORAGE</p><p>group:android.permission-group.MICROPHONE<br>  permission:android.permission.RECORD_AUDIO</p><p>group:android.permission-group.SMS<br>  permission:android.permission.READ_SMS<br>  permission:android.permission.RECEIVE_WAP_PUSH<br>  permission:android.permission.RECEIVE_MMS<br>  permission:android.permission.RECEIVE_SMS<br>  permission:android.permission.SEND_SMS<br>  permission:android.permission.READ_CELL_BROADCASTS</p><p>###参考链接</p><ul><li>1、<a href="https://source.android.com/source/build-numbers" target="_blank" rel="noopener">https://source.android.com/source/build-numbers</a> </li><li>2、<a href="https://www.jianshu.com/p/06e55a322f6f" target="_blank" rel="noopener">https://www.jianshu.com/p/06e55a322f6f</a></li><li>3、<a href="https://developer.android.com/about/versions/marshmallow/android-6.0-changes?hl=zh-cn" target="_blank" rel="noopener">Android 6.0变更</a></li><li>4、<a href="https://developer.android.com/about/versions/marshmallow/android-6.0-changes?hl=zh-cn#behavior-runtime-permissions" target="_blank" rel="noopener">运行时权限</a> </li><li>5、<a href="developer.android.com/intl/zh-cn/training/permissions/best-practices.html#testing">Permissions Best Practices</a></li><li>6、<a href="developer.android.com/intl/zh-cn/training/permissions/index.html">Working with System Permissions</a></li><li>7、<a href="https://blog.csdn.net/andrexpert/article/details/53331836" target="_blank" rel="noopener">探讨Android 6.0及以上新权限系统的检测与处理</a></li><li>8、<a href="https://mp.weixin.qq.com/s/ye7RTgPuIbBS4RCH-jDWAA" target="_blank" rel="noopener">Android 权限机制与适配经验</a></li><li>9、<a href="https://blog.csdn.net/dzsw0117/article/details/51212612" target="_blank" rel="noopener">Android 6.0权限管理，sdk&gt;=23请求权限</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;权限系列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://xsfelvis.github.io/2018/04/06/%E5%8A%A8%E6%80%81%E6%
      
    
    </summary>
    
      <category term="Android" scheme="https://xsfelvis.github.io/categories/Android/"/>
    
    
      <category term="权限" scheme="https://xsfelvis.github.io/tags/%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>service</title>
    <link href="https://xsfelvis.github.io/2017/10/31/Service/"/>
    <id>https://xsfelvis.github.io/2017/10/31/Service/</id>
    <published>2017-10-30T16:00:00.000Z</published>
    <updated>2018-06-06T06:38:15.719Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="service"><a href="#service" class="headerlink" title="service"></a>service</h1><p>本篇博文主要介绍Service相关知识，具体目录如下</p><p><img src="https://i.imgur.com/RjNWNs2.png" alt=""></p><h2 id="0x00-什么是Service"><a href="#0x00-什么是Service" class="headerlink" title="0x00 什么是Service"></a>0x00 什么是Service</h2><ul><li>Service是一个应用程序组件，可以在后台长时间运行的操作，不提供用户界面；</li><li>一个应用程序可以启动一个服务，它将继续在后台运行，即使用户切换到另外一个应用</li><li>一个组件可以绑定到一个服务与它交互，甚至执行进程间通信(IPC)，如处理网络传输、音乐播放、执行文件I/O，与content provider进行交互等。</li></ul><h2 id="0x01-服务的分类"><a href="#0x01-服务的分类" class="headerlink" title="0x01 服务的分类"></a>0x01 服务的分类</h2><ul><li><p>按照运行地点分类</p><p>|           类别           |         区别         |                                                                                                        优点                                                                                                       | 缺点                                                                  | 应用                                             |<br>|:————————:|:——————–:|:—————————————————————————————————————————————————————————————————————–:|———————————————————————–|————————————————–|<br>| 本地服务(Local Service)  | 该服务依附在主进程上 | 服务依附在主进程上而不是独立的进程，这样在一定程度上节约了资源，另外Local服务因为是在同一进程因此不需要IPC，也不需要AIDL。相应bindService会方便很多。                                                             | 主进程被Kill后，服务便会终止。                                        | 如：音乐播放器播放等不需要常驻的服务。           |<br>| 远程服务(Remote Service) | 该服务是独立的进程   | 服务为独立的进程，对应进程名格式为所在包名加上你指定的android:process字符串。由于是独立的进程，因此在Activity所在进程被Kill的时候，该服务依然在运行，不受其他进程影响，有利于为多个进程提供服务具有较高的灵活性。 | 该服务是独立的进程，会占用一定资源，并且使用AIDL进行IPC稍微麻烦一点。 | 一些提供系统服务的Service，这种Service是常驻的。 |</p></li></ul><ul><li>按运行类型分类</li></ul><table><thead><tr><th style="text-align:center">类别</th><th style="text-align:center">区别</th><th>应用</th></tr></thead><tbody><tr><td style="text-align:center">前台服务</td><td style="text-align:center">会在通知栏显示onGoing的 Notification</td><td>当服务被终止的时候，通知一栏的 Notification 也会消失，这样对于用户有一定的通知作用。常见的如音乐播放服务。</td></tr><tr><td style="text-align:center">后台服务</td><td style="text-align:center">默认的服务即为后台服务，即不会在通知一栏显示 onGoing的 Notification。</td><td>当服务被终止的时候，用户是看不到效果的。某些不需要运行或终止提示的服务，如天气更新，日期同步，邮件同步等。</td></tr></tbody></table><ul><li>按使用方式分类</li></ul><table><thead><tr><th style="text-align:center">类别</th><th style="text-align:center">区别</th></tr></thead><tbody><tr><td style="text-align:center">startService启动的服务</td><td style="text-align:center">主要用于启动一个服务执行后台任务，不进行通信。停止服务使用stopService。</td></tr><tr><td style="text-align:center">bindService启动的服务</td><td style="text-align:center">方法启动的服务要进行通信。停止服务使用unbindService。</td></tr><tr><td style="text-align:center">同时使用startService、bindService 启动的服务</td><td style="text-align:center">停止服务应同时使用stopService与unbindService。</td></tr></tbody></table><h2 id="0x02-生命周期"><a href="#0x02-生命周期" class="headerlink" title="0x02 生命周期"></a>0x02 生命周期</h2><p>如使用方式分类所提，service使用常分为两大类，start、bind</p><ul><li><p>如果一个应用程序组件（比如一个activity）通过调用startService()来启动服务，则该服务就是被“started”了。一旦被启动，服务就能在后台一直运行下去，即使启动它的组件已经被销毁了。<br>通常，started的服务执行单一的操作并且不会向调用者返回结果。比如，它可以通过网络下载或上传文件。当操作完成后，服务应该自行终止。</p></li><li><p>如果一个应用程序组件通过调用bindService()绑定到服务上，则该服务就是被“bound”了。bound服务提供了一个客户端/服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至可以利用进程间通信（IPC）跨进程执行这些操作。绑定服务的生存期和被绑定的应用程序组件一致。<br>多个组件可以同时与一个服务绑定，不过所有的组件解除绑定后，服务也就会被销毁。</p></li></ul><p>二者的生命周期如下：</p><p><img src="https://i.imgur.com/36H22oh.png" alt=""></p><p>对应的方法解释如下：</p><ul><li>4个手动调用的方法</li></ul><table><thead><tr><th style="text-align:center">手动调用方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">startService()</td><td style="text-align:center">启动服务</td></tr><tr><td style="text-align:center">stopService()</td><td style="text-align:center">关闭服务</td></tr><tr><td style="text-align:center">stopSelf()</td><td style="text-align:center">关闭服务</td></tr><tr><td style="text-align:center">bindService()</td><td style="text-align:center">绑定服务</td></tr><tr><td style="text-align:center">unbindService()</td><td style="text-align:center">解绑服务</td></tr></tbody></table><ul><li>5个内部调用的方法</li></ul><table><thead><tr><th style="text-align:center">内部调用的方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">onCreat()</td><td style="text-align:center">创建服务</td></tr><tr><td style="text-align:center">onStartCommand()</td><td style="text-align:center">开始服务</td></tr><tr><td style="text-align:center">onDestroy()</td><td style="text-align:center">销毁服务</td></tr><tr><td style="text-align:center">onBind()</td><td style="text-align:center">绑定服务</td></tr><tr><td style="text-align:center">onUnbind()</td><td style="text-align:center">解绑服务</td></tr></tbody></table><p>其中需要注意以下几点：</p><ul><li>startService()和stopService()只能开启和关闭Service，无法操作Service；bindService()和unbindService()可以操作Service</li><li>startService开启的Service，调用者退出后Service仍然存在；BindService开启的Service，调用者退出后，Service随着调用者销毁。</li></ul><h2 id="0x03-如何使用"><a href="#0x03-如何使用" class="headerlink" title="0x03 如何使用"></a>0x03 如何使用</h2><p>建议参照demo学习<a href="https://github.com/xsfelvis/ServiceAIDLStudyDemo.git" target="_blank" rel="noopener">https://github.com/xsfelvis/ServiceAIDLStudyDemo.git</a></p><p><img src="https://i.imgur.com/YrN3X1w.png" alt=""></p><p><strong>本地Service(startService)</strong></p><p>通过start启动的service一旦被启动，服务一般会在后台一直运行即使启动它的的组件已经销毁了，而且<code>不会像调用者返回结果</code>，如可以通过它进行网络下载或者上传文件，当操作完成后，该服务自行终止。</p><blockquote><p>Step 1 在AndroidManifest中注册Service</p></blockquote><p>其中一些相关属性需要重点说明下：</p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">说明</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:center">android:name</td><td style="text-align:center">Service的类名</td><td></td></tr><tr><td style="text-align:center">android:label</td><td style="text-align:center">Service的名字</td><td>若不设置默认为Service类名</td></tr><tr><td style="text-align:center">android:icon</td><td style="text-align:center">Service的图标</td><td></td></tr><tr><td style="text-align:center">android:permission</td><td style="text-align:center">申明此Service的权限</td><td>有提供了该权限的应用才能控制或连接此服务</td></tr><tr><td style="text-align:center">android:process</td><td style="text-align:center">表示该服务是否在另一个进程中运行（远程服务)</td><td>不设置默认为本地服务；remote则设置成远程服务</td></tr><tr><td style="text-align:center">android:enabled</td><td style="text-align:center">系统默认启动</td><td>true：Service 将会默认被系统启动；不设置则默认为false</td></tr><tr><td style="text-align:center">android:exported</td><td style="text-align:center">该服务是否能够被其他应用程序所控制或连接</td><td>不设置默认此项为 false</td></tr></tbody></table><blockquote><p>step 2 新建子类继承自Service类</p></blockquote><p>需要重写onCreate()、onStartCommand()、onDestroy()和onBind()方法</p><blockquote><p>step 3 构建用于启动Service的intent对象</p><p>step 4 调用startService启动，调用stopService/stopSelf停止服务</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里配置一些信息</span></span><br><span class="line">    <span class="comment">//启动运行服务的线程。</span></span><br><span class="line">    <span class="comment">//请记住我们要创建一个单独的线程，因为服务通常运行于进程的主线程中，可我们不想阻塞主线程。</span></span><br><span class="line">    <span class="comment">//我们还要赋予它后台运行的优先级，以便计算密集的工作不会干扰我们的UI。</span></span><br><span class="line">    HandlerThread handlerThread = <span class="keyword">new</span> HandlerThread(TAG);</span><br><span class="line">    handlerThread.start();</span><br><span class="line">    <span class="comment">//获取handlerThread的loop队列并用于Handler</span></span><br><span class="line">    mServiceLooper = handlerThread.getLooper();</span><br><span class="line">    mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</span><br><span class="line">    Log.d(TAG, <span class="string">"onCreate"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    msgStr = intent.getStringExtra(<span class="string">"startService"</span>);</span><br><span class="line">    Log.d(TAG, <span class="string">"onStartCommand getExtraString = "</span> + msgStr);</span><br><span class="line">    <span class="comment">//对于每一个启动请求，都发送一个消息来启动一个处理</span></span><br><span class="line">    <span class="comment">//同时传入启动ID，以便任务完成后我们知道该终止哪一个请求。</span></span><br><span class="line">    Message message = mServiceHandler.obtainMessage();</span><br><span class="line">    message.arg1 = <span class="number">1</span>;</span><br><span class="line">    mServiceHandler.sendMessage(message);</span><br><span class="line">    <span class="comment">//如果我们被杀死了，那从这里返回之后被重启</span></span><br><span class="line">    <span class="keyword">return</span> START_STICKY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Service也是运行在主线程中，如果需要执行一些耗时操作需要放到相应的子线程中处理，谷歌内置了一个<code>IntentService(异步处理服务)</code>，</p><p>它会新开一个线程：handlerThread在线程中发消息，然后接受处理完成后，会清理线程，并且关掉服务。</p><p>IntentService有以下特点：</p><p>（1） 它创建了一个独立的工作线程来处理所有的通过onStartCommand()传递给服务的intents。</p><p>（2） 创建了一个工作队列，来逐个发送intent给onHandleIntent()。</p><p>（3） 不需要主动调用stopSelft()来结束服务。因为，在所有的intent被处理完后，系统会自动关闭服务。</p><p>（4） 默认实现的onBind()返回null</p><p>（5） 默认实现的onStartCommand()的目的是将intent插入到工作队列中</p><p>其中intentService在5.0系统中需要显示启动</p><p>在之前的例子中我们自己手动维护了一个handleThread去处理耗时操作，intentService已经自带了，然后用户只要是实现onHandleIntent去处理新的业务即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IntentService从缺省的工作线程中调用本方法，并用启动服务的intent作为参数。</span></span><br><span class="line"><span class="comment"> * 本方法返回后，IntentService将适时终止这个服务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(@Nullable Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据Intent的不同进行不同的事务处理</span></span><br><span class="line">    String taskName = intent.getExtras().getString(<span class="string">"taskName"</span>);</span><br><span class="line">    <span class="keyword">switch</span> (taskName) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"task1"</span>:</span><br><span class="line">            Log.d(TAG, <span class="string">"do task1"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"task2"</span>:</span><br><span class="line">            Log.d(TAG, <span class="string">"do task2"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两种均在demo中有所实现</p><p><strong>可通信Service(bind) </strong></p><blockquote><p>如果一个应用程序组件通过调用bindService()绑定到服务上，bound服务提供了一个客户端/服务器接口，<code>允许组件与服务进行交互、发送请求、获取结果，甚至可以利用进程间通信（IPC）跨进程执行这些操作</code>。绑定服务的生存期和被绑定的应用程序组件一致。多个组件可以同时与一个服务绑定，不过所有的组件解除绑定后，服务也就会被销毁。</p></blockquote><ul><li><p>使用场景<br>当客户端和服务位于同一个应用程序的进程中，(如一个音乐应用需要把Activity绑定到它自己的后台音乐播放上)</p></li><li><p>使用步骤</p></li></ul><ol><li><p>在你的服务中创建一个Binder的实例，通常需要实现以下3点之一</p><ul><li>包含了可供客户端调用的公共方法，如demo中的 <code>getHelloBoundService()</code>方法</li><li>返回当前Service实例，其中包含了可供客户端调用的公共方法，如demo中的<code>getRandomNumber</code></li><li>或者，返回内含服务类的其它类的一个实例，服务中包含了可供客户端调用的公共方法，</li></ul></li><li><p>从回调方法onBinder()返回Binder的实例</p></li><li>在客户端中，在回调方法onServiceConnected()中接收Binder并用所提供的方法对绑定的服务进行调用，不过服务和客户端之所以必须位于同一个应用程序中，是为了让客户端能够正确转换（cast）返回的对象并调用对象的API。<br>服务和客户端也必须位于同一个进程中，因为这种方式不能执行任何跨进程的序列化（marshalling）操作。</li></ol><ul><li>Tips</li></ul><ol><li>在没有bind时执行unbind，会报Service not registered crash，可以增加标志位控制bind、unbind可以参看demo中的unbind操作</li><li>ServiceConnection中重写2个方法<code>onServiceConnected</code>、<code>onServiceDisconnected</code>，其中bindService会触发onServiceConnected，而unbinderService不会触发onServiceDisconnected；<code>onServiceDisconnected</code>在系统在内存不足的时候可以优先杀死这个服务</li></ol><p><strong>前台service</strong></p><p>前台service和后台service最大的区别在于</p><ul><li>前台service在下来通知栏有显示通知，但是后台service没有</li><li>前台service优先级较高，不会由于系统内存不足而被回收，而后台service优先级比较低，当系统出现内存不足情况时有可能被回收</li></ul><p>与普通service使用类似，核心是增加构建通知部分的处理，具体可以查看demo中代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//API11之后构建Notification的方式</span></span><br><span class="line">    Notification.Builder builder = <span class="keyword">new</span> Notification.Builder(<span class="keyword">this</span>);</span><br><span class="line">    Intent frontServiceIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MainActivity.class);</span><br><span class="line">    PendingIntent frontServicePeningIntent = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">0</span>, frontServiceIntent, <span class="number">0</span>);</span><br><span class="line">    builder.setContentIntent(frontServicePeningIntent)</span><br><span class="line">            .setContentTitle(<span class="string">"下拉列表中的Title"</span>)</span><br><span class="line">            .setContentText(<span class="string">"要显示的内容"</span>)</span><br><span class="line">            .setSmallIcon(R.mipmap.ic_front_small)</span><br><span class="line">            .setLargeIcon(BitmapFactory.decodeResource(<span class="keyword">this</span>.getResources(), R.mipmap.ic_front_big))</span><br><span class="line">            .setWhen(System.currentTimeMillis());</span><br><span class="line">    Notification notification = builder.getNotification();</span><br><span class="line">    notification.defaults = Notification.DEFAULT_SOUND;</span><br><span class="line">    <span class="comment">// 参数一：唯一的通知标识；参数二：通知消息。</span></span><br><span class="line">    startForeground(<span class="number">110</span>, notification);<span class="comment">// 开始前台服务</span></span><br><span class="line">    <span class="keyword">return</span> START_STICKY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>远程service</strong></p><p>主要是为了让Service与多个应用程序的组件进行跨进程通信(IPC)，这里涉及到两个概念</p><ul><li>IPC：Inter-Process Communication，即跨进程通信</li><li>AIDL：Android Interface Definition Language，即Android接口定义语言；用于让某个Service与多个应用程序组件之间进行跨进程通信，从而可以实现多个应用程序共享同一个Service的功能。</li></ul><p>AIDL（Android 接口定义语言）与您可能使用过的其他 IDL 类似。 您可以利用它定义客户端与服务使用进程间通信 (IPC) 进行相互通信时都认可的编程接口。 在 Android 上，一个进程通常无法访问另一个进程的内存。 尽管如此，进程需要将其对象分解成操作系统能够识别的原语，并将对象编组成跨越边界的对象。 编写执行这一编组操作的代码是一项繁琐的工作，因此 Android 会使用 AIDL 来处理。</p><p>并且谷歌特意注明了AIDL使用的场景</p><blockquote><p>注：只有允许不同应用的客户端用 IPC 方式访问服务，并且想要在服务中处理多线程时，才有必要使用 AIDL。 如果您不需要执行跨越不同应用的并发 IPC，就应该通过实现一个 Binder 创建接口；或者，如果您想执行 IPC，但根本不需要处理多线程，则使用 Messenger 类来实现接口。无论如何，在实现 AIDL 之前，请您务必理解绑定服务。</p></blockquote><p>首先新建一个aidl文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IAidlService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">aidlService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后make一下，在build/generated/source/aidl文件下生成一个接口文件</p><p>在使用到通信的地方使用这个接口文件中的api，AIDLService1.Stub.asInterface()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mAidlServiceConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写onServiceConnected()方法和onServiceDisconnected()方法</span></span><br><span class="line">    <span class="comment">//在Activity与Service建立关联和解除关联的时候调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在Activity与Service建立关联时调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用AIDLService1.Stub.asInterface()方法将传入的IBinder对象传换成了mServerAidlService对象</span></span><br><span class="line">        mServerAidlService = IAidlService.Stub.asInterface(service);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过该对象调用在MyAIDLService.aidl文件中定义的接口方法,从而实现跨进程通信</span></span><br><span class="line">            mServerAidlService.aidlService();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>可以看出二者不在一个线程中</p><p><img src="https://i.imgur.com/u6dBylu.png" alt=""><br><img src="https://i.imgur.com/cbwBY5P.png" alt=""></p><p>具体代码在demo中~</p><h2 id="0x04-一些容易混淆的点"><a href="#0x04-一些容易混淆的点" class="headerlink" title="0x04 一些容易混淆的点"></a>0x04 一些容易混淆的点</h2><p><strong>Service和Thread的区别</strong></p><p>官方有两点描述</p><ul><li>1.A Service is not a separate process. The Service object itself does<br>not imply it is running in its own process; unless otherwise specified,<br>it runs in the same process as the application it is part of.</li><li>2.A Service is not a thread. It is not a means itself to do work off<br>of the main thread (to avoid Application Not Responding errors).</li></ul><p>第二点清楚提到不是一个thread，只是有些时候二者均工作在后台而已。</p><p>service和调用者之间的通讯都是同步的（不论是远程service还是本地service），它跟线程一点关系都没有！</p><p><strong>service和intentService之间区别</strong></p><ul><li>1.Service：依赖于应用程序的主线程不要误以为是独立的进程 or 线程，因此不能处理耗时操作,否则就会报ANR(Activity—–&gt;5秒<br>Broadcast—–&gt;10秒,Service—–&gt;20秒)，而intentService内部启动一个HandleThread工作线程来去处理耗时任务</li><li><ol><li>Service需要主动调用stopSelf()来结束服务，而IntentService不需要（在所有intent被处理完后，系统会自动关闭服务，内部调用了stopself()方法）</li></ol></li></ul><p><strong>IntentService与线程的区别</strong></p><ul><li>intentService内部采用了HandlerThread实现，作用类似于后台线程；与后台线程相比，IntentService是一种后台服务，优势是：优先级高（不容易被系统杀死），从而保证任务的执行</li><li>在应用中，如果是长时间的在后台运行，而且不需要交互的情况下，使用服务。</li><li>同样是在后台运行，不需要交互的情况下，如果只是完成某个任务，之后就不需要运行，而且可能是多个任务，需要长时间运行的情况下使用线程。</li><li>如果任务占用CPU时间多，资源大的情况下，要使用线程。</li></ul><h2 id="0x05-小结"><a href="#0x05-小结" class="headerlink" title="0x05 小结"></a>0x05 小结</h2><p>service是Android 四大组件之一，掌握好它对平时的开发有着莫大益处，本文只是介绍了service的常见用法和一些容易混淆的点，还有一些深入的点比如aidl数据传递、自定义notification定制化和在不同android版本的坑，这些都需要在实际开发中遇到再去针对性处理了~</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://developer.android.com/guide/components/services.html?hl=zh-cn" target="_blank" rel="noopener">https://developer.android.com/guide/components/services.html?hl=zh-cn</a></li><li><a href="https://developer.android.com/guide/components/bound-services.html?hl=zh-cn" target="_blank" rel="noopener">https://developer.android.com/guide/components/bound-services.html?hl=zh-cn</a></li><li><a href="https://developer.android.com/guide/components/aidl.html?hl=zh-cn" target="_blank" rel="noopener">https://developer.android.com/guide/components/aidl.html?hl=zh-cn</a></li><li><a href="http://www.jianshu.com/p/1e49e93c3ec8" target="_blank" rel="noopener">http://www.jianshu.com/p/1e49e93c3ec8</a></li><li><a href="http://www.jianshu.com/p/8d0cde35eb10" target="_blank" rel="noopener">http://www.jianshu.com/p/8d0cde35eb10</a></li><li><a href="http://blog.csdn.net/luoyanglizi/article/details/51980630" target="_blank" rel="noopener">http://blog.csdn.net/luoyanglizi/article/details/51980630</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;service&quot;&gt;&lt;a href=&quot;#service&quot; class=&quot;headerlink&quot; title=&quot;service&quot;&gt;&lt;/a&gt;service&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="Android" scheme="https://xsfelvis.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://xsfelvis.github.io/tags/Android/"/>
    
      <category term="Service" scheme="https://xsfelvis.github.io/tags/Service/"/>
    
  </entry>
  
  <entry>
    <title>仿知乎创新广告</title>
    <link href="https://xsfelvis.github.io/2017/05/22/%E4%BB%BF%E7%9F%A5%E4%B9%8E%E5%88%9B%E6%96%B0%E5%B9%BF%E5%91%8A/"/>
    <id>https://xsfelvis.github.io/2017/05/22/仿知乎创新广告/</id>
    <published>2017-05-21T16:00:00.000Z</published>
    <updated>2018-06-06T06:38:54.760Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="1、效果描述"><a href="#1、效果描述" class="headerlink" title="1、效果描述"></a>1、效果描述</h3><p>知乎看到的一种非常有特色的广告展现方式，即在列表页，某一个Item显示背后部分广告图，随着列表滚动，会逐渐展示全部图片。  </p><p><img src="https://rishiqing-file.oss-cn-beijing.aliyuncs.com/1513259506589GIF.gif?Expires=1526540309&amp;OSSAccessKeyId=JZJNf7zIXqCHwLpT&amp;Signature=ygBAc9kD0a1kMYiqKL2fEAMtals%3D" alt="" title="GIF.gif"></p><h3 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h3><ul><li>2.1 实现思路</li></ul><p>在需要列表滚动时候，改变图片的显示部分</p><p>有两个核心点</p><ol><li><p>捕获列表滚动变化的dy，不管是ListView还是RecyclerView都可以做到</p></li><li><p>图片显示部分变化，可以利用canvas.translate</p></li></ol><p>方案一：</p><p>自定义view，自己去绘制bitmap，对外暴露setDy（dy），然后根据dy做canvas.translate偏移重绘即可</p><p>方案二：(更优)</p><p>利用Drawable本身就是可以绘制的，直接利用drawable去完成，当然还是要结合canvas.translate</p><p>注意super.onDrawer的调用时机</p><h3 id="3、涉及到的技术点"><a href="#3、涉及到的技术点" class="headerlink" title="3、涉及到的技术点"></a>3、涉及到的技术点</h3><ul><li>3.1 ImageView:ScaleType</li></ul><blockquote><p>不进行缩放:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATRIX </span><br><span class="line">CENTER : 不改变原图大小从ImageView的左上角开始绘制，超过ImageView部分不再显示。</span><br></pre></td></tr></table></figure><blockquote><p>等比例缩放</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CENTER_CROP: 对原图居中显示后进行等比放缩处理，使原图最小边等于ImageView的相应边。</span><br><span class="line"></span><br><span class="line">CENTER_INSIDE: 若原图宽高小于ImageView宽高，这原图不做处理居中显示，否则按比例放缩原图宽(高)是之等于ImageView的宽(高)。 </span><br><span class="line"></span><br><span class="line">FIT_START: 对原图按比例放缩使之等于ImageView的宽高，若原图高大于宽则左对齐否则上对齐。 </span><br><span class="line"></span><br><span class="line">FIT_CENTER: 对原图按比例放缩使之等于ImageView的宽高使之居中显示。 </span><br><span class="line"></span><br><span class="line">FIT_END: 对原图按比例放缩使之等于ImageView的宽高，若原图高大于宽则右对齐否则下对齐。</span><br></pre></td></tr></table></figure><blockquote><p>不等比例缩放</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FIT_XY： 对原图宽高进行放缩，该放缩不保持原比例来填充满ImageView。</span><br></pre></td></tr></table></figure><blockquote><p>图片信息可能丢失</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MATRIX </span><br><span class="line">CENTER ： 不缩放就有可能丢失 </span><br><span class="line"></span><br><span class="line">CENTER_CROP</span><br></pre></td></tr></table></figure><blockquote><p>图片过小时不会放大的情况</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">不缩放肯定就不会放大 MATRIX </span><br><span class="line">CENTER</span><br><span class="line"></span><br><span class="line">CENTER_INSIDE</span><br></pre></td></tr></table></figure><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="http://mp.weixin.qq.com/s/BHbmtfUzg3XTaGrGcX5-bg" target="_blank" rel="noopener">http://mp.weixin.qq.com/s/BHbmtfUzg3XTaGrGcX5-bg</a>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;1、效果描述&quot;&gt;&lt;a href=&quot;#1、效果描述&quot; class=&quot;headerlink&quot; title=&quot;1、效果描述&quot;&gt;&lt;/a&gt;1、效果描述&lt;/h3&gt;&lt;p&gt;知乎看到
      
    
    </summary>
    
      <category term="实践" scheme="https://xsfelvis.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Android" scheme="https://xsfelvis.github.io/tags/Android/"/>
    
      <category term="知乎广告" scheme="https://xsfelvis.github.io/tags/%E7%9F%A5%E4%B9%8E%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>编译期注解处理之APT</title>
    <link href="https://xsfelvis.github.io/2017/04/07/%E7%BC%96%E8%AF%91%E6%9C%9F%E6%B3%A8%E8%A7%A3%E4%B9%8BAPT/"/>
    <id>https://xsfelvis.github.io/2017/04/07/编译期注解之APT/</id>
    <published>2017-04-06T16:00:00.000Z</published>
    <updated>2018-06-06T06:08:03.937Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>注解系列</p><ul><li><a href="https://xsfelvis.github.io/2017/01/06/%E6%B3%A8%E8%A7%A3%E5%9F%BA%E7%A1%80/">注解基础</a></li><li><a href="https://xsfelvis.github.io/2017/03/12/%E7%BC%96%E8%AF%91%E6%9C%9F%E6%B3%A8%E8%A7%A3%E4%B9%8BJavaPoet/">JavaPoet</a></li><li><a href="https://xsfelvis.github.io/2017/04/07/%E7%BC%96%E8%AF%91%E6%9C%9F%E6%B3%A8%E8%A7%A3%E4%B9%8BAPT/">编译期注解处理之APT</a></li></ul><h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>前一篇介绍了注解的基本知识以及常见用法，由于运行期(RunTime)利用反射去获取信息还是比较损耗性能的，本篇将介绍一种使用注解更加优雅的方式，编译期(Compile time)注解，以及处理编译期注解的手段APT和Javapoet,限于篇幅，本篇着重介绍APT<br>首先你的注解需要声明为CLASS<br>@Retention(RetentionPolicy.CLASS)  </p><p>编译期解析注解基本原理：<br>在某些代码元素上（如类型、函数、字段等）添加注解，在编译时编译器会检查AbstractProcessor的子类，并且调用该类型的process函数，然后将添加了注解的所有元素都传递到process函数中，使得开发人员可以在编译器进行相应的处理，例如，根据注解生成新的Java类，这也就是ButterKnife等开源库的基本原理。</p><h2 id="0x01-APT"><a href="#0x01-APT" class="headerlink" title="0x01 APT"></a>0x01 APT</h2><p>在处理编译器注解的第一个手段就是APT(Annotation Processor Tool),即注解处理器。在java5的时候已经存在，但是java6开始的时候才有可用的API，最近才随着butterknife这些库流行起来。本章将阐述什么是注解处理器，以及如何使用这个强大的工具。</p><blockquote><p>什么是APT</p></blockquote><p>APT是一种处理注解的工具，确切的说它是javac的一个工具，它用来在编译时扫描和处理注解，一个注解的注解处理器，以java代码(或者编译过的字节码)作为输入，生成.java文件作为输出，核心是交给自己定义的处理器去处理，</p><blockquote><p>如何使用</p></blockquote><p>每个自定义的处理器都要继承虚处理器，实现其关键的几个方法</p><ul><li>继承虚处理器 AbstractProcessor</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment env)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment env)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面重点介绍下这几个函数：</p><ol><li><code>init(ProcessingEnvironment env)</code>: 每一个注解处理器类都必须有一个空的构造函数。然而，这里有一个特殊的init()方法，它会被注解处理工具调用，并输入ProcessingEnviroment参数。ProcessingEnviroment提供很多有用的工具类Elements, Types和Filer</li><li><code>process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</code>: 这相当于每个处理器的主函数main()。你在这里写你的扫描、评估和处理注解的代码，以及生成Java文件。输入参数RoundEnviroment，可以让你查询出包含特定注解的被注解元素。这是一个布尔值，表明注解是否已经被处理器处理完成，官方原文<code>whether or not the set of annotations are claimed by this processor</code>，通常在处理出现异常直接返回false、处理完成返回true。</li><li><code>getSupportedAnnotationTypes()</code>: 必须要实现；用来表示这个注解处理器是注册给哪个注解的。返回值是一个字符串的集合，包含本处理器想要处理的注解类型的合法全称。</li><li><code>getSupportedSourceVersion()</code>: 用来指定你使用的Java版本。通常这里返回SourceVersion.latestSupported()，你也可以使用SourceVersion_RELEASE_6、7、8</li></ol><ul><li>注册 处理器</li></ul><p>由于处理器是javac的工具，因此我们必须将我们自己的处理器注册到javac中，在以前我们需要提供一个.jar文件，打包你的注解处理器到此文件中，并在在你的jar中，需要打包一个特定的文件 <code>javax.annotation.processing.Processor到META-INF/services路径下</code><br>把MyProcessor.jar放到你的builpath中，javac会自动检查和读取javax.annotation.processing.Processor中的内容，并且注册MyProcessor作为注解处理器。</p><p>超级麻烦有木有，不过不要慌，谷歌baba给我们开发了AutoService注解，你只需要引入这个依赖，然后在你的解释器第一行加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@AutoService(Processor.class)</span><br></pre></td></tr></table></figure><p>然后就可以自动生成META-INF/services/javax.annotation.processing.Processor文件的。省去了打jar包这些繁琐的步骤。</p><blockquote><p>APT中的Elements和TypeMirrors</p></blockquote><p>在前面的init()中我们可以获取如下引用</p><ul><li>Elements：一个用来处理Element的工具类</li><li>Types：一个用来处理TypeMirror的工具类</li><li>Filer：正如这个名字所示，使用Filer你可以创建文件(通常与javapoet结合)</li></ul><p>在注解处理过程中，我们扫面所有的Java源文件。源文件的每一个部分都是一个特定类型的Element</p><p>先来看一下Element</p><p>对于编译器来说 代码中的元素结构是基本不变的，如，组成代码的基本元素包括包、类、函数、字段、变量的等，JDK为这些元素定义了一个基类也就是<code>Element</code>类</p><p>Element有五个直接子类，分别代表一种特定类型</p><table><thead><tr><th>PackageElement</th><th>表示一个包程序元素，可以获取到包名等</th></tr></thead><tbody><tr><td>TypeElement</td><td>表示一个类或接口程序元素</td></tr><tr><td>VariableElement</td><td>表示一个字段、enum 常量、方法或构造方法参数、局部变量或异常参数</td></tr><tr><td>ExecutableElement</td><td>表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注解类型元素</td></tr><tr><td>TypeParameterElement</td><td>表示一般类、接口、方法或构造方法元素的泛型参数</td></tr></tbody></table><p>开发中Element可根据实际情况强转为以上5种中的一种，它们都带有各自独有的方法，如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;    <span class="comment">// PackageElement</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;        <span class="comment">// TypeElement</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;      <span class="comment">// VariableElement</span></span><br><span class="line">    <span class="keyword">private</span> Test other;  <span class="comment">// VariableElement</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span> <span class="params">()</span> </span>&#123;&#125;    <span class="comment">// ExecuteableElement</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span> <span class="params">(  // ExecuteableElement</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> newA   // TypeElement</span></span></span><br><span class="line"><span class="function"><span class="params">                     )</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再举个栗子🌰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解因为只能作用于函数类型，因此，它对应的元素类型就是ExecutableElement当我们想通过APT处理这个注解的时候就可以获取目标对象上的Test注解，并且将所有这些元素转换为ExecutableElement元素，以便获取到他们对应的信息。</p><p>查看其代码定义</p><p>定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">** </span><br><span class="line"> * 表示一个程序元素，比如包、类或者方法，有如下几种子接口： </span><br><span class="line"> * ExecutableElement：表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注解类型元素 ； </span><br><span class="line"> * PackageElement：表示一个包程序元素； </span><br><span class="line"> * TypeElement：表示一个类或接口程序元素； </span><br><span class="line"> * TypeParameterElement：表示一般类、接口、方法或构造方法元素的形式类型参数； </span><br><span class="line"> * VariableElement：表示一个字段、<span class="keyword">enum</span> 常量、方法或构造方法参数、局部变量或异常参数 </span><br><span class="line"> */  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> <span class="keyword">extends</span> <span class="title">AnnotatedConstruct</span> </span>&#123;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 返回此元素定义的类型 </span></span><br><span class="line"><span class="comment">     * 例如，对于一般类元素 C&lt;N extends Number&gt;，返回参数化类型 C&lt;N&gt; </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function">TypeMirror <span class="title">asType</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 返回此元素的种类：包、类、接口、方法、字段...,如下枚举值 </span></span><br><span class="line"><span class="comment">     * PACKAGE, ENUM, CLASS, ANNOTATION_TYPE, INTERFACE, ENUM_CONSTANT, FIELD, PARAMETER, LOCAL_VARIABLE, EXCEPTION_PARAMETER, </span></span><br><span class="line"><span class="comment">     * METHOD, CONSTRUCTOR, STATIC_INIT, INSTANCE_INIT, TYPE_PARAMETER, OTHER, RESOURCE_VARIABLE; </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function">ElementKind <span class="title">getKind</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 返回此元素的修饰符,如下枚举值 </span></span><br><span class="line"><span class="comment">     * PUBLIC, PROTECTED, PRIVATE, ABSTRACT, DEFAULT, STATIC, FINAL, </span></span><br><span class="line"><span class="comment">     * TRANSIENT, VOLATILE, SYNCHRONIZED, NATIVE, STRICTFP; </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function">Set&lt;Modifier&gt; <span class="title">getModifiers</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 返回此元素的简单名称,例如 </span></span><br><span class="line"><span class="comment">     * 类型元素 java.util.Set&lt;E&gt; 的简单名称是 "Set"； </span></span><br><span class="line"><span class="comment">     * 如果此元素表示一个未指定的包，则返回一个空名称； </span></span><br><span class="line"><span class="comment">     * 如果它表示一个构造方法，则返回名称 "&lt;init&gt;"； </span></span><br><span class="line"><span class="comment">     * 如果它表示一个静态初始化程序，则返回名称 "&lt;clinit&gt;"； </span></span><br><span class="line"><span class="comment">     * 如果它表示一个匿名类或者实例初始化程序，则返回一个空名称 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function">Name <span class="title">getSimpleName</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 返回封装此元素的最里层元素。 </span></span><br><span class="line"><span class="comment">     * 如果此元素的声明在词法上直接封装在另一个元素的声明中，则返回那个封装元素； </span></span><br><span class="line"><span class="comment">     * 如果此元素是顶层类型，则返回它的包； </span></span><br><span class="line"><span class="comment">     * 如果此元素是一个包，则返回 null； </span></span><br><span class="line"><span class="comment">     * 如果此元素是一个泛型参数，则返回 null. </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function">Element <span class="title">getEnclosingElement</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 返回此元素直接封装的子元素 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    List&lt;? extends Element&gt; getEnclosedElements();  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 返回直接存在于此元素上的注解 </span></span><br><span class="line"><span class="comment">     * 要获得继承的注解，可使用 getAllAnnotationMirrors </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    List&lt;? extends AnnotationMirror&gt; getAnnotationMirrors();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 返回此元素针对指定类型的注解（如果存在这样的注解），否则返回 null。注解可以是继承的，也可以是直接存在于此元素上的 </span></span><br><span class="line"><span class="comment">     */</span>   </span><br><span class="line">    &lt;A extends Annotation&gt; <span class="function">A <span class="title">getAnnotation</span><span class="params">(Class&lt;A&gt; annotationType)</span></span>; </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//接受访问者的访问 （？？）</span></span><br><span class="line">     &lt;R, P&gt; <span class="function">R <span class="title">accept</span><span class="params">(ElementVisitor&lt;R, P&gt; var1, P var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一个，并没有使用到，感觉不太好理解，查了资料这个函数接受一个ElementVisitor和类型为P的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ElementVisitor</span>&lt;<span class="title">R</span>, <span class="title">P</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//访问元素</span></span><br><span class="line">    <span class="function">R <span class="title">visit</span><span class="params">(Element e, P p)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">R <span class="title">visit</span><span class="params">(Element e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问包元素</span></span><br><span class="line">    <span class="function">R <span class="title">visitPackage</span><span class="params">(PackageElement e, P p)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问类型元素</span></span><br><span class="line">    <span class="function">R <span class="title">visitType</span><span class="params">(TypeElement e, P p)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//访问变量元素</span></span><br><span class="line">    <span class="function">R <span class="title">visitVariable</span><span class="params">(VariableElement e, P p)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问克而执行元素</span></span><br><span class="line">    <span class="function">R <span class="title">visitExecutable</span><span class="params">(ExecutableElement e, P p)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问参数元素</span></span><br><span class="line">    <span class="function">R <span class="title">visitTypeParameter</span><span class="params">(TypeParameterElement e, P p)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理位置的元素类型，这是为了应对后续Java语言的扩折而预留的接口，例如后续元素类型添加了，那么通过这个接口就可以处理上述没有声明的类型</span></span><br><span class="line">    <span class="function">R <span class="title">visitUnknown</span><span class="params">(Element e, P p)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ElementgVisitor中定义了多个visit接口，每个接口处理一种元素类型，这就是典型的访问者模式。我们制定，一个类元素和函数元素是完全不一样的，他们的结构不一样，因此，在编译器对他们的操作肯定是不一样，通过访问者模式正好可以解决数据结构与数据操作分离的问题，避免某些操作污染数据对象类。</p><p>因此，代码在APT眼中只是一个结构化的文本而已。Element代表的是源代码。TypeElement代表的是源代码中的类型元素，例如类。然而，TypeElement并不包含类本身的信息。你可以从TypeElement中获取类的名字，但是你获取不到类的信息，例如它的父类。这种信息需要通过TypeMirror获取。你可以通过调用elements.asType()获取元素的TypeMirror。</p><h2 id="0x02-辅助接口"><a href="#0x02-辅助接口" class="headerlink" title="0x02 辅助接口"></a>0x02 辅助接口</h2><p>在自定义注解器的初始化时候，可以获取以下4个辅助接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;  </span><br><span class="line">    </span><br><span class="line">      <span class="keyword">private</span> Types typeUtils;  </span><br><span class="line">      <span class="keyword">private</span> Elements elementUtils;  </span><br><span class="line">      <span class="keyword">private</span> Filer filer;  </span><br><span class="line">      <span class="keyword">private</span> Messager messager;  </span><br><span class="line">    </span><br><span class="line">      <span class="meta">@Override</span>  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;  </span><br><span class="line">          <span class="keyword">super</span>.init(processingEnv);  </span><br><span class="line">          typeUtils = processingEnv.getTypeUtils();  </span><br><span class="line">          elementUtils = processingEnv.getElementUtils();  </span><br><span class="line">          filer = processingEnv.getFiler();  </span><br><span class="line">          messager = processingEnv.getMessager();  </span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>Filer </li></ul><p>一般配合JavaPoet来生成需要的java文件（下一篇将详细介绍javaPoet）</p><ul><li>Messager</li></ul><p>Messager提供给注解处理器一个报告错误、警告以及提示信息的途径。它不是注解处理器开发者的日志工具，而是用来写一些信息给使用此注解器的第三方开发者的。在官方文档中描述了消息的不同级别中非常重要的是Kind.ERROR，因为这种类型的信息用来表示我们的注解处理器处理失败了。很有可能是第三方开发者错误的使用了注解。这个概念和传统的Java应用有点不一样，在传统Java应用中我们可能就抛出一个异常Exception。如果你在process()中抛出一个异常，那么运行注解处理器的JVM将会崩溃（就像其他Java应用一样），使用我们注解处理器第三方开发者将会从javac中得到非常难懂的出错信息，因为它包含注解处理器的堆栈跟踪（Stacktace）信息。因此，注解处理器就有一个Messager类，它能够打印非常优美的错误信息。除此之外，你还可以连接到出错的元素。在像现在的IDE（集成开发环境）中，第三方开发者可以直接点击错误信息，IDE将会直接跳转到第三方开发者项目的出错的源文件的相应的行。</p><ul><li>Types</li></ul><p>Types是一个用来处理TypeMirror的工具</p><ul><li>Elements</li></ul><p>Elements是一个用来处理Element的工具</p><h2 id="0x03-优缺点"><a href="#0x03-优缺点" class="headerlink" title="0x03 优缺点"></a>0x03 优缺点</h2><blockquote><p>优点(结合javapoet)</p></blockquote><ul><li>对代码进行标记、在编译时收集信息并做处理</li><li>生成一套独立代码，辅助代码运行</li></ul><blockquote><p>缺点</p></blockquote><ul><li>可以自动生成代码，但在运行时需要主动调用</li><li>如果要生成代码需要编写模板函数</li></ul><h2 id="0x04-其他"><a href="#0x04-其他" class="headerlink" title="0x04 其他"></a>0x04 其他</h2><ol><li><p>通常我们需要分离处理器和注解<br>这样做的原因是，在发布程序时注解及生成的代码会被打包到用户程序中，而注解处理器则不会（注解处理器是在编译期在JVM上运行跟运行时无关）。要是不分离的话，假如注解处理器中使用到了其他第三方库，那就会占用系统资源，特别是方法数，</p></li><li><p>该技术可以让我们在设计自己框架时候多了一种技术选择，更加的优雅</p></li><li><p>反射优化</p></li></ol><p>运行时注解的使用可以减少很多代码的编写，但是谁都知道这是有性能损耗的，不过权衡利弊，我们选择了妥协，这个技术手段可以处理这个问题</p><h2 id="0x05-参考文献"><a href="#0x05-参考文献" class="headerlink" title="0x05 参考文献"></a>0x05 参考文献</h2><ul><li><a href="http://hannesdorfmann.com/annotation-processing/annotationprocessing101" target="_blank" rel="noopener">http://hannesdorfmann.com/annotation-processing/annotationprocessing101</a></li><li><a href="http://blog.csdn.net/github_35180164/article/details/52121038" target="_blank" rel="noopener">http://blog.csdn.net/github_35180164/article/details/52121038</a></li><li><a href="https://www.zhangningning.com.cn/blog/Android/android_rentention.html" target="_blank" rel="noopener">https://www.zhangningning.com.cn/blog/Android/android_rentention.html</a></li><li><a href="https://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/AbstractProcessor.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/AbstractProcessor.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;注解系列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://xsfelvis.github.io/2017/01/06/%E6%B3%A8%E8%A7%A3%E5%
      
    
    </summary>
    
      <category term="注解" scheme="https://xsfelvis.github.io/categories/%E6%B3%A8%E8%A7%A3/"/>
    
    
      <category term="注解" scheme="https://xsfelvis.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
      <category term="APT" scheme="https://xsfelvis.github.io/tags/APT/"/>
    
  </entry>
  
  <entry>
    <title>JavaPoet</title>
    <link href="https://xsfelvis.github.io/2017/03/12/%E7%BC%96%E8%AF%91%E6%9C%9F%E6%B3%A8%E8%A7%A3%E4%B9%8BJavaPoet/"/>
    <id>https://xsfelvis.github.io/2017/03/12/编译期注解之JavaPoet/</id>
    <published>2017-03-11T16:00:00.000Z</published>
    <updated>2018-06-06T06:51:09.073Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>注解系列</p><ul><li><a href="https://xsfelvis.github.io/2017/01/06/%E6%B3%A8%E8%A7%A3%E5%9F%BA%E7%A1%80/">注解基础</a></li><li><a href="https://xsfelvis.github.io/2017/03/12/%E7%BC%96%E8%AF%91%E6%9C%9F%E6%B3%A8%E8%A7%A3%E4%B9%8BJavaPoet/">JavaPoet</a></li><li><a href="https://xsfelvis.github.io/2017/04/07/%E7%BC%96%E8%AF%91%E6%9C%9F%E6%B3%A8%E8%A7%A3%E4%B9%8BAPT/">编译期注解处理之APT</a></li></ul><h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>上一篇限于篇幅只介绍了APT，这篇来继续介绍<a href="https://github.com/square/javapoet" target="_blank" rel="noopener">javapoet</a>，是square公司的开源库。正如其名，java诗人，通过注解来生成java源文件，通常要使用javapoet这个库与Filer配合使用。主要和注解配合用来干掉那些重复的模板代码(如butterknife<br>和databinding所做的事情)，当然你也可以使用这个技术让你的代码更加的炫酷。</p><h2 id="0x01-简单使用"><a href="#0x01-简单使用" class="headerlink" title="0x01 简单使用"></a>0x01 简单使用</h2><p>使用之前要先引入这个库 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.squareup:javapoet:1.7.0&apos;</span><br></pre></td></tr></table></figure><p>javapoet是用来生成代码的，需要借助</p><h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><p>使用javapoet前需要了解4个常用类</p><h4 id="MethodSpec-代表一个构造函数或方法声明。"><a href="#MethodSpec-代表一个构造函数或方法声明。" class="headerlink" title="MethodSpec 代表一个构造函数或方法声明。"></a>MethodSpec 代表一个构造函数或方法声明。</h4><h4 id="TypeSpec-代表一个类，接口，或者枚举声明。"><a href="#TypeSpec-代表一个类，接口，或者枚举声明。" class="headerlink" title="TypeSpec 代表一个类，接口，或者枚举声明。"></a>TypeSpec 代表一个类，接口，或者枚举声明。</h4><h4 id="FieldSpec-代表一个成员变量，一个字段声明。"><a href="#FieldSpec-代表一个成员变量，一个字段声明。" class="headerlink" title="FieldSpec 代表一个成员变量，一个字段声明。"></a>FieldSpec 代表一个成员变量，一个字段声明。</h4><h4 id="JavaFile包含一个顶级类的Java文件。"><a href="#JavaFile包含一个顶级类的Java文件。" class="headerlink" title="JavaFile包含一个顶级类的Java文件。"></a>JavaFile包含一个顶级类的Java文件。</h4><p>国际惯例先自动生成一个helloWorld类<br>定义一个编译期注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> clazz_hello &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后看下helloworld的注解处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoService</span>(Processor.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldProcess</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Filer filer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(processingEnv);</span><br><span class="line">        filer = processingEnv.getFiler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (TypeElement element : annotations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (element.getQualifiedName().toString().equals(clazz_hello.class.getCanonicalName())) &#123;</span><br><span class="line">                MethodSpec main = MethodSpec.methodBuilder(<span class="string">"main"</span>)</span><br><span class="line">                        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">                        .returns(<span class="keyword">void</span>.class)</span><br><span class="line">                        .addParameter(String[].class, <span class="string">"args"</span>)</span><br><span class="line">                        .addStatement(<span class="string">"$T.out.println($S)"</span>, System.class, <span class="string">"Hello, JavaPoet!"</span>)</span><br><span class="line">                        .build();</span><br><span class="line">                TypeSpec helloWorld = TypeSpec.classBuilder(<span class="string">"HelloWorld"</span>)</span><br><span class="line">                        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">                        .addMethod(main)</span><br><span class="line">                        .build();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    JavaFile javaFile = JavaFile.builder(<span class="string">"com.xsf"</span>, helloWorld)</span><br><span class="line">                            .addFileComment(<span class="string">" This codes are generated automatically. Do not modify!"</span>)</span><br><span class="line">                            .build();</span><br><span class="line">                    javaFile.writeTo(filer);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; annotations = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        annotations.add(clazz_hello.class.getCanonicalName());</span><br><span class="line">        <span class="keyword">return</span> annotations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SourceVersion.latestSupported();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就会在app-build-source-apt-debug-com.xsf文件夹下生成这个文件</p><h2 id="0x02-使用进阶"><a href="#0x02-使用进阶" class="headerlink" title="0x02 使用进阶"></a>0x02 使用进阶</h2><p>###方法&amp;控制流：</p><h4 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h4><p><code>addcode</code> 和 <code>addstatement</code>,对与无需类引入的极简代码可以直接使用<code>addCode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec main = MethodSpec.methodBuilder(<span class="string">"main"</span>)</span><br><span class="line">    .addCode(<span class="string">""</span></span><br><span class="line">        + <span class="string">"int total = 0;\n"</span></span><br><span class="line">        + <span class="string">"for (int i = 0; i &lt; 10; i++) &#123;\n"</span></span><br><span class="line">        + <span class="string">"  total += i;\n"</span></span><br><span class="line">        + <span class="string">"&#125;\n"</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成的是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    total += i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要是需要import的方法，如上面的<code>.addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;Hello, JavaPoet!&quot;)</code> 就需要使用<code>.addStatement</code>来声明</p><h5 id="更优雅的流控制"><a href="#更优雅的流控制" class="headerlink" title="更优雅的流控制"></a>更优雅的流控制</h5><p><code>beginControlFlow</code> 流开启<br><code>addStatement</code> 处理语句<br><code>endControlFlow()</code>流结束</p><p>如上面的用流改写就是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec main = MethodSpec.methodBuilder(<span class="string">"main"</span>)</span><br><span class="line">    .addStatement(<span class="string">"int total = 0"</span>)</span><br><span class="line">    .beginControlFlow(<span class="string">"for (int i = 0; i &lt; 10; i++)"</span>)</span><br><span class="line">    .addStatement(<span class="string">"total += i"</span>)</span><br><span class="line">    .endControlFlow()</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure></p><p>###占位符</p><p>javapoet里面提供了占位符来帮助我们更好地生成代码</p><h4 id="L-字面常量（Literals）"><a href="#L-字面常量（Literals）" class="headerlink" title="$L 字面常量（Literals）"></a>$L 字面常量（Literals）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MethodSpec <span class="title">computeRange</span><span class="params">(String name, <span class="keyword">int</span> from, <span class="keyword">int</span> to, String op)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> MethodSpec.methodBuilder(name)</span><br><span class="line">      .returns(<span class="keyword">int</span>.class)</span><br><span class="line">      .addStatement(<span class="string">"int result = 0"</span>)</span><br><span class="line">      .beginControlFlow(<span class="string">"for (int i = $L; i &lt; $L; i++)"</span>, from, to)</span><br><span class="line">      .addStatement(<span class="string">"result = result $L i"</span>, op)</span><br><span class="line">      .endControlFlow()</span><br><span class="line">      .addStatement(<span class="string">"return result"</span>)</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是一个for循环，op负责加减乘除等符号</p><h4 id="S-字符串常量（String）"><a href="#S-字符串常量（String）" class="headerlink" title="$S 字符串常量（String）"></a>$S 字符串常量（String）</h4><h4 id="T-类型-Types"><a href="#T-类型-Types" class="headerlink" title="$T 类型(Types)"></a>$T 类型(Types)</h4><p>最大的特点是自动导入包，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec today = MethodSpec.methodBuilder(<span class="string">"today"</span>)</span><br><span class="line">    .returns(Date.class)</span><br><span class="line">    .addStatement(<span class="string">"return new $T()"</span>, Date.class)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">TypeSpec helloWorld = TypeSpec.classBuilder(<span class="string">"HelloWorld"</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">    .addMethod(today)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">JavaFile javaFile = JavaFile.builder(<span class="string">"com.example.helloworld"</span>, helloWorld)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">javaFile.writeTo(System.out);</span><br></pre></td></tr></table></figure><p>生成的代码如下，而且会自动导包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function">Date <span class="title">today</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想要导入自己写的类怎么办？上面的例子是传入系统的class，这里也提供一种方式，通过ClassName.get（”类的路径”，”类名“），结合$T可以生成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ClassName hoverboard = ClassName.get(<span class="string">"com.mattel"</span>, <span class="string">"Hoverboard"</span>);</span><br><span class="line">ClassName list = ClassName.get(<span class="string">"java.util"</span>, <span class="string">"List"</span>);</span><br><span class="line">ClassName arrayList = ClassName.get(<span class="string">"java.util"</span>, <span class="string">"ArrayList"</span>);</span><br><span class="line">TypeName listOfHoverboards = ParameterizedTypeName.get(list, hoverboard);</span><br><span class="line"></span><br><span class="line">MethodSpec beyond = MethodSpec.methodBuilder(<span class="string">"beyond"</span>)</span><br><span class="line">    .returns(listOfHoverboards)</span><br><span class="line">    .addStatement(<span class="string">"$T result = new $T&lt;&gt;()"</span>, listOfHoverboards, arrayList)</span><br><span class="line">    .addStatement(<span class="string">"result.add(new $T())"</span>, hoverboard)</span><br><span class="line">    .addStatement(<span class="string">"result.add(new $T())"</span>, hoverboard)</span><br><span class="line">    .addStatement(<span class="string">"result.add(new $T())"</span>, hoverboard)</span><br><span class="line">    .addStatement(<span class="string">"return result"</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>然后生成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mattel.Hoverboard;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function">List&lt;Hoverboard&gt; <span class="title">beyond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Hoverboard&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    result.add(<span class="keyword">new</span> Hoverboard());</span><br><span class="line">    result.add(<span class="keyword">new</span> Hoverboard());</span><br><span class="line">    result.add(<span class="keyword">new</span> Hoverboard());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在导入包这里，javapoet 同样支持import static,通过<code>addStaticImport</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ClassName hoverboard = ClassName.get(<span class="string">"com.mattel"</span>, <span class="string">"Hoverboard"</span>);</span><br><span class="line"></span><br><span class="line">ClassName namedBoards = ClassName.get(<span class="string">"com.mattel"</span>, <span class="string">"Hoverboard"</span>, <span class="string">"Boards"</span>);</span><br><span class="line"></span><br><span class="line">MethodSpec beyond = MethodSpec.methodBuilder(<span class="string">"beyond"</span>)</span><br><span class="line">    .returns(listOfHoverboards)</span><br><span class="line">    .addStatement(<span class="string">"$T result = new $T&lt;&gt;()"</span>, listOfHoverboards, arrayList)</span><br><span class="line">    .addStatement(<span class="string">"result.add($T.createNimbus(2000))"</span>, hoverboard)</span><br><span class="line">    .addStatement(<span class="string">"result.add($T.createNimbus(\"2001\"))"</span>, hoverboard)</span><br><span class="line">    .addStatement(<span class="string">"result.add($T.createNimbus($T.THUNDERBOLT))"</span>, hoverboard, namedBoards)</span><br><span class="line">    .addStatement(<span class="string">"$T.sort(result)"</span>, Collections.class)</span><br><span class="line">    .addStatement(<span class="string">"return result.isEmpty() $T.emptyList() : result"</span>, Collections.class)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">TypeSpec hello = TypeSpec.classBuilder(<span class="string">"HelloWorld"</span>)</span><br><span class="line">    .addMethod(beyond)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">JavaFile.builder(<span class="string">"com.example.helloworld"</span>, hello)</span><br><span class="line">    .addStaticImport(hoverboard, <span class="string">"createNimbus"</span>)</span><br><span class="line">    .addStaticImport(namedBoards, <span class="string">"*"</span>)</span><br><span class="line">    .addStaticImport(Collections.class, <span class="string">"*"</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h4 id="N-命名-Names"><a href="#N-命名-Names" class="headerlink" title="$N 命名(Names)"></a>$N 命名(Names)</h4><p>通常指我们自己生成的方法名或者变量名等等比如这样的代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">byteToHex</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span>[] result = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span>];</span><br><span class="line">  result[<span class="number">0</span>] = hexDigit((b &gt;&gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xf</span>);</span><br><span class="line">  result[<span class="number">1</span>] = hexDigit(b &amp; <span class="number">0xf</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> String(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">hexDigit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">char</span>) (i &lt; <span class="number">10</span> ? i + <span class="string">'0'</span> : i - <span class="number">10</span> + <span class="string">'a'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以传递<code>hexDigit()</code>来代替。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec hexDigit = MethodSpec.methodBuilder(<span class="string">"hexDigit"</span>)</span><br><span class="line">    .addParameter(<span class="keyword">int</span>.class, <span class="string">"i"</span>)</span><br><span class="line">    .returns(<span class="keyword">char</span>.class)</span><br><span class="line">    .addStatement(<span class="string">"return (char) (i &lt; 10 ? i + '0' : i - 10 + 'a')"</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">MethodSpec byteToHex = MethodSpec.methodBuilder(<span class="string">"byteToHex"</span>)</span><br><span class="line">    .addParameter(<span class="keyword">int</span>.class, <span class="string">"b"</span>)</span><br><span class="line">    .returns(String.class)</span><br><span class="line">    .addStatement(<span class="string">"char[] result = new char[2]"</span>)</span><br><span class="line">    .addStatement(<span class="string">"result[0] = $N((b &gt;&gt;&gt; 4) &amp; 0xf)"</span>, hexDigit)</span><br><span class="line">    .addStatement(<span class="string">"result[1] = $N(b &amp; 0xf)"</span>, hexDigit)</span><br><span class="line">    .addStatement(<span class="string">"return new String(result)"</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h3 id="构建类的元素"><a href="#构建类的元素" class="headerlink" title="构建类的元素"></a>构建类的元素</h3><h4 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h4><p>方法的修饰，如<code>Modifiers.ABSTRACT</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec flux = MethodSpec.methodBuilder(<span class="string">"flux"</span>)</span><br><span class="line">    .addModifiers(Modifier.ABSTRACT, Modifier.PROTECTED)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">TypeSpec helloWorld = TypeSpec.classBuilder(<span class="string">"HelloWorld"</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)</span><br><span class="line">    .addMethod(flux)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>这将会生成如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">flux</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然Methods需要和<code>MethodSpec.Builder</code>配置来增加方法参数、异常、javadoc、注解等。</p><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>这个其实也是个函数方法而已，因此可以使用MethodSpec来生成构造器方法。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec flux = MethodSpec.constructorBuilder()</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addParameter(String.class, <span class="string">"greeting"</span>)</span><br><span class="line">    .addStatement(<span class="string">"this.$N = $N"</span>, <span class="string">"greeting"</span>, <span class="string">"greeting"</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">TypeSpec helloWorld = TypeSpec.classBuilder(<span class="string">"HelloWorld"</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addField(String.class, <span class="string">"greeting"</span>, Modifier.PRIVATE, Modifier.FINAL)</span><br><span class="line">    .addMethod(flux)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>将会生成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String greeting;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HelloWorld</span><span class="params">(String greeting)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.greeting = greeting;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>之前我们是通过<code>addstatement</code>直接设置参数，其实参数也有自己的一个专用类<code>ParameterSpec</code>，我们可以使用<code>ParameterSpec.builder()</code>来生成参数，然后MethodSpec的addParameter去使用，这样更加优雅。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ParameterSpec android = ParameterSpec.builder(String.class, <span class="string">"android"</span>)</span><br><span class="line">    .addModifiers(Modifier.FINAL)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">MethodSpec welcomeOverlords = MethodSpec.methodBuilder(<span class="string">"welcomeOverlords"</span>)</span><br><span class="line">    .addParameter(android)</span><br><span class="line">    .addParameter(String.class, <span class="string">"robot"</span>, Modifier.FINAL)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">welcomeOverlords</span><span class="params">(<span class="keyword">final</span> String android, <span class="keyword">final</span> String robot)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4><p>可以使用FieldSpec去声明字段，然后加到Method中处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FieldSpec android = FieldSpec.builder(String.class, <span class="string">"android"</span>)</span><br><span class="line">    .addModifiers(Modifier.PRIVATE, Modifier.FINAL)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">TypeSpec helloWorld = TypeSpec.classBuilder(<span class="string">"HelloWorld"</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addField(android)</span><br><span class="line">    .addField(String.class, <span class="string">"robot"</span>, Modifier.PRIVATE, Modifier.FINAL)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>然后生成代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String android;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String robot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常Builder可以更加详细的创建字段的内容，比如javadoc、annotations或者初始化字段参数等，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FieldSpec android = FieldSpec.builder(String.class, <span class="string">"android"</span>)</span><br><span class="line">    .addModifiers(Modifier.PRIVATE, Modifier.FINAL)</span><br><span class="line">    .initializer(<span class="string">"$S + $L"</span>, <span class="string">"Lollipop v."</span>, <span class="number">5.0</span>d)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>对应生成的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String android = <span class="string">"Lollipop v."</span> + <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口方法必须是PUBLIC ABSTRACT并且接口字段必须是PUBLIC STATIC FINAL ，使用<code>TypeSpec.interfaceBuilder</code></p><p>如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TypeSpec helloWorld = TypeSpec.interfaceBuilder(<span class="string">"HelloWorld"</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addField(FieldSpec.builder(String.class, <span class="string">"ONLY_THING_THAT_IS_CONSTANT"</span>)</span><br><span class="line">        .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)</span><br><span class="line">        .initializer(<span class="string">"$S"</span>, <span class="string">"change"</span>)</span><br><span class="line">        .build())</span><br><span class="line">    .addMethod(MethodSpec.methodBuilder(<span class="string">"beep"</span>)</span><br><span class="line">        .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)</span><br><span class="line">        .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  String ONLY_THING_THAT_IS_CONSTANT = <span class="string">"change"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">beep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>枚举类型</li></ul><p>使用<code>TypeSpec.enumBuilder</code>来创建，使用<code>addEnumConstant</code>来添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TypeSpec helloWorld = TypeSpec.enumBuilder(<span class="string">"Roshambo"</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addEnumConstant(<span class="string">"ROCK"</span>)</span><br><span class="line">    .addEnumConstant(<span class="string">"SCISSORS"</span>)</span><br><span class="line">    .addEnumConstant(<span class="string">"PAPER"</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Roshambo &#123;</span><br><span class="line">  ROCK,</span><br><span class="line"></span><br><span class="line">  SCISSORS,</span><br><span class="line"></span><br><span class="line">  PAPER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更复杂的类型也可以支持，如重写、注解等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">TypeSpec helloWorld = TypeSpec.enumBuilder(<span class="string">"Roshambo"</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addEnumConstant(<span class="string">"ROCK"</span>, TypeSpec.anonymousClassBuilder(<span class="string">"$S"</span>, <span class="string">"fist"</span>)</span><br><span class="line">        .addMethod(MethodSpec.methodBuilder(<span class="string">"toString"</span>)</span><br><span class="line">            .addAnnotation(Override.class)</span><br><span class="line">            .addModifiers(Modifier.PUBLIC)</span><br><span class="line">            .addStatement(<span class="string">"return $S"</span>, <span class="string">"avalanche!"</span>)</span><br><span class="line">            .build())</span><br><span class="line">        .build())</span><br><span class="line">    .addEnumConstant(<span class="string">"SCISSORS"</span>, TypeSpec.anonymousClassBuilder(<span class="string">"$S"</span>, <span class="string">"peace"</span>)</span><br><span class="line">        .build())</span><br><span class="line">    .addEnumConstant(<span class="string">"PAPER"</span>, TypeSpec.anonymousClassBuilder(<span class="string">"$S"</span>, <span class="string">"flat"</span>)</span><br><span class="line">        .build())</span><br><span class="line">    .addField(String.class, <span class="string">"handsign"</span>, Modifier.PRIVATE, Modifier.FINAL)</span><br><span class="line">    .addMethod(MethodSpec.constructorBuilder()</span><br><span class="line">        .addParameter(String.class, <span class="string">"handsign"</span>)</span><br><span class="line">        .addStatement(<span class="string">"this.$N = $N"</span>, <span class="string">"handsign"</span>, <span class="string">"handsign"</span>)</span><br><span class="line">        .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Roshambo &#123;</span><br><span class="line">  ROCK(<span class="string">"fist"</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"avalanche!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  SCISSORS(<span class="string">"peace"</span>),</span><br><span class="line"></span><br><span class="line">  PAPER(<span class="string">"flat"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String handsign;</span><br><span class="line"></span><br><span class="line">  Roshambo(String handsign) &#123;</span><br><span class="line">    <span class="keyword">this</span>.handsign = handsign;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>需要使用<code>Type.anonymousInnerClass(&quot;&quot;)</code>,通常可以使用$L占位符来指代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TypeSpec comparator = TypeSpec.anonymousClassBuilder(<span class="string">""</span>)</span><br><span class="line">    .addSuperinterface(ParameterizedTypeName.get(Comparator.class, String.class))</span><br><span class="line">    .addMethod(MethodSpec.methodBuilder(<span class="string">"compare"</span>)</span><br><span class="line">        .addAnnotation(Override.class)</span><br><span class="line">        .addModifiers(Modifier.PUBLIC)</span><br><span class="line">        .addParameter(String.class, <span class="string">"a"</span>)</span><br><span class="line">        .addParameter(String.class, <span class="string">"b"</span>)</span><br><span class="line">        .returns(<span class="keyword">int</span>.class)</span><br><span class="line">        .addStatement(<span class="string">"return $N.length() - $N.length()"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>)</span><br><span class="line">        .build())</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">TypeSpec helloWorld = TypeSpec.classBuilder(<span class="string">"HelloWorld"</span>)</span><br><span class="line">    .addMethod(MethodSpec.methodBuilder(<span class="string">"sortByLength"</span>)</span><br><span class="line">        .addParameter(ParameterizedTypeName.get(List.class, String.class), <span class="string">"strings"</span>)</span><br><span class="line">        .addStatement(<span class="string">"$T.sort($N, $L)"</span>, Collections.class, <span class="string">"strings"</span>, comparator)</span><br><span class="line">        .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortByLength</span><span class="params">(List&lt;String&gt; strings)</span> </span>&#123;</span><br><span class="line">  Collections.sort(strings, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a.length() - b.length();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义匿名内部类的一个特别棘手的问题是参数的构造。在上面的代码中我们传递了不带参数的空字符串。TypeSpec.anonymousClassBuilder(“”)。</p><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>注解使用起来比较简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec toString = MethodSpec.methodBuilder(<span class="string">"toString"</span>)</span><br><span class="line">    .addAnnotation(Override.class)</span><br><span class="line">    .returns(String.class)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addStatement(<span class="string">"return $S"</span>, <span class="string">"Hoverboard"</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hoverboard"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>AnnotationSpec.builder()</code> 可以对注解设置属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec logRecord = MethodSpec.methodBuilder(<span class="string">"recordEvent"</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)</span><br><span class="line">    .addAnnotation(AnnotationSpec.builder(Headers.class)</span><br><span class="line">        .addMember(<span class="string">"accept"</span>, <span class="string">"$S"</span>, <span class="string">"application/json; charset=utf-8"</span>)</span><br><span class="line">        .addMember(<span class="string">"userAgent"</span>, <span class="string">"$S"</span>, <span class="string">"Square Cash"</span>)</span><br><span class="line">        .build())</span><br><span class="line">    .addParameter(LogRecord.class, <span class="string">"logRecord"</span>)</span><br><span class="line">    .returns(LogReceipt.class)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>代码生成如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Headers</span>(</span><br><span class="line">    accept = <span class="string">"application/json; charset=utf-8"</span>,</span><br><span class="line">    userAgent = <span class="string">"Square Cash"</span></span><br><span class="line">)</span><br><span class="line"><span class="function">LogReceipt <span class="title">recordEvent</span><span class="params">(LogRecord logRecord)</span></span>;</span><br></pre></td></tr></table></figure><p>注解同样可以注解其他注解，通过$L引用如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec logRecord = MethodSpec.methodBuilder(<span class="string">"recordEvent"</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)</span><br><span class="line">    .addAnnotation(AnnotationSpec.builder(HeaderList.class)</span><br><span class="line">        .addMember(<span class="string">"value"</span>, <span class="string">"$L"</span>, AnnotationSpec.builder(Header.class)</span><br><span class="line">            .addMember(<span class="string">"name"</span>, <span class="string">"$S"</span>, <span class="string">"Accept"</span>)</span><br><span class="line">            .addMember(<span class="string">"value"</span>, <span class="string">"$S"</span>, <span class="string">"application/json; charset=utf-8"</span>)</span><br><span class="line">            .build())</span><br><span class="line">        .addMember(<span class="string">"value"</span>, <span class="string">"$L"</span>, AnnotationSpec.builder(Header.class)</span><br><span class="line">            .addMember(<span class="string">"name"</span>, <span class="string">"$S"</span>, <span class="string">"User-Agent"</span>)</span><br><span class="line">            .addMember(<span class="string">"value"</span>, <span class="string">"$S"</span>, <span class="string">"Square Cash"</span>)</span><br><span class="line">            .build())</span><br><span class="line">        .build())</span><br><span class="line">    .addParameter(LogRecord.class, <span class="string">"logRecord"</span>)</span><br><span class="line">    .returns(LogReceipt.class)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HeaderList</span>(&#123;</span><br><span class="line">    <span class="meta">@Header</span>(name = <span class="string">"Accept"</span>, value = <span class="string">"application/json; charset=utf-8"</span>),</span><br><span class="line">    <span class="meta">@Header</span>(name = <span class="string">"User-Agent"</span>, value = <span class="string">"Square Cash"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function">LogReceipt <span class="title">recordEvent</span><span class="params">(LogRecord logRecord)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="0x03-后续"><a href="#0x03-后续" class="headerlink" title="0x03 后续"></a>0x03 后续</h2><p>在javapoet之前有javawriter，但javapoet有着更强大的代码模型，并且对类的理解更加到位，因此推荐使用javapoet </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;注解系列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://xsfelvis.github.io/2017/01/06/%E6%B3%A8%E8%A7%A3%E5%
      
    
    </summary>
    
      <category term="注解" scheme="https://xsfelvis.github.io/categories/%E6%B3%A8%E8%A7%A3/"/>
    
    
      <category term="注解" scheme="https://xsfelvis.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
      <category term="JavaPoet" scheme="https://xsfelvis.github.io/tags/JavaPoet/"/>
    
  </entry>
  
  <entry>
    <title>Andfix学习</title>
    <link href="https://xsfelvis.github.io/2017/01/11/Andfix%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>https://xsfelvis.github.io/2017/01/11/Andfix学习记录/</id>
    <published>2017-01-10T16:00:00.000Z</published>
    <updated>2018-06-04T08:39:01.573Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="概述篇"><a href="#概述篇" class="headerlink" title="概述篇"></a>概述篇</h1><p>AndFix，全称是Android hot-fix。是阿里开源的一个热补丁框架，允许APP在不重新发布版本的情况下修复线上的bug。支持Android 2.3 到 7.0，并且支持arm 与 X86系统架构的设备。完美支持Dalvik与ART的Runtime，补丁文件是以 .apatch 结尾的文件，并且是立即生效的</p><p>项目地址<a href="https://github.com/alibaba/AndFix" target="_blank" rel="noopener">https://github.com/alibaba/AndFix</a></p><p>官方ReadMe</p><blockquote><p>大致修复图</p></blockquote><p><img src="https://github.com/alibaba/AndFix/raw/master/images/principle.png" alt=""></p><blockquote><p>How to Use(官方)</p></blockquote><p>Initialize PatchManager,</p><pre><code>`patchManager = new PatchManager(context); patchManager.init(appversion);//current version`</code></pre><p>Load patch,</p><pre><code>`patchManager.loadPatch();`</code></pre><p>You should load patch as early as possible, generally, in the initialization phase of your application(such as Application.onCreate()).</p><p>Add patch,</p><pre><code>`patchManager.addPatch(path);//path of the patch file that was downloaded`</code></pre><p>When a new patch file has been downloaded, it will become <code>effective immediately</code> by addPatch</p><p>还有一点就是混淆需要注意</p><pre><code>`-keep class * extends java.lang.annotation.Annotation -keepclasseswithmembernames class * {  native &lt;methods&gt;;  } -keep class com.alipay.euler.andfix.** { *; } `</code></pre><p>如何制作一个apatch呢，阿里在这个开源项目中提供了一个工具<a href="https://github.com/alibaba/AndFix/blob/master/tools/apkpatch-1.0.3.zip" target="_blank" rel="noopener">https://github.com/alibaba/AndFix/blob/master/tools/apkpatch-1.0.3.zip</a><br>，这里先大致介绍一下原理：通过diff增量比对两个apk改变的地方，在其上通过加上注解标记，生成一个apatch</p><p><img src="http://images2015.cnblogs.com/blog/886182/201603/886182-20160311145621210-104524703.png" alt=""></p><p>例如旧的apk为1.apk，新的apk为2.apk, -o表示补丁的输出目录，-k表示keystore, -p表示keystore的密码，-a表示alias, -e表示entry password。</p><p><img src="http://images2015.cnblogs.com/blog/886182/201603/886182-20160311192720366-164535579.png" alt=""></p><p>命令输入有点麻烦，可以自己写一个win的脚本</p><blockquote><p>apkpatch -f 2.apk -t 1.apk -o . -k finance.keystore  -p finance.tech.netease.com -a android.finance.163.com -e finance.tech.netease.com</p></blockquote><p>这样基本可以照猫画虎折腾热更新了,当然不要忘记添加读写权限</p><pre><code>`&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;`</code></pre><h1 id="原理篇"><a href="#原理篇" class="headerlink" title="原理篇"></a>原理篇</h1><ul><li><p>andfix 深入</p></li><li><p>补丁深入</p></li></ul><h2 id="andfix-原理"><a href="#andfix-原理" class="headerlink" title="andfix 原理"></a>andfix 原理</h2><p>andfix的核心原理就是方法替换 在通过其apath工具给需要替换的方法加上注解@repleaceMethod，这样在执行时把有bug的方法替换成补丁文件中执行的方法。（在Native 层使用指针替换的方式替换bug的方法，从而达到修复bug的目的），具体过程如下图：</p><p><img src="http://i.imgur.com/ErUHzr9.jpg" alt=""></p><ul><li>加载补丁</li></ul><p>使用虚拟机的JarFile加载的补丁文件，读取PATCH.MF文件得到补丁类名称</p><ul><li>获取补丁方法</li></ul><p>使用DexFile读取patch文件的dex文件，获取后根据注解获取补丁方法</p><ul><li><p>获取bug所在的方法</p><p>根据注解中获取到的类名和方法，使用ClassLaoder获取到class，然后根据反射得到bug Method，并将其访问属性修改为public<br>—————————————–java 层————————————————————-</p></li><li><p>Native 层替换方法</p></li></ul><p>使用JNI来替换bug所在方法对象的属性来修复bug</p><p>简要类之间关系图<br><img src="http://i.imgur.com/hXtSBHF.png" alt=""></p><p>修复的具体过程为：</p><p>1）我们及时修复好bug之后，我们可以apkpatch工具将两个apk做一次对比，然后找出不同的部分。生成的apatch了文件。若果这个时候，我们把后缀改成zip再解压开，里面有一个dex文件。反编译之后查看一下源码，里面就是被修复的代码所在的类文件,这些更改过的类都加上了一个_CF的后缀，并且变动的方法都被加上了一个叫@MethodReplace的annotation，通过clazz和method指定了需要替换的方法。(后面补丁原理会说到)</p><p>2）客户端得到补丁文件后就会根据annotation来寻找需要替换的方法。从AndFixManager.fix方法开始，客户端找到对应的需要替换的方法，然后在fix方法的具体实现中调用fixClass方法进行方法替换过程。</p><p>3）由JNI层完成方法的替换。fixClass方法遍历补丁class里的方法，在jni层对所需要替换的方法进行一一替换。(AndfixManager#replaceMethod)</p><blockquote><p>源码解析</p></blockquote><p>遵循使用时四步走：</p><blockquote><p>Step1：初始化PatchManger</p></blockquote><pre><code>`PatchManager patchManager = new PatchManager();`</code></pre><p>参阅 patchManager类源码——&gt;AndfixManager 其中包含了Compat兼容性检测类、SecurityChecker安全性检查类</p><pre><code>`public AndFixManager(Context context) {    mContext = context;    //判断机型是否支持Andfix 阿里的YunOs不支持    mSupport = Compat.isSupport();    if (mSupport) {        //初始化签名判断类        mSecurityChecker = new SecurityChecker(mContext);        mOptDir = new File(mContext.getFilesDir(), DIR);        // make directory fail        if (!mOptDir.exists() &amp;&amp; !mOptDir.mkdirs()) {            mSupport = false;            Log.e(TAG, &quot;opt dir create error.&quot;);        } else if (!mOptDir.isDirectory()) {// not directory            //如果不是目录则删除            mOptDir.delete();            mSupport = false;        }    }}`</code></pre><blockquote><p>Step2:使用PatchManger检查版本</p></blockquote><pre><code>`patchManager.init(apk版本)`</code></pre><p>参阅patchManager#init ——&gt;Patch 构造函数初始化 init<br>主要是版本比对，记录版本号；根据版本号将patch清除或者加载到缓存中</p><p>参阅Patch#init</p><pre><code>`    public void init(String appVersion) {    if (!mPatchDir.exists() &amp;&amp; !mPatchDir.mkdirs()) {// make directory fail        Log.e(TAG, &quot;patch dir create error.&quot;);        return;    } else if (!mPatchDir.isDirectory()) {// not directory        mPatchDir.delete();        return;    }    SharedPreferences sp = mContext.getSharedPreferences(SP_NAME,            Context.MODE_PRIVATE);//缓存版本号    String ver = sp.getString(SP_VERSION, null);    if (ver == null || !ver.equalsIgnoreCase(appVersion)) {        //根据传入版本号作对比，若不同，则删除本地的补丁文件        cleanPatch();        sp.edit().putString(SP_VERSION, appVersion).commit();//传入新的版本号    } else {        initPatchs();//初始化patch列表，把本地的patch加载到内存中    }}private void initPatchs() {    File[] files = mPatchDir.listFiles();    for (File file : files) {        addPatch(file);    }}`</code></pre><p>Patch文件的加载 使用JarFile读取Patch文件，读取一些属性如patchname，createtime，其中如果本地保存了多个补丁，那么AndFix会按照补丁生成的时间顺序加载补丁。具体是根据.apatch文件中的PATCH.MF的字段Created-Time。</p><blockquote><p>step3:loadPatch</p></blockquote><pre><code>`patchManager.loadPatch();`</code></pre><p>参阅patchManager#loadPatch</p><p>提供了3个重载方法</p><pre><code>`public void loadPatch()//andfix 初始化之后调用 private void loadPatch(Patch patch)//下载补丁完成后调用，addPatch(path) public void loadPatch(String patchName, ClassLoader classLoader)//提供了自定义类加载器的实现 `</code></pre><p>这三个核心都是调用了public synchronized void fix(File file, ClassLoader classLoader, List<string> classes)</string></p><p>参看AndfixManager#fix</p><pre><code>`public synchronized void fix(File file, ClassLoader classLoader,        List&lt;String&gt; classes) {    if (!mSupport) {        return;    }    //判断补丁的签名    if (!mSecurityChecker.verifyApk(file)) {// security check fail        return;    }    try {        File optfile = new File(mOptDir, file.getName());        boolean saveFingerprint = true;        if (optfile.exists()) {            // need to verify fingerprint when the optimize file exist,            // prevent someone attack on jailbreak device with            // Vulnerability-Parasyte.            // btw:exaggerated android Vulnerability-Parasyte            // http://secauo.com/Exaggerated-Android-Vulnerability-Parasyte.html            //如果本地已经存在补丁文件，则校验指纹信息            if (mSecurityChecker.verifyOpt(optfile)) {                saveFingerprint = false;            } else if (!optfile.delete()) {                return;            }        }        //加载patch文件中的dex        final DexFile dexFile = DexFile.loadDex(file.getAbsolutePath(),                optfile.getAbsolutePath(), Context.MODE_PRIVATE);        if (saveFingerprint) {            mSecurityChecker.saveOptSig(optfile);        }        ClassLoader patchClassLoader = new ClassLoader(classLoader) {            //重写了ClassLoader的findClass方法            @Override            protected Class&lt;?&gt; findClass(String className)                    throws ClassNotFoundException {                Class&lt;?&gt; clazz = dexFile.loadClass(className, this);                if (clazz == null                        &amp;&amp; className.startsWith(&quot;com.alipay.euler.andfix&quot;)) {                    return Class.forName(className);// annotation注解class                                                    // not found                }                if (clazz == null) {                    throw new ClassNotFoundException(className);                }                return clazz;            }        };        Enumeration&lt;String&gt; entrys = dexFile.entries();        Class&lt;?&gt; clazz = null;        while (entrys.hasMoreElements()) {            String entry = entrys.nextElement();            if (classes != null &amp;&amp; !classes.contains(entry)) {                continue;// skip, not need fix            }            clazz = dexFile.loadClass(entry, patchClassLoader);//获取有bug的类文件            if (clazz != null) {                fixClass(clazz, classLoader);//核心-            }        }    } catch (IOException e) {        Log.e(TAG, &quot;pacth&quot;, e);    }}`</code></pre><p>fix——&gt;fixclass——&gt;replaceMethod——&gt;Andfix#replaceMethod(Method dest,Method src) Native方法</p><pre><code>`private void fixClass(Class&lt;?&gt; clazz, ClassLoader classLoader) {    //反射找到clazz中的所有方法    Method[] methods = clazz.getDeclaredMethods();    //MethodReplace的注解    MethodReplace methodReplace;    String clz;    String meth;    for (Method method : methods) {        //遍历所有方法，找到有MethodReplace注解的方法，即需要替换的方法        methodReplace = method.getAnnotation(MethodReplace.class);//获取此方法的注解，有bug的方法生成patch的类中的方法都是有注解的        if (methodReplace == null)            continue;        clz = methodReplace.clazz(); //获取注解中的clazz的值        meth = methodReplace.method(); //获取注解中method的值        if (!isEmpty(clz) &amp;&amp; !isEmpty(meth)) {            //找到需要替换的方法后调用replaceMethod替换方法            replaceMethod(classLoader, clz, meth, method);        }    }}</code></pre><p>`</p><pre><code>`private void replaceMethod(ClassLoader classLoader, String clz,        String meth, Method method) {    try {        String key = clz + &quot;@&quot; + classLoader.toString();        //根据key查找缓存中的数据，该缓存记录了已经被修复过得class        Class&lt;?&gt; clazz = mFixedClass.get(key);        if (clazz == null) {// class not load            //找不到说明该class没有被修复过，则通过类加载器去加载            Class&lt;?&gt; clzz = classLoader.loadClass(clz);            // initialize target class            //通过C层改写accessFlag，把需要替换的类的所有方法(Field)改成了public            clazz = AndFix.initTargetClass(clzz);//初始化target class        }        if (clazz != null) {// initialize class OK            mFixedClass.put(key, clazz);            Method src = clazz.getDeclaredMethod(meth,                    method.getParameterTypes());  //根据反射拿到有bug的类的方法            //这里是调用了jni，art和dalvik分别执行不同的替换逻辑，在cpp进行实现            AndFix.addReplaceMethod(src, method);//替换方法 src是有bug的方法，method是补丁方法        }    } catch (Exception e) {        Log.e(TAG, &quot;replaceMethod&quot;, e);    }}`</code></pre><p> <code>Natvie方法的分析</code>见下面</p><p>前三步都是一开始初始化时候要做的，而最后一步第四步则是补丁下载好之后再做的</p><blockquote><p>step4: 添加Patch</p></blockquote><pre><code>`patchManager.addPatch(path)`</code></pre><p>参阅PatchManager#addPatch，最终还是执行loadpatch</p><p>appPatch——&gt;copy到andfix默认的文件夹下——&gt;执行loadPatch(补丁立即生效)</p><pre><code>`    public void addPatch(String path) throws IOException {    File src = new File(path);    File dest = new File(mPatchDir, src.getName());    if(!src.exists()){        throw new FileNotFoundException(path);    }    if (dest.exists()) {        Log.d(TAG, &quot;patch [&quot; + path + &quot;] has be loaded.&quot;);        return;    }    //这一步很重要，通过这一步将你所下载保存的patch文件，copy到andfix自己默认的文件夹内存的data/data/apatch    FileUtil.copyFile(src, dest);// copy to patch&apos;s directory    Patch patch = addPatch(dest);    if (patch != null) {        //加载patch 补丁立即生效        loadPatch(patch);    }}`</code></pre><p>小结一下：<br>可以看出andfix的核心就是两大步</p><ul><li>java层 实现加载补丁文件，安全验证等操作，然后根据补丁汇总的注解找到将要替换的方法，交给Native层去处理替换方法</li><li>native层：利用java hook的技术来替换要修复的方法</li></ul><h2 id="附-Native-分析"><a href="#附-Native-分析" class="headerlink" title="附 Native 分析"></a>附 Native 分析</h2><p>在JNI目录下 art和darvik文件中</p><p>andfix.cpp#replaceMethod——&gt;art_method_replace.cpp(根据版本)——art_method_replace_5_0.cpp</p><ul><li><p>Dalvik</p><p>Dalvik是Google公司自己设计用于Android平台的Java虚拟机。Dalvik虚拟机是Google等厂商合作开发的Android移动设备平台的核心组成部分之一。它可以支持已转换为 .dex（即Dalvik Executable）格式的Java应用程序的运行，.dex格式是专为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。Dalvik 经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik 应用作为一个独立的Linux 进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。</p></li><li><p>ART</p></li></ul><p>Android操作系统已经成熟，Google的Android团队开始将注意力转向一些底层组件，其中之一是负责应用程序运行的Dalvik运行时。Google开发者已经花了两年时间开发更快执行效率更高更省电的替代ART运行时。 ART代表Android Runtime，其处理应用程序执行的方式完全不同于Dalvik，Dalvik是依靠一个Just-In-Time (JIT)编译器去解释字节码。开发者编译后的应用代码需要通过一个解释器在用户的设备上运行，这一机制并不高效，但让应用能更容易在不同硬件和架构上运 行。ART则完全改变了这套做法，在应用安装时就预编译字节码到机器语言，这一机制叫Ahead-Of-Time (AOT）编译。在移除解释代码这一过程后，应用程序执行将更有效率，启动更快。</p><p>-优缺点</p><p>ART优点：</p><p>1、系统性能的显著提升。</p><p>2、应用启动更快、运行更快、体验更流畅、触感反馈更及时。</p><p>3、更长的电池续航能力。</p><p>4、支持更低的硬件。</p><p>ART缺点：</p><p>1、更大的存储空间占用，可能会增加10%-20%。</p><p>2、更长的应用安装时间。</p><p>总的来说ART的功效就是“空间换时间”。</p><blockquote><p>其他重要函数</p></blockquote><p>PatchManage#removeAllPatch()</p><p>这个函数是在PatchManage#init(viersin) verision不同时调用的方法一样，清空补丁目录文件，这在做保护的时候十分重要。</p><pre><code>`    public void removeAllPatch() {    cleanPatch();    SharedPreferences sp = mContext.getSharedPreferences(SP_NAME,            Context.MODE_PRIVATE);    sp.edit().clear().commit();}`</code></pre><p>比如在laodPatch,包括初始化的时候patchManager.loadPatch()和patchManager.addPatch(其实也是调用loadpath)</p><pre><code>`public void loadPatch() {    mLoaders.put(&quot;*&quot;, mContext.getClassLoader());// wildcard    Set&lt;String&gt; patchNames;    List&lt;String&gt; classes;    for (Patch patch : mPatchs) {        patchNames = patch.getPatchNames();        for (String patchName : patchNames) {            classes = patch.getClasses(patchName);//获取patch对用的class类集合            mAndFixManager.fix(patch.getFile(), mContext.getClassLoader(),                    classes);//核心-修复bug方法        }    }}`</code></pre><p>   因此需要在以下两处做好保护</p><pre><code>`public void starAndfix() {    try {        mPatchManager = new PatchManager(context);        mPatchManager.init(BuildConfig.VERSION_NAME);//更换版本号，补丁会被清除        AppLog.d(TAG, &quot;inited.&quot;);        mPatchManager.loadPatch();                  ……        requestHotFixServer(lastSign);    } catch (Throwable throwable) {        mPatchManager.removeAllPatch();        AppLog.d(TAG, &quot;outer catch error remove apatch&quot;);    }}`` try{                mPatchManager.addPatch(context.getFilesDir() + &quot;/&quot; + DIR + APATCH_PATH);            }catch (Throwable throwable){                mPatchManager.removeAllPatch();                AppLog.d(TAG, &quot;inner catch error remove apatch&quot;);            }`</code></pre><h2 id="补丁原理"><a href="#补丁原理" class="headerlink" title="补丁原理"></a>补丁原理</h2><h3 id="apkPatch工具解析"><a href="#apkPatch工具解析" class="headerlink" title="apkPatch工具解析"></a>apkPatch工具解析</h3><p>apkpatch是一个jar包，并没有开源出来，我们可以使用JD-GUI来查看其源码。首先找到Main.class 位于com.euler.patch包下，找到main方法 Main#97</p><pre><code>`public static void main(final String[] args) {    .....    //根据上面命令输入拿到参数           ApkPatch apkPatch = new ApkPatch(from, to, name, out, keystore, password, alias, entry);   apkPatch.doPatch();}`</code></pre><p>——&gt;ApkPatch#doPatch</p><pre><code>` public void doPatch() {try {  //生成smail文件夹  File smaliDir = new File(this.out, &quot;smali&quot;);  if (!smaliDir.exists())    smaliDir.mkdir();  try  {    FileUtils.cleanDirectory(smaliDir);  } catch (IOException e) {    throw new RuntimeException(e);  }  //新建diff.dex文件  File dexFile = new File(this.out, &quot;diff.dex&quot;);  if ((dexFile.exists()) &amp;&amp; (!dexFile.delete())) {    throw new RuntimeException(&quot;diff.dex can&apos;t be removed.&quot;);  }  //新建diff.apatch文件  File outFile = new File(this.out, &quot;diff.apatch&quot;);  if ((outFile.exists()) &amp;&amp; (!outFile.delete())) {    throw new RuntimeException(&quot;diff.apatch can&apos;t be removed.&quot;);  }  //第一步：拿到两个apk文件对比，对比信息写入DiffInfo  DiffInfo info = new DexDiffer().diff(this.from, this.to);  //第二步：将对比结果info写入.smail文件中，然后打包成dex文件  this.classes = buildCode(smaliDir, dexFile, info);  //第三步：将生成的dex文件写入jar包，并根据输入的签名信息进行签名生成diff.apatch文件  build(outFile, dexFile);  //第四步：将diff.apatch文件重命名  release(this.out, dexFile, outFile);} catch (Exception e) {  e.printStackTrace();}}`</code></pre><p>代码翻译一下：</p><ul><li>对比apk文件，得到所需信息</li><li>将结果打包为apatch文件</li></ul><p>主要的就是对比文件信息的DexDiffer().diff(this.from, this.to)方法</p><p>——&gt;diff#DexDiffer#diff</p><pre><code>`public DiffInfo diff(File newFile, File oldFile)throws IOException{//提取新apk的dex文件DexBackedDexFile newDexFile = DexFileFactory.loadDexFile(newFile, 19,   true);//提取旧apk的dex文件DexBackedDexFile oldDexFile = DexFileFactory.loadDexFile(oldFile, 19,   true);DiffInfo info = DiffInfo.getInstance();boolean contains = false;for (DexBackedClassDef newClazz : newDexFile.getClasses()) {  Set oldclasses = oldDexFile    .getClasses();  for (DexBackedClassDef oldClazz : oldclasses) {    //对比相同的方法，存储为修改的方法    if (newClazz.equals(oldClazz)) {      //对比class文件的变量      compareField(newClazz, oldClazz, info);      //对比class的方法，如果同一个类中没有相同的方法，则判断为新增方法(后面方法)      compareMethod(newClazz, oldClazz, info);      contains = true;      break;    }  }  if (!contains)  {    info.addAddedClasses(newClazz);  }}return info;}`</code></pre><p>从这段代码可以看出dex diff得到两个apk文件的差别信息，变量和方法</p><blockquote><p>变量</p></blockquote><pre><code>`public void addAddedFields(DexBackedField field) {this.addedFields.add(field);throw new RuntimeException(&quot;can,t add new Field:&quot; +   field.getName() + &quot;(&quot; + field.getType() + &quot;), &quot; + &quot;in class :&quot; +   field.getDefiningClass()); } public void addModifiedFields(DexBackedField field) { this.modifiedFields.add(field); throw new RuntimeException(&quot;can,t modified Field:&quot; +   field.getName() + &quot;(&quot; + field.getType() + &quot;), &quot; + &quot;in class :&quot; +   field.getDefiningClass());}`</code></pre><p>可以看出不支持增加成员变量，也不支持修改成员变量。</p><blockquote><p>方法</p></blockquote><pre><code>`public void addAddedMethods(DexBackedMethod method) {System.out.println(&quot;add new Method:&quot; + method.getReturnType() +   &quot;  &quot; + method.getName() + &quot;(&quot; +   Formater.formatStringList(method.getParameterTypes()) +   &quot;)  in Class:&quot; + method.getDefiningClass());this.addedMethods.add(method);if (!this.modifiedClasses.contains(method.classDef))  this.modifiedClasses.add(method.classDef);}public void addModifiedMethods(DexBackedMethod method) {System.out.println(&quot;add modified Method:&quot; + method.getReturnType() +   &quot;  &quot; + method.getName() + &quot;(&quot; +   Formater.formatStringList(method.getParameterTypes()) +   &quot;)  in Class:&quot; + method.getDefiningClass());this.modifiedMethods.add(method);if (!this.modifiedClasses.contains(method.classDef))  this.modifiedClasses.add(method.classDef);}}`</code></pre><p>可以看出对比方法过程中对比两个dex文件中同时存在的方法，如果方法实现不同则存储为修改过的方法；如果方法名不同，存储为新增的方法，也就是说AndFix支持增加新的方法</p><p>最后还有一点需要注意下：<br>在diff#DexDiffer#diff中<br>    //提取新apk的dex文件<br>    DexBackedDexFile newDexFile = DexFileFactory.loadDexFile(newFile, 19, true);</p><p>——&gt;org#jf#dexlib2#DexFileFactory</p><pre><code>`public static DexBackedDexFile loadDexFile(String path, int api, boolean experimental)throws IOException{return loadDexFile(new File(path), &quot;classes.dex&quot;, new Opcodes(api, experimental));}`</code></pre><p>可以看出只提取出了classes.dex这个文件，所以并不支持multidex，如果使用了multidex方案，并且修复的类不在同一个dex文件中，那么补丁就不会生效。</p><h3 id="生成补丁解析"><a href="#生成补丁解析" class="headerlink" title="生成补丁解析"></a>生成补丁解析</h3><p>当时在研究热更新时出现了使用release包加壳后的补丁不能使，为了更好地研究生成的补丁的使用，需要进一步研究一下生成的补丁具体是什么。</p><blockquote><p>工具： jadx</p></blockquote><p>使用参考：<a href="https://liuzhichao.com/2016/jadx-decompiler.html" target="_blank" rel="noopener">https://liuzhichao.com/2016/jadx-decompiler.html</a></p><blockquote><p>将加壳前和加壳后生成的补丁，后缀改为zip，得到noshell.out.zip和shell.out.zip，解压后二者都是由两部分组成</p></blockquote><p><img src="http://i.imgur.com/6TLvmKO.png" alt=""></p><p>通过jadx查看 未加壳生成的补丁dex文件<br><img src="http://i.imgur.com/3QTF5Es.png" alt=""><br>可以清楚看到加注解的方法，注解之中写了clazz和method的值，对应着apk包中的类名和方法名称；然后就是前后替换的地方</p><p>而当用jadx查看加壳后引起一场的补丁时候，<br><img src="http://i.imgur.com/Zi75LwY.png" alt=""></p><p>可以看出，加壳之后两个apk根本无法通过diff正确生成补丁，初步推断应该是加壳引入更大的混淆，是的前后两个apk根本无法通过增量比对判断变化，这种error补丁后补丁加入之后会引起 java.lang.VerifyError<br><img src="http://i.imgur.com/8Mcue65.png" alt=""></p><p>因此做好异常保护十分重要</p><h1 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h1><blockquote><p>优点</p></blockquote><p>1）可以多次打补丁。如果本地保存了多个补丁，那么AndFix会按照补丁生成的时间顺序加载补丁。具体是根据.apatch文件中的PATCH.MF的字段Created-Time。</p><p>2）安全性</p><p>readme提示开发者需要验证下载过来的apatch文件的签名是否就是在使用apkpatch工具时使用的签名，如果不验证那么任何人都可以制作自己的apatch文件来对你的APP进行修改。 但是我看到AndFix已经做了验证，如果补丁文件的证书和当前apk的证书不是同一个的话，就不能加载补丁。 官网还有一条，提示需要验证optimize file的指纹，应该是为了防止有人替换掉本地保存的补丁文件，所以要验证MD5码，然而SecurityChecker类里面也已经做了这个工作。。但是这个MD5码是保存在sharedpreference里面，如果手机已经root那么还是可以被访问的。</p><p>3）不需要重启APP即可应用补丁。</p><blockquote><p>缺点</p></blockquote><p>1）不支持YunOS </p><p>2）无法添加新类和新的字段 </p><p>3）需要使用加固前的apk制作补丁，但是补丁文件很容易被反编译，也就是修改过的类源码容易泄露 </p><p>4）使用加固平台可能会使热补丁功能失效 </p><p>5）无法添加类和字段</p><p>6)如果使用了multidex方案，并且修复的类不在同一个dex文件中，那么补丁就不会生效。</p><h1 id="再次总结"><a href="#再次总结" class="headerlink" title="再次总结"></a>再次总结</h1><p>andfix热补丁的原理就是，通过加载差分补丁，把需要替换的方法注入到native层，然后通过替换新老方法的函数指针，从而达到bug修复的目的，但是由于Andfix是动态的跳过了类的初始化，所以对于静态方法，静态成员变量，构造方法，是不能处理的，而且也不支持新增成员变量和修改成员变量。</p><h1 id="其他一些坑"><a href="#其他一些坑" class="headerlink" title="其他一些坑"></a>其他一些坑</h1><ul><li>自己下载文件的位置不要跟andfix默认的位置一致，否则源码执行addpatch先会在默认位置检查，如果存在直接return而不会去执行loadpatch</li><li>含有loadpatch的地方要做好保护</li><li>需要提供未加壳apk生成的补丁文件，而不是加壳后的补丁</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;概述篇&quot;&gt;&lt;a href=&quot;#概述篇&quot; class=&quot;headerlink&quot; title=&quot;概述篇&quot;&gt;&lt;/a&gt;概述篇&lt;/h1&gt;&lt;p&gt;AndFix，全称是Androi
      
    
    </summary>
    
      <category term="开源学习" scheme="https://xsfelvis.github.io/categories/%E5%BC%80%E6%BA%90%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Andfix" scheme="https://xsfelvis.github.io/tags/Andfix/"/>
    
  </entry>
  
  <entry>
    <title>注解基础</title>
    <link href="https://xsfelvis.github.io/2017/01/06/%E6%B3%A8%E8%A7%A3%E5%9F%BA%E7%A1%80/"/>
    <id>https://xsfelvis.github.io/2017/01/06/注解基础/</id>
    <published>2017-01-05T16:00:00.000Z</published>
    <updated>2018-06-06T06:44:36.329Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>注解系列</p><ul><li><a href="https://xsfelvis.github.io/2017/01/06/%E6%B3%A8%E8%A7%A3%E5%9F%BA%E7%A1%80/">注解基础</a></li><li><a href="https://xsfelvis.github.io/2017/03/12/%E7%BC%96%E8%AF%91%E6%9C%9F%E6%B3%A8%E8%A7%A3%E4%B9%8BJavaPoet/">JavaPoet</a></li><li><a href="https://xsfelvis.github.io/2017/04/07/%E7%BC%96%E8%AF%91%E6%9C%9F%E6%B3%A8%E8%A7%A3%E4%B9%8BAPT/">编译期注解处理之APT</a></li></ul><h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>本文主要是介绍注解的基础知识，为后面的APT和JavaPoet打下基础</p><h2 id="0x01-什么是注解"><a href="#0x01-什么是注解" class="headerlink" title="0x01 什么是注解"></a>0x01 什么是注解</h2><p>注解（Annotation）是Java5的一个新特性,是插入在代码中的一种注释或者说是一种元数据（meta data），这些注释信息可以在编译期使用预编译工具进行获取处理，也可以在运行期使用Java反射机制来获取，这取决于你的注解类型。</p><h2 id="0x02-注解的语法及其定义"><a href="#0x02-注解的语法及其定义" class="headerlink" title="0x02 注解的语法及其定义"></a>0x02 注解的语法及其定义</h2><p>在Android中注解经常存在我们代码中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main4);</span><br><span class="line">    getIntentData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的<code>@Override</code>就是系统的注解，表明这是个重写方法，点击源码可以看到长成下面的样子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际中会带有一些参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> run_methodInfo &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> "<span class="keyword">long</span>"</span>;</span><br><span class="line">    <span class="function">String <span class="title">data</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> 365</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Retention @Target @Document @Inherited四种 是元注解即 “注解的注解”</p><blockquote><p>@Target 表示该注解目标,可能的 ElemenetType 参数包括:</p></blockquote><ul><li>ElemenetType.CONSTRUCTOR 构造器声明</li><li>ElemenetType.FIELD 域声明(包括 enum 实例) </li><li>ElemenetType.LOCAL_VARIABLE 局部变量声明 </li><li>ElemenetType.METHOD 方法声明 </li><li>ElemenetType.PACKAGE 包声明 </li><li>ElemenetType.PARAMETER 参数声明 </li><li>ElemenetType.TYPE 类，接口(包括注解类型)或enum声明</li></ul><blockquote><p>@Retention 表示该注解的生命周期,可选的 RetentionPolicy 参数包括</p></blockquote><ul><li>RetentionPolicy.SOURCE 注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃注解将被编译器丢弃 </li><li>RetentionPolicy.CLASS 注解被保留到class文件，但jvm加载class文件时候被遗弃</li><li>RetentionPolicy.RUNTIME 注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在；，因此可以通过反射机制读取注解的信息</li></ul><blockquote><p>@Documented 指示将此注解包含在 javadoc 中<br>@Inherited 指示允许子类继承父类中的注解</p></blockquote><p>使用注解需要遵守它的规则：</p><ul><li>Annotation型定义为@interface, 所有的Annotation会自动继承java.lang.Annotation这一接口,并且不能再去继承别的类或是接口.</li><li>参数成员只能用public或默认(default)这两个访问权修饰</li><li>参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和String、Enum、Class、annotations等数据类型,以及这一些类型的数组.</li><li>要获取类方法和字段的注解信息，必须通过Java的反射技术来获取 Annotation对象,因为你除此之外没有别的获取注解对象的方法（分为编译期还是运行期）</li></ul><h2 id="0x03-使用"><a href="#0x03-使用" class="headerlink" title="0x03 使用"></a>0x03 使用</h2><p>（这里仅介绍最常见的运行期的注解，编译期注解涉及到apt、javapoet会单独再开一篇介绍）</p><blockquote><p>Step One 定义注解</p></blockquote><p>先看三个Runtime注解，包括类、方法、字段，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> run_classInfo &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> run_methodInfo &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> "<span class="keyword">long</span>"</span>;</span><br><span class="line">    <span class="function">String <span class="title">data</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> 365</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> run_fieldInfo &#123;</span><br><span class="line">    <span class="keyword">int</span>[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Step two 使用这些注解，</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@run</span>_classInfo(<span class="string">"类注解RunTime Class"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunTimeTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@run</span>_fieldInfo(value = &#123;<span class="number">77</span>, <span class="number">88</span>&#125;)</span><br><span class="line">    <span class="keyword">public</span> String fieldInfo = <span class="string">"filedInfo"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@run</span>_fieldInfo(value = &#123;<span class="number">163</span>&#125;)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@run</span>_methodInfo(name = <span class="string">"彩笔学长"</span>, data = <span class="string">"finance"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RunTimeTest.class.getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用反射解析注解</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析运行时注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showRunTimeInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="comment">//获取Class 注解</span></span><br><span class="line">    Class&lt;?&gt; clazz = RunTimeTest.class;</span><br><span class="line">    Constructor&lt;?&gt;[] constructors = clazz.getConstructors();</span><br><span class="line">    <span class="comment">//获取包含的注解类信息</span></span><br><span class="line">    run_classInfo runClassInfo = clazz.getAnnotation(run_classInfo.class);</span><br><span class="line">    <span class="keyword">if</span> (runClassInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取class注解</span></span><br><span class="line">        sb.append(<span class="string">"Class注解: "</span>).append(<span class="string">"\n"</span>);</span><br><span class="line">        sb.append(Modifier.toString(clazz.getModifiers())).append(<span class="string">" "</span>)</span><br><span class="line">                .append(clazz.getSimpleName()).append(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        sb.append(<span class="string">"注解值："</span>).append(<span class="string">"\n"</span>)</span><br><span class="line">                .append(runClassInfo.value()).append(<span class="string">"\n\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Field注解</span></span><br><span class="line">    sb.append(<span class="string">"Field注解："</span>).append(<span class="string">"\n"</span>);</span><br><span class="line">    Field[] fields = clazz.getDeclaredFields(); <span class="comment">//获取自身的不包括继承类</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">        <span class="comment">//获取field注解类信息</span></span><br><span class="line">        run_fieldInfo fieldInfo = field.getAnnotation(run_fieldInfo.class);</span><br><span class="line">        <span class="keyword">if</span> (fieldInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sb.append(Modifier.toString(field.getModifiers())).append(<span class="string">" "</span>)</span><br><span class="line">                    .append(field.getType().getSimpleName()).append(<span class="string">" "</span>)</span><br><span class="line">                    .append(field.getName()).append(<span class="string">"\n"</span>);</span><br><span class="line">            sb.append(<span class="string">"注解值： "</span>).append(<span class="string">"\n"</span>)</span><br><span class="line">                    .append(Arrays.toString(fieldInfo.value())).append(<span class="string">"\n\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Method 注解</span></span><br><span class="line">    sb.append(<span class="string">"Method注解： "</span>).append(<span class="string">"\n"</span>);</span><br><span class="line">    Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        run_methodInfo methodInfo = method.getAnnotation(run_methodInfo.class);</span><br><span class="line">        <span class="keyword">if</span> (methodInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sb.append(Modifier.toString(method.getModifiers())).append(<span class="string">" "</span>)</span><br><span class="line">                    .append(method.getReturnType().getSimpleName()).append(<span class="string">" "</span>)</span><br><span class="line">                    .append(method.getName()).append(<span class="string">"\n"</span>);</span><br><span class="line">            sb.append(<span class="string">"注解值："</span>).append(<span class="string">"\n"</span>);</span><br><span class="line">            sb.append(<span class="string">"name: "</span>).append(methodInfo.name()).append(<span class="string">"\n"</span>);</span><br><span class="line">            sb.append(<span class="string">"data: "</span>).append(methodInfo.data()).append(<span class="string">"\n"</span>);</span><br><span class="line">            sb.append(<span class="string">"id: "</span>).append(methodInfo.id()).append(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    tvDes.setText(sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##0x04 参考文献</p><ul><li><a href="http://www.cnblogs.com/lbangel/p/3523741.html" target="_blank" rel="noopener">http://www.cnblogs.com/lbangel/p/3523741.html</a></li><li><a href="http://blog.csdn.net/github_35180164/article/details/52107204" target="_blank" rel="noopener">http://blog.csdn.net/github_35180164/article/details/52107204</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;注解系列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://xsfelvis.github.io/2017/01/06/%E6%B3%A8%E8%A7%A3%E5%
      
    
    </summary>
    
      <category term="注解" scheme="https://xsfelvis.github.io/categories/%E6%B3%A8%E8%A7%A3/"/>
    
    
      <category term="注解" scheme="https://xsfelvis.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>自定义Lint</title>
    <link href="https://xsfelvis.github.io/2016/12/16/%E8%87%AA%E5%AE%9A%E4%B9%89Lint/"/>
    <id>https://xsfelvis.github.io/2016/12/16/自定义Lint/</id>
    <published>2016-12-15T16:00:00.000Z</published>
    <updated>2018-06-04T15:26:13.043Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Lint"><a href="#Lint" class="headerlink" title="Lint"></a>Lint</h1><p>在android studio中内置了大概200个左右的lint检查，比如定义变量未使用，直接Handler报内存泄漏提醒，时时刻刻在监督着我们的代码。自己定制了一些Lint规则，项目开源在GitHub上<br><a href="https://github.com/xsfelvis/LintDemo" title="项目地址" target="_blank" rel="noopener">https://github.com/xsfelvis/LintDemo</a></p><h3 id="为什么需要自定义Lint"><a href="#为什么需要自定义Lint" class="headerlink" title="为什么需要自定义Lint"></a>为什么需要自定义Lint</h3><ul><li><p>原生Lint无法满足团队特有的需求，如：编码规范</p></li><li><p>原生Lint存在一些检测缺陷或者缺少一些我们认为有必要的检测,如new Message等</p></li></ul><h3 id="自定义Lint-主要完成了以下功能"><a href="#自定义Lint-主要完成了以下功能" class="headerlink" title="自定义Lint,主要完成了以下功能"></a>自定义Lint,主要完成了以下功能</h3><ul><li>Actvity、Fragment布局文件名称前缀为<code>actvity_</code>、<code>fragment_</code>的检查</li><li>Log、System.out.pritln打印必须为工程中自定义的<code>AppLog</code>检查(这个因项目而异)</li><li>检测new Message,提醒使用<code>Message.Obtain()</code>/<code>handler.obtainMessage</code></li><li>xml文件中各种控件命名规范化，如Buttion前缀为btn，适合规范化编程</li></ul><blockquote><p>依赖方式</p></blockquote><p>采用LinkedIn提供了另一种思路 : 将jar放到一个aar中。这样我们就可以针对工程进行自定义Lint，lint.jar只对当前工程有效，使用前记得开启AS的支持自定义Lint检查功能，如下图<br><img src="https://user-gold-cdn.xitu.io/2016/12/16/d99bffe30fec6ddc7eb08c02afecad0f.png" alt=""></p><blockquote><p>部分效果示意图</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2016/12/16/19f5dfe820be8ef2944395f8c2ab72d0.png" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2016/12/16/c90d7bffdc9558febbbeaf6baa5b9cda.png" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2016/12/16/6bd951cd05c7e3b245908b1d6d2dc1aa.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Lint&quot;&gt;&lt;a href=&quot;#Lint&quot; class=&quot;headerlink&quot; title=&quot;Lint&quot;&gt;&lt;/a&gt;Lint&lt;/h1&gt;&lt;p&gt;在android stu
      
    
    </summary>
    
      <category term="工具" scheme="https://xsfelvis.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Lint" scheme="https://xsfelvis.github.io/tags/Lint/"/>
    
  </entry>
  
  <entry>
    <title>粒子动画效果</title>
    <link href="https://xsfelvis.github.io/2016/11/28/%E7%B2%92%E5%AD%90%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0/"/>
    <id>https://xsfelvis.github.io/2016/11/28/粒子动画学习/</id>
    <published>2016-11-27T16:00:00.000Z</published>
    <updated>2018-06-04T04:56:43.869Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="粒子效果动画"><a href="#粒子效果动画" class="headerlink" title="粒子效果动画"></a>粒子效果动画</h1><p>看了几个开源库，自己在学习过程中重构了一个供自己以后使用</p><p>源码地址:<a href="https://github.com/xsfelvis/Explosion" target="_blank" rel="noopener">https://github.com/xsfelvis/Explosion</a></p><p>效果图：</p><p><img src="http://ogopjinry.bkt.clouddn.com/particle.gif" alt="particle"></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>提供了6中粒子动画效果，框架支持扩展，若有新的粒子需求可以继承Particle实现自己的需求，整体框架如下</p><p><img src="http://ogopjinry.bkt.clouddn.com/Particle.jpeg" alt="particleUml"></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>已经单独将粒子动画部分抽成modudle依赖，直接添加依赖即可，或者使用jar包<a href="http://ogopjinry.bkt.clouddn.com/explosion.jar" target="_blank" rel="noopener">jar包下载地址</a>，然后在Actvity中按照如下方式使用即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ExplosionView explosionView;</span><br><span class="line"><span class="comment">//找到对应的控件</span></span><br><span class="line">tvNormal = (TextView) findViewById(R.id.tvNormal);</span><br><span class="line">ivVx = (ImageView) findViewById(R.id.ivVx);</span><br><span class="line"><span class="comment">//设置监听即可</span></span><br><span class="line">explosionView = <span class="keyword">new</span> ExplosionView(<span class="keyword">this</span>, <span class="keyword">new</span> ParticleFactory(ParticleFactory.NORMAL));     explosionView.addExplosionListener(tvNormal);</span><br><span class="line">explosionView.addExplosionListener(ivVx);</span><br></pre></td></tr></table></figure><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>站在巨人的肩膀上会领略到更多的风景，并在他们的基础上做了大量的重构。<br>Thanks </p><ul><li><a href="https://github.com/Xieyupeng520/AZExplosion" target="_blank" rel="noopener">https://github.com/Xieyupeng520/AZExplosion</a></li><li><a href="https://github.com/tyrantgit/ExplosionField" target="_blank" rel="noopener">https://github.com/tyrantgit/ExplosionField</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;粒子效果动画&quot;&gt;&lt;a href=&quot;#粒子效果动画&quot; class=&quot;headerlink&quot; title=&quot;粒子效果动画&quot;&gt;&lt;/a&gt;粒子效果动画&lt;/h1&gt;&lt;p&gt;看了几个
      
    
    </summary>
    
      <category term="开源学习" scheme="https://xsfelvis.github.io/categories/%E5%BC%80%E6%BA%90%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="粒子动画" scheme="https://xsfelvis.github.io/tags/%E7%B2%92%E5%AD%90%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>常用设计模式</title>
    <link href="https://xsfelvis.github.io/2016/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
    <id>https://xsfelvis.github.io/2016/11/16/设计模式学习/</id>
    <published>2016-11-15T16:00:00.000Z</published>
    <updated>2018-06-04T04:55:24.485Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>学习设计模式是一个漫长的过程，也是一个程序员登堂入室的必经之路。这篇博文就是记录学习设计模式的过程,会持续更新(属于<code>天狼星</code>计划的一部分，严肃脸)，<code>每个模式都有对应的学习代码</code>，学习在<a href="https://github.com/xsfelvis/DesignPattern.git" target="_blank" rel="noopener">https://github.com/xsfelvis/DesignPattern.git</a></p><h2 id="0x01-大纲"><a href="#0x01-大纲" class="headerlink" title="0x01 大纲"></a>0x01 大纲</h2><table><thead><tr><th></th><th style="text-align:center">创建型</th><th>结构型</th><th style="text-align:right">行为型</th></tr></thead><tbody><tr><td>对象</td><td style="text-align:center">Factory Method</td><td>Adapter_Class</td><td style="text-align:right">Interpreter<br>Template Method</td></tr><tr><td>类</td><td style="text-align:center">Abstract Factory <br> Builder <br> Prototype <br> Singleton</td><td>Adapter_Object <br>Bridge<br>Composite<br> Decorator<br>Facade<br> Flyweight<br>Proxy</td><td style="text-align:right">Chain of Responsibility<br>Command<br> Iterator<br>Mediator<br> Memento<br>Observer<br> State<br>Strategy<br> Visitor</td></tr></tbody></table><h2 id="0x02-Factory-Method-简单工厂方法"><a href="#0x02-Factory-Method-简单工厂方法" class="headerlink" title="0x02 Factory Method (简单工厂方法)"></a>0x02 Factory Method (简单工厂方法)</h2><blockquote><p>Factory Method (简单工厂方法)</p></blockquote><p>又称简单工厂模式或者静态工厂模式</p><ul><li>使用动机</li></ul><p>定义一个用于创建对象的接口，让子类决定去实例化哪一个类。Factory Method使用一个类的实例化延迟到其子类。</p><ul><li>通用UML图</li></ul><p><img src="http://ogopjinry.bkt.clouddn.com/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F" alt="工厂模式"></p><p>这个uml基本概括了工厂模式的核心，其他的都是可以根据这个衍生发展。</p><p>主要分为4大模块，</p><p><code>抽象工厂</code>：其为工厂方法模式的核心；</p><p><code>具体工厂</code>：体现实现具体的业务逻辑</p><p><code>抽象产品</code>：是工厂方法模式所创建的产品的父类</p><p><code>具体产品</code>：实现抽象产品的某个具体产品的对象</p><ul><li>适用场景</li></ul><ol><li>当一个类不知道它所必须创建对象类的时候</li><li>当一个类希望由它的子类来指定它所创建的对象的时候</li><li>当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候</li></ol><ul><li>要点分析</li></ul><blockquote><p>工厂根据type生成对应示例</p></blockquote><p>在最简单的工厂中，往往传入产品的type，然后得到具体的产品示例。在我们金融app中分享部分的代码就是按照这个思路来处理的(代码已经脱敏)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShareButtonClick</span><span class="params">(<span class="keyword">int</span> btnType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (btnType)&#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.weixin:</span><br><span class="line">                client = ShareFactory.getClient(<span class="keyword">this</span>, ShareFactory.ClientEnum.wx);</span><br><span class="line">                ((WXClient) client).setType(SendMessageToWX.Req.WXSceneSession);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出通过在工厂中定义一个枚举类型，然后根据传入的type生成对应的示例</p><blockquote><p>传入class 根据反射更加简洁的生产出具体产品</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 抽象工厂方法</span></span><br><span class="line"><span class="comment"> * 具体交由子类实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//public abstract Product createProduct();</span></span><br><span class="line">    <span class="comment">//使用抽象类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends Product&gt; <span class="function">T <span class="title">createProduct</span><span class="params">(Class&lt;T&gt; clz)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 具体工厂实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreateFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="comment">//根据传入的class通过反射取得</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Product&gt; <span class="function">T <span class="title">createProduct</span><span class="params">(Class&lt;T&gt; clz)</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            product = (Product) (Class.forName(clz.getName())).newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) product;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public Product createProduct() &#123;</span></span><br><span class="line"><span class="comment">        return new ProductA();</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Factory factory = <span class="keyword">new</span> ConcreateFactory();</span><br><span class="line">        <span class="comment">//Product product = new ProductA();</span></span><br><span class="line">        Product product = factory.createProduct(ProductA.class);</span><br><span class="line">        product.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>工厂方法模式 降低了对象之间的耦合度，而且依赖于抽象的架构，扩展性比较好</p></blockquote><h2 id="0x03-Abstract-Factory-抽象工厂模式"><a href="#0x03-Abstract-Factory-抽象工厂模式" class="headerlink" title="0x03 Abstract Factory(抽象工厂模式)"></a>0x03 Abstract Factory(抽象工厂模式)</h2><blockquote><p>Abstract Factory(抽象工厂模式)</p></blockquote><ul><li>使用动机</li></ul><p>提供一个创建一些列相关或相互依赖对象的接口,而无需指定它们的具体类</p><p>相比之前的工厂都是生产具体的产品，抽象工厂生产的产品是不确定的。起源于操作系统的图形化结业方案，每个操作系统都是一个产品类，而各自的按钮与文本框也是构成一个产品类，这两种产品都有自己的特性，如android和ios的Button和TextView等。</p><ul><li>通用UML图</li></ul><p><img src="http://ogopjinry.bkt.clouddn.com/abstract%20factory.jpg" alt="abstract factory"></p><p>跟普通工厂一样，主要的类还是4个：</p><p><code>AbstractFactroy</code>：抽象工厂角色，声明了一组用于创建一种产品的方法，每个方法对应一种产品。</p><p><code>ConcreateFactroy</code>：具体工厂角色，实现在抽象工厂中定义的产品的方法，生成一组具体产品，这些产品构成一个产品种类，每个产品都位于某个产品等级结构中，如ConcreateFactroy1和ConcreateFactroy2。</p><p><code>AbstractProduct</code>：抽象产品角色，它为每种产品声明接口，如AbstractProductA和AbstractProductB。</p><p><code>ConcreateProduct</code>：具体产品角色，它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。</p><ul><li><p>适用场景</p><ol><li>一个系统要独立于它的产品的创建、组合和表示</li><li>一个系统要由多个产品系列中的一个来配置时</li><li>当需要强调一系列相关的产品对象的设计以便进行联合使用</li><li>当提供一个产品类库，只想显示它们接口而不是实现</li></ol></li></ul><p>缺点：</p><p>抽象工厂的缺点就是随着工厂类增多而导致类文件非常多，这个在实际开发中要权衡使用</p><h2 id="0x04-Builder-建造者模式"><a href="#0x04-Builder-建造者模式" class="headerlink" title="0x04 Builder(建造者模式)"></a>0x04 Builder(建造者模式)</h2><ul><li>使用动机</li></ul><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p><ul><li>适用场景</li></ul><ol><li>当要实例化的类是在运行时刻指定时，例如，通过动态装载；</li><li>为了避免创建一个与产品类层次平行的工厂类层次时；</li><li>当一个类的实例只能有几个不同状态组合中的一种时，建立相应得原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</li></ol><ul><li>通用UML图</li></ul><p><img src="http://ogopjinry.bkt.clouddn.com/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.jpg" alt="Builder"></p><p>建造者模式通常也是有4大部分组成</p><p>Product产品类: 产品的抽象类</p><p>Builder: 抽象Builder类，规范产品的组建，一般是由子类实现具体的构建过程</p><p>ConcreateBuilder： 具体的Builder类</p><p>Director： 统一组装过程</p><ul><li>要点分析</li></ul><blockquote><p>链式调用</p></blockquote><p>通常在开发中，Director可以当做内部类来处理，直接使用一个Builder来进行对象的组装，这个Buidler通常称为链式调用，它的关键点是每个setter方法都返回自身即<code>return this</code> 这样就使得setter方法可以称为链式调用，套路如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">new</span> TestBuilder().setA(<span class="string">"A"</span>).setB(<span class="string">"B"</span>).create();</span><br></pre></td></tr></table></figure><blockquote><p>Dialog的经典实现</p></blockquote><h2 id="0x05-单例模式"><a href="#0x05-单例模式" class="headerlink" title="0x05 单例模式"></a>0x05 单例模式</h2><ul><li>使用动机</li></ul><p>保证一个类仅有一个实例，而且自行实例化并向整个系统提供这个实例</p><ul><li>使用场景</li></ul><ol><li>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时</li><li>当这个唯一实例应该是通过子类化可以扩展，并且客户应该无需更改代码就可以使用一个扩展的实例时</li></ol><ul><li>核心UML图</li></ul><p><img src="http://ogopjinry.bkt.clouddn.com/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.jpeg" alt=""></p><p>核心角色有2个</p><p><code>Client</code>  高层客户端<br><code>Singleton</code> 单例类</p><ul><li>要点分析</li></ul><ol><li>构造函数不对外开放，一般为Private</li><li>通过一个静态方法或者枚举类返回单例类对象</li><li>确保单例类的对象有且只有一个，尤其是在多线程的环境下</li><li>确保单例类对象在反序列化是不会重新构建对象</li><li>实现方式：</li></ol><p>单例看似简单，其实很有门道的，常见的比如<code>饿汉模式</code>、<code>懒汉模式</code> 、<code>双重检验(valtile)</code>等，下面将一一道来。</p><blockquote><p>饿汉模式&amp;懒汉模式</p></blockquote><p>首先需要介绍下什么是<code>延迟加载</code>，即等到真正使用的时候才去创建实例，不用的时候不去创建实例。</p><p>因此从速度和反应时间角度来看，非延时加载(饿汉模式)好,从资源利用率上看，延时加载(又称懒汉模式)好。<br>先从两个简单的入手：</p><p>第一种：非延时加载(饿汉模式)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种：同步延迟加载(懒汉模式)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>双重检验(valtile) 同步延时加载</p></blockquote><p>第三种：双重检测同步延迟加载(懒汉模式)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DCSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span>  <span class="keyword">static</span>  DCSingleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DCSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DCSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DCSingleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> DCSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种单例方式在java中会行不通的，可以看到上面的代码对instance进行二次检查，第一层判断是为了避免不必要的同步，第二层判断是为了在null情况下创建实例，目的是避开过多的同步，需要声明instance时定义为volatile即可。java中之所以需要双重加锁进行单例，是由于java内存模型允许<code>无序写入</code>，假设未加上关键字volatile时，执行到instance=new Singleton()时，实际上它并不是一个原子操作，会被编译成多条汇编指令，大致做了3件事：</p><p>(1)给DCSingleton 的实例分配内存<br>(2)调用DCSingleton()的构造函数，初始化成员字段<br>(3)将instance对象指向分配的内存空间(此时instance就不是null)</p><p>由于java编译器<code>无序写入</code>，Cache、寄存器到主内存的回写顺序，上面第二第三条顺序是无法保证的，即可以是1-2-3也有可能是1-3-2，如果是后者，并且在3执行完毕、2未执行之前，被切换到线程B上，此时A线程已经执行了第三点，instance已经是非空了，B线程直接取走instance再使用时就会报错，这就是DCL失效的问题。而加上volatile关键字则禁止了指令的重排序从而避免了这个问题。</p><blockquote><p>更加优雅的单例</p></blockquote><p>DLC并不优雅，在《java 并发编程实践》一书中建议使用下面的单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BetterSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BetterSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BetterSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BetterSingleton instance = <span class="keyword">new</span> BetterSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式当第一次加载是不会初始化实例instance，只有第一次调用getInstance方法时才会导致instance被初始化。这样不会能够确保线程安全，也能够保证单例对象的唯一性，同时也延时了单例的实例化，这是推荐的单例模式实现方式</p><blockquote><p>使用容器实现单例模式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; objMap = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SingletonManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String key,Object instance)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!objMap.containsKey(key))&#123;</span><br><span class="line">            objMap.put(key,instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getService</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> objMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在程序的初始将多种单例类型注入到一个统一的管理类中，在使用时根据key获取对象对应类型的对象，这种方式使得我们可以管理多种类型的单例，并且在使用可以通过统一的接口进行获取操作，降低了用户的成本，也对用户隐藏了具体实现，降低了耦合度。</p><h2 id="0x06-策略模式"><a href="#0x06-策略模式" class="headerlink" title="0x06 策略模式"></a>0x06 策略模式</h2><ul><li>使用动机</li></ul><p>策略模式定义了一些列的算法，并将每一个算法封装起来，而且使他们可以相互替换。。策略模式让算法独立于使用它的客户端而独立变化。</p><ul><li>使用场景</li></ul><ol><li>针对同一问题的多种处理方式，仅仅是具体行为有差别时</li><li>需要安全地封装多种同一类型的操作时</li><li>出现同一抽象类有多个子类，而又需要使用if-else或者switch-case来选择具体子类时</li></ol><ul><li>核心UML图</li></ul><p><img src="http://ogopjinry.bkt.clouddn.com/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.jpeg" alt="策略模式"></p><p>策略模式主要有3个核心</p><p><code>Context</code>: 用来操作策略的上下文环境</p><p><code>Stragety</code>:策略的抽象</p><p><code>ConcreateStragetyX</code>:具体策略的实现</p><ul><li>要点分析</li></ul><blockquote><p>通过一个Context(实际中可能称作Manager/Controller)结合注入的方式来管理不同的策略</p><p>干掉了多余的if-else</p><p>可扩展性变得很强</p></blockquote><p>缺点： 随着策略的增加，子类会变得繁多</p><h2 id="0x07责任链模式"><a href="#0x07责任链模式" class="headerlink" title="0x07责任链模式"></a>0x07责任链模式</h2><ul><li>动机</li></ul><p>使很多对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，将这些对象连成一条链，并沿着这条链条传递，直到有一个对象处理它为止。</p><ul><li>使用场景</li></ul><ol><li>有多个的对象可以处理一个请求，哪个对象处理该请求，运行时刻自动确定</li><li>你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求<br>3.可处理一个请求的对象集合应被动态指定</li></ol><ul><li>核心UML</li></ul><p><img src="http://ogopjinry.bkt.clouddn.com/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.png" alt="责任链模式"></p><p>主要抽象成两个角色：</p><p><code>Hanlder</code>: 抽象处理者角色，声明一个请求处理的方法，并在其中保持Handler对象的引用</p><p><code>ConcreateHanlder</code>: 具体处理者角色，对请求进行处理，如果不能处理则将该请求转发给下一个节点上的对象处理</p><ul><li>要点分析</li></ul><blockquote><p>精髓在与保持Handler对象的引用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Handler successor;<span class="comment">//下一节点的处理者</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String condition)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通常，责任链中的请求和处理规则是不尽相同的，在这种请求下可以将请求进行封装，同时对请求的处理规则也进行封装作为一个独立的对象</p></blockquote><p>下面将介绍一下基于核心UML的稍微复杂的扩展，UML图如下：</p><p><img src="http://ogopjinry.bkt.clouddn.com/%E5%A4%8D%E6%9D%82%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.png" alt="复杂责任链"></p><blockquote><p>android源码中最典型就是Touch事件的分发</p><p>可以借鉴责任链的思想来优化 有序广播</p><p>优缺点</p></blockquote><ol><li><p>最大的缺点就是对链中请求的遍历，如果处理者爱多那么遍历必定会影响性能，特别是在一些递归调用中，需要谨慎使用</p></li><li><p>优点显而易见，就是请求者和处理者的关系解耦</p></li></ol><h2 id="0x07-状态模式"><a href="#0x07-状态模式" class="headerlink" title="0x07 状态模式"></a>0x07 状态模式</h2><ul><li>使用动机</li></ul><p>允许一个对象再起内部状态改变时改变它的行为，这个对象看起来像是改变了其类</p><ul><li>使用场景</li></ul><ol><li>一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为</li><li>代码中包含大量与对象状态有关的条件语句，且这些分值依赖于该对象的状态。状态模式将每一个条件分值放入一个独立的类中，使得可以根据对象自身情况将对象的状态作为一个对象，这个对象可以不依赖于其他对象而独立变化，这样通过多态来去除过多的、重复的if-else等分支语句</li></ol><ul><li>核心UML图</li></ul><p><img src="http://ogopjinry.bkt.clouddn.com/state.jpg" alt="state"></p><p>抽象成3和核心角色</p><p><code>Context</code>: 环境类，定义客户感兴趣的接口，维护一个State子类实例，这个子类定义了对象当前的状态</p><p><code>State</code>: 抽象状态类或者状态接口，定义一个或者一组接口，表示该状态下的行为</p><p><code>ConcreateX</code>: 具体状态类，每一个具体的状态类实现抽象State中定义的接口，从而达到不同的行为</p><ul><li>要点分析</li></ul><ol><li>状态模式的关键是在不同的状态下对于同一行为在不同状态下有着不同的响应</li></ol><h2 id="0x08-观察者模式"><a href="#0x08-观察者模式" class="headerlink" title="0x08 观察者模式"></a>0x08 观察者模式</h2><ul><li>使用动机</li></ul><p>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并且被自动更新</p><ul><li>使用场景</li></ul><ol><li>关联行为场景，需要注意的是关联行为是可拆分的，而不是组合关系</li><li>事件多级触发场景</li><li>跨系统的消息交换场景，如消息队列，事件总线的处理机制</li></ol><ul><li>核心UML图</li></ul><p><img src="http://ogopjinry.bkt.clouddn.com/Observer.jpg" alt="Observer"></p><p>核心为2个</p><p><code>Observer</code>:抽象观察者，该角色是观察者的抽象类，它定义了一个更新接口，使得在主题更改时通知更新自己</p><p><code>ConcreateObserver</code>: 具体的观察者，该角色实现抽象观察者角色所定义的更新接口，以便在主题的状态发生改变时更新自己</p><ul><li>要点分析</li></ul><p>1.在java中观察者可以继承Observer,发布者可以继承Observable来迅速实现</p><p>2.观察者模式最经典的就是listview的adapter，当然也有EventBus这种事件总线的库也是采用观察者模式</p><blockquote><p>Note：</p><p><code>Step1</code>在ListView中设置Adapter时会构建一个AdapterDataSetObserver,并且注册到Adapter中，这就是一个<code>观察者</code>。Adapter中包含一个数据集<code>可观察者</code>DataSetObservable。<br><code>Step2</code> 在数据发生变更时，开发者手动调用Adapter.notifyDataSetChanged,而notifyDataSetChanged会去调用notifyChanged函数，该函数会遍历所有观察者的onChanged函数。<br><code>Step3</code> 在AdapterDataSetObserver的onChanged函数中会获取Adapter中数据集的新数据，然后调用ListView的requestLayout()方法重新布局更新用户界面</p></blockquote><h2 id="0x09-代理模式"><a href="#0x09-代理模式" class="headerlink" title="0x09 代理模式"></a>0x09 代理模式</h2><ul><li>使用动机</li></ul><p>为其他对象提供一种代理以控制这个对象的访问。</p><ul><li>适用场景</li></ul><ol><li>当无法或者不想直接访问某个对象或者访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口</li></ol><ul><li>核心UML图</li></ul><p><img src="http://ogopjinry.bkt.clouddn.com/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.jpg" alt="代理模式"></p><p>主要有3个角色组成：<br><code>Subject</code>:抽象主题类,该类主要职责是声明真实主题与代理的共同接口方法，该类既可以是一个接口也可以是一个接口</p><p><code>RealSubject</code>:真实主题类,该类也被称为委托类或被代理类，该类定义了代理表示的真实对象，由其执行具体的业务逻辑方法。</p><p><code>ProxSubject</code>:代理类,该类也称为委托类，该类持有一个对真实主题类的引用,在其所实现的接口方法中调用真实主题类中相应的接口方法执行，以此起到代理的作用</p><p><code>Client</code>: 客户类，即使用代理类的类型</p><ul><li>要点分析</li></ul><ol><li>通常代理模式分为<code>静态代理</code>、<code>动态代理</code>,静态代理即在我们的代码运行前代理类的class编译文件就已经存在，而动态代理则与静态代理相反，通过反射机制动态地生成代理者对象，而java也给我们提供了一个便捷的动态代理接口InvocationHandler实现该接口需要重写其调用方法invoke</li><li>静态代理和动态代理只是从code方面来区分代理模式的两种方法，我们也可以通过适用范围来区分不同类型的代理实现<ul><li>远程代理(Remote Proxy):为某个对象在不同的内存地址空间提供局部代理，使系统可以将Server部分实现隐藏，以便Client可以不考虑Server的存在</li><li>虚拟代理(Virtual Proxy):虚拟代理经常直到我们真正需要一个对象时才创建它，当对象在创建前和创建中时，由虚拟代理来扮演对象的替身，对象创建后，代理就会将请求直接委托给对象</li><li>保护代理（Protection Proxy):使用代理控制对原始对象的访问,该类型的代理常用于原始对象有着不同的访问权限的情况<a href="http://blog.csdn.net/shuangde800/article/details/10381495" target="_blank" rel="noopener">保护模式实例</a></li></ul></li></ol><p>未完待续……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00-概述&quot;&gt;&lt;a href=&quot;#0x00-概述&quot; class=&quot;headerlink&quot; title=&quot;0x00 概述&quot;&gt;&lt;/a&gt;0x00 概述&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="设计模式" scheme="https://xsfelvis.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://xsfelvis.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="常用设计模式" scheme="https://xsfelvis.github.io/tags/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式六大原则</title>
    <link href="https://xsfelvis.github.io/2016/11/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%A5%E9%97%A8/"/>
    <id>https://xsfelvis.github.io/2016/11/13/设计模式入门/</id>
    <published>2016-11-12T16:00:00.000Z</published>
    <updated>2018-06-04T04:56:55.754Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>本文主要介绍设计模式的六大原则，这是学习设计模式的总纲。</p><p>设计模式其实是一套被反复使用、总结出来的代码设计经验的总结，使用设计模式是为了重用代码，让代码更加容易的被他人理解，保证代码的可靠性。在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。</p><p>四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。</p><ul><li>对接口编程而不是对实现编程。</li><li>优先使用对象组合而不是继承。</li></ul><h2 id="0x01-设计模式六大原则"><a href="#0x01-设计模式六大原则" class="headerlink" title="0x01 设计模式六大原则"></a>0x01 设计模式六大原则</h2><blockquote><p> 单一职责</p></blockquote><p>一个类只负责一项职责</p><blockquote><p>里氏替换原则</p></blockquote><p>所有引用基类的地方必须透明的使用其子类的对象。该原则是面向对象设计的基本原则之一，是继承复用的基石。只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正的被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充，实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现</p><blockquote><p>依赖倒转原则</p></blockquote><p>这是开闭原则的基础：针对接口编程，依赖于抽象而不依赖于具体</p><blockquote><p>接口隔离原则</p></blockquote><p>使用多个隔离的接口，比使用单个接口要好。还有就是降低类之间的耦合度。</p><blockquote><p>迪米特法则</p></blockquote><p>又称最少知道原则，即一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立</p><h2 id="0x02-设计模式类型"><a href="#0x02-设计模式类型" class="headerlink" title="0x02 设计模式类型"></a>0x02 设计模式类型</h2><p>通常设计模式分为23种，划分为3大类</p><ul><li>创建型模式</li><li>结构型模式</li><li>行为型模式</li></ul><blockquote><p>创建型模式</p></blockquote><p>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用新的运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p><ul><li>工厂模式（Factory Pattern）</li><li>抽象工厂模式（Abstract Factory Pattern）</li><li>单例模式（Singleton Pattern）</li><li>建造者模式（Builder Pattern）</li><li>原型模式（Prototype Pattern）</li></ul><blockquote><p>结构型模式</p></blockquote><p>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p><ul><li>适配器模式（Adapter Pattern）</li><li>桥接模式（Bridge Pattern）</li><li>过滤器模式（Filter、Criteria Pattern）</li><li>组合模式（Composite Pattern）</li><li>装饰器模式（Decorator Pattern）</li><li>外观模式（Facade Pattern）</li><li>享元模式（Flyweight Pattern）</li><li>代理模式（Proxy Pattern）</li></ul><blockquote><p>行为型模式</p></blockquote><p>这些设计模式特别关注对象之间的通信。</p><ul><li>责任链模式（Chain of Responsibility Pattern）</li><li>命令模式（Command Pattern）</li><li>解释器模式（Interpreter Pattern）</li><li>迭代器模式（Iterator Pattern）</li><li>中介者模式（Mediator Pattern）</li><li>备忘录模式（Memento Pattern）</li><li>观察者模式（Observer Pattern）</li><li>状态模式（State Pattern）</li><li>空对象模式（Null Object Pattern）</li><li>策略模式（Strategy Pattern）</li><li>模板模式（Template Pattern）</li><li>访问者模式（Visitor Pattern）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00-概述&quot;&gt;&lt;a href=&quot;#0x00-概述&quot; class=&quot;headerlink&quot; title=&quot;0x00 概述&quot;&gt;&lt;/a&gt;0x00 概述&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="设计模式" scheme="https://xsfelvis.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://xsfelvis.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="solid" scheme="https://xsfelvis.github.io/tags/solid/"/>
    
  </entry>
  
  <entry>
    <title>MAC使用记录</title>
    <link href="https://xsfelvis.github.io/2016/10/29/MAC%20%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <id>https://xsfelvis.github.io/2016/10/29/MAC 使用记录/</id>
    <published>2016-10-28T16:00:00.000Z</published>
    <updated>2018-06-04T04:53:41.900Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h2><p>使用MAC一些记录，方面以后更换设备时候查阅，不断更新</p><h2 id="ox01-软件包"><a href="#ox01-软件包" class="headerlink" title="ox01 软件包"></a>ox01 软件包</h2><blockquote><p>包括常用的工作软件<br><a href="百度云地址">http://pan.baidu.com/s/1bNRkdS</a></p></blockquote><p>加密后的提取码：ejZmOA== （8*8）</p><ul><li>Android studio</li><li>CleanMyMac</li><li>charles</li><li>Mweb</li><li>sublime</li><li>Tunnelblick</li><li>sourceTree</li><li>office</li><li>gasMark</li><li>jdk</li><li>xmind</li><li>evernote</li></ul><p>推荐一个常用的软件下载地址<a href="xclient.info">http://xclient.info/</a></p><h2 id="ox02插件"><a href="#ox02插件" class="headerlink" title="ox02插件"></a>ox02插件</h2><blockquote><p>zsh<br>其实装机时mac已经预制了很多脚本工具<br>在 /etc/shells 中<br>手动安装：</p></blockquote><ol><li><p>clone 项目到本地<br><code>git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</code></p></li><li><p>创建一个zsh的一个配置<br>要是已经有一个~/.zshrc文件的话，建议先备份，使用命令<br><code>cp ~/.zshrc ~/.zshrc.orig</code><br>然后开始创建zsh的配置文件<br><code>cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</code></p></li><li><p>设置zsh为你默认的shell<br><code>chsh -s /bin/zsh</code></p></li></ol><blockquote><p>git</p></blockquote><p>开发必备，这里说一下一台电脑管理多个git账号<br>在 .ssh文件夹中建立一个名称为config无后缀文本,管理你的id_rsa,其中github的不要重新命名就用两次enter之后自动生成的，有的公司会屏蔽github端口，在这个配置文件中可以更改端口<br>比如我的config文件管理了github和公司的gitlab（敏感信息已屏蔽）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User your github name</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">port 443</span><br><span class="line"></span><br><span class="line">Host your git host name</span><br><span class="line">User your git name</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_ne </span><br><span class="line">port 80</span><br></pre></td></tr></table></figure><p>上面的~/.ssh/id_rsa_ne 是在生成id_rsa时按完第一个enter输入你定义的名称，github用默认的id_rsa否则ssh -T git@github会出错的</p><blockquote><p>adb  环境配置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xsfelvis@xsfelviss-Mac-mini:~</span><br><span class="line">&gt; echo $HOME </span><br><span class="line">/Users/xsfelvis</span><br><span class="line"></span><br><span class="line">xsfelvis@xsfelviss-Mac-mini:~</span><br><span class="line">&gt; touch .bash_profile</span><br><span class="line"></span><br><span class="line">xsfelvis@xsfelviss-Mac-mini:~</span><br><span class="line">&gt; open -e .bash_profile</span><br></pre></td></tr></table></figure><p>打开之后输入sdk下platform-tools的路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$&#123;PATH&#125;:~/Library/Android/sdk/platform-tools</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00&quot;&gt;&lt;a href=&quot;#0x00&quot; class=&quot;headerlink&quot; title=&quot;0x00&quot;&gt;&lt;/a&gt;0x00&lt;/h2&gt;&lt;p&gt;使用MAC一些记录，方面
      
    
    </summary>
    
      <category term="工具" scheme="https://xsfelvis.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="MAC" scheme="https://xsfelvis.github.io/tags/MAC/"/>
    
  </entry>
  
  <entry>
    <title>认识Dalvik虚拟机</title>
    <link href="https://xsfelvis.github.io/2016/10/20/%E8%AE%A4%E8%AF%86Dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>https://xsfelvis.github.io/2016/10/20/认识Dalvik虚拟机/</id>
    <published>2016-10-19T16:00:00.000Z</published>
    <updated>2018-06-04T04:49:24.641Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>虽然Android平台使用java开发，但是android程序去不是运行在标准java虚拟机上，为了解决移动设备软件运行效率问题及规避Oracle公司版权，Google为android平台专门设计一套虚拟机来运行Android程序，即Dalvik Virtual Manchine(Dalvik 虚拟机)，它的作者是Dan Bornstein,名称由来于他祖先曾居住过的名叫Dalvik的小渔村</p><h1 id="Dalvik虚拟机的特点"><a href="#Dalvik虚拟机的特点" class="headerlink" title="Dalvik虚拟机的特点"></a>Dalvik虚拟机的特点</h1><blockquote><p>主要特点</p></blockquote><ul><li>体积小</li><li>专有的DEX可执行文件，体积小执行速度快</li><li>常量池采用32位索引值，寻址类方法名称、字段名、常量更快</li><li>基于寄存器架构，拥有自己的一套完整指令系统</li><li>提供了对象生命周期管理、堆栈管理、线程管理、安全和异常管理以及垃圾回收等重要功能</li><li>所有的Android程序都运行在Android系统进程里，每个进程都对应着一个Dalvik虚拟机实例</li></ul><h1 id="Dalvik虚拟机与java虚拟机区别"><a href="#Dalvik虚拟机与java虚拟机区别" class="headerlink" title="Dalvik虚拟机与java虚拟机区别"></a>Dalvik虚拟机与java虚拟机区别</h1><ul><li>1、Java虚拟机运行的是Java字节码，Dalvik运行的是Dalvik字节码</li></ul><p>所有的Dalvik字节码由Java字节码转换而来，并被打包到一个DEX可执行文件，Dalvik虚拟机通过解释DEX文件来执行这些字节码</p><ul><li>2、Dalvik可执行文件体积更小</li></ul><p>Android SDK中有一个叫dx的工具负责将java字节码转换为Dalvik字节码。dx工具将Java类文件重新排列，消除类文件中出现的所有冗余信息，避免虚拟机初始化时出现重复的文件加载与解析过程。</p><p>（注：一般情况下，Java类文件包含多个不同的方法签名，如果其他的类文件引用该类文件中的方法，方法签名也会复制到其中，就会造成多个不同的类会同时包含相同的方法签名，同样的，大量的字符串常量在多个类文件中也会被重复使用，这些冗余信息会直接增加文件的体积，），同时也会严重影响虚拟机解析文件的效率。</p><p>dx工具针对这个做了专门的处理，它将所有java类文件中常量池进行分解，消除其中的冗余信息，重新形成一个常量池，所有类文件共享同一个常量池，从而减小了体积</p><p><img src="http://i.imgur.com/nwkRTaC.png" alt=""></p><ul><li>3、Java虚拟机与Dalvik虚拟机架构不同</li></ul><blockquote><p>架构不同</p></blockquote><p>Java虚拟机基于栈架构，程序在运行时虚拟机需要频繁的从栈上读取或者写入数据，该过程需要更多的指令分派和内存访问，耗费CPU时间<br>，Dalvik虚拟机基于寄存器架构，数据访问通过寄存器间接传递，这样访问要比基于栈的方式要快很多。</p><blockquote><p>虚拟机运行状态不同</p></blockquote><p>Java虚拟机的指令集被称为零地址形式的指令集，所谓零地址形式，是指指令的源参数与目标参数都是隐含的，通过Java虚拟机中提供的一种数据结构“求值栈”来传递。对于Java程序来说，每个线程在执行时都有一个PC计数器与一个Java栈，PC计数器只对当前方法有效，Java虚拟机通过它的值来取指令执行,Java栈用于记录java方法调用的“活动记录”，Java栈以帧为单位保存线程的运行状态</p><p><img src="http://i.imgur.com/AwvCDiN.png" alt=""></p><p>第一条指令 iload_1 表示将第二个int类型局部变量进栈</p><p>第三条指令 iadd 从栈顶弹出两个int类型值，将值相加，然后把结果压回栈顶</p><p>第四、五条指令 分别压入第一个和第二个参数</p><p>第六条指令 isub 从栈顶弹出两个int类型值，将值相减，然后把结果压回栈顶</p><p>第七条指令 imul从栈顶弹出两个int型值，将两值相乘，然后把结果压回栈顶</p><p>第八条指令 ireturn返回一个int值</p><p>Dalvik虚拟机运行时同样为每个线程维护一个PC计数器与调用栈，与Java虚拟机不同的是，这个调用栈维护一份寄存器列表，同样的程序Dalvik命令明显减少</p><p><img src="http://i.imgur.com/9F7jahW.png" alt=""></p><h1 id="所处位置"><a href="#所处位置" class="headerlink" title="所处位置"></a>所处位置</h1><p>Android 系统架构采用分层思想，Dalvik虚拟机位于Android运行时环境，它与一些核心库共同承担Android应用程序的运行工作</p><p><img src="http://i.imgur.com/9RhIzBQ.png" alt=""></p><p>android启动加载完内核后，第一个执行的是init进程，init进程首先要做的是设备初始化，然后读取init.rc文件并启动系统中的重要的外部程序Zygote。</p><p>Zygote进程是Android所有进程的孵化器进程，它启动后会首先初始化Dalvik虚拟机，然后启动system_server并进入Zygote模式，通过socket等候命令。当执行一个Android应用程序时，system_server进程通过socket方式发送命令给zygote，zygote收到命令之后通过fork自身创建一个Daalvik虚拟机的实例来执行应用程序的入口程序，这样一个程序就启动完了</p><p>其中Zygote提供了三种创建进程的方法</p><ul><li>fork(),创建一个Zygote进程</li><li>forkAndSecialize(),创建一个非Zygote进程</li><li>forkSystemSever（），创建一个系统服务进程</li></ul><p>其中Zygote进程可以再fork出其他进程，非zygote进程则不能fork其他进程，而服务系统的进程终止后它的子进程也必须终止。</p><h1 id="关于Dalvik虚拟机JIT（即时编译）"><a href="#关于Dalvik虚拟机JIT（即时编译）" class="headerlink" title="关于Dalvik虚拟机JIT（即时编译）"></a>关于Dalvik虚拟机JIT（即时编译）</h1><p>JIT 又称动态编译，是一种通过在运行时将字节码翻译为机器码的技术，使得程序的执行速度更快，在Android2.2版本的Dalvik虚拟机引入了JIT技术</p><p>主流的JIT包含两种字节码编译方式</p><ul><li>method方式 以函数或者方法为单位进行编译</li><li>trace方式 以trace为单位进行编译</li></ul><p>注：trace是指：在函数中一般很少顺序执行代码的，多数代码都被分为好几条执行路径，其中有的函数路径实际过程很少被执行的，这部分被称为冷路径，而执行比较频繁的被称为热路径，采用传统的method方式会编译整个方法的代码，这会使得冷路径上浪费很多编译时间，并且耗费更多的内存：trace方式编译则能够快速的获取热路径代码，使用更短的时间与更少的内存来编译代码，目前Dalvik虚拟机默认采用trace方式编译代码同时也支持method方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;虽然Android平台使用java开发，
      
    
    </summary>
    
      <category term="Android" scheme="https://xsfelvis.github.io/categories/Android/"/>
    
    
      <category term="Dalvik" scheme="https://xsfelvis.github.io/tags/Dalvik/"/>
    
  </entry>
  
  <entry>
    <title>Android可执行文件</title>
    <link href="https://xsfelvis.github.io/2016/10/19/Android-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"/>
    <id>https://xsfelvis.github.io/2016/10/19/Android-可执行文件/</id>
    <published>2016-10-18T16:00:00.000Z</published>
    <updated>2018-06-04T04:48:22.424Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Android程序的生成"><a href="#Android程序的生成" class="headerlink" title="Android程序的生成"></a>Android程序的生成</h1><p>通常分为7步</p><ul><li>打包资源，生成R.java文件</li></ul><p>打包资源的工具aapt位于android-sdk\platform-tools目录下</p><ul><li>处理aidl文件，生成相应的java文件，对没有使用到aidl的android工程这一步可以跳过</li></ul><p>使用到的工具为aidl，位于android-sdk\platform-tools目录下</p><ul><li>编译工程源码，生成相应的class文件</li></ul><p>这一步调用javac编译工程src目录下所有的java源文件，生成的class文件位于工程的bin\classes目录下</p><ul><li>转换所有的class文件，生成classes.dex文件</li></ul><p>android系统Dalvik虚拟机的可执行文件为DEX格式，程序运行所需的classes.dex就是在这一步生成的，使用到的工具为dx，位于android-sdk\platform-tools</p><ul><li>打包生成APK文件</li></ul><p>打包的工具为apkbuilder，位于android-sdk\tools目录</p><ul><li>对APK文件进行签名</li></ul><p>Android的应用程序需要签名才能在Android设备上安装，在编译调试时候会使用一个debug.keystore对apk签名，另一种是打包发布时候进行签名，需要提供一个符合android开发文档中要求的签名</p><ul><li>对签名后的APK文件进行对齐处理</li></ul><p>使用工具zipalign，位于android-sdk\tools目录，主要工作就是将apk包进行对齐处理，使得apk包中所有资源文件距离文件起始偏移为4字节整数倍，这样通过内存映射访问apk文件时速度会更快</p><h1 id="dex文件格式"><a href="#dex文件格式" class="headerlink" title="dex文件格式"></a>dex文件格式</h1><blockquote><p>数据类型</p></blockquote><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>u1</td><td>等同于unit8_t,表示1字节的无符号数</td><td></td></tr><tr><td>u2</td><td>等同于unit16_t,表示2字节的无符号数</td><td></td></tr><tr><td>u4</td><td>等同于unit32_t,表示4字节的无符号数</td><td></td></tr><tr><td>u8</td><td>等同于unit64_t,表示8字节的无符号数</td><td></td></tr><tr><td>sleb128</td><td>有符号LEB128,可变字节1~5字节</td><td></td></tr><tr><td>uleb128</td><td>无符号LEB128,可变字节1~5字节</td><td></td></tr><tr><td>sleb128p1</td><td>无符号LEB128值加1,可变字节1~5字节</td><td></td></tr></tbody></table><blockquote><p>dex文件整体结构</p></blockquote><p>dex文件的整体结构比较简单，它是由多个结构组合而成的，一共有7个部分组成：</p><p>dex header——指定了dex文件的一些属性，并记录了其他6各部分数据结构在dex文件中的物理偏移</p><p>string_ids到class_def结构可以理解为“索引结构区”</p><p>data：真实的数据存放区</p><p>link_data:静态链接数据区</p><p><img src="http://i.imgur.com/pi8sQPd.png" alt=""></p><h1 id="odex文件"><a href="#odex文件" class="headerlink" title="odex文件"></a>odex文件</h1><p>odex文件的结构可以理解为dex文件的一个超集，它在dex文件头部添加了一些数据，然后在dex文件尾部添加了dex文件的依赖库以及一些辅助效果</p><p><img src="http://i.imgur.com/z86H4Py.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Android程序的生成&quot;&gt;&lt;a href=&quot;#Android程序的生成&quot; class=&quot;headerlink&quot; title=&quot;Android程序的生成&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Android" scheme="https://xsfelvis.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://xsfelvis.github.io/tags/Android/"/>
    
      <category term="dex" scheme="https://xsfelvis.github.io/tags/dex/"/>
    
  </entry>
  
</feed>
