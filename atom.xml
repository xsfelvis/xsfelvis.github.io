<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>渡口一艘船</title>
  
  <subtitle>不积跬步，无以至千里；不积小流，无以成江海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xsfelvis.github.io/"/>
  <updated>2019-02-22T14:49:21.165Z</updated>
  <id>https://xsfelvis.github.io/</id>
  
  <author>
    <name>云来</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解动态代理</title>
    <link href="https://xsfelvis.github.io/2019/02/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>https://xsfelvis.github.io/2019/02/22/深入理解动态代理/</id>
    <published>2019-02-21T16:00:00.000Z</published>
    <updated>2019-02-22T14:49:21.165Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>千山鸟飞绝，万径人踪灭。</p><p>孤舟蓑笠翁，独钓寒江雪</p><p>——唐·柳宗元《江雪》</p><p>首发于我的公众号</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU5OTgzNzM0NA==&amp;mid=2247483807&amp;idx=1&amp;sn=2981adda8dd17924cda1c9b05ad17f58&amp;chksm=feaf9e50c9d8174662f43f039de9b500094635d83fbff1a4df2c0923ef51dffbf11a2ae0d135&amp;token=722070929&amp;lang=zh_CN#rd" target="_blank" rel="noopener">深入理解动态代理</a></p></blockquote><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>最近在阅读retrofit源码时,有个关键的所在就是动态代理，细细回想了一下动态代理,发现之前有些细节还没有理解到位，本篇博文将重新深入理解一下动态代理。</p><h1 id="二、关于代理"><a href="#二、关于代理" class="headerlink" title="二、关于代理"></a>二、关于代理</h1><p>中华名族是一个含蓄的名族，讲究微妙和间接的交流方式。对象之间的间接通信也是同样是面向对象设计中一条重要的审美观，迪米特法则也指出“一个对象应该对其他对象保持最少的了解”,间接间通信可以达到“高内聚，低耦合”的效果。<br>代理是一种重要的手段之一，比如生活中的微商代理，厂家委托其代理销售商品，我们只跟微商打交道，不知道背后的“厂家是谁”，微商和厂家就可以抽象为 “代理类”和“委托类”，这样就可以，隐藏委托类的实现、实现客户与委托类之间的解耦，可以不用修改委托类的情况下做一些额外的处理</p><h2 id="2-1、代理模式简介"><a href="#2-1、代理模式简介" class="headerlink" title="2.1、代理模式简介"></a>2.1、代理模式简介</h2><p>在《Java与模式》一书中指出”代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的访问”，类图如下<br><img src="https://user-gold-cdn.xitu.io/2019/2/22/16915a41d98d4237?w=1172&amp;h=422&amp;f=png&amp;s=38943" alt="image.png"><br>通过类图可以发现，代理模式的代理对象<code>Proxy</code>和目标对象<code>Subject</code>实现同一个接口，客户调用的是<code>Proxy</code>对象，<code>Proxy</code>可以控制<code>Subject</code>的访问，真正的功能实现是在<code>Subject</code>完成的。</p><p>适用场景:</p><ul><li>不希望某些类被直接访问。<br></li><li>访问之前希望先进行一些预处理。<br></li><li>希望对被访问的对象进行内存、权限等方面的控制。 </li></ul><p>优点如下</p><ul><li>代理模式是通过使用引用代理对象来访问真实对象，在这里代理对象充当用于连接客户端和真实对象的中介者。<br></li><li>代理模式主要用于远程代理、虚拟代理和保护代理。其中保护代理可以进行访问权限控制。<br></li></ul><h2 id="2-2、静态代理"><a href="#2-2、静态代理" class="headerlink" title="2.2、静态代理"></a>2.2、静态代理</h2><p>“静态”代理，若代理类在程序运行前已经存在，这种通常称为静态代理，比如微商A只代理A品牌的面膜,消费者通过微商才能买到某厂的面膜(控制权)，其中微商和工厂都实现了了Sell的接口</p><blockquote><p>委托类面膜工厂</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">FactoryOne</span> :<span class="type">SellMask&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">sell</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"FactoryOne: 来自工厂A的面膜"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>微商静态代理</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BusinessAgent</span> : <span class="type">SellMask &#123;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> sellMask: SellMask</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        sellMask = FactoryOne()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">sell</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"BusinessAgent: 微商代理开始在朋友圈打广告"</span>)</span><br><span class="line">        sellMask.sell()</span><br><span class="line">        print(<span class="string">"BusinessAgent: 赚了一大把"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共同接口<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SellMask</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sell</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-3、相似模式的比较"><a href="#2-3、相似模式的比较" class="headerlink" title="2.3、相似模式的比较"></a>2.3、相似模式的比较</h2><p>既然获得引用就可以做一些扩展之类的事情，这点跟装饰者模式、适配器模式看起来很像，三者都属于结构型模式，但是代理模式核心是为其它对象提供一种代理以控制对这个对象的访问()<br><br></p><blockquote><p>代理模式 VS 适配器模式</p></blockquote><p>看上去很像，它们都可视为一个对象提供一种前置的接口，但是适配器模式的用意是改变所考虑的对象的接口，而代理模式并不能改变所代理的对象的接口，这一点上两个模式有着明显的区别，下图分别是 对象适配器和类的适配器UML图</p><p><img src="https://user-gold-cdn.xitu.io/2019/2/22/16915a41d9a53c4a?w=1286&amp;h=900&amp;f=png&amp;s=82798" alt="image.png"><br><br></p><blockquote><p>代理模式VS 装饰模式</p></blockquote><p>装饰者模式与所装饰的对象有着相同的接口，这一点跟代理模式相同，但是装饰模式更强调为所装饰的对象提供增强功能，而代理模式则是对对象的使用施加控制，并不提供对象本身的增强功能；被代理对象由代理对象创建，客户端甚至不需要知道被代理类的存在；被装饰对象由客户端创建并传给装饰对象。装饰者UML图如下</p><p><img src="https://user-gold-cdn.xitu.io/2019/2/22/16915a41d9bb2a1a?w=1358&amp;h=590&amp;f=png&amp;s=78546" alt="image.png"></p><p>你以为这就完了吗？下面👇才是重头戏！</p><h1 id="三、深入理解动态代理"><a href="#三、深入理解动态代理" class="headerlink" title="三、深入理解动态代理"></a>三、深入理解动态代理</h1><h2 id="3-1、什么是动态代理"><a href="#3-1、什么是动态代理" class="headerlink" title="3.1、什么是动态代理"></a>3.1、什么是动态代理</h2><p>代理类在程序运行时创建的代理方式被成为 动态代理。即代理类并不是在代码中定义的，而是在运行时根据我们在Java代码中”规定”的信息自动生成。静态代理容易造成代码的膨胀，。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数。 还是以上面的卖面膜微商为例，她在进货市场进行一番比较之后再决定代理哪个品牌的面膜。</p><h2 id="3-2、如何使用动态代理"><a href="#3-2、如何使用动态代理" class="headerlink" title="3.2、如何使用动态代理"></a>3.2、如何使用动态代理</h2><p>跟上文一样，微商和面膜工厂都实现了sell接口，这里就不赘述了，下面看下与众不同的地方，实现动态代理需要实现InvocationHandler接口</p><blockquote><p>实现InvocationHandler接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object;<span class="comment">//被引用的代理</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newProxyInstance</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(object.getClass().getClassLoader(),object.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"代理商 包装发朋友圈"</span>);</span><br><span class="line">        Object result = method.invoke(object,args);</span><br><span class="line">        System.out.println(<span class="string">"代理商 赚钱"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>target 属性表示委托类对象</li><li><code>InvocationHandler</code>是负责连接代理类和委托类的中间类必须实现的接口。其中只有一个 invoke函数需要实现</li><li>invoke函数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br></pre></td></tr></table></figure><p>下面好好看看这个核心函数的参数含义</p><ul><li>proxy 代通过dynamicproxy.newProxyInstance(business)自动生成的代理类 $Proxy0.class(下文会详细介绍)</li><li>method表示代理对象被调用的函数，比如sellMask接口里面的sell方法</li><li>args 表示代理大力调用函数的的参数，这里sell方法无参数</li></ul><p>调用代理对象的每个函数，实际上最终都是走到InvocationHandler的invoke函数，因此可以在这里做一些统一的处理，AOP的雏形就慢慢出现了，我们也可以根据method方法名做一些判断，从而实现对某些函数的特殊处理。</p><blockquote><p>使用动态代理</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    System.getProperties().put(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>)  <span class="comment">//加入这个可以获取代理类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> maskFactory = FactoryMaskOne()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dynamicproxy: DynamicProxy = DynamicProxy()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sellMask: SellMask = dynamicproxy.newProxyInstance(maskFactory) <span class="keyword">as</span> SellMask</span><br><span class="line"></span><br><span class="line">    sellMask.sell()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将委托类面膜工程FactoryMaskOne传到dynamicproxy.newProxyInstance中，通过下面的函数返回了一个代理对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Object newProxyInstance(Object object) &#123;</span><br><span class="line">        this.object = object;</span><br><span class="line">        return Proxy.newProxyInstance(object.getClass().getClassLoader(),object.getClass().getInterfaces(),this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>实际代理类就是在这个时候动态生成的，后续调用到这个代理类的函数就会直接调用invoke函数，让我们细细看下这个Proxy.newProxyInstance</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure><p>法的三个参数含义分别如下：</p><ul><li>loader：定义了代理类的ClassLoder;</li><li>interfaces：代理类实现的接口列表</li><li>h：调用处理器，也就是我们上面定义的实现了InvocationHandler接口的类实例</li></ul><p>这里简单总结一下，委托类通过<strong>newProxyInstance </strong>方法获取动态生成的代理类的实例(本例是$Proxy0.class),然后可以通过这个代理类实例调用代理的方法获得委托类的控制权，对代理类的调用实际上都会走到invoke方法，在这里我们调用委托类的相应方法，并且可以添加自己的一些逻辑，比如统一处理登陆、校验之类的。</p><h2 id="3-3、动态生成的代理类-Proxy0"><a href="#3-3、动态生成的代理类-Proxy0" class="headerlink" title="3.3、动态生成的代理类$Proxy0"></a>3.3、动态生成的代理类$Proxy0</h2><p>在Android Studio中调用不了<code>ProxyGenerator</code>这个类,这个类在sun.misc包中,使用IntelliJ IDE创建java工程，需要看一下<a href="">jdk</a>的反射中Proxy和生成的代理类$Proxy0的源码，可以使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成$Proxy0的class文件</span></span><br><span class="line">System.getProperties().put(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><p>生成的代理类在com.sun.proxy包里面完整代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">SellMask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//可以看到接口方法都交由h的invoke方法处理，h在父类Proxy中定义为InvocationHandler接口</span></span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"dev.proxy.SellMask"</span>).getMethod(<span class="string">"sell"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从生成的代理类中可以看到</p><ul><li>动态生成的代理类是以<code>$Proxy</code>为类名前缀，继承自<code>Proxy</code>，并且实现了<code>Proxy.newProxyInstance(…)</code>第二个参数传入的所有接口的类。</li><li>接口方法都交由h的invoke方法处理，h在父类Proxy中定义为InvocationHandler接口，为Proxy.newProxyInstance(…)的第三个参数<h2 id="3-4-动态代理类如何生成"><a href="#3-4-动态代理类如何生成" class="headerlink" title="3.4 动态代理类如何生成"></a>3.4 动态代理类如何生成</h2></li><li>关注点1 Proxy.newProxyInstance(……)函数</li></ul><p>动态代理类是在调用 Proxy.newProxyInstance(……)函数时生成的，精简后的核心代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">        ……</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">         * 得到动态代理类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ……</span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//然后将InvocationHandler作为代理类构造函数入参新建代理类对象</span></span><br><span class="line">            <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">           ……</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到 首先调用它先调用<code>getProxyClass(loader, interfaces)</code>得到动态代理类，然后将<code>InvocationHandler</code>作为代理类构造函数入参新建代理类对象。</p><ul><li>关注点2  Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</li></ul><p>如何获取到 生成动态代理类呢，一步步追踪，我们发现，在Proxy#ProxyClassFactory类中，在ProxyGenerator中去生成动态代理，类名以$Proxy+num作为标记</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">       * Generate the specified proxy class.</span><br><span class="line">       */</span><br><span class="line">      byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">          proxyName, interfaces, accessFlags);</span><br><span class="line">      try &#123;</span><br><span class="line">          return defineClass0(loader, proxyName,</span><br><span class="line">                              proxyClassFile, 0, proxyClassFile.length);</span><br><span class="line">      &#125; catch (ClassFormatError e) &#123;</span><br><span class="line">          throw new IllegalArgumentException(e.toString());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇主要java中的代理模式以及跟其他模式的对比，并重点介绍了JDK中的动态代理机制，像AOP、retrofit核心机制之一就使用到了这种技术，但Java动态代理是基于接口的，如果对象没有实现接口我们该如何代理呢？那就需要CGLIB了，<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">CGLIB</a>(<em>Code Generation Library</em>)是一个基于<a href="http://www.baeldung.com/java-asm" target="_blank" rel="noopener">ASM</a>的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB通过继承方式实现代理，这里就不展开赘述了。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://juejin.im/post/5a99048a6fb9a028d5668e62" target="_blank" rel="noopener">https://juejin.im/post/5a99048a6fb9a028d5668e62</a></li><li><a href="https://juejin.im/post/5ad3e6b36fb9a028ba1fee6a" target="_blank" rel="noopener">https://juejin.im/post/5ad3e6b36fb9a028ba1fee6a</a></li><li><a href="http://www.cnblogs.com/xiaoluo501395377/p/3383130.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaoluo501395377/p/3383130.html</a></li><li><a href="https://www.zhihu.com/question/20794107" target="_blank" rel="noopener">https://www.zhihu.com/question/20794107</a></li><li><a href="https://blog.csdn.net/qq_27095957/article/details/80184291" target="_blank" rel="noopener">https://blog.csdn.net/qq_27095957/article/details/80184291</a></li><li><a href="http://a.codekk.com/detail/Android/Caij/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86" target="_blank" rel="noopener">http://a.codekk.com/detail/Android/Caij/公共技术点之 Java 动态代理</a></li><li><a href="https://www.jianshu.com/p/0391a8e93d3d" target="_blank" rel="noopener">https://www.jianshu.com/p/0391a8e93d3d</a></li></ul><blockquote><p>欢迎关注我的公众号，一起学习，共同提高~<br><br><img src="https://user-gold-cdn.xitu.io/2019/2/22/16915a41d97876fc?w=304&amp;h=302&amp;f=jpeg&amp;s=46553" alt=""></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;千山鸟飞绝，万径人踪灭。&lt;/p&gt;
&lt;p&gt;孤舟蓑笠翁，独钓寒江雪&lt;/p&gt;
&lt;p&gt;——唐·柳宗元《江雪》&lt;/p&gt;
&lt;p&gt;首发于我的公众号&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="设计模式" scheme="https://xsfelvis.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://xsfelvis.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式精简图册</title>
    <link href="https://xsfelvis.github.io/2019/02/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B2%BE%E7%AE%80%E5%9B%BE%E5%86%8C/"/>
    <id>https://xsfelvis.github.io/2019/02/19/设计模式精简图册/</id>
    <published>2019-02-18T16:00:00.000Z</published>
    <updated>2019-02-19T16:00:59.407Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="设计模式精简图册"><a href="#设计模式精简图册" class="headerlink" title="设计模式精简图册"></a>设计模式精简图册</h1><blockquote><p>首发于我的公众号</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU5OTgzNzM0NA==&amp;tempkey=OTk2X1BicGw2U2lQRURlOVBhMUU3SklRenkyQW5lMF9xRWRWOHVjTlJyaE5yRGJrcVh1UElfU3VtOGxsdTVMSTRuREs0X0JJYVpvRGRFMUVheXNxMmJXZ3pJR0V3aUFDV3VpSWZIa09VZ2J3Nkw5Z19BVENlaHpZSkZvbEZ2UWNqZEVwbGE2WTRoVVZBQmZta1RqdzE4UTV2TFUwOG90WHlpTURuRmw2dWd%2Bfg%3D%3D&amp;chksm=7eaf9eac49d817baef4bd670f1571d475435e108ca8246731fb3c47c52cfccac32905e63d13f#rd" target="_blank" rel="noopener">设计模式图册</a></p></blockquote><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><h3 id="创建型模式："><a href="#创建型模式：" class="headerlink" title="创建型模式："></a>创建型模式：</h3><p>主要用于创建对象，包括</p><ul><li>工厂方法(Factory Method)</li><li>抽象工厂(Abstract Factory)</li><li>单例(Singleton)</li><li>生成器(Builder)</li><li><p>原型(Prototype)</p><h3 id="结构型模式："><a href="#结构型模式：" class="headerlink" title="结构型模式："></a>结构型模式：</h3><p>用于处理类或者对象的组合，包括</p></li><li><p>适配器(Adapter)</p></li><li>装饰者(Decorator)</li><li>代理(Proxy)</li><li>外观(Facade)</li><li>桥接(<span data-type="color" style="color:rgb(84, 84, 84)"><span data-type="background" style="background-color:rgb(255, 255, 255)">Bridge Pattern</span></span>)</li><li>组合(Composite)</li><li>轻量(<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">Flyweigh</span></span>)</li></ul><h3 id="行为型模式："><a href="#行为型模式：" class="headerlink" title="行为型模式："></a>行为型模式：</h3><p>用于描述类与对象怎样的交互和分配职责，包括</p><ul><li>策略(Strategy)</li><li>观察者(Observer)</li><li>命令(Command)</li><li>模板方法(Template Method)</li><li>迭代器(Iterator)</li><li>状态(State)</li><li>责任链(Chain)</li><li>解释器(Interpreter)</li><li>中介者(Mediator)</li><li>备忘录(Memo)</li><li>访问者(Visitor)</li></ul><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="单一职责原则-Single-responsibility-principle"><a href="#单一职责原则-Single-responsibility-principle" class="headerlink" title="单一职责原则(Single responsibility principle)"></a>单一职责原则(Single responsibility principle)</h3><ul><li>核心<br><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。</span></span></li><li>问题产生<br>类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。</li><li>解决方案<br>遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。</li></ul><p>但是由于职责扩散会导致在实际中往往会有悖于单一职责</p><h3 id="里氏代换原则-Liskov-Substitution-Principle-LSP"><a href="#里氏代换原则-Liskov-Substitution-Principle-LSP" class="headerlink" title="里氏代换原则(Liskov Substitution Principle LSP)"></a>里氏代换原则(Liskov Substitution Principle LSP)</h3><ul><li>核心<br><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">所有引用基类的地方必须能透明地使用其子类的对象。</span></span></li><li>问题产生<br>有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。</li><li>解决方案<br>当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。</li></ul><p>继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。</p><p>继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。</p><h3 id="接口隔离原则-Interface-Segregation-Principle"><a href="#接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="接口隔离原则(Interface Segregation Principle)"></a>接口隔离原则(Interface Segregation Principle)</h3><ul><li>核心<br><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上</span></span><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">。</span></span></li><li>问题产生<br><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。</span></span></li><li>解决方案<br><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。</span></span></li></ul><p>接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。</p><p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p><ul><li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li><li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li></ul><p>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</p><h3 id="迪米特原则-Law-of-Demeter-Least-Knowledge-Principle"><a href="#迪米特原则-Law-of-Demeter-Least-Knowledge-Principle" class="headerlink" title="迪米特原则(Law of Demeter/Least Knowledge Principle )"></a>迪米特原则(<span data-type="color" style="color:rgb(34, 34, 34)"><span data-type="background" style="background-color:rgb(255, 255, 255)">Law of Demeter/Least Knowledge Principle </span></span>)</h3><ul><li>核心<br><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">迪米特法则又叫最少知道原则，一个对象应该对其他对象保持最少的了解。</span></span></li><li>问题产生<br><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</span></span></li><li>解决方案<br><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">尽量降低类与类之间的耦合。</span></span></li></ul><p><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息，</span></span><br><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">迪米特法则还有一个更简单的定义：只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。</span></span></p><h3 id="依赖倒置原则（Dependence-Inversion-Principle）"><a href="#依赖倒置原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒置原则（Dependence Inversion Principle）"></a>依赖倒置原则（Dependence Inversion Principle）</h3><ul><li>核心<br><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</span></span></li><li>问题产生<br>类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。</li><li>解决方案<br><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。</span></span></li></ul><p>依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。</p><p>依赖倒置原则的核心思想是面向接口编程，</p><h3 id="开闭原则-Open-Close-Principle"><a href="#开闭原则-Open-Close-Principle" class="headerlink" title="开闭原则(Open Close Principle)"></a>开闭原则(Open Close Principle)</h3><ul><li>核心<br><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</span></span></li><li>问题产生<br><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。</span></span></li><li>解决方案<br>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</li></ul><p><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">开闭原则无非就是想表达这样一层意思：用抽象构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。</span></span></p><h2 id="几个原则的关联性"><a href="#几个原则的关联性" class="headerlink" title="几个原则的关联性"></a>几个原则的关联性</h2><p><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">用抽象构建框架，用实现扩展细节的注意事项而已：</span></span></p><ul><li><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">单一职责原则告诉我们实现类要职责单一；</span></span></li><li><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">里氏替换原则告诉我们不要破坏继承体系；</span></span></li><li><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">依赖倒置原则告诉我们要面向接口编程；</span></span></li><li><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">接口隔离原则告诉我们在设计接口的时候要精简单一；</span></span></li><li><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">迪米特法则告诉我们要降低耦合。</span></span><br><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。</span></span></li></ul><h2 id="创建型设计模式-创建对象"><a href="#创建型设计模式-创建对象" class="headerlink" title="创建型设计模式(创建对象)"></a>创建型设计模式(创建对象)</h2><h3 id="工厂方法-Factory-Method-Pattern"><a href="#工厂方法-Factory-Method-Pattern" class="headerlink" title="工厂方法(Factory Method Pattern)"></a>工厂方法(Factory Method Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="90px"><br>      <col width="740px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Factory Method</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/169066ffce5cc3db?w=525&h=177&f=gif&s=4810" data-width="525"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/169066ffce5cc3db?w=525&h=177&f=gif&s=4810" width="525"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当一个类不知道它所必须创建的对象的类的时候。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当一个类希望由它的子类来指定它所创建的对象的时候。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">在工厂方法中，用户只需要知道所要产品的具体工厂，无须关系具体的创建过程，甚至不需要具体产品类的类名。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p"> 在系统增加新的产品时，我们只需要添加一个具体产品类和对应的实现工厂，无需对原工厂进行任何修改，很好地符合了“开闭原则”。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">每次增加一个产品时，都需要增加一个具体类和对象实现工厂，是的系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p"> 简单工厂模式的要点就在于当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p"> 简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，但是如果产品过多时，会导致工厂代码非常复杂。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="抽象工厂-Abstract-Factory-Pattern"><a href="#抽象工厂-Abstract-Factory-Pattern" class="headerlink" title="抽象工厂(Abstract Factory Pattern)"></a>抽象工厂(Abstract Factory Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="94px"><br>      <col width="736px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Abstract Factory</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/169066ffce813741?w=568&h=253&f=gif&s=9088" data-width="568"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/169066ffce813741?w=568&h=253&f=gif&s=9088" width="568"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">一个系统要独立于它的产品的创建、组合和表示时。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">一个系统要由多个产品系列中的一个来配置时。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当你要强调一系列相关的产品对象的设计以便进行联合使用时。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当你提供一个产品类库，而只想显示它们的接口而不是实现时。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">抽象工厂隔离了具体类的生成，是的客户端不需要知道什么被创建。所有的具体工厂都实现了抽象工厂中定义的公共接口，因此只需要改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">添加新的行为时比较麻烦。如果需要添加一个新产品族对象时，需要更改接口及其下所有子类，这必然会带来很大的麻烦。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">抽象工厂模式中主要的优点在于具体类的隔离，是的客户端不需要知道什么被创建了。其缺点在于增加新的等级产品结构比较复杂，需要修改接口及其所有子类。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="生成器-建造者模式-Builder-Pattern"><a href="#生成器-建造者模式-Builder-Pattern" class="headerlink" title="生成器/建造者模式(Builder Pattern)"></a>生成器/建造者模式(Builder Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="100px"><br>      <col width="730px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Builder</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/169066ffcfb3a6e6?w=568&h=200&f=gif&s=4696" data-width="568"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/169066ffcfb3a6e6?w=568&h=200&f=gif&s=4696" width="568"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当构造过程必须允许被构造的对象有不同的表示时。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，使得我们能够更加精确的控制复杂对象的产生过程。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">将产品的创建过程与产品本身分离开来，可以使用相同的创建过程来得到不同的产品。也就说细节依赖抽象。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">建造者模式是将一个复杂对象的创建过程给封装起来，客户只需要知道可以利用对象名或者类型就能够得到一个完整的对象实例，而不需要关心对象的具体创建过程。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">建造者模式将对象的创建过程与对象本身隔离开了，使得细节依赖于抽象，符合依赖倒置原则。可以使用相同的创建过程来创建不同的产品对象。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="原型模式-Prototype-Pattern"><a href="#原型模式-Prototype-Pattern" class="headerlink" title="原型模式(Prototype Pattern)"></a>原型模式(Prototype Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="105px"><br>      <col width="725px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Prototype</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/169066ffcef96639?w=518&h=242&f=gif&s=5229" data-width="518"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/169066ffcef96639?w=518&h=242&f=gif&s=5229" width="518"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当要实例化的类是在运行时刻指定时，例如，通过动态装载；或者</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">为了避免创建一个与产品类层次平行的工厂类层次时；或者</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">如果创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">可以使用深克隆保持对象的状态。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">原型模式提供了简化的创建结构。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">在实现深克隆的时候可能需要比较复杂的代码。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">需要为每一个类配备一个克隆方法，而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事，必须修改其源代码，违背了“开闭原则”。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">原型模式向客户隐藏了创建对象的复杂性。客户只需要知道要创建对象的类型，然后通过请求就可以获得和该对象一模一样的新对象，无须知道具体的创建过程。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">克隆分为浅克隆和深克隆两种。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">我们虽然可以利用原型模式来获得一个新对象，但有时对象的复制可能会相当的复杂，比如深克隆。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="单例模式-Singleton-Pattern"><a href="#单例模式-Singleton-Pattern" class="headerlink" title="单例模式(Singleton Pattern)"></a>单例模式(Singleton Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="110px"><br>      <col width="720px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Singleton</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/169066ffd087c1e5?w=394&h=146&f=gif&s=3706" data-width="394"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/169066ffd087c1e5?w=394&h=146&f=gif&s=3706" width="394"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">保证一个类仅有一个实例，并提供一个访问它的全局访问点。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">节约了系统资源。由于系统中只存在一个实例对象，对与一些需要频繁创建和销毁对象的系统而言，单 例模式无疑节约了系统资源和提高了系统的性能。<br>              </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">单例类的职责过重，在一定程度上违背了“单一职责原则”。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">单例模式中确保程序中一个类最多只有一个实例。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">单例模式的构造器是私有了，而且它必须要提供实例的全局访问点。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">单例模式可能会因为多线程的问题而带来安全隐患。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BetterSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BetterSingleton2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BetterSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.BETTER_SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>​ <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span>  BetterSingleton BETTER_SINGLETON = <span class="keyword">new</span> BetterSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建型设计模式小结"><a href="#创建型设计模式小结" class="headerlink" title="创建型设计模式小结"></a>创建型设计模式小结</h3><table><thead><tr><th style="text-align:left"><strong>模式</strong></th><th>场景发散</th><th style="text-align:left"><strong>一句话概括</strong></th></tr></thead><tbody><tr><td style="text-align:left">工厂方法(Factory Method)</td><td>new太多如何管理</td><td style="text-align:left">生产系列产品。</td></tr><tr><td style="text-align:left">抽象工厂(Abstract Factory)</td><td>new太多如何管理</td><td style="text-align:left">一次生产多个不同产品。</td></tr><tr><td style="text-align:left">生成器(Builder)</td><td>车手选车</td><td style="text-align:left">生产有很多组件的产品。</td></tr><tr><td style="text-align:left">原型(Prototype)</td><td>复制不能很难</td><td style="text-align:left">克隆对象。</td></tr><tr><td style="text-align:left">单件(Singleton)</td><td>如何管理全局信息</td><td style="text-align:left">全局只有一个。</td></tr></tbody></table><h2 id="结构型设计模式-处理类或者对象的组合"><a href="#结构型设计模式-处理类或者对象的组合" class="headerlink" title="结构型设计模式(处理类或者对象的组合)"></a>结构型设计模式(处理类或者对象的组合)</h2><h3 id="桥接模式-Bridge-Pattern"><a href="#桥接模式-Bridge-Pattern" class="headerlink" title="桥接模式(Bridge Pattern)"></a>桥接模式(Bridge Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="131px"><br>      <col width="699px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Bridge</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/169066ffd161b914?w=600&h=246&f=gif&s=5880" data-width="600"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/169066ffd161b914?w=600&h=246&f=gif&s=5880" width="600"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">将抽象部分与它的实现部分分离，使它们都可以独立地变化。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">分离抽象接口及其实现部分。提高了比继承更好的解决方案。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">实现细节对客户透明，可以对用户隐藏实现细节。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">桥接模式实现了抽象化与实现化的脱耦。他们两个互相独立，不会影响到对方。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">对于两个独立变化的维度，使用桥接模式再适合不过了。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">对于“具体的抽象类”所做的改变，是不会影响到客户。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="轻量模式-享元模式-FlyWeightPattern"><a href="#轻量模式-享元模式-FlyWeightPattern" class="headerlink" title="轻量模式/享元模式(FlyWeightPattern)"></a>轻量模式/享元模式(FlyWeightPattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="130px"><br>      <col width="700px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Flyweight</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/169066fff2baad07?w=598&h=369&f=gif&s=9534" data-width="598"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/169066fff2baad07?w=598&h=369&f=gif&s=9534" width="598"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">运用共享技术有效地支持大量细粒度的对象。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">一个应用程序使用了大量的对象。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">完全由于使用大量的对象，造成很大的存储开销。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">对象的大多数状态都可变为外部状态。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">应用程序不依赖于对象标识。由于F l y w e i g h t 对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">享元模式的优点在于它能够极大的减少系统中对象的个数。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">享元模式由于使用了外部状态，外部状态相对独立，不会影响到内部状态，所以享元模式使得享元对象能够在不同的环境被共享。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">由于享元模式需要区分外部状态和内部状态，使得应用程序在某种程度上来说更加复杂化了。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。 </div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">享元模式可以极大地减少系统中对象的数量。但是它可能会引起系统的逻辑更加复杂化。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">享元模式的核心在于享元工厂，它主要用来确保合理地共享享元对象。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">内部状态为不变共享部分，存储于享元享元对象内部，而外部状态是可变部分，它应当由客户端来负责。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="外观模式-Facade-Pattern"><a href="#外观模式-Facade-Pattern" class="headerlink" title="外观模式(Facade Pattern)"></a>外观模式(Facade Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="130px"><br>      <col width="700px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Facade</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/169066fff3c18dd3?w=476&h=185&f=gif&s=3356" data-width="476"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/169066fff3c18dd3?w=476&h=185&f=gif&s=3356" width="476"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">为子系统中的一组接口提供一个一致的界面，F a c a d e 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。F a c a d e 可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过f a c a d e 层。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">客户程序与抽象类的实现部分之间存在着很大的依赖性。引入f a c a d e 将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当你需要构建一个层次结构的子系统时，使用f a c a d e 模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过f a c a d e 进行通讯，从而简化了它们之间的依赖关系。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">引入外观模式，是客户对子系统的使用变得简单了，减少了与子系统的关联对象，实现了子系统与客户之间的松耦合关系。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p"> 外观模式的主要优点就在于减少了客户与子系统之间的关联对象，使用客户对子系统的使用变得简单了，也实现了客户端与子系统之间的松耦合关系。它的缺点就在于违背了“开闭原则”。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">如果需要实现一个外观模式，需要将子系统组合进外观中，然后将工作委托给子系统执行。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="装饰者模式-Decorator-Pattern"><a href="#装饰者模式-Decorator-Pattern" class="headerlink" title="装饰者模式(Decorator Pattern)"></a>装饰者模式(Decorator Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="134px"><br>      <col width="696px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Decorator</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/1690670008f047fb?w=645&h=285&f=gif&s=7475" data-width="645"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/1690670008f047fb?w=645&h=285&f=gif&s=7475" width="645"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动态地给一个对象添加一些额外的职责。就增加功能来说，D e c o r a t o r 模式相比生成子类更为灵活。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">处理那些可以撤消的职责。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">装饰者模式可以提供比继承更多的灵活性</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">可以通过一种动态的方式来扩展一个对象的功能，在运行时选择不同的装饰器，从而实现不同的行为。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">会产生很多的小对象，增加了系统的复杂性</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">装饰者模式意味着一群装饰者类，这些类用来包装具体组件</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">装饰者可以在被装饰者的行为前面或者后面加上自己的行为，甚至可以将被装饰者的行为整个取代掉，从而达到特定的目的。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">可以用多个装饰者包装一个组件。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">装饰者一般对于组件的客户是透明的，除非客户程序依赖于组件的具体类型。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">装饰者会导致设计中出现许多的小对象，如果过度的使用，会让系统变得更加复杂。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">装饰者和被装饰者对象有相同的超类型。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="组合模式-Composite-Pattern"><a href="#组合模式-Composite-Pattern" class="headerlink" title="组合模式(Composite Pattern)"></a>组合模式(Composite Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="139px"><br>      <col width="691px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Composite</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/169067000a66785d?w=571&h=257&f=gif&s=6139" data-width="571"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/169067000a66785d?w=571&h=257&f=gif&s=6139" width="571"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">将对象组合成树形结构以表示?部分-整体?的层次结构。C o m p o s i t e 使得用户对单个对象和组合对象的使用具有一致性。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">你想表示对象的部分-整体层次结构。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，使得增加新构件也更容易。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">客户端调用简单，客户端可以一致的使用组合结构或其中单个对象。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">定义了包含叶子对象和容器对象的类层次结构，叶子对象可以被组合成更复杂的容器对象，而这个容器对象又可以被组合，这样不断递归下去，可以形成复杂的树形结构。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">更容易在组合体内加入对象构件，客户端不必因为加入了新的对象构件而更改原有代码。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">使设计变得更加抽象，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象子类都有关联，会有冗余代码</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p"> 组合模式用于将多个对象组合成树形结构以表示“整体-部分”的结构层次。组合模式对单个对象（叶子对象）和组合对象（容器对象）的使用具有一致性。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">组合对象的关键在于它定义了一个抽象构建类，它既可表示叶子对象，也可表示容器对象，客户仅仅需要针对这个抽象构建进行编程，无须知道他是叶子对象还是容器对象，都是一致对待。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p"> 组合模式虽然能够非常好地处理层次结构，也使得客户端程序变得简单，但是它也使得设计变得更加抽象，而且也很难对容器中的构件类型进行限制，这会导致在增加新的构件时会产生一些问题。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="代理模式-Proxy-Pattern"><a href="#代理模式-Proxy-Pattern" class="headerlink" title="代理模式(Proxy Pattern)"></a>代理模式(Proxy Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="140px"><br>      <col width="690px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Proxy</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/169067000f5e737e?w=540&h=226&f=gif&s=4257" data-width="540"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/169067000f5e737e?w=540&h=226&f=gif&s=4257" width="540"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">为其他对象提供一种代理以控制对这个对象的访问。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">不希望某些类被直接访问。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">访问之前希望先进行一些预处理。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">希望对被访问的对象进行内存、权限等方面的控制。 模式。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了的作用和保护了目标对象的</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">代理模式是通过使用引用代理对象来访问真实对象，在这里代理对象充当用于连接客户端和真实对象的中介者。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">代理模式主要用于远程代理、虚拟代理和保护代理。其中保护代理可以进行访问权限控制。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="适配器模式-Adapter-Pattern"><a href="#适配器模式-Adapter-Pattern" class="headerlink" title="适配器模式(Adapter Pattern)"></a>适配器模式(Adapter Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="150px"><br>      <col width="680px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Adapter</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/169067001155f956?w=524&h=197&f=gif&s=4173" data-width="524"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/169067001155f956?w=524&h=197&f=gif&s=4173" width="524"><br>            </div><pre><code>        &lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;center&quot; data-src=&quot;http://www.uml.org.cn/chanpin/intro/WebHelp/Adapter_Class.gif&quot; data-width=&quot;543&quot;&gt;          &lt;img src=&quot;http://www.uml.org.cn/chanpin/intro/WebHelp/Adapter_Class.gif&quot; width=&quot;543&quot; /&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td rowspan=&quot;1&quot; colSpan=&quot;1&quot;&gt;      &lt;div data-type=&quot;p&quot;&gt;动机&lt;/div&gt;    &lt;/td&gt;    &lt;td rowspan=&quot;1&quot; colSpan=&quot;1&quot;&gt;      &lt;div data-type=&quot;p&quot;&gt;将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。&lt;/div&gt;    &lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td rowspan=&quot;1&quot; colSpan=&quot;1&quot;&gt;      &lt;div data-type=&quot;p&quot;&gt;适用性&lt;/div&gt;    &lt;/td&gt;    &lt;td rowspan=&quot;1&quot; colSpan=&quot;1&quot;&gt;      &lt;ul data-type=&quot;unordered-list&quot;&gt;        &lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;          &lt;div data-type=&quot;p&quot;&gt;你想使用一个已经存在的类，而它的接口不符合你的需求。&lt;/div&gt;        &lt;/li&gt;        &lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;          &lt;div data-type=&quot;p&quot;&gt;你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。&lt;/div&gt;        &lt;/li&gt;        &lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;          &lt;div data-type=&quot;p&quot;&gt;（仅适用于对象Adapter ）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。&lt;/div&gt;        &lt;/li&gt;      &lt;/ul&gt;    &lt;/td&gt;  &lt;/tr&gt;  &lt;tr height=&quot;34px&quot;&gt;    &lt;td rowspan=&quot;1&quot; colSpan=&quot;1&quot;&gt;      &lt;div data-type=&quot;p&quot;&gt;优点&lt;/div&gt;    &lt;/td&gt;    &lt;td rowspan=&quot;1&quot; colSpan=&quot;1&quot;&gt;      &lt;ul data-type=&quot;unordered-list&quot;&gt;        &lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;          &lt;div data-type=&quot;p&quot;&gt;将目标类和适配者类解耦，通过使用适配器让不兼容的接口变成了兼容，让客户从实现的接口解耦。&lt;/div&gt;        &lt;/li&gt;        &lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;          &lt;div data-type=&quot;p&quot;&gt;增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。&lt;/div&gt;        &lt;/li&gt;        &lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;          &lt;div data-type=&quot;p&quot;&gt;灵活性和扩展性都非常好在不修改原有代码的基础上增加新的适配器类，符合“开闭原则”。&lt;/div&gt;        &lt;/li&gt;      &lt;/ul&gt;    &lt;/td&gt;  &lt;/tr&gt;  &lt;tr height=&quot;34px&quot;&gt;    &lt;td rowspan=&quot;1&quot; colSpan=&quot;1&quot;&gt;      &lt;div data-type=&quot;p&quot;&gt;缺点&lt;/div&gt;    &lt;/td&gt;    &lt;td rowspan=&quot;1&quot; colSpan=&quot;1&quot;&gt;      &lt;ul data-type=&quot;unordered-list&quot;&gt;        &lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;          &lt;div data-type=&quot;p&quot;&gt;过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。&lt;/div&gt;        &lt;/li&gt;        &lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;          &lt;div data-type=&quot;p&quot;&gt;因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。&lt;/div&gt;        &lt;/li&gt;      &lt;/ul&gt;    &lt;/td&gt;  &lt;/tr&gt;  &lt;tr height=&quot;34px&quot;&gt;    &lt;td rowspan=&quot;1&quot; colSpan=&quot;1&quot;&gt;      &lt;div data-type=&quot;p&quot;&gt;小结&lt;/div&gt;    &lt;/td&gt;    &lt;td rowspan=&quot;1&quot; colSpan=&quot;1&quot;&gt;      &lt;ul data-type=&quot;unordered-list&quot;&gt;        &lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;          &lt;div data-type=&quot;p&quot;&gt;当我们需要使用的一个现有的类，但是他的接口并不符合我们的需求时，我们可以使用适配器模式。&lt;/div&gt;        &lt;/li&gt;        &lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;          &lt;div data-type=&quot;p&quot;&gt;适配器模式分为类适配器和对象适配器，其中类适配器需要用到多重继承。&lt;/div&gt;        &lt;/li&gt;      &lt;/ul&gt;    &lt;/td&gt;  &lt;/tr&gt;&lt;/tbody&gt;</code></pre><p>  </p></div></td></tr></tbody></table><br></div><p></p><h3 id="结构型设计模式小结"><a href="#结构型设计模式小结" class="headerlink" title="结构型设计模式小结"></a>结构型设计模式小结</h3><table><thead><tr><th style="text-align:left">模式</th><th>场景发散</th><th style="text-align:left">一句话说明</th></tr></thead><tbody><tr><td style="text-align:left">桥(Bridge)</td><td>麻烦的日志记录</td><td style="text-align:left">将“抽象”和“实现”自由搭配。</td></tr><tr><td style="text-align:left">轻量(Flyweight)</td><td>森林里的树太多了</td><td style="text-align:left">轻松地处理“大量”对象。</td></tr><tr><td style="text-align:left">外观(Façade)</td><td>超级手机</td><td style="text-align:left">同时提供简单接口和复杂接口。</td></tr><tr><td style="text-align:left">装饰者(Decorator)</td><td>星巴克的饮料计较系统</td><td style="text-align:left">不改变接口但要增强功能。</td></tr><tr><td style="text-align:left">组合(Composite)</td><td>超酷的绘图软件</td><td style="text-align:left">不管你是老子还是儿子，都一样处理。</td></tr><tr><td style="text-align:left">代理(Proxy)</td><td>找中介租房</td><td style="text-align:left">代理要控制你的访问，同时让你的访问更舒服 。</td></tr><tr><td style="text-align:left">适配器(Adapter)</td><td>老掉牙系统的重生</td><td style="text-align:left">不改变功能但要改变接口</td></tr></tbody></table><h2 id="行为型设计模式-类与对象怎样的交互和分配职责"><a href="#行为型设计模式-类与对象怎样的交互和分配职责" class="headerlink" title="行为型设计模式(类与对象怎样的交互和分配职责)"></a>行为型设计模式(类与对象怎样的交互和分配职责)</h2><h3 id="观察者模式-Observer-Pattern"><a href="#观察者模式-Observer-Pattern" class="headerlink" title="观察者模式(Observer Pattern)"></a>观察者模式(Observer Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="145px"><br>      <col width="685px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Observer</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/1690670017eda10c?w=615&h=243&f=gif&s=7719" data-width="615"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/1690670017eda10c?w=615&h=243&f=gif&s=7719" width="615"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之, 你不希望这些对象是紧密耦合的。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当两个对象之间送耦合，他们依然可以交互，但是不太清楚彼此的细节。观察者模式提供了一种对象设计，让主题和观察者之间送耦合。主题所知道只是一个具体的观察者列表，每一个具体观察者都符合一个抽象观察者的接口。主题并不认识任何一个具体的观察者，它只知道他们都有一个共同的接口。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">观察者模式支持“广播通信”。主题会向所有的观察者发出通知。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">观察者模式符合“开闭原则”的要求。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进 行循环调用，可能导致系统崩溃。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">观察者模式定义了对象之间的一对多关系。多个观察者监听同一个被观察者，当该被观察者的状态发生改变时，会通知所有的观察者。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">观察者模式中包含四个角色。主题，它指被观察的对象。具体主题是主题子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；观察者，将对观察主题的改变做出反应；具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="策略模式-Strategy-Pattern"><a href="#策略模式-Strategy-Pattern" class="headerlink" title="策略模式(Strategy Pattern)"></a>策略模式(Strategy Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="150px"><br>      <col width="680px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Strategy</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/16906700244d00fb?w=539&h=186&f=gif&s=5220" data-width="539"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/16906700244d00fb?w=539&h=186&f=gif&s=5220" width="539"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">许多相关的类仅仅是行为有异。策略模式提供了一种用多个行为中的一个行为来配置一个类的方法。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">需要使用一个算法的不同变体。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">一个类定义了多种行为, 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的S t r a t e g y 类中以代替这些条件语句。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">策略模式提供了可以替换继承关系的办法。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">使用策略模式可以避免使用多重条件转移语句。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">客户端必须知道所有的策略类，并自行决定使用哪一个策略类。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">策略模式将造成产生很多策略类，</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">一个系统需要动态地在几种算法中选择一种。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="迭代器模式-Iterator-Pattern"><a href="#迭代器模式-Iterator-Pattern" class="headerlink" title="迭代器模式(Iterator Pattern)"></a>迭代器模式(Iterator Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="152px"><br>      <col width="678px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Iterator</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/169067001fb0546f?w=560&h=276&f=gif&s=5453" data-width="560"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/169067001fb0546f?w=560&h=276&f=gif&s=5453" width="560"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">访问一个聚合对象的内容而无需暴露它的内部表示。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">支持对聚合对象的多种遍历。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">为遍历不同的聚合结构提供一个统一的接口(即, 支持多态迭代)。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">它支持以不同的方式遍历一个聚合对象。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">迭代器简化了聚合类。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">在同一个聚合上可以有多个遍历。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">将遍历聚合对象中数据的行为提取出来，封装到一个迭代器中，通过专门的迭代器来遍历聚合对象的内部数据，这就是迭代器模式的本质。迭代器模式是“单一职责原则”的完美体现。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当使用迭代器的时候，我们依赖聚合提供遍历。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">迭代器提供了一个通用的接口，让我们遍历聚合的项，放我们编码使用聚合项时，就可以使用多态机制。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="命令模式-Command-Pattern"><a href="#命令模式-Command-Pattern" class="headerlink" title="命令模式(Command Pattern)"></a>命令模式(Command Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="160px"><br>      <col width="670px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Command</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="left" data-src="https://user-gold-cdn.xitu.io/2019/2/19/1690670025102900?w=603&h=212&f=gif&s=4649" data-width="603"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/1690670025102900?w=603&h=212&f=gif&s=4649" width="603"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">抽象出待执行的动作以参数化某对象，你可用过程语言中的回调（c a l l b a c k ）函数表达这种参数化机制。所谓回调函数是指函数先在某处注册，而它将在稍后某个需要的时候被调用。C o m m a n d 模式是回调机制的一个面向对象的替代品。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">在不同的时刻指定、排列和执行请求。一个C o m m a n d 对象可以有一个与初始请求无关的生存期。如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可将负责该请求的命令对象传送给另一个不同的进程并在那儿实现该请求。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">支持取消操作。C o m m a n d 的E x c u t e 操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。C o m m a n d 接口必须添加一个U n e x e c u t e 操作，该操作取消上一次E x e c u t e 调用的效果。执行的命令被存储在一个历史列表中。可通过向后和向前遍历这一列表并分别调用U n e x e c u t e 和E x e c u t e 来实现重数不限的取消和重做。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍。在C o m m a n d 接口中添加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。从崩溃中恢复的过程包括从磁盘中重新读入记录下来的命令并用E x e c u t e 操作重新执行它们。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">用构建在原语操作上的高层操作构造一个系统。这样一种结构在支持事务( t r a n s a c t i o n )的信息系统中很常见。一个事务封装了对数据的一组变动。C o m m a n d 模式提供了对事务进行建模的方法。C o m m a n d 有一个公共的接口，使得你可以用同一种方式调用所有的事务。同时使用该模式也易于添加新事务以扩展系统。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">降低了系统耦合度</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">新的命令可以很容易添加到系统中去。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">使用命令模式可能会导致某些系统有过多的具体命令类。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">命令模式的本质就是将命令对象进行封装打包，将发出命令的责任和执行命令的责任进行割开。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">命令模式中发送者只需要知道如何发送请求命令，无须关心命令执行具体过程。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">在发送者和接收者两者间是通过命令对象进行沟通的。请求命令本身就当做一个对象在两者间进行传递，它封装了接收者和一组动作。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p"> 命令模式支持撤销。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">命令模式队列请求和日志请求。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="访问者模式-Visitor-Pattern"><a href="#访问者模式-Visitor-Pattern" class="headerlink" title="访问者模式(Visitor Pattern)"></a>访问者模式(Visitor Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="89px"><br>      <col width="668px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Visitor</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/16906700257347dc?w=536&h=417&f=gif&s=11308" data-width="536"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/16906700257347dc?w=536&h=417&f=gif&s=11308" width="536"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作?污染?这些对象的类。Vi s i t o r 使得你可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用Vi s i t o r 模式让每个应用仅包含需要用到的操作。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">使得新增新的访问操作变得更加简单。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">能够使得用户在不修改现有类的层次结构下，定义该类层次结构的操作。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">将有关元素对象的访问行为集中到一个访问者对象中，而不是分散搞一个个的元素类中。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">增加新的元素类很困难。在访问者模式中，每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，违背了“开闭原则”的要求。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">破坏封装。当采用访问者模式的时候，就会打破组合类的封装。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">1.SomeClass 的 Accept()方法就是访问原来类的小口， Accept()方法只有一句代码，就是: visitor.NewMethod(this) ，这是访问者模式的精妙之处。 2.SomeClass 的新功能通过实现 IVisitor 接口的类来实现。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">访问者模式封装了对象结构元素之上的操作，使得新增元素的操作变得非常简单。所以它比较适用于那么对象结构很少变化的类。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">访问者模式中对象结构存储了不同类型的元素对象，以供不同访问者访问。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="解释器模式-Interpreter-Pattern"><a href="#解释器模式-Interpreter-Pattern" class="headerlink" title="解释器模式(Interpreter Pattern)"></a>解释器模式(Interpreter Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="154px"><br>      <col width="596px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Interpreter</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/1690670030b73b10?w=450&h=242&f=gif&s=4615" data-width="450"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/1690670030b73b10?w=450&h=242&f=gif&s=4615" width="450"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">当有一个语言需要解释执行, 并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。而当存在以下情况时该模式效果最好：</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">该文法简单对于复杂的文法, 文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无需构建抽象语法树即可解释表达式, 这样可以节省空间而且还可能节省时间。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的, 而是首先将它们转换成另一种形式。例如，正则表达式通常被转换成状态机。但即使在这种情况下, 转换器仍可用解释器模式实现, 该模式仍是有用的。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">可扩展性比较好，灵活。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">增加了新的解释表达式的方式。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">易于实现文法。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">执行效率比较低，可利用场景比较少。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">对于复杂的文法比较难维护。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">在解释器模式中由于语法是由很多类表示的，所以可扩展性强。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">虽然解释器的可扩展性强，但是如果语法规则的数目太大的时候，该模式可能就会变得异常复杂。所以解释器模式适用于文法较为简单的。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">解释器模式可以处理脚本语言和编程语言。常用于解决某一特定类型的问题频繁发生情况。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="中介者模式-Mediator-Pattern"><a href="#中介者模式-Mediator-Pattern" class="headerlink" title="中介者模式(Mediator Pattern)"></a>中介者模式(Mediator Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="130px"><br>      <col width="620px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Mediator</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/1690670033512cc2?w=535&h=166&f=gif&s=3603" data-width="535"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/1690670033512cc2?w=535&h=166&f=gif&s=3603" width="535"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">一个对象引用其他很多对象并且直接与这些对象通信,导致难以复用该对象。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">想定制一个分布在多个类中的行为，而又不想生成太多的子类。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p"> 简化了对象之间的关系，将系统的各个对象之间的相互关系进行封装，将各个同事类解耦，使系统成为松耦合系统。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p"> 减少了子类的生成。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">可以减少各同事类的设计与实现。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">由于中介者对象封装了系统中对象之间的相互关系，导致其变得非常复杂，使得系统维护比较困难。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">每个控件不需要直接和别的控件打交道，只需要知道中介者就可以了。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">每个控件都需要保持保持中介者的引用，而中介者不一定需要保持每个控件的引用</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">Mediator 的代码可能很复杂。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="备忘录模式-Memento-Pattern"><a href="#备忘录模式-Memento-Pattern" class="headerlink" title="备忘录模式(Memento Pattern)"></a>备忘录模式(Memento Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="129px"><br>      <col width="621px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Mediator</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/1690670033512cc2?w=535&h=166&f=gif&s=3603" data-width="535"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/1690670033512cc2?w=535&h=166&f=gif&s=3603" width="535"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">一个对象引用其他很多对象并且直接与这些对象通信,导致难以复用该对象。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">想定制一个分布在多个类中的行为，而又不想生成太多的子类。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">给用户提供了一种可以恢复状态的机制。可以是用户能够比较方便地回到某个历史的状态。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">实现了信息的封装。使得用户不需要关心状态的保存细节。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">到需要保存对象多个状态，并且可以恢复到任意状态，可考虑备忘录模式。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">将对象、对象状态和状态的保存办法分离，设计上会更加灵活。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">但对象属性的备份、恢复、保存等动作，都是可能比较耗时的。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">备忘录模式只是提供了保存对象状态的一种解决方案框架 ，真正应用时还需要解决这些 问题:1.如何设计 Memento? 2.怎样保存多个对象? 3.怎样保存组织成树结构的多个对象?</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="模板方法模式-TemplateMethod-Pattern"><a href="#模板方法模式-TemplateMethod-Pattern" class="headerlink" title="模板方法模式(TemplateMethod Pattern)"></a>模板方法模式(TemplateMethod Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="152px"><br>      <col width="598px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Template Method</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/1690670043aff038?w=395&h=225&f=gif&s=4901" data-width="395"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/1690670043aff038?w=395&h=225&f=gif&s=4901" width="395"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Te m p l a t e M e t h o d 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">算法的骨架是不变的，但其中的步骤实现可能有变化，这时可应用模板方法。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">模板方法模式在定义了一组算法，将具体的实现交由子类负责。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">模板方法模式是一种代码复用的基本技术。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">模板方法模式导致一种反向的控制结构，通过一个父类调用其子类的操作，通过对子类的扩展增加新的行为，符合“开闭原则”。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">每一个不同的实现都需要一个子类来实现，导致类的个数增加，是的系统更加庞大。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">模板方法模式定义了算法的步骤，将这些步骤的实现延迟到了子类。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">模板方法模式为我们提供了一种代码复用的重要技巧。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">模板方法模式的抽象类可以定义抽象方法、具体方法和钩子。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">为了防止子类改变算法的实现步骤，我们可以将模板方法声明为final。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="状态模式-State-Pattern"><a href="#状态模式-State-Pattern" class="headerlink" title="状态模式(State Pattern)"></a>状态模式(State Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="153px"><br>      <col width="597px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>State</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/1690670043f86963?w=472&h=190&f=gif&s=4128" data-width="472"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/1690670043f86963?w=472&h=190&f=gif&s=4128" width="472"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常, 有多个操作包含这一相同的条件结构。S t a t e模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">封装了转换规则。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">枚举可能的状态，在枚举状态之前需要确定状态种类。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">状态模式的使用必然会增加系统类和对象的个数。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 </div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">状态模式允许一个对象基于内部状态而拥有不同的行为。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">Context会将行为委托给当前状态对象。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">状态模式对“开闭原则”支持不是很好。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="责任链模式-Chain-of-Responsibility-Pattern"><a href="#责任链模式-Chain-of-Responsibility-Pattern" class="headerlink" title="责任链模式(Chain of Responsibility Pattern)"></a>责任链模式(Chain of Responsibility Pattern)</h3><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="156px"><br>      <col width="594px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">名称</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><strong>Chain of Responsibility</strong></div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">结构</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p"><br>            <div data-type="image" data-display="block" data-align="center" data-src="https://user-gold-cdn.xitu.io/2019/2/19/169067004412f3b7?w=412&h=218&f=gif&s=3962" data-width="412"><br>              <img src="https://user-gold-cdn.xitu.io/2019/2/19/169067004412f3b7?w=412&h=218&f=gif&s=3962" width="412"><br>            </div><br>          </div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">动机</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</div><br>        </td><br>      </tr><br>      <tr><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">适用性</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">可处理一个请求的对象集合应被动态指定。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">优点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">降低耦合度。它将请求的发送者和接受者解耦。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">简化了对象。使得对象不需要知道链的结构。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">增加新的请求处理类很方便。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">缺点</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">不能保证请求一定被接收。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">系统性能将受到一定影响，而且在进行代码调试时不太方便；可能会造成循环调用</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">可能不容易观察运行时的特征，有碍于除错。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">小结</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <ul data-type="unordered-list"><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">职责链模式将请求的发送者和接受者解耦了。客户端不需要知道请求处理者的明确信息，甚至不需要知道链的结构，它只需要将请求进行发送即可。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">职责链模式能够非常方便的动态增加新职责或者删除职责。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">客户端发送的请求可能会得不到处理。</div><br>            </li><br>            <li data-type="list-item" data-list-type="unordered-list"><br>              <div data-type="p">处理者不需要知道链的结构，只需要明白他的后续者是谁就可以了。这样就简化了系统中的对象。</div><br>            </li><br>          </ul><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><h3 id="行为型设计模式小结"><a href="#行为型设计模式小结" class="headerlink" title="行为型设计模式小结"></a>行为型设计模式小结</h3><table><thead><tr><th style="text-align:left">模式</th><th>场景发散</th><th style="text-align:left">一句话说明</th></tr></thead><tbody><tr><td style="text-align:left">观察者(Observer)</td><td>同步更新的问题</td><td style="text-align:left">一呼百应。</td></tr><tr><td style="text-align:left">策略(Strategy)</td><td>设计你的战士</td><td style="text-align:left">分离算法。</td></tr><tr><td style="text-align:left">迭代器(Iterator)</td><td>集合访问的烦恼</td><td style="text-align:left">以一致的方式访问集合， “松绑 ”遍历算法代码。</td></tr><tr><td style="text-align:left">命令(Command)</td><td>神奇的Do与Undo</td><td style="text-align:left">分离功能调用者与功能实现者。</td></tr><tr><td style="text-align:left">访问者(Visitor)</td><td>增加新方法的烦恼</td><td style="text-align:left">不改变对象结构增加新方法。</td></tr><tr><td style="text-align:left">解释器(Interpreter)</td><td>超级表达解释引擎</td><td style="text-align:left">语法解释。</td></tr><tr><td style="text-align:left">中介者(Mediator)</td><td>麻烦的多角关系</td><td style="text-align:left">处理多对多关系。</td></tr><tr><td style="text-align:left">备忘录(Memento)</td><td>假如一切可以重来</td><td style="text-align:left">保存对象的多个状态并可任意恢复。</td></tr><tr><td style="text-align:left">模板方法(Template Method)</td><td>万能的排序器</td><td style="text-align:left">定义好框架算法 ，某些步骤可自己定义 。</td></tr><tr><td style="text-align:left">状态(State)</td><td>是攻击还是逃走</td><td style="text-align:left">方便地处理不同状态不同行为，以及状态之间的转换。</td></tr><tr><td style="text-align:left">责任链(Chain)</td><td>邮件自动处理系统</td><td style="text-align:left">用不同的规则去处理请求。</td></tr></tbody></table><h2 id="模式比较"><a href="#模式比较" class="headerlink" title="模式比较"></a>模式比较</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.uml.org.cn/sjms/201211023.asp" target="_blank" rel="noopener">http://www.uml.org.cn/sjms/201211023.asp</a></li><li><a href="http://www.cnblogs.com/chenssy/p/3357683.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenssy/p/3357683.html</a></li><li><a href="https://academy.realm.io/cn/posts/donn-felker-solid-part-1/" target="_blank" rel="noopener">https://academy.realm.io/cn/posts/donn-felker-solid-part-1/</a></li><li><a href="http://www.cnblogs.com/chenssy/p/3357683.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenssy/p/3357683.html</a></li><li>《硬啃设计模式》</li><li>《HeadFirst 设计模式》</li><li><p>GoF 《可复用面向对象软件的基础》</p><pre><code>欢迎关注我的公众号，一起学习，共同提高~</code></pre><p><img src="https://user-gold-cdn.xitu.io/2019/2/18/168ff71fee39e5cf?w=304&amp;h=302&amp;f=jpeg&amp;s=46553" alt="公众号小.jpg"></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;设计模式精简图册&quot;&gt;&lt;a href=&quot;#设计模式精简图册&quot; class=&quot;headerlink&quot; title=&quot;设计模式精简图册&quot;&gt;&lt;/a&gt;设计模式精简图册&lt;/h1
      
    
    </summary>
    
      <category term="设计模式" scheme="https://xsfelvis.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://xsfelvis.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Dart语法基础</title>
    <link href="https://xsfelvis.github.io/2019/01/13/Dart%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>https://xsfelvis.github.io/2019/01/13/Dart语法基础/</id>
    <published>2019-01-12T16:00:00.000Z</published>
    <updated>2019-01-13T14:46:12.554Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Dart语法基础"><a href="#Dart语法基础" class="headerlink" title="Dart语法基础"></a>Dart语法基础</h1><h1 id="Dart语言简介"><a href="#Dart语言简介" class="headerlink" title="Dart语言简介"></a>Dart语言简介</h1><p>在Dart官方网站上，对于Dart的描述如下：</p><blockquote><p>Developers at Google and elsewhere use Dart to create high-quality, mission-critical apps for iOS, Android, and the web. With features aimed at client-side development, Dart is a great fit for both mobile and web apps.<br>Google和其他地方的一些开发者使用Dart语言为Android、iOS和web构建高质量，关键任务的应用程序，针对客户端开发的特点，Dart非常适合移动和Web应用程序。</p></blockquote><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">Dart是Google推出的一门编程语言，最初是希望取代Javascript运行在浏览器端，后来慢慢发展成可以开发Android、iOS和Web端App的一门高质量的编程语言，目前Dart的版本是Dart2，官网是：</span></span><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.dartlang.org%2F" target="_blank" rel="noopener">www.dartlang.org/</a></p><p>更加详细的可以参考</p><ul><li>英文官方文档 <a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.dartlang.org%2F" target="_blank" rel="noopener">www.dartlang.org/</a></li><li>中文官方文档 <a href="http://dart.goodev.org/guides/language" target="_blank" rel="noopener">http://dart.goodev.org/guides/language</a></li><li>在线联系 <a href="https://dartpad.dartlang.org/" target="_blank" rel="noopener">https://dartpad.dartlang.org/</a></li></ul><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><p>Dart语言博采众长，在我们学习Dart时候需要记住以下核心概念</p><ul><li><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">一切都是对象，一切对象都是class的实例，哪怕是数字类型、方法甚至null都是对象，所有的对象都是继承自</span></span><code>Object</code></li><li><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">Dart是强类型语言，但变量类型是可选的因为Dart可以自动推断变量类型</span></span></li><li>Dart支持范型，<code>List&lt;int&gt;</code>表示一个整型的数据列表，<code>List&lt;dynamic&gt;</code>则是一个对象的列表，其中可以装任意对象</li><li>Dart支持顶层方法（如<code>main</code>方法），也支持类方法或对象方法，同时你也可以在方法内部创建方法</li><li>Dart支持顶层变量，也支持类变量或对象变量</li><li><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">跟Java不同的是，Dart没有</span></span><code>public</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span><code>protected</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span><code>private</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">等关键字，如果某个变量以下划线（</span></span><code>_</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">）开头，代表这个变量在库中是私有的</span></span></li></ul><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="声明变量的方式"><a href="#声明变量的方式" class="headerlink" title="声明变量的方式"></a>声明变量的方式</h2><p>可以明确指定某个变量的类型，如<code>int</code> <code>bool</code> <code>String</code>，也可以用<code>var</code>或 <code>dynamic</code>来声明一个变量，Dart会自动推断其数据类型。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  int b = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">String</span> s = <span class="string">"hello"</span>;</span><br><span class="line">  dynamic c = <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="final和const"><a href="#final和const" class="headerlink" title="final和const"></a>final和const</h2><p><code>final</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">修饰的变量是不可改变的，而</span></span><code>const</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">修饰的表示一个常量，声明普通变量可以使用</span></span><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:#E9E9E9">var</span></span></p><h1 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h1><p>Dart有如下几种内建的数据类型：</p><ul><li>numbers</li><li>strings</li><li>booleans</li><li>lists(或者是arrays)</li><li>maps</li><li>runes（UTF-32字符集的字符）</li><li>symbols</li></ul><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul><li>检测两个 String 的内容是否一样事，我们使用 == 进行比较；如果要测试两个对象是否是同一个对象（indentity test），使用 identical 函数</li><li><ul><li>进行拼接</li></ul></li><li>\${} 字符串内表达式</li><li>三个单引号或者双引号可以创建多行字符串对象</li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><a href="http://dart.goodev.org/guides/libraries/library-tour#collections" target="_blank" rel="noopener">http://dart.goodev.org/guides/libraries/library-tour#collections</a></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use a List constructor.</span></span><br><span class="line"><span class="keyword">var</span> vegetables = <span class="keyword">new</span> List();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Or simply use a list literal.</span></span><br><span class="line"><span class="keyword">var</span> fruits = [<span class="string">'apples'</span>, <span class="string">'oranges'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//list是泛型类型也可以指定里面保存的类型</span></span><br><span class="line"><span class="keyword">var</span> fruits = <span class="keyword">new</span> List&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">fruits.add(<span class="string">'apples'</span>);</span><br></pre></td></tr></table></figure><h3 id="核心api"><a href="#核心api" class="headerlink" title="核心api"></a>核心api</h3><ul><li>add</li><li>addAll</li><li>length</li><li>indexOf</li><li>sort</li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><span data-type="color" style="color:rgb(82, 82, 82)"><span data-type="background" style="background-color:rgb(255, 255, 255)">map是一个关联键和值的对象。键和值都可以是任何类型的对象。每个键只出现一次，但是您可以多次使用相同的值。Dart对map的支持是通过map字面量和map类型来提供的。</span></span></p><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;</span><br><span class="line"><span class="comment">// Keys      Values</span></span><br><span class="line">  <span class="string">'first'</span> : <span class="string">'partridge'</span>,</span><br><span class="line">  <span class="string">'second'</span>: <span class="string">'turtledoves'</span>,</span><br><span class="line">  <span class="string">'fifth'</span> : <span class="string">'golden rings'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nobleGases = &#123;</span><br><span class="line"><span class="comment">// Keys  Values</span></span><br><span class="line">  <span class="number">2</span> :   <span class="string">'helium'</span>,</span><br><span class="line">  <span class="number">10</span>:   <span class="string">'neon'</span>,</span><br><span class="line">  <span class="number">18</span>:   <span class="string">'argon'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造函数实现</span></span><br><span class="line"><span class="keyword">var</span> gifts = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">gifts[<span class="string">'first'</span>] = <span class="string">'partridge'</span>;</span><br><span class="line">gifts[<span class="string">'second'</span>] = <span class="string">'turtledoves'</span>;</span><br><span class="line">gifts[<span class="string">'fifth'</span>] = <span class="string">'golden rings'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nobleGases = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">nobleGases[<span class="number">2</span>] = <span class="string">'helium'</span>;</span><br><span class="line">nobleGases[<span class="number">10</span>] = <span class="string">'neon'</span>;</span><br><span class="line">nobleGases[<span class="number">18</span>] = <span class="string">'argon'</span>;</span><br></pre></td></tr></table></figure><h3 id="核心api-1"><a href="#核心api-1" class="headerlink" title="核心api"></a>核心api</h3><ul><li><p>添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;<span class="string">'first'</span>: <span class="string">'partridge'</span>&#125;;</span><br><span class="line">gifts[<span class="string">'fourth'</span>] = <span class="string">'calling birds'</span>; <span class="comment">// Add a key-value pair</span></span><br></pre></td></tr></table></figure></li><li><p>获取map对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;<span class="string">'first'</span>: <span class="string">'partridge'</span>&#125;;</span><br><span class="line">assert(gifts[<span class="string">'first'</span>] == <span class="string">'partridge'</span>);</span><br></pre></td></tr></table></figure></li></ul><p>如果查找的key不存在则返回null</p><ul><li>length 获取map中键值对的数目</li><li>containsKey</li><li>putIfAbsent()<br><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)">但是只有该 key 在 map 中不存在的时候才设置这个值，否则 key 的值保持不变</span></span></li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h3><p><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>Set 是一个无序集合，里面不能保护重复的数据。 由于是无序的，所以无法通过索引来从 set 中获取数据<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ingredients = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">ingredients.addAll([<span class="string">'gold'</span>, <span class="string">'titanium'</span>, <span class="string">'xenon'</span>]);</span><br><span class="line">assert(ingredients.length == <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adding a duplicate item has no effect.</span></span><br><span class="line">ingredients.add(<span class="string">'gold'</span>);</span><br><span class="line">assert(ingredients.length == <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove an item from a set.</span></span><br><span class="line">ingredients.remove(<span class="string">'gold'</span>);</span><br><span class="line">assert(ingredients.length == <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><h3 id="核心api-2"><a href="#核心api-2" class="headerlink" title="核心api"></a>核心api</h3><ul><li><code>contains()</code><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>和 <code>containsAll()</code><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>来判断 set 中是否包含 一个或者多个对象</li></ul><h2 id="常用集合函数"><a href="#常用集合函数" class="headerlink" title="常用集合函数"></a>常用集合函数</h2><ul><li><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>List 和 Set 实现了 Iterable ,虽然 Map 没有实现 Iterable，但是 Map 的 keys 和 values 属性实现了 Iterable</li><li>isEmpty</li><li><p><code>forEach()</code><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>函数可以遍历集合数据，在 Map 上使用 <code>forEach()</code> 的时候，方法需要能 接收两个参数（key 和 value）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var teas = [&apos;green&apos;, &apos;black&apos;, &apos;chamomile&apos;, &apos;earl grey&apos;];</span><br><span class="line"></span><br><span class="line">teas.forEach((tea) =&gt; print(&apos;I drink $tea&apos;));</span><br><span class="line">//map</span><br><span class="line">hawaiianBeaches.forEach((k, v) &#123;</span><br><span class="line">  print(&apos;I want to visit $k and swim at $v&apos;);</span><br><span class="line">  // I want to visit Oahu and swim at</span><br><span class="line">  // [Waikiki, Kailua, Waimanalo], etc.</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>可以使用 <code>map().toList()</code> 或者 <code>map().toSet()</code> 来 强制立刻执行 map 的方法：</p></li></ul><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>Dart是一个面向对象的编程语言，所以即使是函数也是一个对象，也有一种类型<code>Function</code>，这就意味着函数可以赋值给某个变量或者作为参数传给另外的函数。虽然Dart推荐你给函数加上返回值，但是<strong>不加返回值的函数同样可以正常工作</strong>，另外你还可以用<code>=&gt;</code>代替<code>return</code>语句<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// =&gt;是return语句的简写</span></span><br><span class="line">add3(a, b) =&gt; a + b;</span><br></pre></td></tr></table></figure></p><p>所有的函数都有返回值，如果没有指定<code>return</code>语句，那么该函数的返回值为<code>null</code>。</p><h3 id="命名参数、位置参数、参数默认值"><a href="#命名参数、位置参数、参数默认值" class="headerlink" title="命名参数、位置参数、参数默认值"></a>命名参数、位置参数、参数默认值</h3><ul><li>命名参数</li></ul><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">使用花括号将函数的参数括起来就是定义了命名参数</span></span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sayHello(&#123;<span class="built_in">String</span> name&#125;) &#123;</span><br><span class="line">  print(<span class="string">"hello, my name is $name"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHello2(&#123;<span class="attr">name</span>: <span class="built_in">String</span>&#125;) &#123;</span><br><span class="line">  print(<span class="string">"hello, my name is $name"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以以<code>{type paramName}</code>或者<code>{paramName: type}</code>两种方式声明参数，而调用命名参数时，需要以<code>funcName(paramName: paramValue)</code>的形式调用。<br>可以使用<code>@required</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">注解来标识一个命名参数，这代表该参数是必须的，你不传则会报错</span></span></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Scrollbar(&#123;Key key, @required Widget child&#125;)</span><br></pre></td></tr></table></figure><ul><li>位置参数<br><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">使用中括号</span></span><code>[]</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">括起来的参数是函数的位置参数，代表该参数可传可不传，位置参数只能放在函数的参数列表的最后面</span></span></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sayHello(<span class="built_in">String</span> name, int age, [<span class="built_in">String</span> hobby]) &#123; <span class="comment">// 位置参数可以有多个，比如[String a, int b]</span></span><br><span class="line">  StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">  sb.write(<span class="string">"hello, this is $name and I am $age years old"</span>);</span><br><span class="line">  <span class="keyword">if</span> (hobby != <span class="literal">null</span>) &#123;</span><br><span class="line">    sb.write(<span class="string">", my hobby is $hobby"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  print(sb.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="comment">// hello, this is zhangsan and I am 20 years old</span></span><br><span class="line">  sayHello(<span class="string">"zhangsan"</span>, <span class="number">20</span>);</span><br><span class="line">  <span class="comment">// hello, this is zhangsan and I am 20 years old, my hobby is play football</span></span><br><span class="line">  sayHello(<span class="string">"zhangsan"</span>, <span class="number">20</span>, <span class="string">"play football"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参数默认值</li></ul><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">可以为命名参数或者位置参数设置默认值</span></span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命名参数的默认值</span></span><br><span class="line">int add(&#123;int a, int b = <span class="number">3</span>&#125;) &#123; <span class="comment">// 不能写成：int add(&#123;a: int, b: int = 3&#125;)</span></span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位置参数的默认值</span></span><br><span class="line">int sum(int a, int b, [int c = <span class="number">3</span>]) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="函数作为一等方法对象"><a href="#函数作为一等方法对象" class="headerlink" title="函数作为一等方法对象"></a>函数作为一等方法对象</h3><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">函数作为参数传给另一个函数</span></span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">printNum(int a) &#123;</span><br><span class="line">  print(<span class="string">"$a"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="comment">//  依次打印：1,2,3</span></span><br><span class="line">  <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  arr.forEach(printNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者将函数赋值给某个变量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">printNum(int a) &#123;</span><br><span class="line">  print(<span class="string">"$a"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = printNum;</span><br><span class="line">  <span class="built_in">Function</span> f2 = printNum;</span><br><span class="line">  <span class="keyword">var</span> f3 = <span class="function">(<span class="params">int a</span>) =&gt;</span> print(<span class="string">"a = $a"</span>);</span><br><span class="line">  f1(<span class="number">1</span>);</span><br><span class="line">  f2(<span class="number">2</span>);</span><br><span class="line">  f3(<span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><ul><li><p><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)">创建没有名字的方法，称之为 </span></span><em>匿名方法</em><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)">，有时候也被称为 </span></span><em>lambda</em><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>或者 <em>closure 闭包</em><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)">。 你可以把匿名方法赋值给一个变量， 然后你可以使用这个方法，比如添加到集合或者从集合中删除</span></span></p></li><li><p>匿名函数类似于<code>Java</code>中的接口，往往在某个函数的参数为函数时使用到。</p><h2 id="词法闭包"><a href="#词法闭包" class="headerlink" title="词法闭包"></a>词法闭包</h2><p>一个 <em>闭包</em> 是一个方法对象，不管该对象在何处被调用， 该对象都可以访问其作用域内 的变量。</p></li></ul><p><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)">下面的示例中，</span></span><code>makeAdder()</code><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>捕获到了变量 <code>addBy</code><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)">。 不管你在那里执行 </span></span><code>makeAdder()</code><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>所返回的函数，都可以使用 <code>addBy</code><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span> makeAdder(num addBy) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">num i</span>) =&gt;</span> addBy + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><table><thead><tr><th style="text-align:left">描述</th><th style="text-align:left">操作符</th></tr></thead><tbody><tr><td style="text-align:left">unary postfix</td><td style="text-align:left"><code><em>expr</em></code><code>++</code>    <code><em>expr</em></code><code>–</code>    <code>()</code>    <code>[]</code>    <code>.</code>    <code>?.</code></td></tr><tr><td style="text-align:left">unary prefix</td><td style="text-align:left"><code>-</code><code><em>expr</em></code>    <code>!</code><code><em>expr</em></code>    <code>~</code><code><em>expr</em></code>    <code>++</code><code><em>expr</em></code>    <code>–</code><code><em>expr</em></code></td></tr><tr><td style="text-align:left">multiplicative</td><td style="text-align:left"><code>*</code>    <code>/</code>    <code>%</code>  <code>~/</code></td></tr><tr><td style="text-align:left">additive</td><td style="text-align:left"><code>+</code>    <code>-</code></td></tr><tr><td style="text-align:left">shift</td><td style="text-align:left"><code>&lt;&lt;</code>    <code>&gt;&gt;</code></td></tr><tr><td style="text-align:left">bitwise AND</td><td style="text-align:left"><code>&amp;</code></td></tr><tr><td style="text-align:left">bitwise XOR</td><td style="text-align:left"><code>^</code></td></tr><tr><td style="text-align:left">bitwise OR</td><td style="text-align:left">`</td><td>`</td></tr><tr><td style="text-align:left">relational and type test</td><td style="text-align:left"><code>&gt;=</code>    <code>&gt;</code>    <code>&lt;=</code>    <code>&lt;</code>    <code>as</code>    <code>is</code>    <code>is!</code></td></tr><tr><td style="text-align:left">equality</td><td style="text-align:left"><code>==</code>    <code>!=</code></td></tr><tr><td style="text-align:left">logical AND</td><td style="text-align:left"><code>&amp;&amp;</code></td></tr><tr><td style="text-align:left">logical OR</td><td style="text-align:left">`</td><td></td><td>`</td></tr><tr><td style="text-align:left">if null</td><td style="text-align:left"><code>??</code></td></tr><tr><td style="text-align:left">conditional</td><td style="text-align:left"><code><em>expr1</em></code><code> ? </code><code><em>expr2</em></code><code> : </code><code><em>expr3</em></code></td></tr><tr><td style="text-align:left">cascade</td><td style="text-align:left"><code>..</code></td></tr><tr><td style="text-align:left">assignment</td><td style="text-align:left"><code>=</code>    <code>*=</code>    <code>/=</code>    <code>~/=</code>    <code>%=</code>    <code>+=</code>    <code>-=</code>    <code>&lt;&lt;=</code>    <code>&gt;&gt;=</code>    <code>&amp;=</code>    <code>^=</code>    `</td><td>=<code></code>??=`</td></tr></tbody></table><h3 id="类型判定操作符"><a href="#类型判定操作符" class="headerlink" title="类型判定操作符"></a>类型判定操作符</h3><p><code>as</code>、 <code>is</code>、 和 <code>is!</code> 操作符是在运行时判定对象 类型的操作符：</p><table><thead><tr><th style="text-align:left">操作符</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left"><code>as</code></td><td style="text-align:left">类型转换</td></tr><tr><td style="text-align:left"><code>is</code></td><td style="text-align:left">如果对象是指定的类型返回 True</td></tr><tr><td style="text-align:left"><code>is!</code></td><td style="text-align:left">如果对象是指定的类型返回 False</td></tr></tbody></table><h3 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h3><p>使用 <code>=</code> 操作符来赋值。 但是还有一个 <code>??=</code> 操作符用来指定 值为 null 的变量的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = value;   <span class="comment">// 给 a 变量赋值</span></span><br><span class="line">b ??= value; <span class="comment">// 如果 b 是 null，则赋值给 b；</span></span><br><span class="line">             <span class="comment">// 如果不是 null，则 b 的值保持不变</span></span><br></pre></td></tr></table></figure></p><h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><p>Dart 有两个特殊的操作符可以用来替代 if-else 语句：</p><ul><li><p><code><em>condition</em></code><code> ? </code><code><em>expr1</em></code><code> : </code><code><em>expr2</em></code><br>如果 <em>condition</em> 是 true，执行 <em>expr1</em> (并返回执行的结果)； 否则执行 <em>expr2</em> 并返回其结果。<br>如果你需要基于布尔表达式 的值来赋值， 考虑使用 <code>?:</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> finalStatus = m.isFinal ? <span class="string">'final'</span> : <span class="string">'not final'</span>;</span><br></pre></td></tr></table></figure></li><li><p><code><em>expr1</em></code><code> ?? </code><code><em>expr2</em></code><br>如果 <em>expr1</em> 是 non-null，返回其值； 否则执行 <em>expr2</em> 并返回其结果。<br>如果布尔表达式是测试值是否为 null， 考虑使用 <code>??</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> toString() =&gt; msg ?? <span class="keyword">super</span>.toString();</span><br></pre></td></tr></table></figure></li></ul><h3 id="级联操作符"><a href="#级联操作符" class="headerlink" title="级联操作符"></a>级联操作符</h3><p>级联操作符 (<code>..</code>) 可以在同一个对象上 连续调用多个函数以及访问成员变量。 使用级联操作符可以避免创建 临时变量， 并且写出来的代码看起来 更加流畅：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">querySelector(<span class="string">'#button'</span>) <span class="comment">// Get an object.</span></span><br><span class="line">  ..text = <span class="string">'Confirm'</span>   <span class="comment">// Use its members.</span></span><br><span class="line">  ..classes.add(<span class="string">'important'</span>)</span><br><span class="line">  ..onClick.listen(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">window</span>.alert(<span class="string">'Confirmed!'</span>));</span><br></pre></td></tr></table></figure></p><p>级联调用也可以嵌套：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">final addressBook = (<span class="keyword">new</span> AddressBookBuilder()</span><br><span class="line">      ..name = <span class="string">'jenny'</span></span><br><span class="line">      ..email = <span class="string">'jenny@example.com'</span></span><br><span class="line">      ..phone = (<span class="keyword">new</span> PhoneNumberBuilder()</span><br><span class="line">            ..number = <span class="string">'415-555-0100'</span></span><br><span class="line">            ..label = <span class="string">'home'</span>)</span><br><span class="line">          .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure></p><p>在方法上使用级联需要十分小心，无法再void上使用级联操作符<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Does not work</span></span><br><span class="line"><span class="keyword">var</span> sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">sb.write(<span class="string">'foo'</span>)..write(<span class="string">'bar'</span>);</span><br></pre></td></tr></table></figure></p><h3 id="其他操作符"><a href="#其他操作符" class="headerlink" title="其他操作符"></a>其他操作符</h3><table><thead><tr><th style="text-align:left">Operator</th><th style="text-align:left">Name</th><th style="text-align:left">Meaning</th></tr></thead><tbody><tr><td style="text-align:left"><code>()</code></td><td style="text-align:left">使用方法</td><td style="text-align:left">代表调用一个方法</td></tr><tr><td style="text-align:left"><code>[]</code></td><td style="text-align:left">访问 List</td><td style="text-align:left">访问 list 中特定位置的元素</td></tr><tr><td style="text-align:left"><code>.</code></td><td style="text-align:left">访问 Member</td><td style="text-align:left">访问元素，例如 <code>foo.bar</code> 代表访问 <code>foo</code> 的 <code>bar</code> 成员</td></tr><tr><td style="text-align:left"><code>?.</code></td><td style="text-align:left">条件成员访问</td><td style="text-align:left">和 <code>.</code> 类似，但是左边的操作对象不能为 null，例如 <code>foo?.bar</code> 如果 <code>foo</code> 为 null 则返回 null，否则返回 <code>bar</code> 成员</td></tr></tbody></table><h1 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h1><p><code>if / else</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span><code>switch</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span><code>for /while</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span><code>try / catch</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">语句跟</span></span><code>Java</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">中都类似，</span></span><code>try / catch</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">语句可能稍有不同</span></span></p><h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h3><p>捕获异常可以避免异常继续传递（你重新抛出rethrow异常除外）。 捕获异常给你一个处理 该异常的机会：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; on OutOfLlamasException &#123;</span><br><span class="line">  buyMoreLlamas();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于可以抛出多种类型异常的代码，你可以指定 多个捕获语句。每个语句分别对应一个异常类型， 如果捕获语句没有指定异常类型，则 该可以捕获任何异常类型：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; on OutOfLlamasException &#123;</span><br><span class="line">  <span class="comment">// A specific exception</span></span><br><span class="line">  buyMoreLlamas();</span><br><span class="line">&#125; on Exception <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// Anything else that is an exception</span></span><br><span class="line">  print(<span class="string">'Unknown exception: $e'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// No specified type, handles all</span></span><br><span class="line">  print(<span class="string">'Something really unknown: $e'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)">使用 </span></span><code>on</code><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>来指定异常类型，使用 <code>catch</code><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>来 捕获异常对象。<br>使用 <code>rethrow</code> 关键字可以 把捕获的异常给 重新抛出。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">final foo = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> misbehave() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    foo = <span class="string">"You can't change a final variable's value."</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    print(<span class="string">'misbehave() partially handled $&#123;e.runtimeType&#125;.'</span>);</span><br><span class="line">    rethrow; <span class="comment">// Allow callers to see the exception.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    misbehave();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    print(<span class="string">'main() finished handling $&#123;e.runtimeType&#125;.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="类的定义与构造方法"><a href="#类的定义与构造方法" class="headerlink" title="类的定义与构造方法"></a>类的定义与构造方法</h2><p><code>Dart</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">中的类没有访问控制，所以你不需要用</span></span><code>private</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">, </span></span><code>protected</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">, </span></span><code>public</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">等修饰成员变量或成员函数</span></span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  int age;</span><br><span class="line">  <span class="built_in">String</span> gender;</span><br><span class="line">  Person(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age, <span class="keyword">this</span>.gender);</span><br><span class="line">  sayHello() &#123;</span><br><span class="line">    print(<span class="string">"hello, this is $name, I am $age years old, I am a $gender"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">上面的</span></span><code>Person</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">类中有3个成员变量，一个构造方法和一个成员方法，看起来比较奇怪的是</span></span><code>Person</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">的构造方法，里面传入的3个参数都是</span></span><code>this.xxx</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">，而且没有大括号</span></span><code>{}</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">包裹的方法体，这种语法是Dart比较独特而简洁的构造方法声明方式，它等同于下面的代码：</span></span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person(<span class="built_in">String</span> name, int age, <span class="built_in">String</span> gender) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">由于</span></span><code>Dart</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">中的类没有访问控制权限，所以你可以直接用</span></span><code>obj.var</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">的方式访问一个对象的成员变量。</span></span></p><h3 id="命名构造函数"><a href="#命名构造函数" class="headerlink" title="命名构造函数"></a>命名构造函数</h3><p>使用命名构造函数可以为一个类实现多个构造函数， 或者使用命名构造函数来更清晰的表明你的意图：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  num x, y;</span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">  <span class="comment">// 类的命名构造方法</span></span><br><span class="line">  Point.origin() &#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="comment">// 调用Point类的命名构造方法origin()</span></span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> Point.origin();</span><br><span class="line">  <span class="keyword">var</span> p2 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="调用超类构造函数"><a href="#调用超类构造函数" class="headerlink" title="调用超类构造函数"></a>调用超类构造函数</h3><p>子类的构造函数会自动调用超类的 无名无参数的默认构造函数。 超类的构造函数在子类构造函数体开始执行的位置调用。 如果提供了一个 <a href="http://dart.goodev.org/guides/language/language-tour#initializer-list" target="_blank" rel="noopener">initializer list</a>（初始化参数列表） ，则初始化参数列表在超类构造函数执行之前执行。 下面是构造函数执行顺序：</p><ol><li>initializer list（初始化参数列表）</li><li>superclass’s no-arg constructor（超类的无名构造函数）</li><li>main class’s no-arg constructor（主类的无名构造函数）</li></ol><p>如果超类没有无名无参数构造函数， 则你需要手工的调用超类的其他构造函数。 在构造函数参数后使用冒号 (<code>:</code>) 可以调用 超类构造函数。<br><code>Dart</code>中使用<code>extends</code>关键字做类的继承，如果一个类只有命名的构造方法，在继承时需要注意，如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  Human.fromJson(<span class="built_in">Map</span> data) &#123;</span><br><span class="line">    print(<span class="string">"Human's fromJson constructor"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">  Man.fromJson(<span class="built_in">Map</span> data) : <span class="keyword">super</span>.fromJson(data) &#123;</span><br><span class="line">    print(<span class="string">"Man's fromJson constructor"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="重定向构造函数"><a href="#重定向构造函数" class="headerlink" title="重定向构造函数"></a>重定向构造函数</h3><p>有时候一个构造函数会调动类中的其他构造函数。 一个重定向构造函数是没有代码的，在构造函数声明后，使用 冒号调用其他构造函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  num x;</span><br><span class="line">  num y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The main constructor for this class.</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Delegates to the main constructor.</span></span><br><span class="line">  Point.alongXAxis(num x) : <span class="keyword">this</span>(x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h2><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">使用abstract修饰一个类，则这个类是抽象类，</span></span><br><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"><strong>抽象类中可以有抽象方法和非抽象方法</strong></span></span><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">，抽象方法没有方法体，需要子类去实现，如下代码：</span></span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 抽象方法，没有方法体，需要子类去实现</span></span><br><span class="line">  <span class="keyword">void</span> doSomething();</span><br><span class="line">  <span class="comment">// 普通的方法</span></span><br><span class="line">  <span class="keyword">void</span> greet() &#123;</span><br><span class="line">    print(<span class="string">"hello world!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EffectiveDoer</span> <span class="keyword">extends</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 实现了父类的抽象方法</span></span><br><span class="line">  <span class="keyword">void</span> doSomething() &#123;</span><br><span class="line">    print(<span class="string">"I'm doing something..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>枚举类型通常称之为 <em>enumerations</em> 或者 <em>enums</em>， 是一种特殊的类，用来表现一个固定 数目的常量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">  red,</span><br><span class="line">  green,</span><br><span class="line">  blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>枚举类型中的每个值都有一个 <code>index</code> getter 函数， 该函数返回该值在枚举类型定义中的位置（从 0 开始）。 例如，第一个枚举值的位置为 0， 第二个为 1.</li><li>枚举的 <code>values</code> 常量可以返回 所有的枚举值。</li></ul><p>枚举类型具有如下的限制：</p><ul><li>无法继承枚举类型、无法使用 mix in、无法实现一个枚举类型</li><li>无法显示的初始化一个枚举类型</li></ul><h2 id="Mixins-为类添加新的功能"><a href="#Mixins-为类添加新的功能" class="headerlink" title="Mixins 为类添加新的功能"></a>Mixins 为类添加新的功能</h2><p>Mixins 是一种在多类继承中重用 一个类代码的方法。使用 with 关键字后面为一个或者多个 mixin 名字来使用 mixin。 下面是示例显示了如何使用 mixin：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  a() &#123;</span><br><span class="line">    print(<span class="string">"A's a()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  b() &#123;</span><br><span class="line">    print(<span class="string">"B's b()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用with关键字，表示类C是由类A和类B混合而构成</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>= A <span class="keyword">with</span> B;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  C c = <span class="keyword">new</span> C();</span><br><span class="line">  c.a(); <span class="comment">// A's a()</span></span><br><span class="line">  c.b(); <span class="comment">// B's b()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="静态成员变量-和-静态成员方法"><a href="#静态成员变量-和-静态成员方法" class="headerlink" title="静态成员变量 和 静态成员方法"></a>静态成员变量 和 静态成员方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类的静态成员变量和静态成员方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cons</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> name = <span class="string">"zhangsan"</span>;</span><br><span class="line">  <span class="keyword">static</span> sayHello() &#123;</span><br><span class="line">    print(<span class="string">"hello, this is $&#123;Cons.name&#125;"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  Cons.sayHello(); <span class="comment">// hello, this is zhangsan</span></span><br><span class="line">  print(Cons.name); <span class="comment">// zhangsan</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p><a href="http://dart.goodev.org/guides/language/language-tour#generics%E6%B3%9B%E5%9E%8B" target="_blank" rel="noopener">http://dart.goodev.org/guides/language/language-tour#generics%E6%B3%9B%E5%9E%8B</a></p><p>使用泛型可以减少冗余的代码，<span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>泛型可以在多种类型之间定义同一个实现，在Dart中Dart 的泛型类型是固化的，在运行时有也 可以判断具体的类型。例如在运行时（甚至是成产模式） 也可以检测集合里面的对象类型：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="keyword">new</span> List&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">names.addAll([<span class="string">'Seth'</span>, <span class="string">'Kathy'</span>, <span class="string">'Lars'</span>]);</span><br><span class="line">print(names is List&lt;<span class="built_in">String</span>&gt;); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>这个跟Java中是不同的 Java 中的泛型信息是编译时的，泛型信息在运行时是不纯在的。 在 Java 中你可以测试一个对象是否为 List， 但是你无法测试一个对象是否为 List<string>。</string></p><h2 id="限制型泛型"><a href="#限制型泛型" class="headerlink" title="限制型泛型"></a>限制型泛型</h2><p><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)">使用 </span></span><code>extends</code><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>可以实现这个功能<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// T must be SomeBaseClass or one of its descendants.</span><br><span class="line">class Foo&lt;T extends SomeBaseClass&gt; &#123;...&#125;</span><br><span class="line"></span><br><span class="line">class Extender extends SomeBaseClass &#123;...&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  // It's OK to use SomeBaseClass or any of its subclasses inside &lt;&gt;.</span><br><span class="line">  var someBaseClassFoo = new Foo&lt;SomeBaseClass&gt;();</span><br><span class="line">  var extenderFoo = new Foo&lt;Extender&gt;();</span><br><span class="line"></span><br><span class="line">  // It's also OK to use no &lt;&gt; at all.</span><br><span class="line">  var foo = new Foo();</span><br><span class="line"></span><br><span class="line">  // Specifying any non-SomeBaseClass type results in a warning and, in</span><br><span class="line">  // checked mode, a runtime error.</span><br><span class="line">  // var objectFoo = new Foo&lt;Object&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h2><p>一开始，泛型只能在 Dart 类中使用。 新的语法也支持在函数和方法上使用泛型了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T first&lt;T&gt;(List&lt;T&gt; ts) &#123;</span><br><span class="line">  <span class="comment">// ...Do some initial work or error checking, then...</span></span><br><span class="line">  T tmp ?= ts[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// ...Do some additional checking or processing...</span></span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的 <code>first</code> (<code>&lt;T&gt;</code>) 泛型可以在如下地方使用 参数 <code>T</code> ：</p><ul><li>函数的返回值类型 (<code>T</code>).</li><li>参数的类型 (<code>List&lt;T&gt;</code>).</li><li>局部变量的类型 (<code>T tmp</code>).</li></ul><h1 id="库的可见性"><a href="#库的可见性" class="headerlink" title="库的可见性"></a>库的可见性</h1><ul><li><p>普通引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./util.dart'</span>;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  print(add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>as关键字 设置前缀</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:lib1/lib1.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:lib2/lib2.dart'</span> <span class="keyword">as</span> lib2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uses Element from lib1.</span></span><br><span class="line">Element element1 = Element();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uses Element from lib2.</span></span><br><span class="line">lib2.Element element2 = lib2.Element();</span><br></pre></td></tr></table></figure></li><li><p>show hide 关键字导入包的部分功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只导入foo</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:lib1/lib1.dart'</span> show foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入除了foo的所有其他部分</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:lib2/lib2.dart'</span> hide foo;</span><br></pre></td></tr></table></figure></li><li><p><span data-type="color" style="color:rgb(255, 80, 44)"><span data-type="background" style="background-color:rgb(255, 245, 245)">deferred as </span></span>懒加载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:greetings/hello.dart'</span> deferred <span class="keyword">as</span> hello;</span><br></pre></td></tr></table></figure></li></ul><h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><p><code>Dart</code>提供了类似ES7中的<code>async</code> <code>await</code>等异步操作，这种异步操作在Flutter开发中会经常遇到，比如网络或其他IO操作，文件选择等都需要用到异步的知识。<code>async</code>和<code>await</code>往往是成对出现的，如果一个方法中有耗时的操作，你需要将这个方法设置成<code>async</code>，并给其中的耗时操作加上<code>await</code>关键字，如果这个方法有返回值，你需要将返回值塞到<code>Future</code>中并返回，如下代码所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future checkVersion() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> version = <span class="keyword">await</span> lookUpVersion();</span><br><span class="line">  <span class="comment">// Do something with version</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多请见 <a href="https://segmentfault.com/a/1190000014396421" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014396421</a></p><h1 id="可调用类"><a href="#可调用类" class="headerlink" title="可调用类"></a>可调用类</h1><p>如果 Dart 类实现了 <code>call()</code> 函数则 可以当做方法来调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WannabeFunction</span> </span>&#123;</span><br><span class="line">  call(<span class="built_in">String</span> a, <span class="built_in">String</span> b, <span class="built_in">String</span> c) =&gt; <span class="string">'$a $b $c!'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> wf = <span class="keyword">new</span> WannabeFunction();</span><br><span class="line">  <span class="keyword">var</span> out = wf(<span class="string">"Hi"</span>,<span class="string">"there,"</span>,<span class="string">"gang"</span>);</span><br><span class="line">  print(<span class="string">'$out'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h1><p>使用元数据给你的代码添加其他额外信息。 元数据注解是以 <code>@</code> 字符开头，后面是一个编译时 常量(例如 <code>deprecated</code>)或者 调用一个常量构造函数。<br><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)">有三个注解所有的 Dart 代码都可以使用： </span></span><code>@deprecated</code><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)">、 </span></span><code>@override</code><span data-type="color" style="color:rgb(17, 17, 17)"><span data-type="background" style="background-color:rgb(255, 255, 255)">、 和 </span></span><code>@proxy</code></p><p>你还可以定义自己的元数据注解。 下面的示例定义了一个带有两个参数的 @todo 注解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">library todo;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">todo</span> </span>&#123;</span><br><span class="line">  final <span class="built_in">String</span> who;</span><br><span class="line">  final <span class="built_in">String</span> what;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> todo(<span class="keyword">this</span>.who, <span class="keyword">this</span>.what);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'todo.dart'</span>;</span><br><span class="line"></span><br><span class="line">@todo(<span class="string">'seth'</span>, <span class="string">'make this do something'</span>)</span><br><span class="line"><span class="keyword">void</span> doSomething() &#123;</span><br><span class="line">  print(<span class="string">'do something'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>元数据可以在 library、 class、 typedef、 type parameter、 constructor、 factory、 function、 field、 parameter、或者 variable 声明之前使用，也可以在 import 或者 export 指令之前使用。 使用反射可以在运行时获取元数据 信息。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>中文官方文档 <a href="http://dart.goodev.org/guides/language" target="_blank" rel="noopener">http://dart.goodev.org/guides/language</a></li><li><a href="https://juejin.im/post/5b5005866fb9a04fea589561#heading-14" target="_blank" rel="noopener">https://juejin.im/post/5b5005866fb9a04fea589561#heading-14</a></li><li><a href="https://juejin.im/post/5bcc8527f265da0aff17729a#heading-2" target="_blank" rel="noopener">https://juejin.im/post/5bcc8527f265da0aff17729a#heading-2</a></li><li><a href="https://segmentfault.com/a/1190000014396421" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014396421</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Dart语法基础&quot;&gt;&lt;a href=&quot;#Dart语法基础&quot; class=&quot;headerlink&quot; title=&quot;Dart语法基础&quot;&gt;&lt;/a&gt;Dart语法基础&lt;/h1
      
    
    </summary>
    
      <category term="Dart" scheme="https://xsfelvis.github.io/categories/Dart/"/>
    
    
      <category term="Dart" scheme="https://xsfelvis.github.io/tags/Dart/"/>
    
      <category term="Dart语法基础" scheme="https://xsfelvis.github.io/tags/Dart%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Flutter中消息传递</title>
    <link href="https://xsfelvis.github.io/2019/01/12/%20Flutter%E4%B8%AD%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92/"/>
    <id>https://xsfelvis.github.io/2019/01/12/ Flutter中消息传递/</id>
    <published>2019-01-11T16:00:00.000Z</published>
    <updated>2019-01-12T12:29:44.649Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Flutter中消息传递"><a href="#Flutter中消息传递" class="headerlink" title="Flutter中消息传递"></a>Flutter中消息传递</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在native开发中消息传递有多种手段，系统的广播，第三方的eventbus等，在flutter中会有哪些手段呢？本篇将会介绍</p><h1 id="Flutter中的消息传递"><a href="#Flutter中的消息传递" class="headerlink" title="Flutter中的消息传递"></a>Flutter中的消息传递</h1><h2 id="InheritedWidget"><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h2><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">InheritedWidget是Flutter中非常重要的一个功能型Widget，它可以高效的将数据在</span></span><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"><strong>Widget树中向下传递、共享</strong></span></span><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">，这在一些需要在Widget树中共享数据的场景中非常方便， 我们经常通过这样的方式，通过</span></span><code>BuildContext</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">,可以拿到</span></span><code>Theme</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">和</span></span><code>MediaQuery</code></p><blockquote><p>InheritedWidget和React中的context功能类似，和逐级传递数据相比，它们能实现组件跨级传递数据。InheritedWidget的在Widget树中数据传递方向是从上到下的，这和Notification的传递方向正好相反。</p></blockquote><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">在介绍StatefulWidget时，我们提到State对象有一个回调</span></span><code>didChangeDependencies</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">，它会在“依赖”发生变化时被Flutter Framework调用。而这个“依赖”指的就是是否使用了父widget中InheritedWidget的数据，如果使用了，则代表有依赖，如果没有使用则代表没有依赖。这种机制可以使子组件在所依赖的主题、locale等发生变化时有机会来做一些事情 </span></span>比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到状态栏的高度</span></span><br><span class="line">var statusBarHeight = MediaQuery.of(context).padding.top;</span><br><span class="line"><span class="comment">//复制合并出新的主题</span></span><br><span class="line">var copyTheme =Theme.of(context).copyWith(primaryColor: Colors.blue);</span><br></pre></td></tr></table></figure><h3 id="使用InheritedWidget"><a href="#使用InheritedWidget" class="headerlink" title="使用InheritedWidget"></a>使用<span data-type="color" style="color:rgb(74, 74, 74)"><span data-type="background" style="background-color:rgb(255, 255, 255)">InheritedWidget</span></span></h3><p>主要涉及2部分工作量</p><ul><li>创建一个继承自 InheritedWidget 的类，使用时将其插入 Widget 树</li><li>通过 BuildContext 对象提供的 inheritFromWidgetOfExactType 方法查找 Widget 树中最近的一个特定类型的 InheritedWidget 类的实例</li></ul><p>共享数据类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InheritedContext</span> <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//数据</span></span><br><span class="line">  <span class="keyword">final</span> InheritedTestModel inheritedTestModel;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//点击+号的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="title">Function</span><span class="params">()</span> increment</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//点击-号的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="title">Function</span><span class="params">()</span> reduce</span>;</span><br><span class="line"></span><br><span class="line">  InheritedContext(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.inheritedTestModel,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.increment,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.reduce,</span><br><span class="line">    <span class="meta">@required</span> Widget child,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> InheritedContext <span class="title">of</span><span class="params">(BuildContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> context.inheritFromWidgetOfExactType(InheritedContext);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//是否重建widget就取决于数据是否相同</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function">bool <span class="title">updateShouldNotify</span><span class="params">(InheritedContext oldWidget)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> inheritedTestModel != oldWidget.inheritedTestModel;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在widget中使用共享数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerWidgetB</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function">Widget <span class="title">build</span><span class="params">(BuildContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> inheritedContext = InheritedContext.of(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> inheritedTestModel = inheritedContext.inheritedTestModel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Padding(</span><br><span class="line">      padding: <span class="keyword">const</span> EdgeInsets.only(left: <span class="number">10.0</span>, top: <span class="number">10.0</span>, right: <span class="number">10.0</span>),</span><br><span class="line">      child: <span class="keyword">new</span> Text(</span><br><span class="line">        <span class="string">'当前count:$&#123;inheritedTestModel.count&#125;'</span>,</span><br><span class="line">        style: <span class="keyword">new</span> TextStyle(fontSize: <span class="number">20.0</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在树中从上向下传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="function">Widget <span class="title">build</span><span class="params">(BuildContext context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> InheritedContext(</span><br><span class="line">      inheritedTestModel: inheritedTestModel,</span><br><span class="line">      increment: _incrementCount,</span><br><span class="line">      reduce: _reduceCount,</span><br><span class="line">      child: <span class="keyword">new</span> Scaffold(</span><br><span class="line">        appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">          title: <span class="keyword">new</span> Text(<span class="string">'InheritedWidgetTest'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: <span class="keyword">new</span> Column(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            <span class="keyword">new</span> Padding(</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.only(left: <span class="number">10.0</span>, top: <span class="number">10.0</span>, right: <span class="number">10.0</span>),</span><br><span class="line">              child: <span class="keyword">new</span> Text(<span class="string">'我们常使用的\nTheme.of(context).textTheme\nMediaQuery.of(context).size等\n就是通过InheritedWidget实现的'</span>,</span><br><span class="line">                style: <span class="keyword">new</span> TextStyle(fontSize: <span class="number">20.0</span>),),</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">new</span> CustomerWidgetA(),</span><br><span class="line">            <span class="keyword">new</span> CustomerWidgetB(),</span><br><span class="line">            <span class="keyword">new</span> CustomerWidgetC(),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体代码可以查看</p><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><blockquote><p>MediaQuery.of() called with a context that does not contain a MediaQuery</p></blockquote><p>见ss <a href="https://stackoverflow.com/questions/50214338/flutter-error-mediaquery-of-called-with-a-context-that-does-not-contain-a-med" target="_blank" rel="noopener">https://stackoverflow.com/questions/50214338/flutter-error-mediaquery-of-called-with-a-context-that-does-not-contain-a-med</a><br><span data-type="color" style="color:rgb(36, 39, 41)"><span data-type="background" style="background-color:rgb(255, 255, 255)">You need a </span></span><code>MaterialApp</code><span data-type="color" style="color:rgb(36, 39, 41)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>or a <code>WidgetsApp</code><span data-type="color" style="color:rgb(36, 39, 41)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>arround your widget. They provide the <code>MediaQuery</code><span data-type="color" style="color:rgb(36, 39, 41)"><span data-type="background" style="background-color:rgb(255, 255, 255)">. When you call </span></span><code>.of(context)</code></p><h2 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h2><p>notification 跟inheritedWidget恰恰相反，是从 子节点向父节点发送消息<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">在Widget树中，每一个节点都可以分发通知，通知会沿着当前节点（context）向上传递，所有父节点都可以通过NotificationListener来监听通知，Flutter中称这种通知由子向父的传递为“通知冒泡”（Notification Bubbling）。Flutter中很多地方使用了通知，如可滚动(Scrollable) Widget中滑动时就会分发ScrollNotification，而Scrollbar正是通过监听ScrollNotification来确定滚动条位置的。</span></span></p><h3 id="使用Notification"><a href="#使用Notification" class="headerlink" title="使用Notification"></a>使用Notification</h3><ul><li>自定义通知<br><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">要继承自Notification类</span></span></li><li>分发通知<br><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">Notification有一个</span></span><code>dispatch(context)</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">方法，它是用于分发通知的，我们说过context实际上就是操作Element的一个接口，它与Element树上的节点是对应的，通知会从context对应的Element节点向上冒泡。</span></span></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerNotification</span> <span class="keyword">extends</span> <span class="title">Notification</span> </span>&#123;</span><br><span class="line">  CustomerNotification(<span class="keyword">this</span>.msg);</span><br><span class="line">  <span class="keyword">final</span> String msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotificationStudyState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">NotificationStudy</span>&gt; </span>&#123;</span><br><span class="line">  String _msg = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function">Widget <span class="title">build</span><span class="params">(BuildContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//监听通知</span></span><br><span class="line">    <span class="keyword">return</span> NotificationListener&lt;CustomerNotification&gt;(</span><br><span class="line">      onNotification: (notification) &#123;</span><br><span class="line">        setState(() &#123;</span><br><span class="line">          _msg += notification.msg + <span class="string">"  "</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">      child: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisSize: MainAxisSize.min,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line"><span class="comment">//          RaisedButton(</span></span><br><span class="line"><span class="comment">//           onPressed: () =&gt; CustomerNotification("Hello NotificationStudy").dispatch(context),</span></span><br><span class="line"><span class="comment">//           child: Text("Send Notification"),</span></span><br><span class="line"><span class="comment">//          ),</span></span><br><span class="line">            Builder(</span><br><span class="line">              builder: (context) &#123;</span><br><span class="line">                <span class="keyword">return</span> RaisedButton(</span><br><span class="line">                  <span class="comment">//按钮点击时分发通知</span></span><br><span class="line">                  onPressed: () =&gt; CustomerNotification(<span class="string">"Hello NotificationStudy"</span>).dispatch(context),</span><br><span class="line">                  child: Text(<span class="string">"Send Notification"</span>),</span><br><span class="line">                );</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">            Text(_msg)</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span data-type="color" style="color:rgb(133, 133, 133)"><span data-type="background" style="background-color:rgb(255, 255, 255)">注意：代码中注释的部分是不能正常工作的，因为这个</span></span><code>context</code><span data-type="color" style="color:rgb(133, 133, 133)"><span data-type="background" style="background-color:rgb(255, 255, 255)">是根Context，而NotificationListener是监听的子树，所以我们通过</span></span><code>Builder</code><span data-type="color" style="color:rgb(133, 133, 133)"><span data-type="background" style="background-color:rgb(255, 255, 255)">来构建RaisedButton，来获得按钮位置的context。</span></span></p><p>以上代码 参见 <a href="https://github.com/xsfelvis/learnflutter/tree/a2824a6d0db70fe3d4c92609cbd172ec7854ab3f/lib/demo6" target="_blank" rel="noopener">https://github.com/xsfelvis/learnflutter/tree/a2824a6d0db70fe3d4c92609cbd172ec7854ab3f/lib/demo6</a></p><h2 id="事件总线"><a href="#事件总线" class="headerlink" title="事件总线"></a>事件总线</h2><p>目前在已经有了一个eventbus插件</p><p><a href="https://pub.flutter-io.cn/packages/event_bus#-readme-tab-" target="_blank" rel="noopener">https://pub.flutter-io.cn/packages/event_bus#-readme-tab-</a></p><p>用法跟原生eventbus类似</p><ul><li><p>引入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:event_bus/event_bus.dart'</span>;</span><br><span class="line"></span><br><span class="line">EventBus eventBus = <span class="keyword">new</span> EventBus();</span><br></pre></td></tr></table></figure></li><li><p>监听事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eventBus.on().listen((event) &#123; </span><br><span class="line">    print(event.runtimeType);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>发送事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventBus.fire(event);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Flutter中消息传递&quot;&gt;&lt;a href=&quot;#Flutter中消息传递&quot; class=&quot;headerlink&quot; title=&quot;Flutter中消息传递&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Flutter" scheme="https://xsfelvis.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://xsfelvis.github.io/tags/Flutter/"/>
    
      <category term="Flutter消息传递" scheme="https://xsfelvis.github.io/tags/Flutter%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92/"/>
    
  </entry>
  
  <entry>
    <title>flutter中的路由</title>
    <link href="https://xsfelvis.github.io/2018/12/15/2018-12-15flutter%E4%B8%AD%E7%9A%84%E8%B7%AF%E7%94%B1/"/>
    <id>https://xsfelvis.github.io/2018/12/15/2018-12-15flutter中的路由/</id>
    <published>2018-12-15T06:41:34.032Z</published>
    <updated>2018-12-15T06:42:34.365Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>路由是native中应用的比较多，特别是组件化的工程中，更是用来解耦的利器，比较常用的有阿里的ARouter等，路由这一思想也是借鉴前端而来，比如web中页面跳转就是一个url就到了一个新的页面，Flutter既然是新一代的跨端方案，而且从RN借鉴了不少思想，路由当然也是必不可少的，本篇将了解下Flutter的路由</p><h1 id="Flutter的路由"><a href="#Flutter的路由" class="headerlink" title="Flutter的路由"></a>Flutter的路由</h1><p>在Flutter中支持所有路由场景，<span data-type="color" style="color:rgb(47, 47, 47)"><span data-type="background" style="background-color:rgb(255, 255, 255)">push、pop页面，页面间的参数传递等等。flutter里面的路由可以分成两种，</span></span></p><ul><li><span data-type="color" style="color:rgb(47, 47, 47)"><span data-type="background" style="background-color:rgb(255, 255, 255)">一种是直接注册，不能传递参数，可以称 为静态路由</span></span></li><li><span data-type="color" style="color:rgb(47, 47, 47)"><span data-type="background" style="background-color:rgb(255, 255, 255)">一种要自己构造实例，可以传递参数，可以称为 动态路由。</span></span></li></ul><h2 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h2><p>在<span data-type="color" style="color:rgb(52, 73, 94)">创建时就已经明确知道了要跳转的页面和值，</span><span data-type="color" style="color:rgb(47, 47, 47)"><span data-type="background" style="background-color:rgb(255, 255, 255)">在新建一个MD风格的App的时候，可以传入一个routes参数来定义路由。但是这里定义的路由是静态的，它不可以向下一个页面传递参数</span></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="function">Widget <span class="title">build</span><span class="params">(BuildContext context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">    title: <span class="string">'Flutter Demo'</span>,</span><br><span class="line">    theme: <span class="keyword">new</span> ThemeData(</span><br><span class="line">      primarySwatch: Colors.blue,</span><br><span class="line">    ),</span><br><span class="line">    <span class="comment">//注册路由表</span></span><br><span class="line">    routes: &#123;</span><br><span class="line">      <span class="string">"router/static_page"</span>: (context) =&gt; StaticRoute(),</span><br><span class="line">    &#125;,</span><br><span class="line">    home: <span class="keyword">new</span> MyHomePage(title: <span class="string">'Flutter Demo Home Page'</span>),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过routes这个属性注册好跳转的页面即key-value，上面的代码中 </p><p>key：router/static_page    value: StaticRouter<br>然后使用的时候使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FlatButton(</span><br><span class="line">  child: Text(<span class="string">"open static router"</span>),</span><br><span class="line">  textColor: Colors.blue,</span><br><span class="line">  onPressed: () &#123;</span><br><span class="line">    Navigator.pushNamed(context, <span class="string">"router/static_page"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p><span data-type="color" style="color:rgb(47, 47, 47)"><span data-type="background" style="background-color:rgb(255, 255, 255)">当需要向下一个页面传递参数时，要用到所谓的动态路由，自己生成页面对象，所以可以传递自己想要的参数。</span></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FlatButton(</span><br><span class="line">  child: Text(<span class="string">"open dynamic router"</span>),</span><br><span class="line">  textColor: Colors.blue,</span><br><span class="line">  onPressed: () &#123;</span><br><span class="line">    Navigator.push(context, MaterialPageRoute(</span><br><span class="line">        builder: (context) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> EchoRoute(<span class="string">"传入跳转参数"</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">    或者</span><br><span class="line">    Navigator.of（(context).push(MaterialPageRoute(</span><br><span class="line">        builder: (context) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> EchoRoute(<span class="string">"传入跳转参数"</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="点击返回"><a href="#点击返回" class="headerlink" title="点击返回"></a>点击返回</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> RaisedButton(</span><br><span class="line">  child: <span class="keyword">new</span> Text(<span class="string">"点我返回"</span>),</span><br><span class="line">  onPressed: () &#123;</span><br><span class="line">    Navigator.of(context).pop();</span><br><span class="line">  &#125;,</span><br><span class="line">  color: Colors.blue,</span><br><span class="line">  highlightColor: Colors.lightBlue,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们可以在前一个页面接受第二个页面的返回值<br>在第一个页面跳转时候加上futrue来接收<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FlatButton(</span><br><span class="line">  child: Text(<span class="string">"open dynamic router"</span>),</span><br><span class="line">  textColor: Colors.blue,</span><br><span class="line">  onPressed: () &#123;</span><br><span class="line">    Future future = Navigator.push(context,</span><br><span class="line">        MaterialPageRoute(builder: (context) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> EchoRoute(<span class="string">"传入跳转参数"</span>);</span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="comment">//接收动态页面返回时传回的值</span></span><br><span class="line">    future.then((value) &#123;</span><br><span class="line">      showDialog(</span><br><span class="line">          context: context,</span><br><span class="line">          child: <span class="keyword">new</span> AlertDialog(</span><br><span class="line">            title: <span class="keyword">new</span> Text(value),</span><br><span class="line">          ));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>在EchoRoute页面 返回时使用带参数的pop方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> RaisedButton(</span><br><span class="line">                child: <span class="keyword">new</span> Text(<span class="string">"点我返回"</span>),</span><br><span class="line">                onPressed: () &#123;</span><br><span class="line"><span class="comment">//                  Navigator.of(context).pop();</span></span><br><span class="line">                  Navigator.of(context).pop(<span class="string">"我是来自dymamic 关闭的返回值"</span>);</span><br><span class="line">                &#125;,</span><br><span class="line">                color: Colors.blue,</span><br><span class="line">                highlightColor: Colors.lightBlue,</span><br><span class="line">              )</span><br></pre></td></tr></table></figure></p><p>这样就会在关闭EchoRoute回到跳转前页面时弹出dialog收到EchoRoute传来的参数</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">Navigator的职责是负责管理Route的，管理方式就是利用一个栈不停压入弹出，当然也可以直接替换其中某一个Route。而Route作为一个管理单元，主要负责创建对应的界面，响应Navigator压入路由和弹出路由</span></span></p><p>入栈：</p><ul><li>使用Navigator.of(context).pushName(“path“)或者Navigator.pushName(context,“path“)可以进行静态路由的跳转前提是需要在route属性里面注册</li><li>使用push(Route)可以进行态路由的跳转，动态路由可以传入未知数据</li></ul><p>出栈</p><ul><li>使用pop()可以进行路由的出栈并且可以传递参数</li><li>可以使用Future接收上个页面返回的值。</li></ul><p>代码在 <a href="https://github.com/xsfelvis/learnflutter/blob/e7bd2e29c1b39c8ea19e06bfebb6e7d55b9ab42a/lib/demo4/demo4main.dart" target="_blank" rel="noopener">https://github.com/xsfelvis/learnflutter/blob/e7bd2e29c1b39c8ea19e06bfebb6e7d55b9ab42a/lib/demo4/demo4main.dart</a></p><p># </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;路由是native中应用的比较多，特别是
      
    
    </summary>
    
      <category term="Flutter" scheme="https://xsfelvis.github.io/categories/Flutter/"/>
    
    
      <category term="路由" scheme="https://xsfelvis.github.io/tags/%E8%B7%AF%E7%94%B1/"/>
    
      <category term="Flutter" scheme="https://xsfelvis.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>dio+json_serializable从网络请求到数据解析</title>
    <link href="https://xsfelvis.github.io/2018/12/08/dio+json_serializable%E8%AF%B7%E6%B1%82%E5%88%B0%E8%A7%A3%E6%9E%90%E6%95%B0%E6%8D%AE/"/>
    <id>https://xsfelvis.github.io/2018/12/08/dio+json_serializable请求到解析数据/</id>
    <published>2018-12-07T16:00:00.000Z</published>
    <updated>2018-12-08T12:01:25.280Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网络请求到数据解析是一个app必不可少的流程之一，在flutter官网中目前主要是介绍 自带的<a href="https://flutterchina.club/networking/" target="_blank" rel="noopener">Http</a>请求+<a href="https://flutterchina.club/json/" target="_blank" rel="noopener">Json解析</a> 但是也推荐了更好的网路请求到组合的方式 dio 和 json_serializable，本篇文章主要介绍这两个方式的使用，源码在结尾</p><h1 id="dio"><a href="#dio" class="headerlink" title="dio"></a>dio</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>package地址 <a href="https://pub.flutter-io.cn/packages/dio" target="_blank" rel="noopener">https://pub.flutter-io.cn/packages/dio</a>，<br>添加依赖</p><blockquote><p><span data-type="color" style="color:rgb(51, 51, 51)">dependencies:  </span><br>    <strong>dio: </strong><strong><span data-type="color" style="color:rgb(221, 17, 68)">^1.0.9</span></strong><br>支持了<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">支持Restful API、FormData、拦截器、请求取消、Cookie管理、文件上传/下载、超时等</span></span><br>Performing a <code>GET</code> request: 简单的使用如下</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Response response;</span><br><span class="line">response=await dio.get(<span class="string">"/test?id=12&amp;name=wendu"</span>)</span><br><span class="line">print(response.data.toString());</span><br><span class="line"><span class="comment">// Optionally the request above could also be done as</span></span><br><span class="line">response=await dio.get(<span class="string">"/test"</span>,data:&#123;<span class="string">"id"</span>:<span class="number">12</span>,<span class="string">"name"</span>:<span class="string">"wendu"</span>&#125;)</span><br><span class="line">print(response.data.toString());</span><br></pre></td></tr></table></figure><p>Performing a <code>POST</code> request:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response=await dio.post(<span class="string">"/test"</span>,data:&#123;<span class="string">"id"</span>:<span class="number">12</span>,<span class="string">"name"</span>:<span class="string">"wendu"</span>&#125;)</span><br></pre></td></tr></table></figure><p>Performing multiple concurrent requests:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response= await Future.wait([dio.post(<span class="string">"/info"</span>),dio.get(<span class="string">"/token"</span>)]);</span><br></pre></td></tr></table></figure><p>Downloading a file:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response=await dio.download(<span class="string">"https://www.google.cn/"</span>,<span class="string">"./xx.html"</span>)</span><br></pre></td></tr></table></figure><p>Sending FormData:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FormData formData = <span class="keyword">new</span> FormData.from(&#123;</span><br><span class="line">   <span class="string">"name"</span>: <span class="string">"wendux"</span>,</span><br><span class="line">   <span class="string">"age"</span>: <span class="number">25</span>,</span><br><span class="line">&#125;);</span><br><span class="line">response = await dio.post(<span class="string">"/info"</span>, data: formData)</span><br></pre></td></tr></table></figure><p>Uploading multiple files to server by FormData:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FormData formData = <span class="keyword">new</span> FormData.from(&#123;</span><br><span class="line">   <span class="string">"name"</span>: <span class="string">"wendux"</span>,</span><br><span class="line">   <span class="string">"age"</span>: <span class="number">25</span>,</span><br><span class="line">   <span class="string">"file1"</span>: <span class="keyword">new</span> UploadFileInfo(<span class="keyword">new</span> File(<span class="string">"./upload.txt"</span>), <span class="string">"upload1.txt"</span>),</span><br><span class="line">   <span class="comment">// upload with bytes (List&lt;int&gt;) </span></span><br><span class="line">   <span class="string">"file2"</span>: <span class="keyword">new</span> UploadFileInfo.fromBytes(utf8.encode(<span class="string">"hello world"</span>),<span class="string">"word.txt"</span>),</span><br><span class="line">   <span class="comment">// Pass multiple files within an Array </span></span><br><span class="line">   <span class="string">"files"</span>: [</span><br><span class="line">      <span class="keyword">new</span> UploadFileInfo(<span class="keyword">new</span> File(<span class="string">"./example/upload.txt"</span>), <span class="string">"upload.txt"</span>),</span><br><span class="line">      <span class="keyword">new</span> UploadFileInfo(<span class="keyword">new</span> File(<span class="string">"./example/upload.txt"</span>), <span class="string">"upload.txt"</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br><span class="line">response = await dio.post(<span class="string">"/info"</span>, data: formData)</span><br></pre></td></tr></table></figure><p>更多可以参考作者的<a href="https://juejin.im/post/5b04c954f265da0b9c10fb61" target="_blank" rel="noopener">说明文章</a>以及 <a href="https://github.com/flutterchina/dio/tree/flutter/example" target="_blank" rel="noopener">example</a></p><p>并且由于flutter原生的网络库http不支持charles抓包，这个库可以使用设置代理来达到抓包的目的，ip自己替换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dio.onHttpClientCreate = (HttpClient client) &#123;</span><br><span class="line">  client.findProxy = (uri) &#123;</span><br><span class="line">    <span class="comment">//proxy all request to localhost:8888</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"PROXY yourIP:yourPort"</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样就可抓包了。</p><h2 id="网络请求封装使用"><a href="#网络请求封装使用" class="headerlink" title="网络请求封装使用"></a>网络请求封装使用</h2><p>简单封装使我们更加容易的使用，核心代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_request</span><span class="params">(String url, Function callBack,</span></span></span><br><span class="line"><span class="function"><span class="params">      &#123;String method,</span></span></span><br><span class="line"><span class="function"><span class="params">      Map&lt;String, String&gt; params,</span></span></span><br><span class="line"><span class="function"><span class="params">      Function errorCallBack&#125;)</span> async </span>&#123;</span><br><span class="line"><span class="comment">//    dio.onHttpClientCreate = (HttpClient client) &#123;</span></span><br><span class="line"><span class="comment">//      client.findProxy = (uri) &#123;</span></span><br><span class="line"><span class="comment">//        //proxy all request to localhost:8888</span></span><br><span class="line"><span class="comment">//        return "PROXY 172.23.235.153:8888";</span></span><br><span class="line"><span class="comment">//      &#125;;</span></span><br><span class="line"><span class="comment">//    &#125;;</span></span><br><span class="line">    String errorMsg = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> statusCode;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Response response;</span><br><span class="line">      <span class="keyword">if</span> (method == GET) &#123;</span><br><span class="line">        <span class="keyword">if</span> (params != <span class="keyword">null</span> &amp;&amp; params.isNotEmpty) &#123;</span><br><span class="line">          StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"?"</span>);</span><br><span class="line">          params.forEach((key, value) &#123;</span><br><span class="line">            sb.write(<span class="string">"$key"</span> + <span class="string">"="</span> + <span class="string">"$value"</span> + <span class="string">"&amp;"</span>);</span><br><span class="line">          &#125;);</span><br><span class="line">          String paramStr = sb.toString();</span><br><span class="line">          paramStr = paramStr.substring(<span class="number">0</span>, paramStr.length - <span class="number">1</span>);</span><br><span class="line">          url += paramStr;</span><br><span class="line">        &#125;</span><br><span class="line">        response = await dio.get(url);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method == POST) &#123;</span><br><span class="line">        <span class="keyword">if</span> (params != <span class="keyword">null</span> &amp;&amp; params.isNotEmpty) &#123;</span><br><span class="line">          response = await dio.post(url, data: params);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          response = await dio.post(url);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      statusCode = response.statusCode;</span><br><span class="line">      <span class="keyword">if</span> (statusCode &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        errorMsg = <span class="string">"网络请求错误,状态码:"</span> + statusCode.toString();</span><br><span class="line">        _handError(errorCallBack, errorMsg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (callBack != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String res2Json  = json.encode(response.data);</span><br><span class="line">        Map&lt;String,dynamic&gt; map=json.decode(res2Json);</span><br><span class="line">        callBack(map[<span class="string">"data"</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (exception) &#123;</span><br><span class="line">      _handError(errorCallBack, exception.toString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>详细的可以参考源码<a href="https://github.com/xsfelvis/learnflutter/blob/047fb2c9cc08334c1adcc7b7892ebfe28a2cf13f/lib/demo3/utils/net/HttpCore.dart" target="_blank" rel="noopener">https://github.com/xsfelvis/learnflutter/blob/047fb2c9cc08334c1adcc7b7892ebfe28a2cf13f/lib/demo3/utils/net/HttpCore.dart</a></p><p>使用如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HttpCore.instance.get(Api.HOME_BANNER, (data) &#123;</span><br><span class="line">  List&lt;BannerData&gt; banners = getBannersList(data);</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    slideData = banners;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, errorCallBack: (errorMsg) &#123;</span><br><span class="line">  print(<span class="string">"error:"</span> + errorMsg);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><p>在封装网络库的的时候发现 底层 response.data[‘data’]时候当是一个<a href="ttp://www.wanandroid.com/banner/json" target="_blank" rel="noopener">jsonarray</a>时候竟然无法直接取出’data’,”Stirng not subType of Index “错误，原因是 此时拿到的不是一个json数据，没有双引号的假json数据，但是在<a href="http://www.wanandroid.com/article/list/1/json" target="_blank" rel="noopener">jsonobject</a>却可以，解决如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (callBack != <span class="keyword">null</span>) &#123;</span><br><span class="line">  String res2Json  = json.encode(response.data);</span><br><span class="line">  Map&lt;String,dynamic&gt; map=json.decode(res2Json);</span><br><span class="line">  callBack(map[<span class="string">"data"</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="json-serializable"><a href="#json-serializable" class="headerlink" title="json_serializable"></a>json_serializable</h1><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>package地址 <a href="https://pub.flutter-io.cn/packages/json_serializable" target="_blank" rel="noopener">https://pub.flutter-io.cn/packages/json_serializable</a><br>添加依赖</p><blockquote><p><span data-type="color" style="color:rgb(51, 51, 51)">dependencies:  </span><br>    <strong>json_serializable: </strong><strong><span data-type="color" style="color:rgb(221, 17, 68)">^2.0.0 </span></strong><br>dev_dependencies<br>    build_runner: ^1.1.2<br>    json_serializable: ^2.0.0</p></blockquote><p>这个是个好东西，之前的相当于json数据一个个通过key解出来（关于自带的json解析可以参考 <a href="https://juejin.im/post/5b5d782ae51d45191c7e7fb3#heading-7" target="_blank" rel="noopener">https://juejin.im/post/5b5d782ae51d45191c7e7fb3#heading-7</a>），不仅耗时而且容易出错，json_serializable 让我们直接反序列化成对象直接使用类似于Gson，而且还提供了<a href="https://caijinglong.github.io/json2dart/index_ch.html" target="_blank" rel="noopener">一个工具</a>来自动帮助我们生成代码，简单快捷而且不容易出错</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>以json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>:&#123;</span><br><span class="line">        <span class="attr">"curPage"</span>:<span class="number">2</span>,</span><br><span class="line">        <span class="attr">"datas"</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"apkLink"</span>:<span class="string">""</span>,</span><br><span class="line">                <span class="attr">"author"</span>:<span class="string">"鸿洋"</span>,</span><br><span class="line">                <span class="attr">"chapterId"</span>:<span class="number">410</span>,</span><br><span class="line">                <span class="attr">"chapterName"</span>:<span class="string">"玉刚说"</span>,</span><br><span class="line">                <span class="attr">"collect"</span>:<span class="literal">false</span>,</span><br><span class="line">                <span class="attr">"courseId"</span>:<span class="number">13</span>,</span><br><span class="line">                <span class="attr">"desc"</span>:<span class="string">""</span>,</span><br><span class="line">                <span class="attr">"envelopePic"</span>:<span class="string">""</span>,</span><br><span class="line">                <span class="attr">"fresh"</span>:<span class="literal">false</span>,</span><br><span class="line">                <span class="attr">"id"</span>:<span class="number">7604</span>,</span><br><span class="line">                <span class="attr">"link"</span>:<span class="string">"https://mp.weixin.qq.com/s/cCZKmqKrdCn63eWTbOuANw"</span>,</span><br><span class="line">                <span class="attr">"niceDate"</span>:<span class="string">"2018-12-03"</span>,</span><br><span class="line">                <span class="attr">"origin"</span>:<span class="string">""</span>,</span><br><span class="line">                <span class="attr">"projectLink"</span>:<span class="string">""</span>,</span><br><span class="line">                <span class="attr">"publishTime"</span>:<span class="number">1543830090000</span>,</span><br><span class="line">                <span class="attr">"superChapterId"</span>:<span class="number">408</span>,</span><br><span class="line">                <span class="attr">"superChapterName"</span>:<span class="string">"公众号"</span>,</span><br><span class="line">                <span class="attr">"tags"</span>:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>:<span class="string">"公众号"</span>,</span><br><span class="line">                        <span class="attr">"url"</span>:<span class="string">"/wxarticle/list/410/1"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">"title"</span>:<span class="string">"在 Retrofit 和 OkHttp 中使用网络缓存，提高访问效率"</span>,</span><br><span class="line">                <span class="attr">"type"</span>:<span class="number">0</span>,</span><br><span class="line">                <span class="attr">"userId"</span>:<span class="number">-1</span>,</span><br><span class="line">                <span class="attr">"visible"</span>:<span class="number">1</span>,</span><br><span class="line">                <span class="attr">"zan"</span>:<span class="number">0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"apkLink"</span>:<span class="string">""</span>,</span><br><span class="line">                <span class="attr">"author"</span>:<span class="string">"鸿洋"</span>,</span><br><span class="line">                <span class="attr">"chapterId"</span>:<span class="number">408</span>,</span><br><span class="line">                <span class="attr">"chapterName"</span>:<span class="string">"鸿洋"</span>,</span><br><span class="line">                <span class="attr">"collect"</span>:<span class="literal">false</span>,</span><br><span class="line">                <span class="attr">"courseId"</span>:<span class="number">13</span>,</span><br><span class="line">                <span class="attr">"desc"</span>:<span class="string">""</span>,</span><br><span class="line">                <span class="attr">"envelopePic"</span>:<span class="string">""</span>,</span><br><span class="line">                <span class="attr">"fresh"</span>:<span class="literal">false</span>,</span><br><span class="line">                <span class="attr">"id"</span>:<span class="number">7605</span>,</span><br><span class="line">                <span class="attr">"link"</span>:<span class="string">"https://mp.weixin.qq.com/s/r3AWeYafyMEc1-g8BWEHBg"</span>,</span><br><span class="line">                <span class="attr">"niceDate"</span>:<span class="string">"2018-12-03"</span>,</span><br><span class="line">                <span class="attr">"origin"</span>:<span class="string">""</span>,</span><br><span class="line">                <span class="attr">"projectLink"</span>:<span class="string">""</span>,</span><br><span class="line">                <span class="attr">"publishTime"</span>:<span class="number">1543766400000</span>,</span><br><span class="line">                <span class="attr">"superChapterId"</span>:<span class="number">408</span>,</span><br><span class="line">                <span class="attr">"superChapterName"</span>:<span class="string">"公众号"</span>,</span><br><span class="line">                <span class="attr">"tags"</span>:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>:<span class="string">"公众号"</span>,</span><br><span class="line">                        <span class="attr">"url"</span>:<span class="string">"/wxarticle/list/408/1"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">"title"</span>:<span class="string">"非 UI 线程能调用 View.invalidate()？"</span>,</span><br><span class="line">                <span class="attr">"type"</span>:<span class="number">0</span>,</span><br><span class="line">                <span class="attr">"userId"</span>:<span class="number">-1</span>,</span><br><span class="line">                <span class="attr">"visible"</span>:<span class="number">1</span>,</span><br><span class="line">                <span class="attr">"zan"</span>:<span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"offset"</span>:<span class="number">20</span>,</span><br><span class="line">        <span class="attr">"over"</span>:<span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"pageCount"</span>:<span class="number">289</span>,</span><br><span class="line">        <span class="attr">"size"</span>:<span class="number">20</span>,</span><br><span class="line">        <span class="attr">"total"</span>:<span class="number">5779</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"errorCode"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="attr">"errorMsg"</span>:<span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为例，我们首先找到实际数据信息，因为异errorcode 之类的处理已在上面的封装网络请求中处理了，这里需要关注 实际内容传递者 “data”里面的数据，将上面这个data里面的jsonObject，从data 这个key后面包括大括号一起复制到上面的代码生成工具网页里面，截图如下</p><p><img src="https://cdn.nlark.com/yuque/0/2018/png/215777/1544266913529-762efea8-b8e9-4d65-b7a1-67599f277055.png" alt="image.png | left | 747x341"></p><p>然后<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">当前项目的目录下运行</span></span><br><code>flutter packages pub run build_runner build</code></p><p>然就可以得到news.g.dart文件</p><p>然后在使用中通过获取对象属性的方式就可以直接拿到我们关注的字段了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  获取News数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_getNewsList</span><span class="params">(<span class="keyword">int</span> curpage)</span> </span>&#123;</span><br><span class="line">  var url = Api.HOME_ARTICLE + curpage.toString() + <span class="string">"/json"</span>;</span><br><span class="line">  HttpCore.instance.get(url, (data) &#123;</span><br><span class="line">    News news = News.fromJson(data);</span><br><span class="line">    List&lt;Datas&gt; newsDatas = news.datas;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      listData = newsDatas;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="自定义字段的处理"><a href="#自定义字段的处理" class="headerlink" title="自定义字段的处理"></a>自定义字段的处理</h4><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">我们可以通过JsonKey自定义参数进行注释并自定义参数来自定义各个字段。例如:是否允许字段为空等。</span></span><strong>注意，这里不加任何JsonKey默认允许空json字段。</strong><br>比如解析字段有个横线，<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">而dart中只允许字母数字下划线作为变量名。所以我们必须对它进行特殊处理。@JsonKey(name=&quot;Nicehash-CNHeavy&quot;)来解析map，通常自动生成代码的工具已经可以帮助我们解决了</span></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonKey</span>(name: <span class="string">'off-set'</span>)</span><br><span class="line"><span class="keyword">int</span> offset;</span><br></pre></td></tr></table></figure><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>效果如下图</p><p><img src="https://cdn.nlark.com/yuque/0/2018/png/215777/1544267293376-274ccea1-1b3b-457c-8150-04fd795f6909.png" alt="image.png | left | 250x515.9574468085107"></p><p>接口来自 <a href="http://www.wanandroid.com/blog/show/2" target="_blank" rel="noopener">玩Android的开放接口</a></p><p>代码在<a href="https://github.com/xsfelvis/learnflutter" target="_blank" rel="noopener"> learnflutter</a> 的demo3</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;网络请求到数据解析是一个app必不可少的
      
    
    </summary>
    
      <category term="Flutter" scheme="https://xsfelvis.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://xsfelvis.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入坑指南</title>
    <link href="https://xsfelvis.github.io/2018/12/01/Flutter%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <id>https://xsfelvis.github.io/2018/12/01/Flutter入坑指南/</id>
    <published>2018-11-30T16:00:00.000Z</published>
    <updated>2018-12-01T14:09:58.365Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是一个纯Flutter项目，主要通过实现网络请求新闻表展示以及跳转webview详情页，来初步感受了一下最近很火的Flutter</p><p><img src="https://cdn.nlark.com/yuque/0/2018/png/215777/1543666189481-c2561294-1f65-4191-b487-8a8e7675d3ba.png" alt="image.png | left | 200x348.28660436137073"></p><p>代码在 <a href="https://github.com/xsfelvis/learnflutter.git" target="_blank" rel="noopener">源码地址</a> 部分代码参考 <a href="https://github.com/zhangjianli/flutter_news" target="_blank" rel="noopener">https://github.com/zhangjianli/flutter_news</a></p><h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><p>可以参考 <a href="https://flutterchina.club/setup-macos/" target="_blank" rel="noopener">Flutter中文网</a> 我使用的是AndroidStudio，这里需要注意的是下载下来的flutter sdk 在会自动下载dart sdk 具体在 flutter/bin/cache/dark-sdk往往在导入新工程时候需要设置dart sdk 注意设置一下就好</p><h1 id="Dart"><a href="#Dart" class="headerlink" title="Dart"></a>Dart</h1><p>Flutter的开发语言采用Dart，这是一门很棒的语言，集合了现代语言的很多优点，学习了一下之后感觉有java的影子，也有es6的影子，写起来很简练,Dart有个<a href="http://dart.goodev.org/guides/language/language-tour#operators%E6%93%8D%E4%BD%9C%E7%AC%A6" target="_blank" rel="noopener">官方学习网站</a></p><h1 id="Flutter之布局"><a href="#Flutter之布局" class="headerlink" title="Flutter之布局"></a>Flutter之布局</h1><p>比如实现一个如下的布局</p><p><img src="https://cdn.nlark.com/yuque/0/2018/png/215777/1543669524555-f934cfa0-42a7-438f-ac6a-6237b9118896.png" alt="stack.png | center | 150x150"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function">Widget <span class="title">build</span><span class="params">(BuildContext context)</span> </span>&#123;</span><br><span class="line">    var stack = <span class="keyword">new</span> Stack(</span><br><span class="line">      alignment: <span class="function"><span class="keyword">const</span> <span class="title">Alignment</span><span class="params">(<span class="number">0.6</span>, <span class="number">0.6</span>)</span>,</span></span><br><span class="line"><span class="function">      children: [</span></span><br><span class="line"><span class="function">        new <span class="title">CircleAvatar</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          backgroundImage: new AssetImage(<span class="string">'images/pic.jpg'</span>)</span>,</span></span><br><span class="line"><span class="function">          radius: 100.0,</span></span><br><span class="line"><span class="function">        ),</span></span><br><span class="line"><span class="function">        new <span class="title">Container</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          decoration: new BoxDecoration(</span></span></span><br><span class="line"><span class="function"><span class="params">            color: Colors.black45,</span></span></span><br><span class="line"><span class="function"><span class="params">          )</span>,</span></span><br><span class="line"><span class="function">          child: new <span class="title">Text</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">'Mia B'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            style: new TextStyle(</span></span></span><br><span class="line"><span class="function"><span class="params">              fontSize: <span class="number">20.0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              fontWeight: FontWeight.bold,</span></span></span><br><span class="line"><span class="function"><span class="params">              color: Colors.white,</span></span></span><br><span class="line"><span class="function"><span class="params">            )</span>,</span></span><br><span class="line"><span class="function">          ),</span></span><br><span class="line"><span class="function">        ),</span></span><br><span class="line"><span class="function">      ],</span></span><br><span class="line"><span class="function">    )</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看其实挺懵逼的，</p><p>要记住一点在Flutter中一切皆为’<a href="https://flutterchina.club/widgets/layout/" target="_blank" rel="noopener">Widget</a>‘，<span data-type="color" style="color:rgb(26, 26, 26)"><span data-type="background" style="background-color:rgb(255, 255, 255)">在flutter的世界里，包括views,view controllers,layouts等在内的概念都建立在Widget之上。widget是flutter功能的抽象描述,掌握Flutter的基础就是学会使用widget开始</span></span>甚至一个padding就是一个widget，官网是按照子元素来分类的</p><ul><li>单个子元素（child）的布局，包括Container、Padding等<code>18</code>种（目前是2018年12月1日，后续我想肯定会增加的）；</li><li>多个子元素（children）的布局，包括Row、Column等<code>11</code>种；</li><li>layout helper，例如ListView.Builder，在元素多的时候，用这种方式更加的高效，类似Android的RecyclerView，有自动的回收机制。这种严格意义上不能算是一个种类，我觉得这种helper会越来越多。</li></ul><p>常见有的<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">其中常用有 </span></span><em>Container、Padding、Center、Flex、Stack、Row、Column、ListView</em><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>等</p><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="auto"><br>      <col width="auto"><br>    </colgroup><br>    <tbody><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">类型</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">特点</div><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">Container</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">只有一个子 Widget。默认充满，包含了padding、margin、color、宽高、decoration 等配置。<br>          </div><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">Padding</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">只有一个子 Widget。只用于设置Padding，常用于嵌套child，给child设置padding。<br>          </div><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">Center </div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">只有一个子 Widget。只用于居中显示，常用于嵌套child，给child设置居中。<br>          </div><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">Expanded</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">只有一个子 Widget。在 Column 和 Row 中充满。</div><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">Stack </div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">可以有多个子 Widget。 子Widget堆叠在一起。 (类似Android的 FrameLayout)</div><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">Column</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">可以有多个子 Widget。垂直布局。 (类似Android的 LinearLayout vertical)</div><br>        </td><br>      </tr><br>      <tr height="34px"><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">Row</div><br>        </td><br>        <td rowspan="1" colspan="1"><br>          <div data-type="p">可以有多个子 Widget。水平布局。 (类似Android的 LinearLayout horizon)</div><br>        </td><br>      </tr><br>    </tbody><br>  </table><br></div><p>这布局写起来确实很酸爽，不过统一渲染效率更高，但是掌握起来比较费事，感觉平台侧的一些成本转嫁到开发者身上，不知道后期有没有类似xml这种布局单独剥离出来的实现。</p><h2 id="widget详解"><a href="#widget详解" class="headerlink" title="widget详解"></a>widget详解</h2><p>一切皆为widget，主要分为两类 <span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">StatefulWidget(有状态)</span></span>和 <span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">StatelessWidget(无状态)</span></span></p><ul><li><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">StatefulWidget(有状态)</span></span><br><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">如果一个控件需要动态的去改变或者相应一些状态，例如点击态、色值、内容区域等，那么一般都是继承自StatefulWidget，常见的有CheckBox、AppBar、TabBar等</span></span></li><li><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">StatelessWidget(无状态)</span></span><br><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">如果一个控件自身状态不会去改变，创建了就直接显示，不会有色值、大小或者其他属性的变化，这种widget一般都是继承自StatelessWidget，常见的有Container、ScrollView等</span></span></li></ul><p>StatefulWidget和StatelessWidget如下所示</p><p><img src="https://cdn.nlark.com/yuque/0/2018/png/215777/1543671041809-a8dbbd7b-8372-4d53-9a6c-c852f3123920.png" alt="image.png | left | 747x214"></p><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">一个StatelessWidget可以用多个不同的BuildContext构建，而一个StatefulWidget会为每个BuildContext创建一个State对象</span></span></p><p>对于StatelessWidget，build方法会在如下三种情况下调用，</p><ol><li>widget第一次被插入到树中；</li><li>widget的父节点更改了配置（configuration）；</li><li>widget依赖的InheritedWidget改变了;</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frog</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">Frog</span><span class="params">(&#123; Key key &#125;)</span> : <span class="title">super</span><span class="params">(key: key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function">Widget <span class="title">build</span><span class="params">(BuildContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Container(color: <span class="function"><span class="keyword">const</span> <span class="title">Color</span><span class="params">(<span class="number">0xFF2DBD3A</span>)</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StatefulWidget的两个主要类别：</p><ul><li>在initState中创建资源，在dispose中销毁，但是不依赖于InheritedWidget或者调用setState方法，这类widget基本上用在一个应用或者页面的root；</li><li>使用setState或者依赖于InheritedWidget，这种会在生命周期中会被重建（rebuild）很多次。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YellowBird</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">YellowBird</span><span class="params">(&#123; Key key &#125;)</span> : <span class="title">super</span><span class="params">(key: key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function">_YellowBirdState <span class="title">createState</span><span class="params">()</span> </span>=&gt; <span class="keyword">new</span> _YellowBirdState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_YellowBirdState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">YellowBird</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function">Widget <span class="title">build</span><span class="params">(BuildContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Container(color: <span class="function"><span class="keyword">const</span> <span class="title">Color</span><span class="params">(<span class="number">0xFFFFE306</span>)</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p>状态有何作用呢</p><ul><li>在widget构建的时候可以被同步读取；</li><li><p>在widget的生命周期中可能会被改变。</p><h3 id="State生命周期"><a href="#State生命周期" class="headerlink" title="State生命周期"></a>State生命周期</h3><p>对应的生命周期如下</p></li><li><p>created：当State对象被创建时候，State.initState方法会被调用；</p></li><li>initialized：当State对象被创建，但还没有准备构建时，State.didChangeDependencies在这个时候会被调用；</li><li>ready：State对象已经准备好了构建，State.dispose没有被调用的时候；</li><li>defunct：State.dispose被调用后，State对象不能够被构建</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2018/png/215777/1543671683971-29e23732-0120-4cd7-a8d1-019a3ba5510b.png" alt="image.png | left | 747x391"></p><p>完整生命周期如下：</p><ul><li>创建一个State对象时，会调用StatefulWidget.createState；</li><li>和一个BuildContext相关联，可以认为被加载了（mounted）；</li><li>调用initState；</li><li>调用didChangeDependencies；</li><li>经过上述步骤，State对象被完全的初始化了，调用build；</li><li>如果有需要，会调用didUpdateWidget；</li><li>如果处在开发模式，热加载会调用reassemble；</li><li>如果它的子树（subtree）包含需要被移除的State对象，会调用deactivate；</li><li>调用dispose,State对象以后都不会被构建；</li><li>当调用了dispose,State对象处于未加载（unmounted），已经被dispose的State对象没有办法被重新加载（remount）。</li></ul><h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">当修改状态时，调用setState widget会被更新</span></span></p><h2 id="如何布局"><a href="#如何布局" class="headerlink" title="如何布局"></a>如何布局</h2><p>每个页面设计都不一样，相同页面可选择的布局方式也不一样，可以参考下<a href="https://link.juejin.im?target=https%3A%2F%2Fflutterchina.club%2Ftutorials%2Flayout%2F%23common-layout-widgets" target="_blank" rel="noopener">Flutter官方的布局教程</a>。整个过程，基本上按照拆解、组件封装、具体布局这三步来的。</p><h1 id="Flutter之网络请求"><a href="#Flutter之网络请求" class="headerlink" title="Flutter之网络请求"></a>Flutter之网络请求</h1><p>在Android开发者我们可以使用okHttp，Flutter给我们封装好了，在pubspec.yaml文件中接入网络依赖库，相当于gradle的dependency，可以在 <a href="https://pub.flutter-io.cn/flutter/packages?q=http" target="_blank" rel="noopener">包查找</a> 中找到最新版本，在pubspec.yaml接入时候主要空格就好<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  flutter:</span><br><span class="line">    sdk: flutter</span><br><span class="line"></span><br><span class="line">  json_annotation: ^2.0.0</span><br><span class="line">  flutter_webview_plugin: ^0.3.0+2</span><br><span class="line">  http: ^0.12.0</span><br><span class="line"></span><br><span class="line">  # The following adds the Cupertino Icons font to your application.</span><br><span class="line">  # Use with the CupertinoIcons class for iOS style icons.</span><br><span class="line">  cupertino_icons: ^0.1.2</span><br></pre></td></tr></table></figure></p><p>具体使用起来也比较简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsApi</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Future&lt;NewsList&gt; <span class="title">getHeadlines</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      &#123;String category: <span class="string">"general"</span>, <span class="keyword">int</span> page: <span class="number">0</span>&#125;)</span> async </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> response = await http.get(</span><br><span class="line">        <span class="string">"https://newsapi.org/v2/top-headlines?country=us&amp;apiKey=$apikey&amp;page=$page&amp;category=$category"</span>);</span><br><span class="line">    <span class="keyword">return</span> compute(parseResult, response.body);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> NewsList <span class="title">parseResult</span><span class="params">(String respond)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> NewsList.fromJson(json.decode(respond));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体可以学习官网 <a href="https://flutterchina.club/networking/" target="_blank" rel="noopener">在Flutter中发起HTTP网络请求</a></p><h1 id="Flutter之数据解析"><a href="#Flutter之数据解析" class="headerlink" title="Flutter之数据解析"></a>Flutter之数据解析</h1><p>官网也给了反序列化的方法但是感觉比较古老，就跟json一样拿到msg一个个解析，有个更好的方式直接反序列化成对象，后面使用更加快捷</p><p>首先需要添加依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  ……</span><br><span class="line">  json_annotation: ^2.0.0</span><br><span class="line">dev_dependencies:</span><br><span class="line">  ……</span><br><span class="line">  build_runner: ^1.1.2</span><br><span class="line">  json_serializable: ^2.0.0</span><br></pre></td></tr></table></figure><p>具体用法可以参考 <a href="https://juejin.im/post/5b5f00e7e51d45190571172f#heading-13" target="_blank" rel="noopener">https://juejin.im/post/5b5f00e7e51d45190571172f#heading-13</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://flutterchina.club/setup-macos/" target="_blank" rel="noopener">Flutter中文网</a></li><li><a href="https://juejin.im/post/5b09fe716fb9a07aa114a6d9" target="_blank" rel="noopener">https://juejin.im/post/5b09fe716fb9a07aa114a6d9</a></li><li><a href="https://juejin.im/post/5b5192c4e51d4519115d0d8f#heading-7" target="_blank" rel="noopener">https://juejin.im/post/5b5192c4e51d4519115d0d8f#heading-7</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文是一个纯Flutter项目，主要通过
      
    
    </summary>
    
      <category term="Flutter" scheme="https://xsfelvis.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://xsfelvis.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Gradle进阶</title>
    <link href="https://xsfelvis.github.io/2018/10/19/gradle%E8%BF%9B%E9%98%B6/"/>
    <id>https://xsfelvis.github.io/2018/10/19/gradle进阶/</id>
    <published>2018-10-18T16:00:00.000Z</published>
    <updated>2018-10-19T14:12:41.126Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="Groovy-基础"><a href="#Groovy-基础" class="headerlink" title="Groovy 基础"></a>Groovy 基础</h2><ul><li><a href="https://gradle.org/" target="_blank" rel="noopener">官网</a></li><li><a href="https://blog.csdn.net/yanbober/article/details/49047515" target="_blank" rel="noopener">Groovy脚本基础全攻略</a></li></ul><h2 id="Gradle-DSL-基础"><a href="#Gradle-DSL-基础" class="headerlink" title="Gradle DSL 基础"></a>Gradle DSL 基础</h2><p><a href="https://docs.gradle.org/current/dsl/index.html" target="_blank" rel="noopener">DSL</a></p><h2 id="Android-DSL-基础"><a href="#Android-DSL-基础" class="headerlink" title="Android DSL 基础"></a>Android DSL 基础</h2><p><a href="http://google.github.io/android-gradle-dsl/current/index.html" target="_blank" rel="noopener">ASL</a></p><h2 id="自定义插件开发"><a href="#自定义插件开发" class="headerlink" title="自定义插件开发"></a>自定义插件开发</h2><h3 id="三种方式"><a href="#三种方式" class="headerlink" title="三种方式"></a>三种方式</h3><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>Build script</td><td>把插件写在 build.gradle 文件中，一般用于简单的逻辑，只在该 build.gradle 文件中可见</td></tr><tr><td>buildSrc 项目</td><td>将插件源代码放在 rootProjectDir/buildSrc/src/main/groovy 中，只对该项目中可见，适用于逻辑较为复杂</td></tr><tr><td>独立项目</td><td>一个独立的 Groovy 和 Java 项目，可以把这个项目打包成 Jar 文件包，一个 Jar 文件包还可以包含多个插件入口，将文件包发布到托管平台上，供其他人使用。本文将着重介绍此类。</td></tr></tbody></table><p>具体从插件开发可以参考</p><ul><li><a href="https://xsfelvis.github.io/2018/06/09/%E8%AF%91%E6%96%87_Writing%20Custom%20Plugins/">Writing Custom Plugins</a></li><li><a href="http://blog.bugtags.com/2016/03/28/embrace-android-studio-gradle-plugin/" target="_blank" rel="noopener">拥抱 Android Studio 之五：Gradle 插件开发</a></li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><blockquote><p><a href="https://docs.gradle.org/current/javadoc/org/gradle/api/DomainObjectCollection.html" target="_blank" rel="noopener">NamedDomainObjectContainer</a></p></blockquote><p>使用NamedDomainObjectContainer 简称NODC 这是一个容纳object的容器,DomainObjectCollection 可以直接访问所有对象，它的特点是它的内部使用SortedSet实现的，内部对象的name是unique的，而且是按name进行排序的。通常创建NDOC的方法就是调用,调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; [NamedDomainObjectContainer] &lt;T&gt; container(Class&lt;T&gt; type)</span><br></pre></td></tr></table></figure></p><p>这里需要注意的是<code>type</code>有一个要求：必须有一个public的构造函数，接受string作为一个参数</p><p>比如在buildScript中使用一个对象就需要使用NamedDomainObjectContainer </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NamedDomainObjectContainer&lt;Book&gt; bookContainer = mProject.container(Book.class,</span><br><span class="line">               new BookFactory(mInstantiator));</span><br></pre></td></tr></table></figure><p>具体可以参看<a href="https://github.com/xsfelvis/GradlePluginStudy/blob/1c39de3500e02db7d2b9a7facd0c88d7f2e0dc8f/complexscriptdsl/src/main/java/com/dev/complexdsl/ComplexDSLPlugin.java" target="_blank" rel="noopener">构造对象</a></p><blockquote><p>获取 debug还是release</p></blockquote><ul><li>variant.name.capitalize()这个就是获取的字符串是debug 还是release</li><li>variant.buildType.name.capitalize() 获取buildType</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def preDexTask = project.tasks.findByName(&quot;preDex$&#123;variant.name.capitalize()&#125;&quot;)</span><br><span class="line">def dexTask = project.tasks.findByName(&quot;dex$&#123;variant.name.capitalize()&#125;&quot;)</span><br><span class="line">def proguardTask = project.tasks.findByName(&quot;proguard$&#123;variant.name.capitalize()&#125;&quot;)</span><br></pre></td></tr></table></figure><p>这是nuwa热修复的源码他事先定义好了这些任务，这些任务就是把字节码文件打包成dex文件的任务，上面的代码意思就是获取这些任务的名字。（就是apply plugin: ‘com.android.application’里面的任务）。从上面的代码可以看到，我们定义的任务名称分别是（preDex${variant.name.capitalize()}）（dex${variant.name.capitalize()}）（proguard${variant.name.capitalize()}）（$这个符号就是拼接字符串的意思和kotlin一样</p><h2 id="project-beforeEvaluate-project-afterEvaluate"><a href="#project-beforeEvaluate-project-afterEvaluate" class="headerlink" title="project.beforeEvaluate/project.afterEvaluate"></a>project.beforeEvaluate/project.afterEvaluate</h2><p>这里在普及一个小知识，项目中gradle执行的时候，会先解析setting.gradle,然后是build.gradle,如果想在解析build.gradle之前做点事，可以使用project.beforeEvaluate如果想在解析build.gradle之后做点事可以project.afterEvaluate。</p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="加载task"><a href="#加载task" class="headerlink" title="加载task"></a>加载task</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (!imgDirectories.empty) &#123;</span><br><span class="line">                project.task(type: ImgOptimizerTask, overwrite: true, Constants.TASK_NAME.</span><br><span class="line">                        concat(project.name.capitalize()).concat(variant.buildType.name.capitalize())) &#123;</span><br><span class="line">                    it.group = &quot;optimize&quot;</span><br><span class="line">                    it.description = &quot;Optimize $&#123;variant.buildType.name&#125; images&quot;</span><br><span class="line">                    it.imgDirs = imgDirectories</span><br><span class="line">                    it.triggerSize = ext.triggerSize</span><br><span class="line">                    it.suffix = ext.suffix</span><br><span class="line">                    it.type = ext.type</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>关于Task的创建参数 参考 <a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#N14C11" target="_blank" rel="noopener">Project</a></p><h3 id="读取列表-列表长度不定"><a href="#读取列表-列表长度不定" class="headerlink" title="读取列表 列表长度不定"></a>读取列表 列表长度不定</h3><p>比如获取一个person的列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class HelloPlugin implements Plugin&lt;Project&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void apply(Project project) &#123;</span><br><span class="line">        //创建一个容器 </span><br><span class="line">        NamedDomainObjectContainer&lt;Person&gt; persons = project.container(Person)</span><br><span class="line">        //将容器添加为extension </span><br><span class="line">        project.extensions.add(&apos;team&apos;, persons)</span><br><span class="line">        def task = project.task(&apos;showTeam&apos;) &#123;</span><br><span class="line">            group &apos;junli&apos; doLast &#123; def team1 = project.extensions.getByName(&apos;team&apos;) println team1 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加子插件"><a href="#添加子插件" class="headerlink" title="添加子插件"></a>添加子插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// apply the maven publish plugin and dynamic dependency resolve plugin to all the sub projects</span><br><span class="line">project.subprojects &#123;</span><br><span class="line">    it.plugins.apply(MavenPublishPlugin)</span><br><span class="line">    it.plugins.apply(DependencyResolvePlugin)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hook资源"><a href="#hook资源" class="headerlink" title="hook资源"></a>hook资源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">task hookAssets &#123;</span><br><span class="line">  afterEvaluate &#123;</span><br><span class="line">    tasks.findByName(&quot;packageDebug&quot;).doFirst &#123; task -&gt;</span><br><span class="line">      copy &#123;</span><br><span class="line">        from &quot;$&#123;projectDir.absolutePath&#125;/test.png&quot;</span><br><span class="line">        into &quot;$&#123;task.assets.asPath&#125;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>在 project afterEvaluate 之后找到 packageDebug task</p></li><li><p>不妨在 app 目录下放入一个 test.png，使用 copy {} 闭包，from 填入的参数为 test.png 的路径，into 填入的参数为输出的路径，也就是 assets 的路径。</p></li></ol><h3 id="install-amp-amp-launch-apk"><a href="#install-amp-amp-launch-apk" class="headerlink" title="install &amp;&amp; launch apk"></a>install &amp;&amp; launch apk</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">task installAndRun(dependsOn: &apos;assembleDebug&apos;) &#123;</span><br><span class="line">  doFirst &#123;</span><br><span class="line">    exec &#123;</span><br><span class="line">      workingDir &quot;$&#123;buildDir&#125;/outputs/apk/debug&quot;</span><br><span class="line">      commandLine &apos;adb&apos;, &apos;install&apos;, &apos;-r&apos;, &apos;app-debug.apk&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    exec &#123;</span><br><span class="line">      def path = &quot;$&#123;buildDir&#125;/intermediates/manifests/full/debug/AndroidManifest.xml&quot;</span><br><span class="line">      // xml 解析</span><br><span class="line">      def parser = new XmlParser(false, false).parse(new File(path))</span><br><span class="line">      // application 下的每一个 activity 结点</span><br><span class="line">      parser.application.activity.each &#123; activity -&gt;</span><br><span class="line">        // activity 下的每一个 intent-filter 结点</span><br><span class="line">        activity.&apos;intent-filter&apos;.each &#123; filter -&gt;</span><br><span class="line">          // intent-filter 下的 action 结点中的 @android:name 包含 android.intent.action.MAIN</span><br><span class="line">          if (filter.action.@&quot;android:name&quot;.contains(&quot;android.intent.action.MAIN&quot;)) &#123;</span><br><span class="line">            def targetActivity = activity.@&quot;android:name&quot;</span><br><span class="line">            commandLine &apos;adb&apos;, &apos;shell&apos;, &apos;am&apos;, &apos;start&apos;, &apos;-n&apos;,</span><br><span class="line">                &quot;$&#123;android.defaultConfig.applicationId&#125;/$&#123;targetActivity&#125;&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="apk变体"><a href="#apk变体" class="headerlink" title="apk变体"></a>apk变体</h3><p>根据官方文档可以知道开发者可以通过 android.applicationVariants.all 获取到当前所有的 apk 变体，该变体的类型为 ApplicationVariant，其父类 BaseVariantOutput 中含 name 字段，该字段实际上就是当前变体的名字，那么其实只需要判断该 name 字段是否包含 release 关键字即可。</p><ol><li>代码解析</li></ol><p><code>功能</code></p><p>在 app 目录下创建 pic 文件夹，并添加一个名为 test 的 png 图片，hook apk 打包流程将该图片添加入 apk 的 assets 文件夹。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class HookAssetsPlugin implements Plugin&lt;Project&gt; &#123;</span><br><span class="line">  @Override</span><br><span class="line">  void apply(Project project) &#123;</span><br><span class="line">    project.afterEvaluate &#123;</span><br><span class="line">      project.plugins.withId(&apos;com.android.application&apos;) &#123;</span><br><span class="line">        project.android.applicationVariants.all &#123; ApplicationVariant variant -&gt;</span><br><span class="line">          variant.outputs.each &#123; ApkVariantOutput variantOutput -&gt;</span><br><span class="line">            if (variantOutput.name.equalsIgnoreCase(&quot;release&quot;)) &#123;</span><br><span class="line">              variantOutput.packageApplication.doFirst &#123; PackageApplication task -&gt;</span><br><span class="line">                project.copy &#123;</span><br><span class="line">                  from &quot;$&#123;project.projectDir.absolutePath&#125;/pic/test.png&quot;</span><br><span class="line">                  into &quot;$&#123;task.assets.asPath&#125;&quot;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解析点</p></blockquote><ol><li>在 project.afterEvaluate 闭包中才能获取到当前 project 中的所有 task 。</li><li>通过 project.plugins.withId(‘com.android.application’) 确保当前 project 是 Android app project 而不是 Android library project，以此来避免无效操作</li><li>通过 project.android.applicationVariants.all 获取所有变体信息。</li><li>在日常开发中寻找 task 的方式可能更多的是使用 project.tasks.findByName(name)/project.tasks.getByName(name)</li></ol><h3 id="获取依赖配置"><a href="#获取依赖配置" class="headerlink" title="获取依赖配置"></a>获取依赖配置</h3><p><a href="https://github.com/easilycoder/EasyDependency" target="_blank" rel="noopener">EasyDenpendency</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// add the extension config</span><br><span class="line">        NamedDomainObjectContainer&lt;DependencyResolveExt&gt; dependencyResolveContainer = targetProject.container(DependencyResolveExt.class)</span><br><span class="line">        targetProject.extensions.add(&quot;dynamicDependency&quot;, dependencyResolveContainer)</span><br><span class="line"></span><br><span class="line">        targetProject.afterEvaluate &#123;</span><br><span class="line">            Map&lt;Project, DependencyResolveExt&gt; resolveExtMap = new HashMap&lt;&gt;()</span><br><span class="line">            targetProject.configurations.all &#123; Configuration configuration -&gt;</span><br><span class="line">                if (configuration.dependencies.size() == 0) &#123;</span><br><span class="line">                    return</span><br><span class="line">                &#125;</span><br><span class="line">                configuration.dependencies.all &#123; dependency -&gt;</span><br><span class="line">                    if (dependency instanceof DefaultProjectDependency) &#123;</span><br><span class="line">                        def projectName = dependency.dependencyProject.name</span><br><span class="line">                        def dependencyResolveExt = dependencyResolveContainer.find &#123;</span><br><span class="line">                            it.name == projectName</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (dependencyResolveExt != null &amp;&amp; !dependencyResolveExt.debuggable) &#123;</span><br><span class="line">                            resolveExtMap.put(dependency.dependencyProject, dependencyResolveExt)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            targetProject.configurations.all &#123;</span><br><span class="line">                resolutionStrategy &#123;</span><br><span class="line">                    dependencySubstitution &#123;</span><br><span class="line">                        resolveExtMap.each &#123; key, value -&gt;</span><br><span class="line">                            substitute project(&quot;$&#123;key.path&#125;&quot;) with module(&quot;$&#123;value.groupId&#125;:$&#123;getArtifactName(key, value.artifactId)&#125;:$&#123;value.version&#125;&quot;)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;h2 id=&quot;Groovy-基础&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="Gradle" scheme="https://xsfelvis.github.io/categories/Gradle/"/>
    
    
      <category term="Gradle" scheme="https://xsfelvis.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>上传Jcenter</title>
    <link href="https://xsfelvis.github.io/2018/10/11/Jcenter/"/>
    <id>https://xsfelvis.github.io/2018/10/11/Jcenter/</id>
    <published>2018-10-10T16:00:00.000Z</published>
    <updated>2018-10-14T06:08:06.035Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>Jcenter提供了一个方便使用自己开源库的一个平台 在Android中使用 complie引用即可，目前很多文章都是通过<code>gradle-bintray-plugin</code>这个插件，不过<code>bintray-release</code>这个插件更加人性化，本篇将记录使用这个插件如何上传到Jcenter上</p><h1 id="0x01-注册bintray-com账号"><a href="#0x01-注册bintray-com账号" class="headerlink" title="0x01 注册bintray.com账号"></a>0x01 注册bintray.com账号</h1><ul><li>Step 1</li></ul><p>官网注册账号 <a href="https://bintray.com，切记点击右边的For" target="_blank" rel="noopener">https://bintray.com，切记点击右边的For</a> an Open Source Account，个人版本<br>(企业版 加入或者创建组织才可以建立自己的仓库，比较麻烦)</p><p><img src="https://upload-images.jianshu.io/upload_images/6968064-d2afdefd754a26a2.png" alt="注册"></p><ul><li>Step 2</li></ul><p>注册完之后 进入 Edit profile 查看自己的APIKey，这是上传时候需要用到</p><h1 id="0x02-项目配置"><a href="#0x02-项目配置" class="headerlink" title="0x02 项目配置"></a>0x02 项目配置</h1><ul><li>根gradle</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &apos;com.android.tools.build:gradle:2.3.1&apos;</span><br><span class="line"></span><br><span class="line">        classpath &apos;com.novoda:bintray-release:0.8.0&apos;//添加</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        maven&#123;url &quot;https://jitpack.io&quot;&#125;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    tasks.withType(Javadoc) &#123;</span><br><span class="line">        options.addStringOption(&apos;Xdoclint:none&apos;, &apos;-quiet&apos;)</span><br><span class="line">        options.addStringOption(&apos;encoding&apos;, &apos;UTF-8&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">task clean(type: Delete) &#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//统一声明配置</span><br><span class="line">ext &#123;</span><br><span class="line">    userOrg = &apos;androidxsf&apos; //bintray.com用户名 </span><br><span class="line">    groupId = &apos;com.xsfdev&apos; //jcenter上的路径</span><br><span class="line">    uploadName = &apos;android-basiclib-apifactory&apos;</span><br><span class="line">    publishVersion = &apos;1.0.0&apos; //版本号</span><br><span class="line">    desc = &apos;Request code can be generated automatically&apos; //描述</span><br><span class="line">    website = &apos;https://github.com/HouXiaohu/androidbasiclib&apos; //网站，不重要；尽量模拟github上的地址</span><br><span class="line">    licences = [&apos;Apache-2.0&apos;] //开源协议</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需要上传的各个Module中引入</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apply plugin: &apos;com.novoda.bintray-release&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//添加</span><br><span class="line">publish &#123;</span><br><span class="line">    artifactId = &apos;complexcriptdsl&apos;</span><br><span class="line">    userOrg = rootProject.userOrg</span><br><span class="line">    groupId = rootProject.groupId</span><br><span class="line">    uploadName = rootProject.uploadName</span><br><span class="line">    publishVersion = rootProject.publishVersion</span><br><span class="line">    desc = rootProject.description</span><br><span class="line">    website = rootProject.website</span><br><span class="line">    licences = rootProject.licences</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x03-执行上传"><a href="#0x03-执行上传" class="headerlink" title="0x03 执行上传"></a>0x03 执行上传</h1><p><code>./gradlew bintrayUpload -PbintrayUser = androidxsf(你的用户名) -PbintrayKey = 1f8b6d3da641fe0f34d531c1811774c***(你的APIKey) -PdryRun = false</code></p><p>此时可以看到我们上传的项目了,你可以点击进去看该库的一些信息，但是注意此时还不能够直接被引用。</p><p>点击进去该库，按照下图，点击Add To jcenter</p><h1 id="0x04-其他"><a href="#0x04-其他" class="headerlink" title="0x04 其他"></a>0x04 其他</h1><p>你需要等待bintray的工作人员审核，审核通过会给你发送站内Message，并且Add to Jcenter那个按钮就小时了，此外你还可以根据你上传的groupId,访问该网站<code>https://jcenter.bintray.com/</code>你的groupId例如<code>https://jcenter.bintray.com/com/com.xsfdev/</code></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后总结下整个过程，其实非常简单：</p><ul><li>申请账号</li><li>引入bintray-release，在需要上传的module里面填写相关publish的信息</li><li>调用上传的命令</li><li>Add to Jcenter提交审核</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="工具" scheme="https://xsfelvis.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Jcenter" scheme="https://xsfelvis.github.io/tags/Jcenter/"/>
    
  </entry>
  
  <entry>
    <title>Spi的基本使用</title>
    <link href="https://xsfelvis.github.io/2018/06/11/spi/"/>
    <id>https://xsfelvis.github.io/2018/06/11/spi/</id>
    <published>2018-06-10T16:00:00.000Z</published>
    <updated>2018-06-11T11:20:15.907Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>什么是spi</li></ul><p>SPI （Service Provider Interface）属于<code>动态加载接口实现类</code>的的一项技术，是JDK内置的一种服务提供发现机制，使用ServiceLoader去加载接口对应的实现，这样我们就不用关注实现类，ServiceLoader会告诉我们。<a href="https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html" target="_blank" rel="noopener">官方文档</a>描述为：<code>为某个接口寻找服务的机制,类似IOC思想，将装配的控制权交给ServiceLoader。</code></p><ul><li>解决问题</li></ul><p>只提供服务接口，具体服务由其他组件实现，接口和具体实现分离（类似桥接），同时能够<code>通过系统的ServiceLoader</code>拿到这些实现类的集合，统一处理，这样在组件化中往往会带来很多便利，SPI机制可以实现不同模块之间方便的面向接口编程，拒绝了硬编码的方式，解耦效果很好</p><blockquote><p>即相当于制定标准，然后不同实现方用不同的方式实现标准供使用方使用,并且可以动态加载</p></blockquote><h1 id="在Android中如何使用"><a href="#在Android中如何使用" class="headerlink" title="在Android中如何使用"></a>在Android中如何使用</h1><p>上面说的可能比较抽象，下面将结合例子说明下在Android中的运用。</p><p>这种机制在使用起来也比较简单,使用步骤如下：</p><ul><li><p>定义接口和接口的实现类</p></li><li><p>创建resources/META-INF/services目录</p></li><li><p>在上述Service目录下，创建一个以接口名(类的全名) 命名的文件, 其内容是实现类的类名 (类的全名)。</p></li></ul><blockquote><p>在services目录下创建的文件是com.binglumeng.spidemo.IService 文件中的内容为Animal接口的实现类, 可能是com.binglumeng.spidemo.AService</p></blockquote><ul><li>在java代码中使用ServcieLoader来动态加载并调用内部方法.</li></ul><p>主工程和组件之间一些“服务”的配置</p><p><img src="http://p927u2n0k.bkt.clouddn.com/spiblog-%20%E6%A8%A1%E5%9D%97%E4%BE%9D%E8%B5%96.png" alt="示意图"></p><h2 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDisplay</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主工程和bdisplay 模块中的实现该接口</p><h2 id="创建spi描述文件"><a href="#创建spi描述文件" class="headerlink" title="创建spi描述文件"></a>创建spi描述文件</h2><p>在工程的main目录下新建目录resources/META-INF/services，<code>以服务接口名为文件名新建spi描述文件，内容为具体的服务实现类权限定名，可以有多个</code></p><p>文件结构如下</p><p><img src="http://p927u2n0k.bkt.clouddn.com/1528702141671.jpg" alt="文件结构"></p><h2 id="加载不同服务"><a href="#加载不同服务" class="headerlink" title="加载不同服务"></a>加载不同服务</h2><p>通过ServiceLoader来加载接口的不同实现类，然后会得到迭代器，在迭代器中可以拿到不同实现类全限定名，然后通过反射动态加载实例就可以调用display方法了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;Display&gt; loader = ServiceLoader.load(IDisplay.class);</span><br><span class="line">mIterator =loader.iterator(); </span><br><span class="line"><span class="keyword">while</span>(mIterator.hasNext())&#123;</span><br><span class="line">    mIterator.next().display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>感觉有点很神奇</p><blockquote><p>ServiceLoader<display> loader = ServiceLoader.load(Display.class);</display></p></blockquote><p>就可以拿到<code>Display.class</code>接口的所有实现类了, amazing！(感觉这里跟Retrift使用有点类似)下面来分析一下这个背后到底隐藏了什么</p><p>核心类 <code>ServiceLoader.java</code></p><p><img src="http://p927u2n0k.bkt.clouddn.com/Blog-ServiceLoader.png" alt="ServiceLoader"></p><p>先看下几个重要的成员变量</p><ul><li>PREFIX就是配置文件所在的包目录路径；</li><li>service就是接口名称，在我们这个例子中就是Display；</li><li>loader就是类加载器，其实最终都是通过反射加载实例；</li><li>providers就是不同实现类的缓存，key就是实现类的全限定名，value就是实现类的实例</li><li>lookupIterator就是内部类LazyIterator的实例。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">"META-INF/services/"</span>; </span><br><span class="line"><span class="comment">// The class or interface representing the service being loaded </span></span><br><span class="line"><span class="keyword">private</span> Class&lt;S&gt; service; </span><br><span class="line"><span class="comment">// The class loader used to locate, load, and instantiate providers </span></span><br><span class="line"><span class="keyword">private</span> ClassLoader loader; </span><br><span class="line"><span class="comment">// Cached providers, in instantiation order </span></span><br><span class="line"><span class="keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(); </span><br><span class="line"><span class="comment">// The current lazy-lookup iterator </span></span><br><span class="line"><span class="keyword">private</span> LazyIterator lookupIterator;</span><br></pre></td></tr></table></figure><p>之前spi加载的三个关键步骤</p><ul><li>ServiceLoader<display> loader = ServiceLoader.load(IDisplay.class);</display></li><li>mIterator =loader.iterator(); </li><li>while(mIterator.hasNext()){<br>  mIterator.next().display();<br>}</li></ul><h2 id="获取实现接口集合"><a href="#获取实现接口集合" class="headerlink" title="获取实现接口集合"></a>获取实现接口集合</h2><p>ServiceLoader提供了两个静态的load方法,如果我们没有传入类加载器，ServiceLoader会自动为我们获得一个当前线程的类加载器，最终都是调用构造函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">    ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            ClassLoader loader)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceLoader&lt;&gt;(service, loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数中有一个重要的函数<code>reload</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    providers.clear();</span><br><span class="line">    lookupIterator = <span class="keyword">new</span> LazyIterator(service, loader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LazyIterator</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.service = service;</span><br><span class="line">    <span class="keyword">this</span>.loader = loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以看到当我们load class之后并没有得到什么实现类，那么在何时加载的呢？</p><h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>那么service provider在什么地方进行加载？我们接着看第二个步骤loader.iterator(),</p><ul><li>首先会到providers中去查找有没有存在的实例，有就直接返回，没有再到LazyIterator中查找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;S&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;S&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders</span><br><span class="line">            = providers.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> lookupIterator.hasNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                <span class="keyword">return</span> knownProviders.next().getValue();</span><br><span class="line">            <span class="keyword">return</span> lookupIterator.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是返回一个迭代器。我们看下官方文档的解释,这个就是懒加载实现的地方，<br>焦点聚焦在<code>LazyIterator</code>上</p><ul><li>hasNext()</li></ul><ol><li>首先拿到配置文件名fullName,我们这个例子中是com.example.Display</li><li>通过类加载器获得所有模块的配置文件Enumeration<url> configs configs</url></li><li>依次扫描每个配置文件的内容，返回配置文件内容Iterator<string> pending，每个配置文件中可能有多个实现类的全限定名，所以pending也是个迭代器。</string></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//首先拿到配置文件名fullName</span></span><br><span class="line">            String fullName = PREFIX + service.getName();</span><br><span class="line">            <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">            configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                configs = loader.getResources(fullName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        fail(service, <span class="string">"Error locating configuration files"</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依次扫描每个配置文件的内容，返回配置文件内容Iterator&lt;String&gt; pending</span></span><br><span class="line">        pending = parse(service, configs.nextElement());</span><br><span class="line">    &#125;</span><br><span class="line">    nextName = pending.next();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips</p></blockquote><p>关于 ClassLoader.getSystemResources(fullName)可以查阅</p><ul><li><a href="http://zyjustin9.iteye.com/blog/2022654" target="_blank" rel="noopener">Java目录总结（七.路径的获取二——ClassLoader的使用）</a></li><li><a href="https://blog.csdn.net/walkerjong/article/details/13019671" target="_blank" rel="noopener">Class.getResource() 和 ClassLoader.getResource() 的区别</a></li></ul><ul><li>next()</li></ul><p>在上面hasNext()方法中拿到的nextName就是实现类的全限定名，接下来我们去看看具体实例化工作的地方next():</p><ul><li>1.首先根据nextName，Class.forName加载拿到具体实现类的class对象</li><li>2.Class.newInstance()实例化拿到具体实现类的实例对象</li><li>3.将实例对象转换service.cast为接口</li><li>4.将实例对象放到缓存中，providers.put(cn, p)，key就是实现类的全限定名，value是实例对象。</li><li>5.返回实例对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasNext()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    String cn = nextName;</span><br><span class="line">    nextName = <span class="keyword">null</span>;</span><br><span class="line">    Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//首先根据nextName，Class.forName加载拿到具体实现类的class对象</span></span><br><span class="line">        c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">"Provider "</span> + cn + <span class="string">" not found"</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">        ClassCastException cce = <span class="keyword">new</span> ClassCastException(</span><br><span class="line">                service.getCanonicalName() + <span class="string">" is not assignable from "</span> + c.getCanonicalName());</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">"Provider "</span> + cn  + <span class="string">" not a subtype"</span>, cce);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//将实例对象转换service.cast为接口</span></span><br><span class="line">        S p = service.cast(c.newInstance());</span><br><span class="line">        <span class="comment">//将实例对象放到缓存中，providers.put(cn, p)，key就是实现类的全限定名，value是实例对象</span></span><br><span class="line">        providers.put(cn, p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">        <span class="string">"Provider "</span> + cn + <span class="string">" could not be instantiated: "</span> + x, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error();          <span class="comment">// This cannot happen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Spi的优缺点</p><ul><li>优点</li></ul><p>只提供服务接口，具体服务由其他组件实现，接口和具体实现分离，同时能够通过系统的ServiceLoader拿到这些实现类的集合，统一处理。</p><ul><li>缺点</li></ul><ol><li>Java中SPI是随jar发布的，每个不同的jar都可以包含一系列的SPI配置，而Android平台上，应用在构建的时候最终会将所有的jar合并，这样很容易造成相同的SPI冲突，常见的问题是DuplicatedZipEntryException异常</li><li>读取SPI配置信息是在运行时从jar包中读取，由于apk是签过名的，在从jar中读取的时候，签名校验的耗时问题会造成性能损失</li></ol><h1 id="后续可以改进的点"><a href="#后续可以改进的点" class="headerlink" title="后续可以改进的点"></a>后续可以改进的点</h1><p>Java中使用ServiceLoader去读取SPI配置信息是在程序运行时，我们可以将这个读取配置信息提前，在编译时候就搞定，通过gradle插件，去扫描class文件，找到具体的服务类（可以通过标注来确定），然后生成新的java文件，这个文件中包含了具体的实现类。这样程序在运行时，就已经知道了所有的具体服务类，缺点就是编译时间会加长，自己需要重新写一套读取SPI信息、生成java文件等逻辑。</p><p>经过优化后，SPI已经偏离了原本的初衷，但是可以做更多的事，可以将业务服务分离，通过SPI找到业务服务入口，业务组件化，抽成单独的aar，独立成工程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;什么是spi&lt;/li&gt;
&lt;/
      
    
    </summary>
    
      <category term="spi" scheme="https://xsfelvis.github.io/categories/spi/"/>
    
    
      <category term="spi" scheme="https://xsfelvis.github.io/tags/spi/"/>
    
  </entry>
  
  <entry>
    <title>Gradle学习之基本原理</title>
    <link href="https://xsfelvis.github.io/2018/06/10/Gradle%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>https://xsfelvis.github.io/2018/06/10/Gradle基本原理/</id>
    <published>2018-06-09T16:00:00.000Z</published>
    <updated>2018-06-10T12:18:25.403Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Gradle是一个基于JVM的构建工具，目前Android Studio中建立的工程都是基于gradle进行构建的，Gradle框架是使用Groovy语言实现的，关于Groovy语言的学习将不再赘述可以参考(<a href="https://www.ibm.com/developerworks/cn/education/java/j-groovy/j-groovy.html" target="_blank" rel="noopener">精通Groovy</a>),目前很多技术领域开始使用Gradle的plugin，比如模块化、热修复、SPI的优化等等。</p><h1 id="两个最重要的概念-Projetc和Tasks"><a href="#两个最重要的概念-Projetc和Tasks" class="headerlink" title="两个最重要的概念 Projetc和Tasks"></a>两个最重要的概念 Projetc和Tasks</h1><p>这是Gradle中最重要的两个概念,每次构建至少由一个project构成，一个project由一到多个task构成。<code>项目结构中的每个build.gradle文件代表一个project</code>，在这编译脚本文件中可以定义一系列的task；task 本质上又是由一组被顺序执行的<code>Action</code>对象构成，Action其实是一段代码块，类似于Java中的方法。</p><h1 id="Gradle-构建生命周期"><a href="#Gradle-构建生命周期" class="headerlink" title="Gradle 构建生命周期"></a>Gradle 构建生命周期</h1><h2 id="三个阶段"><a href="#三个阶段" class="headerlink" title="三个阶段"></a>三个阶段</h2><p>每次构建的执行本质上是执行一系列的task，并且某些task还需要依赖其他task，这些task的依赖关系都是在构建阶段确定的。每次构建分为3个阶段(<a href="https://docs.gradle.org/current/userguide/build_lifecycle.html#sec:build_phases" target="_blank" rel="noopener">Build phases 文档 </a>)</p><ul><li>Initialization: 初始化阶段</li></ul><p>这是创建Project阶段，构建工具根据每个build.gradle文件创建出一个Project实例。初始化阶段会执行项目根目录下的settings.gradle文件，来分析哪些项目参与构建。</p><ul><li>Configuration:配置阶段</li></ul><p>这个阶段，通过执行构建脚本来为每个project创建并配置Task。配置阶段会去加载所有参与构建的项目的build.gradle文件，会将每个build.gradle文件实例化为一个Gradle的project对象。然后分析project之间的依赖关系，下载依赖文件，分析project下的task之间的依赖关系。</p><ul><li>Execution:执行阶段</li></ul><p>这是Task真正被执行的阶段，Gradle会根据依赖关系决定哪些Task需要被执行，以及执行的先后顺序。task是Gradle中的最小执行单元，我们所有的构建，编译，打包，debug，test等都是执行了某一个task，一个project可以有多个task，task之间可以互相依赖。例如我有两个task，taskA和taskB，指定taskA依赖taskB，然后执行taskA，这时会先去执行taskB，taskB执行完毕后在执行taskA。在AS右侧的Gradle按钮中可以看到这一些列的task</p><h2 id="监听生命周期"><a href="#监听生命周期" class="headerlink" title="监听生命周期"></a>监听生命周期</h2><p>在gradle的构建过程中，gradle为我们提供了钩子，帮助我们针对项目的需求定制构建的逻辑，如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/19/163781a2edc24703?imageslim" alt="监听生命周期"></p><p>要监听这些生命周期，主要有两种方式：</p><ul><li>添加监听器</li><li>使用钩子的配置块</li></ul><p>关于可用的钩子可以参考Gradle和Project中的定义，常用的钩子包括：</p><blockquote><p>Gradle</p></blockquote><ul><li>beforeProject()/afterProject()<br>等同于Project中的beforeEvaluate和afterEvaluate</li></ul><ul><li>settingsEvaluated()<br>settings脚本被执行完毕，Settings对象配置完毕</li></ul><ul><li>projectsLoaded()<br>所有参与构建的项目都从settings中创建完毕</li></ul><ul><li>projectsEvaluated()<br>所有参与构建的项目都已经被评估完</li></ul><blockquote><p>TaskExecutionGraph</p></blockquote><ul><li>whenReady（）<br>task图生成。所有需要被执行的task已经task之间的依赖关系都已经确立</li></ul><blockquote><p>Project</p></blockquote><ul><li>beforeEvaluate（）</li><li>afterEvaluate（）</li></ul><h1 id="三个重要的gradle文件"><a href="#三个重要的gradle文件" class="headerlink" title="三个重要的gradle文件"></a>三个重要的gradle文件</h1><p>Gradle项目有3个重要的文件需要深入理解：</p><ul><li>项目根目录的 build.gradle </li></ul><p>项目根目录的 build.gradle 文件用来配置针对所有模块的一些属性。它默认包含2个代码块：buildscript{…}和allprojects{…}。前者用于配置构建脚本所用到的代码库和依赖关系，后者用于定义所有模块需要用到的一些公共属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:2.3.2'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">clean</span><span class="params">(type: Delete)</span> </span>&#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>settings.gradle </li></ul><p>settings.gradle 文件会在构建的 initialization 阶段被执行，它用于告诉构建系统哪些模块需要包含到构建过程中。对于单模块项目， settings.gradle 文件不是必需的。对于多模块项目，如果没有该文件，构建系统就不能知道该用到哪些模块。</p><ul><li>模块目录的 build.gradle</li></ul><p>模块级配置文件 build.gradle 针对每个moudle 的配置，如果这里的定义的选项和顶层 build.gradle定义的相同。它有3个重要的代码块：plugin，android 和 dependencies。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.csdn.net/zhaoyanjun6/article/details/77678577#android-gradle-%E7%9A%84-project-%E5%92%8C-tasks" target="_blank" rel="noopener">https://blog.csdn.net/zhaoyanjun6/article/details/77678577#android-gradle-%E7%9A%84-project-%E5%92%8C-tasks</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Gradle是一个基于JVM的构建工具，
      
    
    </summary>
    
      <category term="Gradle" scheme="https://xsfelvis.github.io/categories/Gradle/"/>
    
    
      <category term="Gradle" scheme="https://xsfelvis.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Gradle在Android中的常用点</title>
    <link href="https://xsfelvis.github.io/2018/06/10/Gradle%E5%9C%A8Android%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%82%B9/"/>
    <id>https://xsfelvis.github.io/2018/06/10/Gradle在Android中常用点/</id>
    <published>2018-06-09T16:00:00.000Z</published>
    <updated>2018-06-10T14:25:59.220Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本篇主要介绍Gradle在Android开发中的一些常用的技巧</p><h1 id="设置编译类型"><a href="#设置编译类型" class="headerlink" title="设置编译类型"></a>设置编译类型</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android&#123;</span><br><span class="line"></span><br><span class="line">  buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">true</span>  <span class="comment">//打开混淆</span></span><br><span class="line">            <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        debug </span>&#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span> <span class="comment">//关闭混淆</span></span><br><span class="line">            <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"> &#125;</span></span><br></pre></td></tr></table></figure><p>通常我们需要给QA打出一个带调试功能的release包，这时就可以在这个里面加上新的type</p><h1 id="productFlavors-多渠道打包"><a href="#productFlavors-多渠道打包" class="headerlink" title="productFlavors 多渠道打包"></a>productFlavors 多渠道打包</h1><p>AndroidManifest.xml 里设置动态渠道变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;meta-data</span><br><span class="line">android:name=<span class="string">"UMENG_CHANNEL"</span></span><br><span class="line">android:value=<span class="string">"$&#123;UMENG_CHANNEL_VALUE&#125;"</span>/&gt;</span><br></pre></td></tr></table></figure><p>在 build.gradle 设置 productFlavors , 这里假定我们需要打包的渠道为酷安市场、360、小米、百度、豌豆荚。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">android &#123;  </span><br><span class="line"></span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        kuan &#123;</span><br><span class="line">            manifestPlaceholders = [UMENG_CHANNEL_VALUE: <span class="string">"kuan"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        xiaomi &#123;</span><br><span class="line">            manifestPlaceholders = [UMENG_CHANNEL_VALUE: <span class="string">"xiaomi"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        qh360 &#123;</span><br><span class="line">            manifestPlaceholders = [UMENG_CHANNEL_VALUE: <span class="string">"qh360"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        baidu &#123;</span><br><span class="line">            manifestPlaceholders = [UMENG_CHANNEL_VALUE: <span class="string">"baidu"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        wandoujia &#123;</span><br><span class="line">            manifestPlaceholders = [UMENG_CHANNEL_VALUE: <span class="string">"wandoujia"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者批量修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android &#123;  </span><br><span class="line"></span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        kuan &#123;&#125;</span><br><span class="line">        xiaomi &#123;&#125;</span><br><span class="line">        qh360 &#123;&#125;</span><br><span class="line">        baidu &#123;&#125;</span><br><span class="line">        wandoujia &#123;&#125;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    productFlavors.all &#123; </span><br><span class="line">        flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name] </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多渠道设置包名"><a href="#多渠道设置包名" class="headerlink" title="多渠道设置包名"></a>多渠道设置包名</h1><p>有时候我们需要分渠道设置 applicationId 、友盟的 appkey 、友盟渠道号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">productFlavors &#123;</span><br><span class="line">        google &#123;</span><br><span class="line">            applicationId <span class="string">"com.wifi.cool"</span></span><br><span class="line">            manifestPlaceholders = [                </span><br><span class="line">                    UMENG_APPKEY_VALUE : <span class="string">"456789456789"</span>,</span><br><span class="line">                    UMENG_CHANNEL_VALUE: <span class="string">"google"</span>,            </span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        baidu&#123;</span><br><span class="line">            applicationId <span class="string">'com.wifi.hacker'</span></span><br><span class="line">            manifestPlaceholders = [</span><br><span class="line">                    UMENG_APPKEY_VALUE     : <span class="string">"123456789789"</span>,</span><br><span class="line">                    UMENG_CHANNEL_VALUE    : <span class="string">"baidu"</span>,          </span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="Signing-签名"><a href="#Signing-签名" class="headerlink" title="Signing 签名"></a>Signing 签名</h1><p>在 android 标签下添加 signingConfigs 标签，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        config &#123;</span><br><span class="line">            keyAlias <span class="string">'yiba'</span></span><br><span class="line">            keyPassword <span class="string">'123456'</span></span><br><span class="line">            <span class="function">storeFile <span class="title">file</span><span class="params">(<span class="string">'C:/work/Key.jks'</span>)</span></span></span><br><span class="line"><span class="function">            storePassword '1234567'</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"> &#125;</span></span><br></pre></td></tr></table></figure><p>可以在release 和 debug包中定义签名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        config &#123;</span><br><span class="line">            keyAlias <span class="string">'yiba'</span></span><br><span class="line">            keyPassword <span class="string">'123456'</span></span><br><span class="line">            <span class="function">storeFile <span class="title">file</span><span class="params">(<span class="string">'C:/work/Key.jks'</span>)</span></span></span><br><span class="line"><span class="function">            storePassword '1234567'</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    buildTypes </span>&#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class="line"><span class="function">            signingConfig signingConfigs.config</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        debug </span>&#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class="line"><span class="function">            signingConfig signingConfigs.config</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h1><h2 id="依赖jar包"><a href="#依赖jar包" class="headerlink" title="依赖jar包"></a>依赖jar包</h2><ul><li>1、把 jar 包放在 libs 目录下</li><li>2、在 build.gradle 中添加依赖</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">   <span class="function">compile <span class="title">files</span><span class="params">(<span class="string">'libs/xxx.jar'</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="依赖aar"><a href="#依赖aar" class="headerlink" title="依赖aar"></a>依赖aar</h2><ul><li>1、把 aar 包放到 libs 目录下</li><li>2、在 build.gradle 中添加依赖</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    flatDir &#123;</span><br><span class="line">        dirs <span class="string">'libs'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile(name:<span class="string">'YibaAnalytics-release'</span>, ext:<span class="string">'aar'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要是aar需要被多个module依赖时候，我们可以在项目的根目录创建一个目录，比如叫 aar 目录，然后把我们的 aar 包放进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> flatDir &#123;</span><br><span class="line">     dirs <span class="string">'../aar'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排除依赖兼容包"><a href="#排除依赖兼容包" class="headerlink" title="排除依赖兼容包"></a>排除依赖兼容包</h2><p>有的时候，我们所依赖的项目/模块会引入多个传递性依赖。而其中部分的传递性依赖我们是不需要的，这时候可以使用exclude排除部分的传递性依赖，如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compile(<span class="string">'com.google.firebase:firebase-ads:11.0.4'</span>, &#123;</span><br><span class="line">      exclude group: <span class="string">'com.android.support'</span>   <span class="comment">//排除v7 , v4 包</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="强制使用指定的依赖版本"><a href="#强制使用指定的依赖版本" class="headerlink" title="强制使用指定的依赖版本"></a>强制使用指定的依赖版本</h2><p>Gradle通过选择依赖关系图中找到的最新版本来解决任何依赖版本冲突。 可是有的时候，某些项目会需要使用一个较老的版本号作为依赖。这时候我们可以强制指定某一个版本。例如：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">'org.apache.httpcomponents:httpclient:4.5.4'</span></span><br><span class="line">    <span class="comment">// 假设commons-codec的最新版本是1.10</span></span><br><span class="line">    implementation(<span class="string">'commons-codec:commons-codec:1.9'</span>) &#123;</span><br><span class="line">        force = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="禁止传递性依赖"><a href="#禁止传递性依赖" class="headerlink" title="禁止传递性依赖"></a>禁止传递性依赖</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation(<span class="string">'com.google.guava:guava:23.0'</span>) &#123;</span><br><span class="line">        transitive = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码依赖"><a href="#源码依赖" class="headerlink" title="源码依赖"></a>源码依赖</h2><p>要是我们自己工程下的module直接依赖进来即可，有时候需要从别的路径下依赖module源码</p><ul><li>1、将对应的库的源码down下来，记录下放置的路径</li><li>2、在setting.gradle文件中，进行库的源码引入 (这里以项目外同级目录)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//新增依赖</span></span><br><span class="line">include <span class="string">':outmodule'</span></span><br><span class="line">project(<span class="string">':outmodule'</span>).projectDir = <span class="keyword">new</span> File(settingsDir, <span class="string">'../Sdk/Sdk-Android/product/outmodule'</span>)</span><br></pre></td></tr></table></figure><p>Tips：</p><p>若是主工程使用了Flavor这里也要使用对应的Flavor</p><h2 id="全局统一信息配置"><a href="#全局统一信息配置" class="headerlink" title="全局统一信息配置"></a>全局统一信息配置</h2><p>有时候多个moudle需要依赖不同的版本，有时候就会出现一些编译异常，而且零散的版本号也是不好管理的，如：compileSdkVersion、buildToolsVersion、androidTestCompile 等。</p><h3 id="分类属性配置"><a href="#分类属性配置" class="headerlink" title="分类属性配置"></a>分类属性配置</h3><ul><li>在项目的根目录创建一个gradle配置文件config.gradle，项目中所有的依赖只要在这个文件中统一配置即可。格式如下(内容根据需要进行修改)：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">    </span><br><span class="line">    compileSdkVersion: <span class="number">24</span>,</span><br><span class="line">    buildToolsVersion: <span class="string">"24.0.2"</span>,</span><br><span class="line">    applicationId    : <span class="string">"com.carme.carmerchant"</span>,</span><br><span class="line">    minSdkVersion    : <span class="number">15</span>,</span><br><span class="line">    targetSdkVersion : <span class="number">22</span>,</span><br><span class="line">    versionCode      : <span class="number">3</span>,</span><br><span class="line">    versionName      : <span class="string">"1.0.3"</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    dependencies = [</span><br><span class="line">            <span class="string">"test"</span>                  : <span class="string">"junit:junit:4.12"</span>,</span><br><span class="line">            <span class="string">"appcompat-v7"</span>          : <span class="string">"com.android.support:appcompat-v7:25.0.0"</span>,</span><br><span class="line">            <span class="string">"support-v4"</span>            : <span class="string">"com.android.support:support-v4:25.0.0"</span>,</span><br><span class="line">            <span class="string">"support_design"</span>        : <span class="string">"com.android.support:design:25.0.0"</span>,</span><br><span class="line">            <span class="string">"rxjava"</span>                : <span class="string">"io.reactivex:rxjava:1.2.0"</span>,</span><br><span class="line">            <span class="string">"rxandroid"</span>             : <span class="string">"io.reactivex:rxandroid:1.2.1"</span>,</span><br><span class="line">            <span class="string">"retrofit"</span>              : <span class="string">"com.squareup.retrofit2:retrofit:2.1.0"</span>,</span><br><span class="line">            <span class="string">"converter-gson"</span>        : <span class="string">"com.squareup.retrofit2:converter-gson:2.1.0"</span>,</span><br><span class="line">            <span class="string">"adapter-rxjava"</span>        : <span class="string">"com.squareup.retrofit2:adapter-rxjava:2.1.0"</span>,</span><br><span class="line">            <span class="string">"multidex"</span>              : <span class="string">"com.android.support:multidex:1.0.1"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其次在根目录的build.gradle文件中添加内容（apply from:”config.gradle”），所有的module都可以从这个（config.gradle）配置文件里读取公共参数。</li><li>在各个module目录下的build.gradle文件中使用如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android &#123;  </span><br><span class="line">      compileSdkVersion rootProject .ext.android.compileSdkVersion</span><br><span class="line">      buildToolsVersion rootProject .ext.android.buildToolsVersion</span><br><span class="line">      defaultConfig &#123;</span><br><span class="line">          applicationId rootProject .ext.android.applicationId</span><br><span class="line">          minSdkVersion rootProject .ext.android.minSdkVersion</span><br><span class="line">          targetSdkVersion rootProject .ext.android.targetSdkVersion</span><br><span class="line">          versionCode rootProject .ext.android.versionCode</span><br><span class="line">          versionName rootProject .ext.android.versionName</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      &#125;  </span><br><span class="line">      dependencies &#123;</span><br><span class="line">          ...</span><br><span class="line">          compile rootProject .ext.dependencies[ <span class="string">"design"</span>]</span><br><span class="line">          compile rootProject .ext.dependencies[ <span class="string">"appcompat-v7"</span>]</span><br><span class="line">          compile rootProject .ext.dependencies[ <span class="string">"recyclerview-v7"</span>]</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h1 id="依赖关系解析"><a href="#依赖关系解析" class="headerlink" title="依赖关系解析"></a>依赖关系解析</h1><h2 id="使用依赖关系解析规则"><a href="#使用依赖关系解析规则" class="headerlink" title="使用依赖关系解析规则"></a>使用依赖关系解析规则</h2><p>依赖关系解析规则提供了一种非常强大的方法来控制依赖关系解析过程，并可用于实现依赖管理中的各种高级模式。比如：</p><ul><li>统一构件组的版本</li></ul><p>很多时候我们依赖一个公司的库会包含多个module，这些module一般都是统一构建、打包和发布的，具备相同的版本号。这个时候我们可以通过控制依赖关系的解析过程做到版本号统一。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy.eachDependency &#123; DependencyResolveDetails details -&gt;</span><br><span class="line">    <span class="keyword">if</span> (details.requested.group == <span class="string">'org.gradle'</span>) &#123;</span><br><span class="line">        details.useVersion <span class="string">'1.4'</span></span><br><span class="line">        details.because <span class="string">'API breakage in higher versions'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>处理自定义的版本scheme</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy.eachDependency &#123; DependencyResolveDetails details -&gt;</span><br><span class="line">        <span class="keyword">if</span> (details.requested.version == <span class="string">'default'</span>) &#123;</span><br><span class="line">            <span class="keyword">def</span> version = findDefaultVersionInCatalog(details.requested.group, details.requested.name)</span><br><span class="line">            details.useVersion version.version</span><br><span class="line">            details.because version.because</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> findDefaultVersionInCatalog(String group, String name) &#123;</span><br><span class="line">    <span class="comment">//some custom logic that resolves the default version into a specific version</span></span><br><span class="line">    [<span class="string">version:</span> <span class="string">"1.0"</span>, <span class="string">because:</span> <span class="string">'tested by QA'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于更多依赖关系解析规则的使用实例可以参考gradle的API中的 <a href="https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_blank" rel="noopener">ResolutionStrategy</a></p><ul><li>使用依赖关系的替代规则</li></ul><p>依赖关系的替换规则和上面的依赖关系解析规则有点相似。实际上，依赖关系解析规则的许多功能可以通过依赖关系替换规则来实现。依赖关系的替换规则允许项目依赖（Project Dependency）和模块依赖（Module Dependency）被指定的替换规则透明地替换。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 使用项目依赖替换模块依赖</span></span><br><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy.dependencySubstitution &#123;</span><br><span class="line">        substitute module(<span class="string">"org.utils:api"</span>) with project(<span class="string">":api"</span>) because <span class="string">"we work with the unreleased development version"</span></span><br><span class="line">        substitute module(<span class="string">"org.utils:util:2.5"</span>) with project(<span class="string">":util"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用模块依赖替换项目依赖</span></span><br><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy.dependencySubstitution &#123;</span><br><span class="line">        substitute project(<span class="string">":api"</span>) with module(<span class="string">"org.utils:api:1.3"</span>) because <span class="string">"we use a stable version of utils"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多可以查看官方的文档<a href="https://docs.gradle.org/current/userguide/customizing_dependency_resolution_behavior.html#sec:dependency_substitution_rules" target="_blank" rel="noopener">Customizing Dependency Resolution Behavior</a></p><h1 id="SourceSet"><a href="#SourceSet" class="headerlink" title="SourceSet"></a>SourceSet</h1><p>SourceSet 可以定义项目结构，也可以修改项目结构。Java插件默认实现了两个SourceSet，main 和 test。每个 SourceSet 都提供了一系列的属性，通过这些属性，可以定义该 SourceSet 所包含的源文件。比如，java.srcDirs，resources.srcDirs 。Java 插件中定义的其他任务，就根据 main 和 test 的这两个 SourceSet 的定义来寻找产品代码和测试代码等。</p><h2 id="SourceSet-定义源码目录"><a href="#SourceSet-定义源码目录" class="headerlink" title="SourceSet 定义源码目录"></a>SourceSet 定义源码目录</h2><p>在 Android 项目中，我们可以在 src/main/java 目录新建 Java 文件，现在我们在src目录下，新建一个test目录，发现不能在该目录下新建java文件，这是由于在 Gradle 中 SourceSet 默认定义的源码文件路径是src/main/java , 其他的文件下下面的源码我们自然无法访问。解决这个问题也很简单，我们需要在 SourceSet 中增加一个源码路径即可。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            java &#123;</span><br><span class="line">                srcDir <span class="string">'src/test1'</span> <span class="comment">//指定源码目</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 或者按照如下的方式写也可以</span></span><br><span class="line">            <span class="comment">//java.srcDirs( 'src/test1' , 'src/test2' ,'src/test3' )</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SourceSet-定义资源目录"><a href="#SourceSet-定义资源目录" class="headerlink" title="SourceSet 定义资源目录"></a>SourceSet 定义资源目录</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            java.srcDirs(<span class="string">'src/test1/java'</span>)  <span class="comment">//定义java 源代码</span></span><br><span class="line">            res.srcDirs(<span class="string">'src/test1/res'</span>)    <span class="comment">//定义资源目录（layout , drawable,values）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SourceSet-实现-layout-分包"><a href="#SourceSet-实现-layout-分包" class="headerlink" title="SourceSet 实现 layout 分包"></a>SourceSet 实现 layout 分包</h2><p>对于一个大项目来说，页面太多，布局文件就很多，有时在众多布局文件中找某个模块的布局文件，很是痛苦，为了解决这个问题，我们可以在创建多个 layout 目录，不同模块的布局文件放在不同的 layout 目录中，这样查找起来，就容易很多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            res.srcDirs <span class="string">'src/main/res/layouts/login'</span>  <span class="comment">//定义登录布局目录</span></span><br><span class="line">            res.srcDirs <span class="string">'src/main/res/layouts/register'</span>  <span class="comment">//定义注册布局目录</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SourceSet-定义-AndroidManifest-文件"><a href="#SourceSet-定义-AndroidManifest-文件" class="headerlink" title="SourceSet 定义 AndroidManifest 文件"></a>SourceSet 定义 AndroidManifest 文件</h2><p>在组件化开发中, 我们需要针对 debug 与 release 模式下, 指定不同的 Manifest 文件, 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    def appDebug = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class="line"><span class="function">            appDebug </span>= <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        debug &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class="line"><span class="function">            appDebug </span>= <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            <span class="keyword">if</span> (appDebug) &#123;</span><br><span class="line">                manifest.srcFile <span class="string">'src/test1/AndroidManifest.xml'</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                manifest.srcFile <span class="string">'src/main/AndroidManifest.xml'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="buildConfigField自定义配置"><a href="#buildConfigField自定义配置" class="headerlink" title="buildConfigField自定义配置"></a>buildConfigField自定义配置</h1><p>实际开发中服务器可能有正式环境和测试环境，gradle可以通过buildConfigField来配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sdkA &#123;</span><br><span class="line">            buildConfigField ‘String’, ‘API_HOST’, <span class="string">"\"http:api.test.com\""</span><span class="comment">//API Host</span></span><br><span class="line">            buildConfigField <span class="string">'String'</span>,   <span class="string">'LANG'</span>, <span class="string">'"en-US"'</span></span><br><span class="line">            buildConfigField <span class="string">'String'</span>,   <span class="string">'MAP'</span>, <span class="string">'"google"'</span></span><br><span class="line">            buildConfigField <span class="string">'String'</span>,   <span class="string">'COORDINATE_SYSTEM'</span>, <span class="string">'"WGS_84"'</span></span><br><span class="line">            buildConfigField <span class="string">'int'</span>,      <span class="string">'COORDINATE_TYPE'</span>, <span class="string">'4'</span></span><br><span class="line">            buildConfigField <span class="string">'String[]'</span>, <span class="string">'SUPPORTED_LANGS'</span>, <span class="string">'&#123;LANG&#125;'</span></span><br><span class="line">            buildConfigField <span class="string">'String'</span>,   <span class="string">'CONSUMER_HOTLINE'</span>, </span><br><span class="line">            dimension <span class="string">"lang"</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>然后通过BuildConfig可以获取这些属性，从而做些差异化的配置等等</p><h1 id="打包更改包名"><a href="#打包更改包名" class="headerlink" title="打包更改包名"></a>打包更改包名</h1><p>项目的build.gradle</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line"> ……</span><br><span class="line"><span class="comment">//打包命名</span></span><br><span class="line">    applicationVariants.all &#123;</span><br><span class="line">        variant -&gt;</span><br><span class="line">            variant.outputs.each &#123;</span><br><span class="line">                output -&gt;</span><br><span class="line">                    <span class="keyword">if</span> (variant.buildType.name == <span class="string">'release'</span>) &#123;</span><br><span class="line">                        variant.mergedFlavor.versionCode = getVersionCode(<span class="keyword">false</span>)</span><br><span class="line">                        variant.mergedFlavor.versionName = getVersionName(<span class="keyword">false</span>)</span><br><span class="line">                        <span class="comment">// release</span></span><br><span class="line">                        def apkName = <span class="string">"$&#123;project.getName()&#125;_$&#123;variant.flavorName&#125;_$&#123;buildType.name&#125;_v$&#123;variant.versionCode&#125;.apk"</span>;</span><br><span class="line">                        output.outputFile = <span class="keyword">new</span> File(output.outputFile.parent, apkName);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        variant.mergedFlavor.versionCode = getVersionCode(<span class="keyword">true</span>)</span><br><span class="line">                        variant.mergedFlavor.versionName = getVersionName(<span class="keyword">true</span>)</span><br><span class="line">                        <span class="comment">// debug</span></span><br><span class="line">                        def apkName = <span class="string">"$&#123;project.getName()&#125;_$&#123;buildType.name&#125;.apk"</span>;</span><br><span class="line">                        output.outputFile = <span class="keyword">new</span> File(output.outputFile.parent, apkName);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 version code</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> def <span class="title">getVersionCode</span><span class="params">(<span class="keyword">boolean</span> isDebug)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isDebug) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(<span class="keyword">new</span> Date().format(<span class="string">"yyMMddHHmm"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getRevisionNumber()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 version name</span></span><br><span class="line"><span class="function">def <span class="title">getVersionName</span><span class="params">(<span class="keyword">boolean</span> isDebug)</span> </span>&#123;</span><br><span class="line">    String version = appConfig.appmajor +</span><br><span class="line">            <span class="string">'.'</span> + appConfig.appminor +</span><br><span class="line">            <span class="string">'.'</span> + getRevisionNumber()</span><br><span class="line">    String today = <span class="keyword">new</span> Date().format(<span class="string">'yyMMdd'</span>)</span><br><span class="line">    String time = <span class="keyword">new</span> Date().format(<span class="string">'HHmmss'</span>)</span><br><span class="line">    <span class="keyword">if</span> (isDebug) &#123;</span><br><span class="line">        <span class="keyword">return</span> version + <span class="string">".$today.$time."</span> + getRevisionDescription()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> version + <span class="string">".$today."</span> + getRevisionDescription()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.csdn.net/zhaoyanjun6/article/details/77678577#buildtypes-%E5%AE%9A%E4%B9%89%E4%BA%86%E7%BC%96%E8%AF%91%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener">https://blog.csdn.net/zhaoyanjun6/article/details/77678577#buildtypes-%E5%AE%9A%E4%B9%89%E4%BA%86%E7%BC%96%E8%AF%91%E7%B1%BB%E5%9E%8B</a></li><li><a href="https://juejin.im/post/5b000522f265da0b7f44d1c7" target="_blank" rel="noopener">https://juejin.im/post/5b000522f265da0b7f44d1c7</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;本篇主要介绍Gradle在Android
      
    
    </summary>
    
      <category term="Gradle" scheme="https://xsfelvis.github.io/categories/Gradle/"/>
    
    
      <category term="Gradle" scheme="https://xsfelvis.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Writing Custom Plugins[译]</title>
    <link href="https://xsfelvis.github.io/2018/06/09/%E8%AF%91%E6%96%87_Writing%20Custom%20Plugins/"/>
    <id>https://xsfelvis.github.io/2018/06/09/译文_Writing Custom Plugins/</id>
    <published>2018-06-08T16:00:00.000Z</published>
    <updated>2018-06-09T13:28:47.469Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h1><p>Packaging a plugin<br>Writing a simple plugin<br>Making the plugin configurable<br>Working with files in custom tasks and plugins<br>Mapping extension properties to task properties<br>A standalone project<br>Providing a configuration DSL for the plugin</p><p>一个Gradle 插件可以将build逻辑的复用片段打包在一起，我们可以将他们应用在不同的项目之中。Gradle 允许我们实现我们自定义的插件，因此你可可以复用你的build逻辑并且分享给其他人</p><p>理论上你可以使用你喜欢的任何语言实现一个Gradle 插件，前提它们可以最后编译为字节码。在我们的例子中，我们使用Groovy作为实现语言。Groovy，Java或者Kotlin都是实现插件语言的好的选择，Gradle API 已经被设计的可以很好地兼容这些语言的。总的来说，一个由Java或者Kotlin实现的插件，将比Groovy实现的更加通俗易懂,</p><h1 id="Packaging-a-plugin"><a href="#Packaging-a-plugin" class="headerlink" title="Packaging a plugin"></a>Packaging a plugin</h1><p>以下的一些地方可以防止插件的代码</p><h2 id="Build-script"><a href="#Build-script" class="headerlink" title="Build script"></a>Build script</h2><p>你可以直接在build script中直接包含插件源码，这种做法有个优势就是可以自动的编译，并且添加到build script的classpath中。然后，这个插件在外部不可见，因此你不能在该build之外复用这个插件</p><h2 id="buildSrc-project"><a href="#buildSrc-project" class="headerlink" title="buildSrc project"></a>buildSrc project</h2><p>你可以把插件代码放在<code>rootProjectDir/buildSrc/src/main/groovy</code>目录下,Gradle将处理好编译和测试插件，并且让它在build script的路径下可用。这个插件在当前项目build内的build script中都是可见的，然而在其他项目中build中还是不可见的，因此你还是不能在本项目之外的复用该插件</p><p>你可在参考 <a href="https://docs.gradle.org/current/userguide/organizing_gradle_projects.html" target="_blank" rel="noopener">Organizing Gradle Project</a>了解更多 buildSrc 项目使用的细节</p><h2 id="Standalone-project"><a href="#Standalone-project" class="headerlink" title="Standalone project"></a>Standalone project</h2><p>你可以为你的插件创建一个独立的工程。这个工程可以创建和发布JAR文件，这个jia文件可以在多个项目的build中被使用，总而言之，这个jar文件可以包含一些插件，或者绑定一些相关的task</p><p>在我们的例子中,为了使得事情比较简单，我们将在build script使用插件，，然后我们将学习如何创建一个standalone project的插件</p><h1 id="Writing-a-simple-plugin"><a href="#Writing-a-simple-plugin" class="headerlink" title="Writing a simple plugin"></a>Writing a simple plugin</h1><p>创建一个Gradle插件，首先需要实现<code>Plugin</code>接口，实现<code>Plugin.apply(T)</code>方法。其中project对象作为一个参数，这样插件就可以配置它。下面的飞马包含了一个hello world插件，给project添加了一个<code>hello</code>task</p><p><strong>Example: A custom plugin</strong><br><em>build.gradle</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">        project.task(<span class="string">'hello'</span>) &#123;</span><br><span class="line">            doLast &#123;</span><br><span class="line">                println <span class="string">'Hello from the GreetingPlugin'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the plugin</span></span><br><span class="line">apply plugin: GreetingPlugin</span><br></pre></td></tr></table></figure><p><strong>Output of gradle -q hello</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; gradle -q hello</span><br><span class="line">Hello from the GreetingPlugin</span><br></pre></td></tr></table></figure><p>我们需要明白的是一个插件是在被应用进的projetc来创建插件的实例，也需要明白插件是一个泛型。在上面例子里，接受一个Project类型作为一个参数。一个插件也可一件接受<code>Setting</code>类型的参数，这种插件我们可以把它应用到settin script脚本中;或者接受<code>Gradle</code>类型的插件参数,这种插件我们可以应用到script脚本初始化中</p><h1 id="Making-the-plugin-configurable"><a href="#Making-the-plugin-configurable" class="headerlink" title="Making the plugin configurable"></a>Making the plugin configurable</h1><p>大多数插件需要从build script中获取一些配置，一种方案就是使用<code>extension objects</code>. Gradle <code>Project</code>和<code>ExtensionContainer</code>对象具有联系，这个对象包含了这个插件应用到project的setting和属性。你可以通过添加扩展对象到这个容器来给你的插件提供配置。一个扩展对象就是一个简单的Java Bean兼容类。Groovy是一个很好的语言选择，是实现来扩展对象，这是由于普通老的Groovy对象包含了所有的setter和getter方法，当然Java和Kotlin也是其他好的选择.</p><p>让我们给project添加一个简单的扩展对象，在这里我们给project添加一个<code>greeting</code>扩展对象。</p><p><strong>Example: A custom plugin extension</strong></p><p><em>build.gradle</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPluginExtension</span> </span>&#123;</span><br><span class="line">    String message = <span class="string">'Hello from GreetingPlugin'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Add the 'greeting' extension object</span></span><br><span class="line">        def extension = project.extensions.create(<span class="string">'greeting'</span>, GreetingPluginExtension)</span><br><span class="line">        <span class="comment">// Add a task that uses configuration from the extension object</span></span><br><span class="line">        project.task(<span class="string">'hello'</span>) &#123;</span><br><span class="line">            doLast &#123;</span><br><span class="line">                println extension.message</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: GreetingPlugin</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the extension</span></span><br><span class="line">greeting.message = <span class="string">'Hi from Gradle'</span></span><br></pre></td></tr></table></figure><p><em>Output of gradle -q hello</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; gradle -q hello</span><br><span class="line">Hi from Gradle</span><br></pre></td></tr></table></figure><p>在这个例子中,<code>GreetingPluginExtension</code>是一个普通的旧Groovy对象，它带有一个名为message的属性，这个扩展以<code>greeting</code>的名字加载到插件列表中。这个对象然后在Project中就变得可用</p><p>通常情况下，你需要在一个插件里面配置对个相关属性，Gradle为每个扩展对象添加了闭环配置对象，因而你可以将这些设置分组在一起，下面的例子将要向你展示运作的方式</p><p><strong>Example: A custom plugin with configuration closure</strong><br><em>build.gradle</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPluginExtension</span> </span>&#123;</span><br><span class="line">    String message</span><br><span class="line">    String greeter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">        def extension = project.extensions.create(<span class="string">'greeting'</span>, GreetingPluginExtension)</span><br><span class="line">        project.task(<span class="string">'hello'</span>) &#123;</span><br><span class="line">            doLast &#123;</span><br><span class="line">                println <span class="string">"$&#123;extension.message&#125; from $&#123;extension.greeter&#125;"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: GreetingPlugin</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the extension using a DSL block</span></span><br><span class="line">greeting &#123;</span><br><span class="line">    message = <span class="string">'Hi'</span></span><br><span class="line">    greeter = <span class="string">'Gradle'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Output of gradle -q hello</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; gradle -q hello</span><br><span class="line">Hi from Gradle</span><br></pre></td></tr></table></figure><p>在这个例子中，一些设置可以通过<code>greeting</code>闭包归为一类，在build script中的闭包块name需要和扩展对象名称保持一致。然后当闭包被执行，在扩展对象里面的属性将通过Groovy闭包代理的特性被映射为变量</p><h1 id="Working-with-files-in-custom-tasks-and-plugins"><a href="#Working-with-files-in-custom-tasks-and-plugins" class="headerlink" title="Working with files in custom tasks and plugins"></a>Working with files in custom tasks and plugins</h1><p>当我们开发自定义task和插件的时候，当接受文件位置的输入配置时候需要十分的灵活，要到这个点，您可以利用Project.file（java.lang.Object）方法尽可能晚地解析文件的值。</p><p><strong>Example: Evaluating file properties lazily</strong></p><p><em>build.gradle</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingToFileTask</span> <span class="keyword">extends</span> <span class="title">DefaultTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    def destination</span><br><span class="line"></span><br><span class="line">    <span class="function">File <span class="title">getDestination</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        project.file(destination)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TaskAction</span></span><br><span class="line">    <span class="function">def <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        def file = getDestination()</span><br><span class="line">        file.parentFile.mkdirs()</span><br><span class="line">        file.write <span class="string">'Hello!'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">greet</span><span class="params">(type: GreetingToFileTask)</span> </span>&#123;</span><br><span class="line">    destination = &#123; project.greetingFile &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">sayGreeting</span><span class="params">(dependsOn: greet)</span> </span>&#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        <span class="function">println <span class="title">file</span><span class="params">(greetingFile)</span>.text</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">ext.greetingFile </span>= <span class="string">"$buildDir/hello.txt"</span></span><br></pre></td></tr></table></figure><p><em>Output of gradle -q sayGreeting</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; gradle -q sayGreeting</span><br><span class="line">Hello!</span><br></pre></td></tr></table></figure><p>在这个例子中，我们配置了<code>greet</code> Task的<code>destination</code>属性作为了闭环，并在最后转换为File对象进行评通过Project.file（java.lang.Object）方法对闭包的返回值估。在这个例子中你可以看到，我们设置<code>greetingFile</code>属性，在我们已经为task配置属性之后。这种evaluation的懒加载是文件设置属性可以接受任何值的一个关键的好处,然后在读取属性时解析该值。</p><h1 id="Mapping-extension-properties-to-task-properties"><a href="#Mapping-extension-properties-to-task-properties" class="headerlink" title="Mapping extension properties to task properties"></a>Mapping extension properties to task properties</h1><p>build script通过扩展获取用户的输入，并且将它映射到输入输出属性是自定义task的最佳实践。最终用户只需要通过扩展定义的暴露出来的DSL进行交互即可。命令逻辑隐藏在插件实现中。</p><p>在build script中申明的扩展以及扩展属性和自定义任务属性之间的映射发生在构建生命周期的Gradle配置阶段。为了避免evaluation顺序的问题，必须在excution阶段解决映射属性的实际值。（更多信息请参看 <a href="https://docs.gradle.org/current/userguide/build_lifecycle.html#sec:build_phases" target="_blank" rel="noopener">the section called “Build phases”</a>）.Gradle的API提供了用于表示应该进行延迟evaluate的属性的类型，例如在执行期（参阅<a href="https://docs.gradle.org/current/userguide/lazy_configuration.html" target="_blank" rel="noopener">延迟配置</a>），下面的例子演示了将扩展属性映射到任务属性类型的用法</p><p><strong>Example: Mapping extension properties to task properties</strong><br><em>build.gradle</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">        def extension = project.extensions.create(<span class="string">'greeting'</span>, GreetingPluginExtension, project)</span><br><span class="line">        project.tasks.create(<span class="string">'hello'</span>, Greeting) &#123;</span><br><span class="line">            message = extension.message</span><br><span class="line">            outputFiles = extension.outputFiles</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPluginExtension</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Property&lt;String&gt; message</span><br><span class="line">    <span class="keyword">final</span> ConfigurableFileCollection outputFiles</span><br><span class="line"></span><br><span class="line">    GreetingPluginExtension(Project project) &#123;</span><br><span class="line">        message = project.objects.property(String)</span><br><span class="line">        message.set(<span class="string">'Hello from GreetingPlugin'</span>)</span><br><span class="line">        outputFiles = project.layout.configurableFiles()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setOutputFiles</span><span class="params">(FileCollection outputFiles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.outputFiles.setFrom(outputFiles)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">DefaultTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Property&lt;String&gt; message = project.objects.property(String)</span><br><span class="line">    <span class="keyword">final</span> ConfigurableFileCollection outputFiles = project.layout.configurableFiles()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setOutputFiles</span><span class="params">(FileCollection outputFiles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.outputFiles.setFrom(outputFiles)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TaskAction</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        outputFiles.each &#123;</span><br><span class="line">            logger.quiet <span class="string">"Writing message 'Hi from Gradle' to file"</span></span><br><span class="line">            it.text = message.get()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: GreetingPlugin</span><br><span class="line"></span><br><span class="line">greeting &#123;</span><br><span class="line">    message = <span class="string">'Hi from Gradle'</span></span><br><span class="line">    outputFiles = layout.files(<span class="string">'a.txt'</span>, <span class="string">'b.txt'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Note: The code for this example can be found at samples/userguide/tasks/mapExtensionPropertiesToTaskProperties in the ‘-all’ distribution of Gradle.</p></blockquote><p><em>Output of gradle -q hello</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; gradle -q hello</span><br><span class="line">Writing message <span class="string">'Hi from Gradle'</span> to file</span><br><span class="line">Writing message <span class="string">'Hi from Gradle'</span> to file</span><br></pre></td></tr></table></figure><h1 id="A-standalone-project"><a href="#A-standalone-project" class="headerlink" title="A standalone project"></a>A standalone project</h1><p>现在，我们将把插件移到一个独立的project中，这样我们就可以发布并公用这个插件。这个project是个可以生成包含插件class的Jar文件的简单Groovy Project。下面这个project的简单build script，apply了Groovy插件，并且添加了gradle api的依赖</p><p><strong>Example: A build for a custom plugin</strong></p><p><em>build.gradle</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pply plugin: <span class="string">'groovy'</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="function">compile <span class="title">gradleApi</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    compile <span class="title">localGroovy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>Note: The code for this example can be found at samples/customPlugin/plugin in the ‘-all’ distribution of Gradle.</p></blockquote><p>因此Gradle如何发现实现的插件呢？答案是你需要在<code>META-INF/gradle-plugins</code>目录下提供一个匹配你插件id的属性<br><strong>Example: Wiring for a custom plugin</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- src/main/resources/META-INF/gradle-plugins/org.samples.greeting.properties</span><br><span class="line">  |</span><br><span class="line">  -  implementation-<span class="class"><span class="keyword">class</span></span>=org.gradle.GreetingPlugin</span><br></pre></td></tr></table></figure></p><p>需要注意的是，属性文件名与插件标识匹配，并放置在资源文件夹中，而实现类属性标识插件实现类。</p><h2 id="Creating-a-plugin-id"><a href="#Creating-a-plugin-id" class="headerlink" title="Creating a plugin id"></a>Creating a plugin id</h2><p>插件ID以类似于Java软件包的方式被完全限定（即反向域名）。这有助于避免冲突，并提供了一种将类似所有权的插件分组的方法。</p><p>您的插件ID应该是反映名称空间的组件的组合（指向您或您的组织的合理指针）以及它提供的插件的名称。例如，如果您有一个名为“foo”的Github帐户，并且您的插件名为“bar”，则合适的插件ID可能是com.github.foo.bar。同样，如果插件是在baz组织开发的，插件ID可能是org.baz.bar。</p><p>插件id应该按照以下规则：</p><ul><li>可以包含任何字母数字字符，’.’和’ - ‘。</li><li>必须包含至少一个’.’将名称空间与插件名称分开的字符。</li><li>通常对名称空间使用小写反向域名约定。</li><li>通常在名称中只使用小写字符</li><li>不要使用 org.gradle和com.gradleware命名空间</li><li>无法以’.’开始或结束</li><li>不能包含连续的’.’字符（即’..’）</li></ul><p>尽管插件ID和包名称之间存在传统的相似性，但包名通常比插件ID所需的更详细。例如，将“gradle”添加为插件ID的组件似乎是合理的，但由于插件ID仅用于Gradle插件，这将是多余的。一般而言，标识所有权和名称的名称空间都是良好的插件标识所需的</p><h2 id="Publishing-your-plugin"><a href="#Publishing-your-plugin" class="headerlink" title="Publishing your plugin"></a>Publishing your plugin</h2><p>如果您在公司内部发布您的插件以供您的组织使用，可以像发布其他任何代码工件一样发布它。关于发布工件，请参阅<a href="https://docs.gradle.org/current/userguide/publishing_ivy.html" target="_blank" rel="noopener">lvy</a>和<a href="https://docs.gradle.org/current/userguide/publishing_maven.html" target="_blank" rel="noopener">maven</a>章节。</p><p>如果您有兴趣发布您的插件以供更广泛的Gradle社区使用，您可以将其发布到<a href="https://plugins.gradle.org/docs/submit?_ga=2.115105858.438770069.1528507228-204910210.1513922382" target="_blank" rel="noopener">Gradle plugin portal. </a>。该网站提供搜索和收集Gradle社区贡献插件的信息的能力。请参阅<a href="https://plugins.gradle.org/?_ga=2.115105858.438770069.1528507228-204910210.1513922382" target="_blank" rel="noopener">此处</a>的说明，了解如何使您的插件在本网站上可用。</p><h2 id="Using-your-plugin-in-another-project"><a href="#Using-your-plugin-in-another-project" class="headerlink" title="Using your plugin in another project"></a>Using your plugin in another project</h2><p>要在构建脚本中使用插件，需要将插件类添加到构建脚本的类路径中。为此，请使用“buildscript {}”块，如<a href="https://docs.gradle.org/current/userguide/plugins.html#sec:applying_plugins_buildscript" target="_blank" rel="noopener">“Applying plugins with the buildscript block”</a>. 一节中所述。以下示例显示了当包含该插件的JAR已发布到本地存储库时，您需要这样做：</p><p><strong>Example: Using a custom plugin in another project</strong><br><em>build.gradle</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            <span class="function">url <span class="title">uri</span><span class="params">(<span class="string">'../repo'</span>)</span></span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    dependencies </span>&#123;</span><br><span class="line">        classpath group: <span class="string">'org.gradle'</span>, name: <span class="string">'customPlugin'</span>,</span><br><span class="line">                  version: <span class="string">'1.0-SNAPSHOT'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">apply plugin: <span class="string">'org.samples.greeting'</span></span><br></pre></td></tr></table></figure><p>或者，如果您的插件已发布到插件门户，则可以使用孵化插件DSL（请参阅“<a href="https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block" target="_blank" rel="noopener">使用插件DSL应用插件</a>”一节）来应用该插件：</p><p><strong>Example: Applying a community plugin with the plugins DSL</strong><br><em>build.gradle</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'com.jfrog.bintray'</span> version <span class="string">'0.4.1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Providing-a-configuration-DSL-for-the-plugin"><a href="#Providing-a-configuration-DSL-for-the-plugin" class="headerlink" title="Providing a configuration DSL for the plugin"></a>Providing a configuration DSL for the plugin</h1><p>正如我们上面看到的，您可以使用扩展对象为您的插件提供配置。使用扩展对象还扩展了Gradle DSL以为该插件添加项目属性和DSL块。扩展对象只是一个常规对象，因此您可以通过向扩展对象添加属性和方法来提供嵌套在此块中的DSL元素。Gradle提供了一些便利来帮助为插件创建一个行为良好的DSL。</p><h2 id="Nested-DSL-elements"><a href="#Nested-DSL-elements" class="headerlink" title="Nested DSL elements"></a>Nested DSL elements</h2><p>当Gradle创建任务或扩展对象时，Gradle修饰实现类以混合DSL支持。要创建一个嵌套的DSL元素，可以使用ObjectFactory类型来创建具有类似修饰的对象。然后，可以通过插件扩展的属性和方法使这些修饰对象可见。</p><p><strong>Example: Nested DSL elements</strong></p><p><em>build.gradle</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPluginExtension</span> </span>&#123;</span><br><span class="line">    String message</span><br><span class="line">    <span class="keyword">final</span> Person greeter</span><br><span class="line"></span><br><span class="line">    <span class="meta">@javax</span>.inject.Inject</span><br><span class="line">    GreetingPluginExtension(ObjectFactory objectFactory) &#123;</span><br><span class="line">        <span class="comment">// Create a Person instance</span></span><br><span class="line">        greeter = objectFactory.newInstance(Person)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">greeter</span><span class="params">(Action&lt;? <span class="keyword">super</span> Person&gt; action)</span> </span>&#123;</span><br><span class="line">        action.execute(greeter)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create the extension, passing in an ObjectFactory for it to use</span></span><br><span class="line">        def extension = project.extensions.create(<span class="string">'greeting'</span>, GreetingPluginExtension, project.objects)</span><br><span class="line">        project.task(<span class="string">'hello'</span>) &#123;</span><br><span class="line">            doLast &#123;</span><br><span class="line">                println <span class="string">"$&#123;extension.message&#125; from $&#123;extension.greeter.name&#125;"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: GreetingPlugin</span><br><span class="line"></span><br><span class="line">greeting &#123;</span><br><span class="line">    message = <span class="string">'Hi'</span></span><br><span class="line">    greeter &#123;</span><br><span class="line">        name = <span class="string">'Gradle'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Output of gradle -q hello</span><br><span class="line"></span><br><span class="line">&gt; gradle -q hello</span><br><span class="line">Hi from Gradle</span><br></pre></td></tr></table></figure><p>在这个例子中，插件通过其构造函数将项目的ObjectFactory传递给扩展对象。构造函数使用它创建一个嵌套对象，并通过greeter属性使该对象可供DSL使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Table-of-Contents&quot;&gt;&lt;a href=&quot;#Table-of-Contents&quot; class=&quot;headerlink&quot; title=&quot;Table of
      
    
    </summary>
    
      <category term="Gradle" scheme="https://xsfelvis.github.io/categories/Gradle/"/>
    
    
      <category term="Gradle" scheme="https://xsfelvis.github.io/tags/Gradle/"/>
    
      <category term="翻译" scheme="https://xsfelvis.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>ARouter解析之URL跳转</title>
    <link href="https://xsfelvis.github.io/2018/06/06/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8BURL%E8%B7%B3%E8%BD%AC/"/>
    <id>https://xsfelvis.github.io/2018/06/06/ARouter解析之URL跳转/</id>
    <published>2018-06-05T16:00:00.000Z</published>
    <updated>2018-06-06T08:20:03.342Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>ARouter解析</p><ul><li><p><a href="https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%A6%82%E8%BF%B0/">ARouter概述</a></p></li><li><p><a href="https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8B%E8%B7%AF%E7%94%B1%E7%9A%84%E7%A7%98%E5%AF%86/">路由的秘密</a></p></li><li><a href="https://xsfelvis.github.io/2018/06/06/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8BURL%E8%B7%B3%E8%BD%AC/">URL跳转</a></li></ul><h1 id="ARouter解析之URL跳转"><a href="#ARouter解析之URL跳转" class="headerlink" title="ARouter解析之URL跳转"></a>ARouter解析之URL跳转</h1><p>在ARouter Demo中，点击通过URL跳转，会通过WebView加载html</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance()</span><br><span class="line">        .build(<span class="string">"/test/webview"</span>)</span><br><span class="line">        .withString(<span class="string">"url"</span>, <span class="string">"file:///android_asset/schame-test.html"</span>)</span><br><span class="line">        .navigation();</span><br></pre></td></tr></table></figure><p> <img src="https://upload-images.jianshu.io/upload_images/2608779-5104d9c50fcb0553.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340" alt=""></p><h2 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h2><p>通常webview上的url跳转会给webview设置一个<code>webviewClient</code>，然后通过shouldOverrideUrlLoading方法，在方法中构造intent进行跳转，简单示意如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">webview.setWebViewClient(<span class="keyword">new</span> WebViewClient()&#123;    </span><br><span class="line"><span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span> (url != <span class="keyword">null</span> &amp;&amp; url.contains(<span class="string">"arouter"</span>))&#123;    </span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(TestWebview.<span class="keyword">this</span>, Test1Activity.class);    </span><br><span class="line">        startActivity(intent);    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.shouldOverrideUrlLoading(view, url);    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种做法往往会有很多缺陷</p><ol><li>硬编码，业务复杂时候webview变得很臃肿，耦合严重不利于维护</li><li>当外不应用打开链接需要跳转到我们的App某个Activity中时候，此时就不在自己App的webview环境中，这样就无法满足跳转需求的，因此这种方式也不够强大</li></ol><p>ARouter就是通过<code>注册一个没有UI的界面</code>作为跳板来统一处理,scheme是arouter的跳转请求。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">".SchemeFilterActivity"</span>&gt;</span><br><span class="line">    &lt;!-- Schame --&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;data</span><br><span class="line">            android:host=<span class="string">"m.aliyun.com"</span></span><br><span class="line">            android:scheme=<span class="string">"arouter"</span>/&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">"android.intent.action.VIEW"</span>/&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"android.intent.category.BROWSABLE"</span>/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">    &lt;!-- App Links --&gt;</span><br><span class="line">    &lt;intent-filter android:autoVerify=<span class="string">"true"</span>&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">"android.intent.action.VIEW"</span>/&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"android.intent.category.BROWSABLE"</span>/&gt;</span><br><span class="line">        &lt;data</span><br><span class="line">            android:host=<span class="string">"m.aliyun.com"</span></span><br><span class="line">            android:scheme=<span class="string">"http"</span>/&gt;</span><br><span class="line">        &lt;data</span><br><span class="line">            android:host=<span class="string">"m.aliyun.com"</span></span><br><span class="line">            android:scheme=<span class="string">"https"</span>/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><p>在清单文件中注册了SchemeFilterActivity这个activity</p><ul><li>scheme就是arouter, </li><li>host就是m.aliyun.com，</li><li>其中有个category是 android.intent.category.BROWSABLE，</li></ul><p>其中 <code>android.intent.category.BROWSABLE</code>就是让浏览器可以打这个Actvity，当然要符合host和scheme,这样就可以在WebView中跳转SchemeFilterActivity这个界面了。</p><p>这种方式的优点：</p><ol><li><p>首先是页面跳转的灵活性，<br>比如需要和H5中进行通信，H5需要跳转到App本地的页面，Native和H5只需要统一一个path文档即可，H5可以通过path构造一个url就可以实现跳转到对应页面的功能，很类似浏览器，实现很好的解耦</p></li><li><p>更加的安全<br>相比较于隐式的intent，每一个从外面跳转进来的页面都需要注册上intent-filter，每个页面都需要设置export=true，也就是需要让每一个页面都可以导出，在外部可以访问到。这样做会带来非常严重的安全风险，就像是一个房子有十个门还是只有一个门，看门的成本是不同的。而现在使用的这种场景只需要对外暴露出一个activity，然后在这个activity中注册一个intent-filter，这样之后所有的外部路由请求都会经过这唯一的门，然后在这个activity中获取到URL并将其交给ARouter，剩下的就由路由框架做分发了。</p></li><li><p>携带参数注入<br>另外一个好处就是隐式intent跳转无法将参数自动注入，ARouter可以在url中携带参数然后自动注入</p></li></ol><p>这里也需要H5链接需要按照<code>约定的scheme来</code>，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>跳转测试<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>自定义Scheme[通常来说都是这样的]<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"arouter://m.aliyun.com/test/activity1"</span>&gt;</span>arouter://m.aliyun.com/test/activity1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"arouter://m.aliyun.com/test/activity1?url=https%3a%2f%2fm.abc.com%3fa%3db%26c%3dd"</span>&gt;</span>测试URL Encode情况<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"arouter://m.aliyun.com/test/activity1?name=alex&amp;age=18&amp;boy=true&amp;high=180&amp;obj=%7b%22name%22%3a%22jack%22%2c%22id%22%3a666%7d"</span>&gt;</span>arouter://m.aliyun.com/test/activity1?name=alex&amp;age=18&amp;boy=true&amp;high=180&amp;obj=&#123;"name":"jack","id":"666"&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"arouter://m.aliyun.com/test/activity2"</span>&gt;</span>arouter://m.aliyun.com/test/activity2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"arouter://m.aliyun.com/test/activity2?key1=value1"</span>&gt;</span>arouter://m.aliyun.com/test/activity2?key1=value1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"arouter://m.aliyun.com/test/activity3?name=alex&amp;age=18&amp;boy=true&amp;high=180"</span>&gt;</span>arouter://m.aliyun.com/test/activity3?name=alex&amp;age=18&amp;boy=true&amp;high=180<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>App Links[防止被App屏蔽]<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://m.aliyun.com/test/activity1"</span>&gt;</span>http://m.aliyun.com/test/activity1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://m.aliyun.com/test/activity2"</span>&gt;</span>http://m.aliyun.com/test/activity2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="URL中转SchemeFilterActivity"><a href="#URL中转SchemeFilterActivity" class="headerlink" title="URL中转SchemeFilterActivity"></a>URL中转SchemeFilterActivity</h2><p>点击url之后通过清单文件的匹配intent-filter中的data, action, category的标签，其中category匹配任意一个即可。接着就来到SchemeFilterActivity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchemeFilterActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        直接通过ARouter处理外部Uri</span></span><br><span class="line">        Uri uri = getIntent().getData();</span><br><span class="line">        ARouter.getInstance().build(uri).navigation(<span class="keyword">this</span>, <span class="keyword">new</span> NavCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onArrival</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">                finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续处理就跟之前路由逻辑一致了,这里就不赘述了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;ARouter解析&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%
      
    
    </summary>
    
      <category term="开源学习" scheme="https://xsfelvis.github.io/categories/%E5%BC%80%E6%BA%90%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ARouter" scheme="https://xsfelvis.github.io/tags/ARouter/"/>
    
      <category term="路由" scheme="https://xsfelvis.github.io/tags/%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>谈谈APT和JavaPoet的一些使用技巧和要点</title>
    <link href="https://xsfelvis.github.io/2018/06/06/%E8%B0%88%E8%B0%88APT%E5%92%8CJavaPoet%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/"/>
    <id>https://xsfelvis.github.io/2018/06/06/谈谈APT和JavaPoet的一些技巧/</id>
    <published>2018-06-05T16:00:00.000Z</published>
    <updated>2018-06-06T15:28:38.868Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>APT+JavaPoet 是一把利剑，可以将很多模板代码在编译期间直接生成，即通过注解收集信息，然后将这些信息形成一些固定代码；特别是在写框架的时候，可以将一些“脏活、累活”通过这种方式处理掉，然后提供给用户一个干净的API接口使用，目前常用在</p><ul><li>路由 如<a href="https://github.com/alibaba/ARouter" target="_blank" rel="noopener">ARouter</a></li><li>ButterKnife、Dagger等</li><li>JsBridge (Hanlder或者Actioon)</li><li><p>权限<br>如 <a href="https://github.com/hongyangAndroid/MPermissions" target="_blank" rel="noopener">MPermissions</a>、<a href="https://github.com/permissions-dispatcher/PermissionsDispatcher" target="_blank" rel="noopener">PermissionsDispatcher</a></p></li><li><p>工厂模式相关 <a href="https://race604.com/annotation-processing/" target="_blank" rel="noopener">工厂模式简化</a> </p></li></ul><p>一些复杂类型的Adapter 等等，这些都可以找到相关的开源库</p><p>关于APT+JavePoet要是不熟悉的话建议先看看我之前的注解系列</p><p>注解系列</p><ul><li><a href="https://xsfelvis.github.io/2017/01/06/%E6%B3%A8%E8%A7%A3%E5%9F%BA%E7%A1%80/">注解基础</a></li><li><a href="https://xsfelvis.github.io/2017/04/07/%E7%BC%96%E8%AF%91%E6%9C%9F%E6%B3%A8%E8%A7%A3%E4%B9%8BAPT/">编译期注解处理之APT</a></li><li><a href="https://xsfelvis.github.io/2017/03/12/%E7%BC%96%E8%AF%91%E6%9C%9F%E6%B3%A8%E8%A7%A3%E4%B9%8BJavaPoet/">JavaPoet</a></li></ul><p><a href="https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%A6%82%E8%BF%B0/#more">ARouter解析</a></p><h1 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h1><h2 id="老生常谈的面向接口编程"><a href="#老生常谈的面向接口编程" class="headerlink" title="老生常谈的面向接口编程"></a>老生常谈的面向接口编程</h2><p>比如在<a href="https://github.com/hongyangAndroid/MPermissions" target="_blank" rel="noopener">MPermissions</a>中，提供了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PermissionProxy</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">grant</span><span class="params">(T source, <span class="keyword">int</span> requestCode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">denied</span><span class="params">(T source, <span class="keyword">int</span> requestCode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rationale</span><span class="params">(T source, <span class="keyword">int</span> requestCode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">needShowRationale</span><span class="params">(<span class="keyword">int</span> requestCode)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后APT生成的代码实现该接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span>$$<span class="title">PermissionProxy</span> <span class="keyword">implements</span> <span class="title">PermissionProxy</span>&lt;<span class="title">MainActivity</span>&gt; </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际逻辑操作中直接使用该接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldShowRequestPermissionRationale</span><span class="params">(Activity activity, String permission, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//核心逻辑只关注接口</span></span><br><span class="line">        PermissionProxy proxy = findPermissionProxy(activity);</span><br><span class="line">        <span class="keyword">if</span> (!proxy.needShowRationale(requestCode)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (ActivityCompat.shouldShowRequestPermissionRationale(activity,</span><br><span class="line">                permission)) &#123;</span><br><span class="line">            proxy.rationale(activity, requestCode);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ARouter(<a href="https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%A6%82%E8%BF%B0/#more">Arouter解析</a>)中也有这种处理的方式，比如IRouteGroup<br>LogisticsCenter#completion</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();</span><br><span class="line">iGroupInstance.loadInto(Warehouse.routes);</span><br><span class="line">Warehouse.groupsIndex.remove(postcard.getGroup());</span><br></pre></td></tr></table></figure><p>思想一样这里就不展开赘述了</p><h2 id="信息注入分离"><a href="#信息注入分离" class="headerlink" title="信息注入分离"></a>信息注入分离</h2><p>比如在ARouter中有一个<code>仓库</code>WearHouse类里面就是一些空壳容器，用来盛放路由的元信息，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Warehouse</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Cache route and metas</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; groupsIndex = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, RouteMeta&gt; routes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache provider</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Class, IProvider&gt; providers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, RouteMeta&gt; providersIndex = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache interceptor</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; interceptorsIndex = <span class="keyword">new</span> UniqueKeyTreeMap&lt;&gt;(<span class="string">"More than one interceptors use same priority [%s]"</span>);</span><br><span class="line">    <span class="keyword">static</span> List&lt;IInterceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道具体的信息是在注解之中，APT+JavaPoet负责将信息收集，在ARouter中体现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ARouter</span>$$<span class="title">Group</span>$$<span class="title">service</span> <span class="keyword">implements</span> <span class="title">IRouteGroup</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadInto</span><span class="params">(Map&lt;String, RouteMeta&gt; atlas)</span> </span>&#123;</span><br><span class="line">    atlas.put(<span class="string">"/service/hello"</span>, RouteMeta.build(RouteType.PROVIDER, HelloServiceImpl.class, <span class="string">"/service/hello"</span>, <span class="string">"service"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">"/service/json"</span>, RouteMeta.build(RouteType.PROVIDER, JsonServiceImpl.class, <span class="string">"/service/json"</span>, <span class="string">"service"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">"/service/single"</span>, RouteMeta.build(RouteType.PROVIDER, SingleService.class, <span class="string">"/service/single"</span>, <span class="string">"service"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出只有一个接受注入的信息的函数,然后在实际逻辑处理中,将此处的信息load到WareHouse中对应map</p><p>LogisticsCenter#completion</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();</span><br><span class="line">iGroupInstance.loadInto(Warehouse.routes);</span><br><span class="line">Warehouse.groupsIndex.remove(postcard.getGroup());</span><br></pre></td></tr></table></figure><p>干净清爽</p><h2 id="常用的JavaPoet"><a href="#常用的JavaPoet" class="headerlink" title="常用的JavaPoet"></a>常用的JavaPoet</h2><p>基本操作可以查看官方文档<a href="https://github.com/square/javapoet" target="_blank" rel="noopener">JavaPoet</a> 这里讲一下一些难点所在不过一般都是纠结在 获取类、接口、Map、带泛型的Map，下面将一一说明</p><h3 id="获取类"><a href="#获取类" class="headerlink" title="获取类"></a>获取类</h3><p>有两种方式</p><ul><li><p>ClassName.bestGuess(“类全名称”) 返回ClassName对象，这里的类全名称表示的类必须要存在，会自动导入相应的包</p></li><li><p>ClassName.get(“包名”，”类名”) 返回ClassName对象，不检查该类是否存在</p></li></ul><p>因此需要注意获取类全名的类在以后重构时候<code>改名类名</code>或者<code>移动了位置</code>需要对应修改这里</p><h3 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h3><ul><li>$L 字面常量（Literals）</li><li>$S 字符串常量（String）</li><li>$T 类型(Types)<br>该占位符最大特点就是会自动导包</li><li>$N 命名(Names),通常指我们自己生成的方法名或者变量名等等</li></ul><h3 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a>复杂类型</h3><p>稍微复杂点的类型 比如泛型 、Map之类的，需要了解下JavaPoet定义的几种专门描述类型的类</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/26/1639c8621da268bc?imageView2/0/w/1280/h/960/ignore-error/1" alt="复杂类型"></p><p>常见的有</p><table><thead><tr><th>分类</th><th>生成的类型</th><th>JavaPoet 写法</th><th>也可以这么写 （等效的 Java 写法）</th></tr></thead><tbody><tr><td>内置类型</td><td>int</td><td>TypeName.INT</td><td>int.class</td></tr><tr><td>数组类型</td><td>int[]</td><td>ArrayTypeName.of(int.class)</td><td>int[].class</td></tr><tr><td>需要引入包名的类型</td><td>java.io.File</td><td>ClassName.get(“java.io”, “File”)</td><td>java.io.File.class</td></tr><tr><td>参数化类型 （ParameterizedType</td><td>List</td><td>ParameterizedTypeName.get(List.class, String.class)</td><td>-</td></tr><tr><td>类型变量  （WildcardType） 用于声明泛型</td><td>T</td><td>TypeVariableName.get(“T”)</td><td>-</td></tr><tr><td>通配符类型</td><td>? extends String</td><td>WildcardTypeName.subtypeOf(String.class)</td><td>-</td></tr></tbody></table><p>通过ARouter中的一段代码，就可以解释的很清楚</p><p>RouterProcessor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数化类型 Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt;</span></span><br><span class="line">ParameterizedTypeName inputMapTypeOfRoot = ParameterizedTypeName.get(</span><br><span class="line">            ClassName.get(Map.class),</span><br><span class="line">            ClassName.get(String.class),</span><br><span class="line">            ParameterizedTypeName.get(</span><br><span class="line">                    ClassName.get(Class.class),</span><br><span class="line">                    WildcardTypeName.subtypeOf(ClassName.get(type_IRouteGroup))</span><br><span class="line">            )</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line"><span class="comment">//参数化类型 Map&lt;String, RouteMeta&gt;</span></span><br><span class="line">ParameterizedTypeName inputMapTypeOfGroup = ParameterizedTypeName.get(</span><br><span class="line">            ClassName.get(Map.class),</span><br><span class="line">            ClassName.get(String.class),</span><br><span class="line">            ClassName.get(RouteMeta.class)</span><br><span class="line">    );        </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *Build input param name.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ParameterSpec rootParamSpec = ParameterSpec.builder(inputMapTypeOfRoot, <span class="string">"routes"</span>).build();</span><br><span class="line">    ParameterSpec groupParamSpec = ParameterSpec.builder(inputMapTypeOfGroup, <span class="string">"atlas"</span>).build();</span><br></pre></td></tr></table></figure><p>生成代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ARouter</span>$$<span class="title">Root</span>$$<span class="title">app</span> <span class="keyword">implements</span> <span class="title">IRouteRoot</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadInto</span><span class="params">(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes)</span> </span>&#123;</span><br><span class="line">    routes.put(<span class="string">"service"</span>, ARouter$$Group$$service.class);</span><br><span class="line">    routes.put(<span class="string">"test"</span>, ARouter$$Group$$test.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ARouter</span>$$<span class="title">Group</span>$$<span class="title">service</span> <span class="keyword">implements</span> <span class="title">IRouteGroup</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadInto</span><span class="params">(Map&lt;String, RouteMeta&gt; atlas)</span> </span>&#123;</span><br><span class="line">    atlas.put(<span class="string">"/service/hello"</span>, RouteMeta.build(RouteType.PROVIDER, HelloServiceImpl.class, <span class="string">"/service/hello"</span>, <span class="string">"service"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">"/service/json"</span>, RouteMeta.build(RouteType.PROVIDER, JsonServiceImpl.class, <span class="string">"/service/json"</span>, <span class="string">"service"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">"/service/single"</span>, RouteMeta.build(RouteType.PROVIDER, SingleService.class, <span class="string">"/service/single"</span>, <span class="string">"service"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者直接先把你需要的泛型都写出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ClassName java_lang_Class = ClassName.get(Class.class);</span><br><span class="line">        <span class="keyword">final</span> ClassName java_util_Collections = ClassName.get(<span class="string">"java.util"</span>, <span class="string">"Collections"</span>);</span><br><span class="line">        <span class="keyword">final</span> ClassName java_util_Map = ClassName.get(<span class="string">"java.util"</span>, <span class="string">"Map"</span>);</span><br><span class="line">        <span class="keyword">final</span> ClassName java_util_Set = ClassName.get(<span class="string">"java.util"</span>, <span class="string">"Set"</span>);</span><br><span class="line">        <span class="keyword">final</span> ClassName java_util_LinkedHashMap = ClassName.get(<span class="string">"java.util"</span>, <span class="string">"LinkedHashMap"</span>);</span><br><span class="line">        <span class="keyword">final</span> ClassName java_util_LinkedHashSet = ClassName.get(<span class="string">"java.util"</span>, <span class="string">"LinkedHashSet"</span>);</span><br><span class="line">        <span class="keyword">final</span> ClassName instantiator = ClassName.get(<span class="string">"java.util.concurrent"</span>, <span class="string">"Callable"</span>);</span><br><span class="line">        <span class="keyword">final</span> TypeName classOfAny = ParameterizedTypeName.get(java_lang_Class, any);</span><br><span class="line">        <span class="keyword">final</span> TypeName instantiatorOfAny = ParameterizedTypeName.get(instantiator, any);</span><br><span class="line">        <span class="keyword">final</span> TypeName instantiatorOfP = ParameterizedTypeName.get(instantiator, p);</span><br><span class="line">        <span class="keyword">final</span> TypeName classOfS = ParameterizedTypeName.get(java_lang_Class, s);</span><br><span class="line">        <span class="keyword">final</span> TypeName classOfP = ParameterizedTypeName.get(java_lang_Class, p);</span><br><span class="line">        <span class="keyword">final</span> TypeName classOfSubTypeOfS = ParameterizedTypeName.get(java_lang_Class, subTypeOfS);</span><br><span class="line">        <span class="keyword">final</span> TypeName setOfClass = ParameterizedTypeName.get(java_util_Set, classOfAny);</span><br><span class="line">        <span class="keyword">final</span> TypeName setOfClassOfSubTypeOfS = ParameterizedTypeName.get(java_util_Set, classOfSubTypeOfS);</span><br><span class="line">        <span class="keyword">final</span> TypeName linkedHashSetOfClass = ParameterizedTypeName.get(java_util_LinkedHashSet, classOfAny);</span><br><span class="line">        <span class="keyword">final</span> TypeName mapOfClassToSetOfClass = ParameterizedTypeName.get(java_util_Map, classOfAny, setOfClass);</span><br><span class="line">        <span class="keyword">final</span> TypeName mapOfClassToInstantiator = ParameterizedTypeName.get(java_util_Map, classOfAny, instantiatorOfAny);</span><br><span class="line">        <span class="keyword">final</span> TypeName linkedHashMapOfClassToSetOfClass = ParameterizedTypeName.get(java_util_LinkedHashMap, classOfAny, setOfClass);</span><br><span class="line">        <span class="keyword">final</span> TypeName linkedHashMapOfClassToInstantializer = ParameterizedTypeName.get(java_util_LinkedHashMap, classOfAny, instantiatorOfAny);</span><br></pre></td></tr></table></figure><p>然后在需要时直接拿到即可,这里是作为一个变量(Field使用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.addField(FieldSpec.builder(mapOfClassToSetOfClass, <span class="string">"sServices"</span>)</span><br><span class="line">                        .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)</span><br><span class="line">                        .initializer(<span class="string">"new $T()"</span>, linkedHashMapOfClassToSetOfClass)</span><br><span class="line">                        .build())</span><br><span class="line">                        </span><br><span class="line">.addField(FieldSpec.builder(mapOfClassToInstantiator, <span class="string">"sInstantiators"</span>)</span><br><span class="line">                        .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)</span><br><span class="line">                        .initializer(<span class="string">"new $T()"</span>, linkedHashMapOfClassToInstantializer)</span><br><span class="line">                        .build())</span><br></pre></td></tr></table></figure><h1 id="要点分析"><a href="#要点分析" class="headerlink" title="要点分析"></a>要点分析</h1><h2 id="Element和TypeMirror"><a href="#Element和TypeMirror" class="headerlink" title="Element和TypeMirror"></a>Element和TypeMirror</h2><p>这个点还是非常重要的，我们的java代码在对于APT处理时只不过各种的Element的结构化文本，当我们需要进行细致的逻辑判断时候，比如是否是某个类的子类，就需要操作他们了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.example;    // PackageElement</span><br><span class="line"></span><br><span class="line">public class Test &#123;        // TypeElement</span><br><span class="line"></span><br><span class="line">    private int a;      // VariableElement</span><br><span class="line">    private Test other;  // VariableElement</span><br><span class="line"></span><br><span class="line">    public Test () &#123;&#125;    // ExecuteableElement</span><br><span class="line">    public void setA (  // ExecuteableElement</span><br><span class="line">                     int newA   // TypeElement</span><br><span class="line">                     ) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Element</code>代表java源文件中的程序构建元素，例如包、类、方法等。Element接口有5个子类。</p><table><thead><tr><th>PackageElement</th><th>表示一个包程序元素，可以获取到包名等</th></tr></thead><tbody><tr><td>TypeParameterElement</td><td>表示一般类、接口、方法或构造方法元素的泛型参数</td></tr><tr><td>TypeElement</td><td>表示一个类或接口程序元素</td></tr><tr><td>VariableElement</td><td>表示一个字段、enum 常量、方法或构造方法参数、局部变量或异常参数</td></tr><tr><td>ExecutableElement</td><td>表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注解类型元素</td></tr></tbody></table><p>开发中Element可根据实际情况强转为以上5种中的一种</p><ul><li>当你有一个注解是以@Target(ElementType.METHOD)定义时，表示该注解只能修饰方法。<br>那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、方法名、参数类型、返回值,如何做？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//@Target(ElementType.METHOD)修饰</span></span><br><span class="line"><span class="keyword">for</span> (Element element : roundEnv.getElementsAnnotatedWith(Inject.class)) &#123;</span><br><span class="line">    <span class="comment">//对于Element直接强转</span></span><br><span class="line">    ExecutableElement executableElement = (ExecutableElement) element;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非对应的Element，通过getEnclosingElement转换获取</span></span><br><span class="line">    TypeElement classElement = (TypeElement) element</span><br><span class="line">                .getEnclosingElement();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当(ExecutableElement) element成立时，使用(PackageElement) element</span></span><br><span class="line">    <span class="comment">//            .getEnclosingElement();将报错。</span></span><br><span class="line">    <span class="comment">//需要使用elementUtils来获取</span></span><br><span class="line">    Elements elementUtils = processingEnv.getElementUtils();</span><br><span class="line">    PackageElement packageElement = elementUtils.getPackageOf(classElement);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全类名</span></span><br><span class="line">    String fullClassName = classElement.getQualifiedName().toString();</span><br><span class="line">    <span class="comment">//类名</span></span><br><span class="line">    String className = classElement.getSimpleName().toString();</span><br><span class="line">    <span class="comment">//包名</span></span><br><span class="line">    String packageName = packageElement.getQualifiedName().toString();</span><br><span class="line">    <span class="comment">//方法名</span></span><br><span class="line">    String methodName = executableElement.getSimpleName().toString();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取得方法参数列表</span></span><br><span class="line">    List&lt;? extends VariableElement&gt; methodParameters = executableElement.getParameters();</span><br><span class="line">    <span class="comment">//参数类型列表</span></span><br><span class="line">    List&lt;String&gt; types = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (VariableElement variableElement : methodParameters) &#123;</span><br><span class="line">        TypeMirror methodParameterType = variableElement.asType();</span><br><span class="line">        <span class="keyword">if</span> (methodParameterType <span class="keyword">instanceof</span> TypeVariable) &#123;</span><br><span class="line">            TypeVariable typeVariable = (TypeVariable) methodParameterType;</span><br><span class="line">            methodParameterType = typeVariable.getUpperBound();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//参数名</span></span><br><span class="line">        String parameterName = variableElement.getSimpleName().toString();</span><br><span class="line">        <span class="comment">//参数类型</span></span><br><span class="line">        String parameteKind = methodParameterType.toString();</span><br><span class="line">        types.add(methodParameterType.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当你有一个注解是以@Target(ElementType.FIELD)定义时，表示该注解只能修饰属性、类成员。那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、类成员类型、类成员名,如何获取?</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Element element : roundEnv.getElementsAnnotatedWith(IdProperty.class)) &#123;</span><br><span class="line">    <span class="comment">//ElementType.FIELD注解可以直接强转VariableElement</span></span><br><span class="line">    VariableElement variableElement = (VariableElement) element;</span><br><span class="line">    <span class="comment">//非对应的Element，通过getEnclosingElement转换获取</span></span><br><span class="line">    TypeElement classElement = (TypeElement) element</span><br><span class="line">            .getEnclosingElement();</span><br><span class="line">    PackageElement packageElement = elementUtils.getPackageOf(classElement);</span><br><span class="line">    <span class="comment">//类名</span></span><br><span class="line">    String className = classElement.getSimpleName().toString();</span><br><span class="line">    <span class="comment">//包名</span></span><br><span class="line">    String packageName = packageElement.getQualifiedName().toString();</span><br><span class="line">    <span class="comment">//类成员名</span></span><br><span class="line">    String variableName = variableElement.getSimpleName().toString();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类成员类型</span></span><br><span class="line">    TypeMirror typeMirror = variableElement.asType();</span><br><span class="line">    String type = typeMirror.toString();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当你有一个注解是以@Target(ElementType.TYPE)定义时，表示该注解只能修饰类、接口、枚举。那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、全类名、父类，如何获取？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Element element : roundEnv.getElementsAnnotatedWith(xxx.class)) &#123;</span><br><span class="line">    <span class="comment">//ElementType.TYPE注解可以直接强转TypeElement</span></span><br><span class="line">    TypeElement classElement = (TypeElement) element;</span><br><span class="line">    <span class="comment">//非对应的Element，通过getEnclosingElement转换获取</span></span><br><span class="line">    PackageElement packageElement = (PackageElement) element</span><br><span class="line">                .getEnclosingElement();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全类名</span></span><br><span class="line">    String fullClassName = classElement.getQualifiedName().toString();</span><br><span class="line">    <span class="comment">//类名</span></span><br><span class="line">    String className = classElement.getSimpleName().toString();</span><br><span class="line">    <span class="comment">//包名</span></span><br><span class="line">    String packageName = packageElement.getQualifiedName().toString();</span><br><span class="line">    <span class="comment">//父类名</span></span><br><span class="line">    String superClassName = classElement.getSuperclass().toString();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Element代表的是源代码。TypeElement代表的是源代码中的类型元素，例如类。然而，TypeElement并不包含类本身的信息。你可以从TypeElement中获取类的名字，但是你获取不到类的信息，例如它的父类。这种信息需要通过TypeMirror获取。<code>TypeMirror</code>用与描述Java程序中元素的信息，即Elment的元信息。通过通过<code>Element.asType()</code>接口可以获取Element的TypeMirror，结构比较复杂<br><img src="https://blog-10039692.file.myqcloud.com/1508900053643_8070_1508900092231.png" alt="typemirror"></p><p>常用的TypeMirror，如下</p><table><thead><tr><th>PrimitiveType</th><th>原始数据类型，boolean,byte,short int,long,float,char,double</th></tr></thead><tbody><tr><td>ReferenceType</td><td>引用类型</td></tr><tr><td>ArrayType</td><td>数组类型</td></tr><tr><td>DeclaredType</td><td>声明的类型，例如类、接口、枚举、注解类型</td></tr><tr><td>AnnotationType</td><td>注解类型</td></tr><tr><td>ClassType</td><td>类类型</td></tr><tr><td>EnumType</td><td>枚举类型</td></tr><tr><td>InterfaceType</td><td>接口类型</td></tr><tr><td>TypeVariable</td><td>类型变量类型</td></tr><tr><td>VoidType</td><td>void 类型</td></tr><tr><td>WildcardType</td><td>通配符类型</td></tr></tbody></table><p>当TypeMirror是DeclaredType或者TypeVariable时，TypeMirror可以转化成Element:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element element = processingEviroment.getTypeUtils().asElement(typeMirror);</span><br></pre></td></tr></table></figure><p>在ARouter中 为了区分是否是某个类的子类使用到了TypeMirro</p><p>RouterProcessor # parseRoutes</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> TypeMirror type_Activity = elements.getTypeElement(ACTIVITY).asType();</span><br><span class="line">            TypeMirror type_Service = elements.getTypeElement(SERVICE).asType();</span><br><span class="line">            TypeMirror fragmentTm = elements.getTypeElement(FRAGMENT).asType();</span><br><span class="line">            TypeMirror fragmentTmV4 = elements.getTypeElement(Consts.FRAGMENT_V4).asType();</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> (types.isSubtype(tm, type_Activity)) &#123;                 <span class="comment">// Activity</span></span><br><span class="line">                    ……</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (types.isSubtype(tm, iProvider)) &#123;         <span class="comment">// IProvider</span></span><br><span class="line">                ……</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (types.isSubtype(tm, fragmentTm) || types.isSubtype(tm, fragmentTmV4)) &#123;</span><br><span class="line">                 ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ul><li>使用Messager</li></ul><p><code>Messager</code>提供给注解处理器一个报告错误、警告以及提示信息的途径。它不是注解处理器开发者的日志工具，而是用来写一些信息给使用此注解器的第三方开发者的。<br>在官方文档中描述了消息的不同级别中非常重要的是Kind.ERROR，因为这种类型的信息用来表示我们的注解处理器处理失败了。很有可能是第三方开发者错误的使用了注解。这个概念和传统的Java应用有点不一样，在传统Java应用中我们可能就抛出一个异常Exception。如果你在process()中抛出一个异常，那么运行注解处理器的JVM将会崩溃（就像其他Java应用一样），使用我们注解处理器第三方开发者将会从javac中得到非常难懂的出错信息，因为它包含注解处理器的堆栈跟踪（Stacktace）信息。因此，注解处理器就有一个Messager类，它能够打印非常优美的错误信息。除此之外，你还可以连接到出错的元素。在像现在的IDE（集成开发环境）中，第三方开发者可以直接点击错误信息，IDE将会直接跳转到第三方开发者项目的出错的源文件的相应的行。<br>因此我们通常封装一个Logger去打印关键点，具体可以参考ARouter的<a href="https://github.com/alibaba/ARouter/blob/master/arouter-compiler/src/main/java/com/alibaba/android/arouter/compiler/utils/Logger.java" target="_blank" rel="noopener">Logger</a></p><ul><li>断点调试</li></ul><p>(1) 在项目的根目录下的gradle.properties文件中，新增如下配置：</p><blockquote><p>org.gradle.jvmargs=-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005<br>org.gradle.daemon=true</p></blockquote><p>(2)新建remote debugger</p><p>注意新建remoteDebuger的名称一定要是AnnotationProcessor<br><img src="https://blog-10039692.file.myqcloud.com/1508900731628_7034_1508900770128.png" alt=""></p><p><img src="https://blog-10039692.file.myqcloud.com/1508900743976_6437_1508900782462.png" alt=""><br>(3)Debug AnnotationProcessor<br><img src="https://blog-10039692.file.myqcloud.com/1508900753173_3782_1508900791654.png" alt=""></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>APT + JavaPoet 固然比较强大，但是也有其局限性，比如它无法扫描 AAR、JAR包，在一些大型app上分模块最终以jar包形式提供的话，就不能扫描到注解了，那这时就需要借助于更为强大的技术了，可以通过自定义Gradle Plugin + JavaAssist在dex之前扫描class方式去生成我们想要的代码,这是后话了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.im/entry/58fefebf8d6d810058a610de/" target="_blank" rel="noopener">https://juejin.im/entry/58fefebf8d6d810058a610de/</a></li><li><a href="https://cloud.tencent.com/developer/article/1006210" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1006210</a></li><li><a href="https://race604.com/annotation-processing/" target="_blank" rel="noopener">https://race604.com/annotation-processing/</a></li><li><a href="https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/" target="_blank" rel="noopener">https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;APT+JavaPoet 是一把利剑，可
      
    
    </summary>
    
      <category term="注解" scheme="https://xsfelvis.github.io/categories/%E6%B3%A8%E8%A7%A3/"/>
    
    
      <category term="APT" scheme="https://xsfelvis.github.io/tags/APT/"/>
    
      <category term="JavaPoet" scheme="https://xsfelvis.github.io/tags/JavaPoet/"/>
    
  </entry>
  
  <entry>
    <title>ARouter解析之路由的秘密</title>
    <link href="https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8B%E8%B7%AF%E7%94%B1%E7%9A%84%E7%A7%98%E5%AF%86/"/>
    <id>https://xsfelvis.github.io/2018/06/05/ARouter解析之路由的秘密/</id>
    <published>2018-06-04T16:00:00.000Z</published>
    <updated>2018-06-06T15:30:42.105Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>ARouter解析</p><ul><li><p><a href="https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%A6%82%E8%BF%B0/">ARouter概述</a></p></li><li><p><a href="https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8B%E8%B7%AF%E7%94%B1%E7%9A%84%E7%A7%98%E5%AF%86/">路由的秘密</a></p></li><li><a href="https://xsfelvis.github.io/2018/06/06/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8BURL%E8%B7%B3%E8%BD%AC/">URL跳转</a></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本篇主要介绍ARouter如何进行路由的，比如Activity、Fragment、服务等</p><h1 id="路由的秘密"><a href="#路由的秘密" class="headerlink" title="路由的秘密"></a>路由的秘密</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>初始化路由之后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARouter.init(mApplication);</span><br></pre></td></tr></table></figure><p>在需要支持页面路由的页面上添加注解(至少两级)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Route</span>(path = <span class="string">"/test/activity2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2Activity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span></span><br></pre></td></tr></table></figure><p>在路由时候通过建造者模式构建参数，<code>路由页面</code>分为以下几种</p><h3 id="路由页面"><a href="#路由页面" class="headerlink" title="路由页面"></a>路由页面</h3><ul><li>普通跳转</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance()</span><br><span class="line">        .build(<span class="string">"/test/activity2"</span>)</span><br><span class="line">        .navigation();</span><br></pre></td></tr></table></figure><ul><li>带参数跳转</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance()</span><br><span class="line">    .build(<span class="string">"/test/activity2"</span>)</span><br><span class="line">    .withString(<span class="string">"key1"</span>, <span class="string">"value1"</span>)</span><br><span class="line">    .navigation();</span><br></pre></td></tr></table></figure><p>其中ARouter提供了丰富的参数类型主要有基本类型、Object、Parceable等，核心原理也是通过Bundle携带传递</p><ul><li>startActivityForResult</li></ul><p>比如在TestActivity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance().build(<span class="string">"/test/activity2"</span>)</span><br><span class="line">                     .withString(<span class="string">"key1"</span>, <span class="string">"value1"</span>)</span><br><span class="line">                     .navigation(<span class="keyword">this</span>, <span class="number">999</span>);</span><br></pre></td></tr></table></figure><p>然后在TestActivity中 使用onActivityResult得到数据进行处理，这里跟普通过程一样</p><ul><li>带回调路由</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance().build(<span class="string">"/xxx/xxx"</span>).navigation(<span class="keyword">this</span>, <span class="keyword">new</span> NavCallback() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFound</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">                       Log.d(<span class="string">"ARouter"</span>, <span class="string">"找到了"</span>);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLost</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">                       Log.d(<span class="string">"ARouter"</span>, <span class="string">"找不到了"</span>);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onArrival</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">                       Log.d(<span class="string">"ARouter"</span>, <span class="string">"跳转完了"</span>);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInterrupt</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">                       Log.d(<span class="string">"ARouter"</span>, <span class="string">"被拦截了"</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br></pre></td></tr></table></figure><h3 id="路由Fragment"><a href="#路由Fragment" class="headerlink" title="路由Fragment"></a>路由Fragment</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Fragment fragment = (Fragment) ARouter.getInstance()</span><br><span class="line">                    .build(<span class="string">"/test/fragment"</span>)</span><br><span class="line">                    .navigation();</span><br></pre></td></tr></table></figure><h3 id="路由服务"><a href="#路由服务" class="headerlink" title="路由服务"></a>路由服务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance()</span><br><span class="line">        .navigation(SingleService.class)</span><br><span class="line">        .sayHello(<span class="string">"Mike"</span>);</span><br></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>可以看出路由到页面 分为三步</p><ul><li>build 构建 信息邮票(PostCard)</li></ul><p>_ARouter # build</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Build postcard by path and default group</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Postcard <span class="title">build</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(path)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(Consts.TAG + <span class="string">"Parameter is invalid!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != pService) &#123;</span><br><span class="line">            path = pService.forString(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(path, extractGroup(path));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>WithXXX 路由参数</p></li><li><p>navagation 导航</p></li></ul><p>_ARouter # navagation</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">navigation</span><span class="params">(Context mContext, Postcard postcard, <span class="keyword">int</span> requestCode, NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _ARouter.getInstance().navigation(mContext, postcard, requestCode, callback);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面将按照上面的提到三个核心过程进行分析</p><ul><li>通过path构建路由信息</li></ul><p>build是在构建路由信息邮票”PostCard”,从名字看来这就是一张路由邮票，跟网络路由协议传递携带的信息作用一样,通过ARouter这个门面类(Facade)调用实际操控着_ARouter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Build postcard by path and default group</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Postcard <span class="title">build</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">      ……</span><br><span class="line">    <span class="comment">//路径扩展</span></span><br><span class="line">    PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != pService) &#123;</span><br><span class="line">        path = pService.forString(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> build(path, extractGroup(path));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也体现了作者设计这套框架的扩展性能，这个<code>PathReplaceService</code>就是让使用者自己可以给path添加扩展。extractGroup就是根据path(/test/activity2)提取group(test)，这里就是默认第一个/隔断的字符串，通过这些信息<code>初步</code>构造路由信息，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> Postcard <span class="title">build</span><span class="params">(String path, String group)</span> </span>&#123;</span><br><span class="line">       ……</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Postcard(path, group);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一个具有 <code>path</code>和<code>group</code>简单信息的PostCard对象就被构造出来了</p><ul><li>携带参数</li></ul><p>由于是Builder模式，此时构造出postcard之后之后的<code>.WithXXX</code>实际上实在给PostCard对象填充信息，PostCard对象的Bundle来承载这些信息，<br>其中 序列化对象<code>SerializationService</code>转成json存到Bundle中<br>通过这一步PostCard这个<code>邮票</code>信息进一步丰满了</p><ul><li>navigation 导航</li></ul><p>得到PostCard对象之后回去调用postCard对象的navigation对象,调用函数链如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PostCard（Arouter.getInstance.build("test/activity2")）——&gt;PostCard#navigation——&gt;ARouter#navigation</span><br><span class="line">——&gt;_ARouter#navigation`</span><br></pre></td></tr></table></figure><h4 id="ARouter-navigation"><a href="#ARouter-navigation" class="headerlink" title="_ARouter#navigation"></a>_ARouter#navigation</h4><p>来到了核心函数 <code>_ARouter#navigation</code>函数中,这个函数其实是核心路由逻辑的第一道大门,我们越来越接近真相了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">navigation</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="keyword">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//完善postCard 核心信息,主要是跳转路径 后面会详细分析</span></span><br><span class="line">        LogisticsCenter.completion(postcard);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoRouteFoundException ex) &#123;</span><br><span class="line">        <span class="comment">// 未找到页面的降级处理策略</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">            <span class="comment">//自定义回调高于系统</span></span><br><span class="line">            callback.onLost(postcard);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// No callback for this invoke, then we use the global degrade service.</span></span><br><span class="line">            <span class="comment">//没有自定义回调才使用系统onLost</span></span><br><span class="line">            DegradeService degradeService = ARouter.getInstance().navigation(DegradeService.class);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != degradeService) &#123;</span><br><span class="line">                degradeService.onLost(context, postcard);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">        <span class="comment">//onFound回调</span></span><br><span class="line">        callback.onFound(postcard);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!postcard.isGreenChannel()) &#123;   <span class="comment">// It must be run in async thread, maybe interceptor cost too mush time made ANR.</span></span><br><span class="line">        <span class="comment">//非绿色通道检查拦截器</span></span><br><span class="line">        interceptorService.doInterceptions(postcard, <span class="keyword">new</span> InterceptorCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onContinue</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//真正核心导航逻辑</span></span><br><span class="line">            _navigation(context, postcard, requestCode, callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInterrupt</span><span class="params">(Throwable exception)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">                    callback.onInterrupt(postcard);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//真正核心导航逻辑</span></span><br><span class="line">        <span class="keyword">return</span> _navigation(context, postcard, requestCode, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法较长 主要分为以下四步</p><ol><li>首先调用LogisticsCenter.completion完成postcard的补充</li><li>NavigationCallBack的处理</li><li>拦截器Interceptions的处理</li><li>开始路由导航</li></ol><p>路由导航之前如何将之前获取的postcard信息进行完善?<br>ARouter.getInstance() .build(“/test/activity2”)时已经返回了一个postcard对象，那么要完善那些信息呢？其实我们可以看出，postcard中只有path和group的信息，目标页面是什么还不明确，因此需要进一步完善信息，核心函数就是上面的LogisticsCenter.completion，这样就体现了框架的重要性，脏活累活交给框架层面，而跟用户打交道的永远都是那么的简洁。</p><h4 id="ARouter-navigationObject-navigation"><a href="#ARouter-navigationObject-navigation" class="headerlink" title="_ARouter#navigationObject navigation("></a>_ARouter#navigationObject navigation(</h4><p>最后会来到_ARouter#navigationObject navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback)）</p><p>这个函数负责最终的页面跳转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">_navigation</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="keyword">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Context currentContext = <span class="keyword">null</span> == context ? mContext : context;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (postcard.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> ACTIVITY:</span><br><span class="line">                <span class="comment">// Build intent</span></span><br><span class="line">                <span class="keyword">final</span> Intent intent = <span class="keyword">new</span> Intent(currentContext, postcard.getDestination());</span><br><span class="line">                intent.putExtras(postcard.getExtras());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Set flags.</span></span><br><span class="line">                <span class="keyword">int</span> flags = postcard.getFlags();</span><br><span class="line">                <span class="keyword">if</span> (-<span class="number">1</span> != flags) &#123;</span><br><span class="line">                    intent.setFlags(flags);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(currentContext <span class="keyword">instanceof</span> Activity)) &#123;    <span class="comment">// Non activity, need less one flag.</span></span><br><span class="line">                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Navigation in main looper.</span></span><br><span class="line">                <span class="keyword">new</span> Handler(Looper.getMainLooper()).post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (requestCode &gt; <span class="number">0</span>) &#123;  <span class="comment">// Need start for result</span></span><br><span class="line">                            ActivityCompat.startActivityForResult((Activity) currentContext, intent, requestCode, postcard.getOptionsBundle());</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            ActivityCompat.startActivity(currentContext, intent, postcard.getOptionsBundle());</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> ((-<span class="number">1</span> != postcard.getEnterAnim() &amp;&amp; -<span class="number">1</span> != postcard.getExitAnim()) &amp;&amp; currentContext <span class="keyword">instanceof</span> Activity) &#123;    <span class="comment">// Old version.</span></span><br><span class="line">                            ((Activity) currentContext).overridePendingTransition(postcard.getEnterAnim(), postcard.getExitAnim());</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123; <span class="comment">// Navigation over.</span></span><br><span class="line">                            callback.onArrival(postcard);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PROVIDER:</span><br><span class="line">                <span class="keyword">return</span> postcard.getProvider();</span><br><span class="line">            <span class="keyword">case</span> BOARDCAST:</span><br><span class="line">            <span class="keyword">case</span> CONTENT_PROVIDER:</span><br><span class="line">            <span class="keyword">case</span> FRAGMENT:</span><br><span class="line">                Class fragmentMeta = postcard.getDestination();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object instance = fragmentMeta.getConstructor().newInstance();</span><br><span class="line">                    <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> Fragment) &#123;</span><br><span class="line">                        ((Fragment) instance).setArguments(postcard.getExtras());</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> android.support.v4.app.Fragment) &#123;</span><br><span class="line">                        ((android.support.v4.app.Fragment) instance).setArguments(postcard.getExtras());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> instance;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    logger.error(Consts.TAG, <span class="string">"Fetch fragment instance error, "</span> + TextUtils.formatStackTrace(ex.getStackTrace()));</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> METHOD:</span><br><span class="line">            <span class="keyword">case</span> SERVICE:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>Activity</li></ul><p>来到ACTIVITY分支，从postcard中拿到目标页面TestActivity.class然后组成intent，然后putExtras，如果是startActivityForResult,这里面就有参数。如果context不是activity，那么就需要另起一个栈Intent.FLAG_ACTIVITY_NEW_TASK进行activity的展示。接下来通过handler发送启动activity的任务。终于找到了熟悉的ActivityCompat.startActivity和ActivityCompat.startActivityForResult，</p><ul><li>Fragment</li></ul><p>通过postcard拿到目标页面的Fragment Class，然后实例化这个，还需要兼容fragment，设置Arguments参数之后返回这个Fragment实例</p><ul><li>Provider</li></ul><p>这个是用来提供服务的，由于在 完善postCard 核心信息,<code>LogisticsCenter.completion(postcard);</code>中已经将provider实例化了，这里直接直接get出来就好。后面将会分析<code>LogisticsCenter.completion(postcard)</code>具体做了哪些工作</p><h4 id="LogisticsCenter-completion-postcard"><a href="#LogisticsCenter-completion-postcard" class="headerlink" title="LogisticsCenter.completion(postcard)"></a>LogisticsCenter.completion(postcard)</h4><p>这个函数就是完善PostCard信息的，postcard是路由信息的容器，到这个函数时候postcard中只有path和group的信息，目标页面是什么还不知道，LogisticsCenter.completion就是填充剩余的关键信息的，b并且是通过<code>按需加载的</code>,十分重要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">completion</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="comment">//从仓库WareHouse中获取路由元数据，即一些路由基本的数据</span></span><br><span class="line">    RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == routeMeta) &#123;    <span class="comment">// Maybe its does't exist, or didn't load.</span></span><br><span class="line">        Class&lt;? extends IRouteGroup&gt; groupMeta = Warehouse.groupsIndex.get(postcard.getGroup());  <span class="comment">// Load route meta.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == groupMeta) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoRouteFoundException(TAG + <span class="string">"There is no route match the path ["</span> + postcard.getPath() + <span class="string">"], in group ["</span> + postcard.getGroup() + <span class="string">"]"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Load route and cache it into memory, then delete from metas.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ……</span><br><span class="line">                <span class="comment">//将信息加载进Warehouse.routes中</span></span><br><span class="line">                IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();</span><br><span class="line">                iGroupInstance.loadInto(Warehouse.routes);</span><br><span class="line">                Warehouse.groupsIndex.remove(postcard.getGroup());</span><br><span class="line">                ……</span><br><span class="line">            &#125; </span><br><span class="line">            ……</span><br><span class="line">            <span class="comment">//经过上面的处理后，此时可以获取到对应path下的routeMeta，调用本身</span></span><br><span class="line">            completion(postcard);   <span class="comment">// Reload</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//正常获取到routeMeta填充postCard信息</span></span><br><span class="line">        postcard.setDestination(routeMeta.getDestination());</span><br><span class="line">        postcard.setType(routeMeta.getType());</span><br><span class="line">        postcard.setPriority(routeMeta.getPriority());</span><br><span class="line">        postcard.setExtra(routeMeta.getExtra());</span><br><span class="line"></span><br><span class="line">        Uri rawUri = postcard.getUri();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != rawUri) &#123;   <span class="comment">// Try to set params into bundle.</span></span><br><span class="line">            Map&lt;String, String&gt; resultMap = TextUtils.splitQueryParameters(rawUri);</span><br><span class="line">            Map&lt;String, Integer&gt; paramsType = routeMeta.getParamsType();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (MapUtils.isNotEmpty(paramsType)) &#123;</span><br><span class="line">                <span class="comment">// Set value by its type, just for params which annotation by @Param</span></span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; params : paramsType.entrySet()) &#123;</span><br><span class="line">                    setValue(postcard,</span><br><span class="line">                            params.getValue(),</span><br><span class="line">                            params.getKey(),</span><br><span class="line">                            resultMap.get(params.getKey()));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Save params name which need auto inject.</span></span><br><span class="line">                postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(<span class="keyword">new</span> String[]&#123;&#125;));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Save raw uri</span></span><br><span class="line">            postcard.withString(ARouter.RAW_URI, rawUri.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (routeMeta.getType()) &#123;</span><br><span class="line">            <span class="comment">//完成信息的同时顺便把"服务实例化"，fragment置为无须过滤的绿色通道</span></span><br><span class="line">            <span class="keyword">case</span> PROVIDER:  <span class="comment">// if the route is provider, should find its instance</span></span><br><span class="line">                <span class="comment">// Its provider, so it must implement IProvider</span></span><br><span class="line">                Class&lt;? extends IProvider&gt; providerMeta = (Class&lt;? extends IProvider&gt;) routeMeta.getDestination();</span><br><span class="line">                IProvider instance = Warehouse.providers.get(providerMeta);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123; <span class="comment">// There's no instance of this provider</span></span><br><span class="line">                    IProvider provider;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        provider = providerMeta.getConstructor().newInstance();</span><br><span class="line">                        provider.init(mContext);</span><br><span class="line">                        Warehouse.providers.put(providerMeta, provider);</span><br><span class="line">                        instance = provider;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(<span class="string">"Init provider failed! "</span> + e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                postcard.setProvider(instance);</span><br><span class="line">                postcard.greenChannel();    <span class="comment">// Provider should skip all of interceptors</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FRAGMENT:</span><br><span class="line">                postcard.greenChannel();    <span class="comment">// Fragment needn't interceptors</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程图如下<br><img src="http://p927u2n0k.bkt.clouddn.com/arouter-complete.png" alt="arouter-complete"></p><p>这个有一个关键点 WearHouse</p><ul><li>仓库查找页面节点</li></ul><p>首先根据路径信息到WareHouse仓库中查找路由节点信息，其实就是几个map，包含节点、拦截器和组别等信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());</span><br></pre></td></tr></table></figure><p>一开始是没有这个节点信息的，所以需要到WareHouse.groupsIndex中找到组别的信息，这里体现了之前提到的<code>分组加载的策略</code>，这里对应的是test这一组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;? extends IRouteGroup&gt; groupMeta = Warehouse.groupsIndex.get(postcard.getGroup());  <span class="comment">// Load route meta</span></span><br></pre></td></tr></table></figure><p>然后通过反射的方式加载这一组类别的映射关系，就是前面提到的按需加载，然后从仓库中删除这个组别信息节点，防止重复加载</p><pre><code class="java">IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();        iGroupInstance.loadInto(Warehouse.routes);    Warehouse.groupsIndex.remove(postcard.getGroup());</code></pre><p>其中编译期间已经组成了RouteMeta这个节点信息，包含有目标页面、类型、路径、组别、参数、优先级等信息。可以看到生成之后的信息表并没有直接加载到内存中，而是在第一次访问该组内一个页面时才去加载该组的信息，然后该groupindex移除，防止重复加载</p><p>生成的<code>ARouter$$Group$$test</code></p><p><img src="https://upload-images.jianshu.io/upload_images/2608779-20192e96ae6f869f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="test组"></p><ul><li>填充信息</li></ul><p>当第一次没有查找到路由节点之后，要到组别中找到路由信息 load到warehouse中，再次调用本身<code>completion(postcard)</code>函数.然后执行到else中填充路由信息</p><ul><li>一些初始化</li></ul><p>填充玩信息后，将”服务”实例化，方便后面直接获取，并且将“服务”和fragment设置为绿色通道无需检查，感觉是由于二者本身需要返回一个实例，回调接口NavCallBack只能回调PostCard信息，而且二者近似服务性质，因而不如直接给个绿色通道来的直接。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>路由之间跳转到的分析到此基本上告一段落了，其中众多信息都在PostCard中不断完善，然后在LogisticsCenter.completion进行完全填充，更重要的是整体架构关注点分离的设计是非常棒的，编译期间映射信息都下沉到LogisticsCenter与用户层打交道的API都通过ARouter这个门面友好的暴露给用户，我们平时在开发设计中也可以这样学习一下</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;ARouter解析&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%
      
    
    </summary>
    
      <category term="开源学习" scheme="https://xsfelvis.github.io/categories/%E5%BC%80%E6%BA%90%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ARouter" scheme="https://xsfelvis.github.io/tags/ARouter/"/>
    
      <category term="路由" scheme="https://xsfelvis.github.io/tags/%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>ARouter解析</title>
    <link href="https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%A3%E6%9E%90/"/>
    <id>https://xsfelvis.github.io/2018/06/05/ARouter解析/</id>
    <published>2018-06-04T16:00:00.000Z</published>
    <updated>2018-06-08T07:34:40.410Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>ARouter解析</p><ul><li><p><a href="https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%A6%82%E8%BF%B0/">ARouter概述</a></p></li><li><p><a href="https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8B%E8%B7%AF%E7%94%B1%E7%9A%84%E7%A7%98%E5%AF%86/">路由的秘密</a></p></li><li><a href="https://xsfelvis.github.io/2018/06/06/ARouter%E8%A7%A3%E6%9E%90%E4%B9%8BURL%E8%B7%B3%E8%BD%AC/">URL跳转</a></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这个库非常值得学习，里面涉及到的技术和编程思想都是不错的</p><ol><li>APT 编译器注解处理技术</li><li>URL的统一管理跳转的方案</li><li>‘服务’的解耦（接口设计）与获取(反射)</li><li>多线程处理技术 (CountDownLatch的使用) </li><li>拦截器思想、降级策略(（AOP的设计思想）)、分组加载策略</li><li>友好的api设计</li></ol><h1 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h1><p><img src="http://p927u2n0k.bkt.clouddn.com/ARouter.png" alt="ARoute"></p><p>再进一步抽象就是<code>“邮票”PostCard信息的完善过程</code>，当信息完全填充就可以具体往哪里跳，携带什么参数</p><p><img src="http://p927u2n0k.bkt.clouddn.com/Arouter核心抽象.png" alt="Arouter核心抽象"></p><p>使用原作者的抽象图，整个ARouter架构如下:</p><p><img src="http://p927u2n0k.bkt.clouddn.com/37b723fb660fdfcf7cdc09c194c88a8073d8272d.png" alt="37b723fb660fdfcf7cdc09c194c88a8073d8272d"></p><p><img src="http://p927u2n0k.bkt.clouddn.com/e4d3ec6020479ef2043cfd7e10cfaf33254ac309-1.png" alt="e4d3ec6020479ef2043cfd7e10cfaf33254ac309"></p><p>其实在Android原生跳转主要是通过intent，主要分为显式和隐式跳转，显示跳转直接导致类之间的耦合，而隐式跳转需要在清单文件中申明，在多模块协作中比较困难,而且二者最终都会调用startActivity，这个环节我们就无法控制了，而ARouter路由可以在跳转中进行如同拦截,跳转失败进行降级的操作。</p><p>把握好了整体，下面将分几篇介绍这个开源库,见开篇链接。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;ARouter解析&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://xsfelvis.github.io/2018/06/05/ARouter%E8%A7%
      
    
    </summary>
    
      <category term="开源学习" scheme="https://xsfelvis.github.io/categories/%E5%BC%80%E6%BA%90%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ARouter" scheme="https://xsfelvis.github.io/tags/ARouter/"/>
    
      <category term="路由" scheme="https://xsfelvis.github.io/tags/%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>clean架构</title>
    <link href="https://xsfelvis.github.io/2018/05/18/%E5%85%B3%E4%BA%8Eclean%E6%9E%B6%E6%9E%84%E5%9C%A8android%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://xsfelvis.github.io/2018/05/18/关于clean架构在android中的应用/</id>
    <published>2018-05-17T16:00:00.000Z</published>
    <updated>2018-06-06T06:13:38.572Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="1、clean架构简介"><a href="#1、clean架构简介" class="headerlink" title="1、clean架构简介"></a>1、clean架构简介</h2><p>clean架构相信大家早有耳闻，毕竟是Bob大叔的心血之作，最近又把<a href="http://five.agency/blog/android/" target="_blank" rel="noopener">http://five.agency/blog/android/</a> 几篇关于clean 架构的文章拿出来读读加深了对该架构的一些理解。clean架构又称“洋葱架构”，这个是由于它的架构示意图得名的<br><img src="https://user-gold-cdn.xitu.io/2018/5/15/16364599d2727324?w=896&amp;h=472&amp;f=png&amp;s=104636" alt="" title="image.png"><br>删除一些android项目中使用不到的东西加上我们使用的东西看起来如下图</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/15/16364599d36a65e7?w=892&amp;h=467&amp;f=png&amp;s=96377" alt="" title="image.png"></p><h2 id="2、核心概念"><a href="#2、核心概念" class="headerlink" title="2、核心概念"></a>2、核心概念</h2><p>从最抽象的核心到细节的边缘</p><h3 id="Entities"><a href="#Entities" class="headerlink" title="Entities"></a>Entities</h3><ul><li><p>Entities，<br>即<strong>Domain 对象</strong>或业务对象，是App的核心。 它们代表了APP的主要功能， 它们包含业务逻辑， 他们不会与外在世界的细节进行互动。</p></li><li><p>Use case，<br>又名interactors（交互器），又名business services，是Entities的扩展，是业务逻辑的延伸，也就是说。 它们包含的逻辑不仅限于一个实体，而是处理更多的实体。</p></li></ul><h3 id="Repositories"><a href="#Repositories" class="headerlink" title="Repositories"></a>Repositories</h3><p>Repositories用于持久化Entities。 就这么简单。 它们被定义为接口并用作想要对Entities执行CRUD操作的用例的输出端口。</p><h3 id="Presenters"><a href="#Presenters" class="headerlink" title="Presenters"></a>Presenters</h3><p>如果你熟悉MVP模式，Presenters就会做你期望他们做的事情。 他们处理用户交互，调用适当的业务逻辑，并将数据发送到UI进行渲染。 这里通常有不同类型之间的映射<br>大概这几个概念可以帮助我们更好的理解clean 架构，但是核心一点就是越在洋葱里面越是抽象。</p><h2 id="3、clean-架构的核心规则"><a href="#3、clean-架构的核心规则" class="headerlink" title="3、clean 架构的核心规则"></a>3、clean 架构的核心规则</h2><p>首先需要掌握涉及的领域，原文称作“Master of your domain”，就是说当你打开你的工程，除去技术相关，你就应该从宏观上知晓你的app是做什么的，而不要沉浸到细节之中” 为啥需要我们站在这个高度去看待自己的项目呢，因为这也是clean核心所在，该架构越往洋葱里面抽象度越来越高，都是业务逻辑的高度抽象，即”内层包含业务逻辑、外层包含实现细节”</p><p>继而给出了设计出这样特性的clean架构需要具备的技术点</p><p>（1）Dependency rule（依赖原则）</p><p>（2）Abstraction（抽象）</p><p>（3）Communication between layers（层之间的通信）</p><p>下面将一一介绍</p><h3 id="3-1-Dependency-rule（依赖原则）"><a href="#3-1-Dependency-rule（依赖原则）" class="headerlink" title="3.1 Dependency rule（依赖原则）"></a>3.1 Dependency rule（依赖原则）</h3><p>从最开始的第一幅我们就可以看出箭头是”依赖”,即 外层看到并了解内层，但是内层既看不到也不知道外层，结合前面所强调的 内层包含业务逻辑（抽象），外层包含实现细节。 结合依赖关系规则，业务逻辑既看不到，也不知道实现细节。 通常我们可以通过放在不同的module中去来调整它们之间的依赖关系<br><img src="https://user-gold-cdn.xitu.io/2018/5/15/16364599d4727672?w=456&amp;h=405&amp;f=png&amp;s=64878" alt="" title="image.png"></p><h3 id="3-2-Abstraction（抽象）"><a href="#3-2-Abstraction（抽象）" class="headerlink" title="3.2 Abstraction（抽象）"></a>3.2 Abstraction（抽象）</h3><p>之前也说过当你走向图的中间时，东西变得更加抽象。 这是有道理的：抽象往往比细节更加稳定，就像搭积木一样根基越稳越好。</p><p>举个例子比如我们可以将抽象接口定义为“加载网络图片”并将其放入内层，业务逻辑就可以使用它来显示图片。 另一方面，我们可以通过实现改接口调用具体的图片加载库glide或者Picasso，然后将该实现放入外层。业务逻辑可以使用加载图片功能而无需知道实现细节的任何内容。这样抵御了变化的风险，日后换成什么方式加载图片，洋葱内部的抽象业务逻辑是不会感知到的</p><h3 id="3-3-Communication-between-layers（层之间的通信）"><a href="#3-3-Communication-between-layers（层之间的通信）" class="headerlink" title="3.3 Communication between layers（层之间的通信）"></a>3.3 Communication between layers（层之间的通信）</h3><p>既然已经划分好了层，分离了内容，将业务逻辑放在应用程序的架构中心和架构边缘的实现细节中，一切看起来都很棒。 但是你可能很快遇到了一个有趣的问题。<br>如果你的UI是一个实现细节，那么internet也是一个实现细节，业务逻辑介于两者之间，<strong>我们如何从internet获取数据，通过业务逻辑传递它，然后将其发送到屏幕？</strong><br>组合和继承的就要发挥功效了</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/15/16364599d7039681?w=665&amp;h=447&amp;f=png&amp;s=107878" alt="" title="image.png"></p><h2 id="4、实践"><a href="#4、实践" class="headerlink" title="4、实践"></a>4、实践</h2><p>下面用代码示意一下，以RSS Reader 为例我们的用户应该能够管理他们的RSS提要订阅，从提要中获取文章并阅读它们。这里是数据流问题，用例介于表示层和数据层之间。 我们如何建立层之间的沟通？ 记住那些输入和输出端口？<br><img src="https://user-gold-cdn.xitu.io/2018/5/15/16364599d7eca624?w=888&amp;h=466&amp;f=png&amp;s=49877" alt="" title="image.png"></p><p>从上图可以看出我们的 Use Case必须实现输入端口（接口）。 Presenter在 Use Case上调用方法，数据流向 Use Case（feedId）。 Use Case映射feedId提供文章并希望将它们发送回表示层。 它有一个对输出端口（回调）的引用，因为输出端口是在同一层定义的，因此它调用了一个方法。 因此，数据发送到输出端口 - Presenter。</p><p>让我们从domain层开始，创建我们的核心业务模型和逻辑。</p><p>我们的商业模式非常简单：</p><ul><li>Feed - 持有RSS提要相关数据，如网址，缩略图网址，标题和说明</li><li>Article -保存文章相关数据，如文章标题，网址和发布日期</li></ul><p>我们的逻辑，我们将使用UseCases。 他们在简洁的类中封装了小部分业务逻辑。 他们都将实施通用的UseCase 契约接口：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UseCase</span>&lt;<span class="title">P</span>, <span class="title">R</span>&gt;</span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span>&lt;<span class="title">R</span>&gt;</span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(R return)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span></span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(P parameter, Callback&lt;R&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"> callback)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CompletableUseCase</span>&lt;<span class="title">P</span>&gt;</span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span></span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(P parameter, Callback callback)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UseCase接口是输入端口，Callback接口是输出端口，GetFeedArticlesUseCase实现如下  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetFeedArticlesUseCase</span> <span class="keyword">implements</span> <span class="title">UseCase</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">Integer</span>, <span class="title">List</span>&lt;<span class="title">Article</span>&gt;&gt;</span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> FeedRepository feedRepository;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Integer feedId, <span class="keyword">final</span> Callback&lt;List&lt;Article&gt;&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"> callback)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> callback.onSuccess(feedRepository.getFeedArticles(feedId));</span><br><span class="line"> &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable throwable) &#123;</span><br><span class="line"> callback.onError(throwable);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>然后到洋葱外面的UI实现，View有一个简单的契约类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">showArticles</span><span class="params">(List&lt;ArticleViewModel&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"> feedArticles)</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">showErrorMessage</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">showLoadingIndicator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该视图的Presenter具有非常简单的显示逻辑。 它获取文章，将它们映射到view odels并传递到View，再看下FeedArticlesPresenter：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeedArticlesPresenter</span> <span class="keyword">implements</span> <span class="title">UseCase</span>.<span class="title">Callback</span>&lt;<span class="title">List</span>&lt;<span class="title">Article</span>&gt;&gt;</span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> GetFeedArticlesUseCase getFeedArticlesUseCase;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> ViewModeMapper viewModelMapper;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fetchFeedItems</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> feedId)</span> </span>&#123;</span><br><span class="line"> getFeedArticlesUseCase.execute(feedId, <span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">final</span> List&lt;Article&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"> articles)</span> </span>&#123;</span><br><span class="line"> getView().showArticles(viewModelMapper.mapArticlesToViewModels(articles));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="keyword">final</span> Throwable throwable)</span> </span>&#123;</span><br><span class="line"> getView().showErrorMessage();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>到这里可以看出FeedArticlesPresenter实现了Callback接口，并将其自身传递给use case，它实际上是use case的输出端口，并以这种方式关闭了数据流</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/15/16364599d8d3d3ff?w=892&amp;h=472&amp;f=png&amp;s=76180" alt="" title="image.png"></p><p>谷歌架构项目上也有个 <a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean/" target="_blank" rel="noopener">todo-mvp-clean</a>分支可以看下具体玩法。</p><h2 id="5、小结"><a href="#5、小结" class="headerlink" title="5、小结"></a>5、小结</h2><p>这个跟设计模式中依赖倒置和接口隔离有着密不可分的关系，通过依赖倒置，只依赖于抽象而不是细节，将细节的实现倒置到实现类中，这样洋葱的核心就是清清爽爽的业务逻辑（抽象）；</p><p>通常一个良好的架构一般需要满足以下几点：</p><ol><li>Satisfy a multitude of stakeholders.（满足各方利益者）</li><li>Encourage separation of concerns.（鼓励的关注点分离）</li><li>Run away from the real world (Android, DB, Internet…).即高度的抽象</li><li>Enable your components to be testable.（使您的组件成为可测试的）</li></ol><p>但是一个架构往往针对特定的场景，架构也是需要慢慢演进的，比如后面的模块化、插件化等等都是业务发展到一定程度，当前架构的弊端慢慢的凸显需要更新。但不管如何变化，一些核心基本点还是相伴相随，比如依赖翻转、面向接口编程、关注点分离等都是我们需要点亮的技能点之一。</p><p>##参考</p><p>1、<a href="http://five.agency/blog/android/" target="_blank" rel="noopener">http://five.agency/blog/android/</a><br>2、<a href="http://five.agency/android-architecture-part-1-every-new-beginning-is-hard/" target="_blank" rel="noopener">http://five.agency/android-architecture-part-1-every-new-beginning-is-hard/</a><br>3、<a href="http://five.agency/android-architecture-part-2-clean-architecture/" target="_blank" rel="noopener">http://five.agency/android-architecture-part-2-clean-architecture/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;1、clean架构简介&quot;&gt;&lt;a href=&quot;#1、clean架构简介&quot; class=&quot;headerlink&quot; title=&quot;1、clean架构简介&quot;&gt;&lt;/a&gt;1、c
      
    
    </summary>
    
      <category term="架构" scheme="https://xsfelvis.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="clean" scheme="https://xsfelvis.github.io/tags/clean/"/>
    
  </entry>
  
  <entry>
    <title>几个权限库分析</title>
    <link href="https://xsfelvis.github.io/2018/04/21/%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%902%20%E5%87%A0%E4%B8%AA%E6%9D%83%E9%99%90%E5%BA%93%E5%88%86%E6%9E%90/"/>
    <id>https://xsfelvis.github.io/2018/04/21/动态权限2 几个权限库分析/</id>
    <published>2018-04-20T16:00:00.000Z</published>
    <updated>2018-06-06T07:33:00.094Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>权限系列</p><ul><li><a href="https://xsfelvis.github.io/2018/04/06/%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%901/">动态权限基础</a></li><li><a href="https://xsfelvis.github.io/2018/04/21/%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%902%20%E5%87%A0%E4%B8%AA%E6%9D%83%E9%99%90%E5%BA%93%E5%88%86%E6%9E%90/">几个权限库分析</a></li></ul><p>有比较多的权限库,由浅入深先看简单的开开胃</p><h2 id="PermissionGen"><a href="#PermissionGen" class="headerlink" title="PermissionGen"></a>PermissionGen</h2><h3 id="核心源码分析"><a href="#核心源码分析" class="headerlink" title="核心源码分析"></a>核心源码分析</h3><p><a href="https://github.com/lovedise/PermissionGen" target="_blank" rel="noopener">PermissionGen</a>  </p><p>该库比较早 看提交是3年前了 通过看该库的readme可以了解这个库的使用方式，通过链式调用比较易于配置</p><p>核心类图如下：<br><img src="https://user-gold-cdn.xitu.io/2018/5/15/16364446c046e010" alt="" title="image.png"></p><p>将权限涉及到核心api封装到框架之中，干掉冗余函数，使用者只关心功能函数即可。</p><p>涉及到的比较核心的一个点就是，<code>通过注解的方式直接回调权限成功、失败的函数</code></p><p>When it succeeded in obtaining permission</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PermissionSuccess</span>(requestCode = <span class="number">100</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">Toast.makeText(<span class="keyword">this</span>, <span class="string">"Contact permission is granted"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When it failed in obtaining permission</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PermissionFail</span>(requestCode = <span class="number">100</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFailSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">Toast.makeText(<span class="keyword">this</span>, <span class="string">"Contact permission is not granted"</span>, t.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心的处理逻辑在<code>PermissionGen\#requestPermissions\(Object object, int requestCode, String\[\] permissions\)</code>中，最终通过反射调取 PermissionFail和PermissionSucess注解的函数</p><p>通过这种方式干掉了冗余代码，让用户专注于业务的开发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">requestPermissions</span><span class="params">(Object object, <span class="keyword">int</span> requestCode, String[] permissions)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!Utils.isOverMarshmallow()) &#123;</span><br><span class="line">      doExecuteSuccess(object, requestCode);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; deniedPermissions = Utils.findDeniedPermissions(getActivity(object), permissions);</span><br><span class="line">    <span class="keyword">if</span>(deniedPermissions.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(object <span class="keyword">instanceof</span> Activity)&#123;</span><br><span class="line">        ((Activity)object).requestPermissions(deniedPermissions.toArray(<span class="keyword">new</span> String[deniedPermissions.size()]), requestCode);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(object <span class="keyword">instanceof</span> Fragment)&#123;</span><br><span class="line">        ((Fragment)object).requestPermissions(deniedPermissions.toArray(<span class="keyword">new</span> String[deniedPermissions.size()]), requestCode);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(object.getClass().getName() + <span class="string">" is not supported"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      doExecuteSuccess(object, requestCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executeMethod</span><span class="params">(Object activity, Method executeMethod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(executeMethod != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!executeMethod.isAccessible()) executeMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        executeMethod.invoke(activity, <span class="keyword">null</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出反射函数只能无参函数 其中拿到activity或者fragment的注解方法在Utils的方法中，这里可以学习一下反射的一些用法，比如查找对应注解的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;A extends Annotation&gt; <span class="function">Method <span class="title">findMethodWithRequestCode</span><span class="params">(Class clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;A&gt; annotation, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Method method : clazz.getDeclaredMethods())&#123;</span><br><span class="line">      <span class="keyword">if</span>(method.isAnnotationPresent(annotation))&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEqualRequestCodeFromAnntation(method, annotation, requestCode))&#123;</span><br><span class="line">          <span class="keyword">return</span> method;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>这个库比较简单有一些优缺点：<br>优点：初步封装了权限的核心函数的，省去了冗余代码；可以学习反射的一些用法</p><p>缺点：</p><p>（1）大量使用反射（可以使用apt），</p><p>（2）api设计不是很合理</p><p> 链式调用往往是平级调用方法，但是现在这个明显是有先后顺序的，一不留神容易写错</p><h2 id="MPermissions"><a href="#MPermissions" class="headerlink" title="MPermissions"></a>MPermissions</h2><p><a href="https://github.com/hongyangAndroid/MPermissions" target="_blank" rel="noopener">MPermissions</a></p><p>这个是鸿洋在PermissionGen基础上做了一些优化，作者说是使用apt解决了运行时反射的问题，优化了对外提供的api，因为申请只需要三个参数，抛弃了使用原本类库的单例的方式，直接一个几个静态方法，简单整洁暴力。</p><p>看了一下代码，主要是核心类MPermissions操作接口，间接操作实现该接口的APT生成类(依赖翻转，面向接口编程)</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/15/16364446c11d972d" alt="" title="image.png"></p><p>可以学习的一些点：</p><h4 id="2-1-APT-编译前找不到类"><a href="#2-1-APT-编译前找不到类" class="headerlink" title="2.1 APT 编译前找不到类"></a>2.1 APT 编译前找不到类</h4><p>面向接口编程，APT代码生成代码实现这个接口就可以，</p><p>权限类的核心能力通过接口提供</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PermissionProxy</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">grant</span><span class="params">(T source, <span class="keyword">int</span> requestCode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">denied</span><span class="params">(T source, <span class="keyword">int</span> requestCode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rationale</span><span class="params">(T source, <span class="keyword">int</span> requestCode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">needShowRationale</span><span class="params">(<span class="keyword">int</span> requestCode)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>功能类跟接口层交互即可</p><h4 id="2-2-APT技术"><a href="#2-2-APT技术" class="headerlink" title="2.2 APT技术"></a>2.2 APT技术</h4><p>通过APT生成一些重复的模板代码非常有用，关于APT技术在之前的博客多有提及就不再赘述了。<br>不过APT也有它的弊端就是APT 的工作原理是在编译 class 时，通过 Annotation 生成源代码，而在 Android 构建的过程中，像 滴滴出行乘客端 这样的集成方式，所有的模块都是 AAR 的方式来集成构建的，没有机会去同时编译所有的 class，这时候就需要新的手段来生成代码了，比如构建gradle的task在编译前扫描全局结合javapoet生成代码，在这个库里可以学习一下apt processor的异常处理有助于我们定位代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void error(Element element, String message, Object... args) &#123;</span><br><span class="line">    if (args.length &gt; 0) &#123;</span><br><span class="line">        message = String.format(message, args);</span><br><span class="line">    &#125;</span><br><span class="line">    processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, message, element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>作者仅仅是通过APT生成了模板代码，但是还是使用到反射生成实现代理接口的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> PermissionProxy <span class="title">findPermissionProxy</span><span class="params">(Object activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class clazz = activity.getClass();</span><br><span class="line">        Class injectorClazz = Class.forName(clazz.getName() + SUFFIX);</span><br><span class="line">        <span class="keyword">return</span> (PermissionProxy) injectorClazz.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(String.format(<span class="string">"can not find %s , something when compiler."</span>, activity.getClass().getSimpleName() + SUFFIX));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个APT代理的思想还是值得我们去借鉴的</p><h2 id="PermissionsDispatcher"><a href="#PermissionsDispatcher" class="headerlink" title="PermissionsDispatcher"></a>PermissionsDispatcher</h2><p>这个库目前有7726个start，而且有自己的<a href="https://permissions-dispatcher.github.io/PermissionsDispatcher/" target="_blank" rel="noopener">网站</a>指导说明，俨然是动态权限三方库的一哥，看来这个库需要好好分析一下</p><p>从官方这个库使用起来也非常简单，仔细看了下代码发现大同小异，跟前面两个库使用的方式很像，通过注解的方式标记 权限申请成功、权限事情失败、权限弹窗说明等函数调用，唯一多的是：</p><p>1、需要使用动态权的 <code>Activity</code> or <code>Fragment</code>(we support both) to handle permissions加上RuntimePermissions注解</p><p>这个库更多是将所有的逻辑处理放在了权限生成类 xxxPermissionDispatcher类，（生成代码承担了很多的逻辑处理）而不像MPermission库中仅仅将用户使用的功能代码，比如权限成功、失败之类的函数规整到生成类中，核心逻辑还是通过开发者自己代码处理，这样更容易写这个库，用户阅读代码也比较方便</p><p>个人更加倾向于 MPermission</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;权限系列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://xsfelvis.github.io/2018/04/06/%E5%8A%A8%E6%80%81%E6%
      
    
    </summary>
    
      <category term="开源学习" scheme="https://xsfelvis.github.io/categories/%E5%BC%80%E6%BA%90%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="权限" scheme="https://xsfelvis.github.io/tags/%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>动态权限</title>
    <link href="https://xsfelvis.github.io/2018/04/06/%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%901/"/>
    <id>https://xsfelvis.github.io/2018/04/06/动态权限1/</id>
    <published>2018-04-05T16:00:00.000Z</published>
    <updated>2018-06-05T09:53:56.166Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>权限系列</p><ul><li><a href="https://xsfelvis.github.io/2018/04/06/%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%901/">动态权限基础</a></li><li><a href="https://xsfelvis.github.io/2018/04/21/%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%902%20%E5%87%A0%E4%B8%AA%E6%9D%83%E9%99%90%E5%BA%93%E5%88%86%E6%9E%90/">几个权限库分析</a></li></ul><h2 id="1、在给app升级动态权限之前需要注意搞清楚一下几个概念"><a href="#1、在给app升级动态权限之前需要注意搞清楚一下几个概念" class="headerlink" title="1、在给app升级动态权限之前需要注意搞清楚一下几个概念"></a>1、在给app升级动态权限之前需要注意搞清楚一下几个概念</h2><h3 id="1-1、版本号对应的api等级"><a href="#1-1、版本号对应的api等级" class="headerlink" title="1.1、版本号对应的api等级"></a>1.1、版本号对应的api等级</h3><p>查阅官网可以看出</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/15/16364387f6eeb9fc?w=1714&amp;h=1262&amp;f=png&amp;s=192923" alt=""></p><h3 id="1-2、minSdkVersion、targetSdkVersion和-compileSdkVersion"><a href="#1-2、minSdkVersion、targetSdkVersion和-compileSdkVersion" class="headerlink" title="1.2、minSdkVersion、targetSdkVersion和 compileSdkVersion"></a>1.2、minSdkVersion、targetSdkVersion和 compileSdkVersion</h3><p>这几个属性通常在gradle defaultConfig中去配置，作用如下</p><p>（1）minSdkVersion<br>指明应用程序运行所需的最小API level，如果系统的API level低于minSdkVersion设定的值，那么android系统会阻止用户安装这个应用，如果不指明的话，默认是1，如果指明这个属性，并在项目中使用了改与这个API level的API的话，那么将会在编译时报错。<br>可见该属性不仅在程序安装时起作用，而且会在项目构建时起作用</p><p>（2）targetSdkVersion</p><p>指明应用程序目标API level的一个整数，如果不设置就默认和minSdkVersion相同。这个属性通知系统，已经针对这个目标版本测试过程序，系统不必使用兼容模式来让你的应用程序向前兼容这个目标版本。<br>如果targetSdkVersion为19（对应为Android4.4），应用运行时，最高只能使用API 19的新特性。即使代码中使用了API 23的新特性，实际运行时，也不会使用该新特性；<br>可见targetSdkVersion这个属性是在程序运行时期起作用的，系统根据这个属性决定要不要以兼容模式运行这个程序<br>例如，Android6.0系统增加了动态权限机制，如果为了追时髦，盲目把你的targetSDKVersion设置为23(6.0)，那么在需要使用权限的地方将会出现异常。为此，在你做好动态权限申请之前，为保障APP正常运行，你需要将目标版本设置低于23。</p><p>（3）complieSdkVersion</p><p>compileSdkVersion仅仅是告诉Gradle使用哪个版本的SDK编译应用，不会被包含到apk中，完全不影响应用的运行结果；虽然没有影响但是</p><p>即 ：compileSDKVersion是和编译器打交道的，而minSDKVersion和targetSDKVersion是和系统打交道的。</p><h2 id="2、如何升级app的动态权限"><a href="#2、如何升级app的动态权限" class="headerlink" title="2、如何升级app的动态权限"></a>2、如何升级app的动态权限</h2><p>首先需要了解动态权限这个概念</p><h3 id="2-1-动态权限"><a href="#2-1-动态权限" class="headerlink" title="2.1 动态权限"></a>2.1 动态权限</h3><p>这个是在android 6.0提出的，从该版本开始，用户实在运行时而不是应用安装时授予或者撤销应用权限，对应API23,这个版本最重要的变化就是权限动态管理，任何未被授予权限的逻辑都可能引起后续运行的崩溃，可以通过adb 工具从命令行获取权限</p><p>按组列出权限和状态： </p><blockquote><p>$ adb shell pm list permissions -d -g</p></blockquote><p>授予或撤销一项或多项权限：</p><blockquote><p>$ adb shell pm [grant|revoke] <permission-name> …</permission-name></p></blockquote><p>6.0之前的权限在AndroidMenifest声明之后即可获取所有权限，这样会造成用户会默默忍受一些不必要的权限，特别是通讯录，位置短信之类的比较敏感的权限，在6.0之后我们只有在需要权限的时候才会向用户请求，用户可以选择拒绝，新的机制较好的保护的用户的隐私。<br>谷歌将权限分为两大类<br>Normal Permissions<br>这类权限一般不涉及用户隐私是不需要用户进行授权的，比如网络访问、蓝牙（详细权限见附录）<br>Dangenerous Permission<br>这类涉及到用户隐私，需要用户进行授权，比如读取sdcard、开启照相机、访问通讯录等，其中危险权限是分组的，用户之前如果已经选择通过该组某个危险权限，主要有以下几组（详细权限见附录）</p><ol><li>身体传感器</li><li>日历 摄像头</li><li>通讯录</li><li>地理位置</li><li>麦克风</li><li>电话</li><li>短信</li><li>存储空间  </li></ol><h3 id="2-2-权限相关API"><a href="#2-2-权限相关API" class="headerlink" title="2.2 权限相关API"></a>2.2 权限相关API</h3><p>为了方便开发者实现权限管理，谷歌给出下面4个API</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/15/1636438febbcbeb9?w=894&amp;h=494&amp;f=png&amp;s=66186" alt=""></p><p>一般权限检查需要以下三个步骤配合</p><p>1、检查权限是否授予</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Activity.java</span><br><span class="line">&gt; public int checkSelfPermission(permission)</span><br></pre></td></tr></table></figure><p>这个是在ContextCompat类中用来判断是否app已经获取到某一个权限的使用权。如果返回android.content.pm.PackageManager#PERMISSION_GRANTED，则说明app被授予权限，如果返回android.content.pm.PackageManager#PERMISSION_DENIED 则说明权限被禁止授予</p><p>2、申请权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Activity.java</span><br><span class="line">public final void requestPermissions( new String[permission1,permission2,...], requestCode)</span><br></pre></td></tr></table></figure><p>这个是在ActivityCompat类以及FragmentCompat类中用来申请权限的方法</p><p>3、权限回调<br>用户在系统弹窗里面选择以后结果会通过Activity的onRequestPermissionsResult<br>方法回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults)</span><br><span class="line">&#123;</span><br><span class="line">    //继续执行逻辑或者提示权限获取失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些方法可以封装在BaseActvity中</p><p>4、是否显示权限对话框<br>这个是作为辅助类</p><blockquote><p>public static boolean shouldShowRequestPermissionRationale(@NonNull Activity activity, @NonNull String permission)<br>这个是在ActivityCompat类以及FragmentCompat类中用来判断是否显示权限询问对话框。在权限申请的过程中，如果用户选择允许权限使用或者在拒绝的同时又勾选了不再询问对话框，这2种情况下该api就会返回false，表示不再弹出权限询问对话框，其中授权弹窗是不支持自定义的</p></blockquote><p>这个辅助函数十分重要，当动态权限申请时候如果用户如果用户勾选了“不再询问”，那么在执行requestPermissions( )后，onRequestPermissionsResult( )会永远返回PERMISSION_DENIED，这样应用原本的操作将永远无法执行，这是我们不希望看到的</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/15/163643a25ce67cd9?w=1010&amp;h=766&amp;f=png&amp;s=122723" alt=""><br>谷歌还是给我们留了一手，就是<br>shouldShowRequestPermissionRationale，如果返回true，应用应该弹出dialog说明申请权限的缘由比如下面这种</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/15/163643a66ad3eb69?w=1100&amp;h=522&amp;f=png&amp;s=49564" alt=""></p><p>其中第一次申请权限时候该函数默认返回false，无需告知用户申请该权限的理由;当第一次申请被拒绝，再次申请时该函数会返回true，并且弹出的系统dialog上会有一个选择“不再询问”，要是用户勾选了该选项，则以后该函数一直会返回false。</p><h3 id="2-3-如何适配"><a href="#2-3-如何适配" class="headerlink" title="2.3 如何适配"></a>2.3 如何适配</h3><p>如果项目的targetSdkVersion &lt; 23 运行在android 6.0及以上的系统上，会默认给与AndroidManifest.xml中申请的权限，是不是这样就万事大吉了呢？显然是想多了，如果用户在应用的权限页面手动回收权限，将会导致应用crash</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/15/163643b31c161434?w=1064&amp;h=1200&amp;f=png&amp;s=235446" alt=""></p><p>虽然系统提醒了用户，但是还是要取决用户心情，因此稳妥的适配动态还是有必要的事情。</p><p>首先targetSdkVersion小于23的应用默认授予了所申请的所有权限，所以如果你以前的APP设置的targetSdkVersion低于23，也能正常使用。等于或者大于23，则必须 request permission,否则会崩溃闪退。<br>下面将大致阐述一下升级动态权限步骤</p><p>（1）声明目标版本sdk<br>修改build.gradle中targetSdkVersion为23以上</p><p>（2）检查权限申请地方并request权限<br>在我们需要使用到权限的地方，检查是否已经拥有权限，比如读写外置SD卡权限，我们在写入之前检车是否有权限，没有权限则申请权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void requestContactPermission() &#123;</span><br><span class="line">        if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_CONTACTS)</span><br><span class="line">                != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            //申请 WRITE_CONTACTS 权限</span><br><span class="line">            ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.WRITE_CONTACTS&#125;,</span><br><span class="line">                    REQUEST_CODE_WRITE_CONTACTS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"> ```  </span><br><span class="line"></span><br><span class="line">（3）响应用户权限回调</span><br><span class="line"></span><br><span class="line">用户可以选择allow或者deny，可能deny。回调onRequestPermissionsResult方法, 该方法类似于onActivityResult。如果是fragment，最好是使用父fragment，但不是使用ActivityCompat。建议使用getParentFragment().requestPermissions方法。  </span><br><span class="line"></span><br><span class="line">（4）根据requestCode和grandResult（授权结果）做相应处理</span><br></pre></td></tr></table></figure><p>private void handleGrantResults(int requestCode, int[] grantResults) {<br>      if (requestCode == WRITE_EXTERNAL_STORAGE_REQUEST_CODE) {<br>          if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {<br>              // Permission Granted 获得权限后执行xxx<br>          } else {<br>              // Permission Denied 拒绝后xx的操作。<br>          }<br>      }<br>  }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 3、后话</span><br><span class="line"></span><br><span class="line">### 3.1、权限申请如果用户拒绝怎么处理</span><br><span class="line">如果用户拒绝了核心权限一次，下次再次申请会出现不再提醒的选项，要是选择不再提醒，核心权限不给获取一些功能就无法使用，你可以选择直接退出应用，或者可以优雅点，我们自己检测一下是否拒绝了两次或者以上，自己给个提示向用户做一个交互</span><br></pre></td></tr></table></figure></p><p>private void handleContactPermission() {<br>        if (Integer.parseInt(Build.VERSION.SDK)&gt;=23) {<br>            int hasWriteContactsPermission = checkSelfPermission(Manifest.permission.WRITE_CONTACTS);<br>            if (hasWriteContactsPermission != PackageManager.PERMISSION_GRANTED) {<br>                if (!shouldShowRequestPermissionRationale(Manifest.permission.WRITE_CONTACTS)) {<br>                    showMessageOKCancel(“You need to allow access to Contacts”,<br>                            new DialogInterface.OnClickListener() {<br>                                @Override<br>                                public void onClick(DialogInterface dialog, int which) {<br>                                    requestContactPermission();//确定后申请权限。<br>                                }<br>                            });<br>                    return;<br>                }<br>                requestContactPermission();//没有权限的话，申请。<br>            }<br>        }<br>```<br>或者记录用户勾选了不再询问<br>Google提供了一个非常好的思路，详见EasyPermissions .<br>EasyPermissions并没有存储上一次shouldShowRequestPermissionRationale( )的返回值，而是在申请权限被拒后调用shouldShowRequestPermissionRationale( )方法，如果此时返回false则说明用户勾选了“不再询问”。</p><p>两种方式都可以作为参考方式。</p><h3 id="3-2-取消支持Apache-http-客户端"><a href="#3-2-取消支持Apache-http-客户端" class="headerlink" title="3.2 取消支持Apache http 客户端"></a>3.2 取消支持Apache http 客户端</h3><p>Android 6.0 版移除了对 Apache HTTP 客户端的支持。如果您的应用使用该客户端，并以 Android 2.3（API 级别 9）或更高版本为目标平台，请改用HttpURLConnection 类。此 API 效率更高，因为它可以通过透明压缩和响应缓存减少网络使用，并可最大限度降低耗电量。要继续使用 Apache HTTP API，您必须先在 build.gradle 文件中声明以下编译时依赖项：<br>  android {<br>      useLibrary ‘org.apache.http.legacy’<br>  }</p><h3 id="3-3-升级到7-0-api-24及以上"><a href="#3-3-升级到7-0-api-24及以上" class="headerlink" title="3.3 升级到7.0 api 24及以上"></a>3.3 升级到7.0 api 24及以上</h3><p>对于面向 Android 7.0 的应用，Android 框架执行的 StrictMode API 政策禁止在您的应用外部公开 file:// URI。如果一项包含文件 URI 的 intent 离开您的应用，则应用出现故障，并出现 FileUriExposedException 异常，常见的是访问升级下载到内部sd卡，访问手机相册等。<br>网上有很多解决方案</p><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote><p>Normal Permissions</p></blockquote><p>ACCESS_LOCATION_EXTRA_COMMANDS</p><p>ACCESS_NETWORK_STATE</p><p>ACCESS_NOTIFICATION_POLICY</p><p>ACCESS_WIFI_STATE</p><p>BLUETOOTH</p><p>BLUETOOTH_ADMIN</p><p>BROADCAST_STICKY</p><p>CHANGE_NETWORK_STATE</p><p>CHANGE_WIFI_MULTICAST_STATE</p><p>CHANGE_WIFI_STATE</p><p>DISABLE_KEYGUARD</p><p>EXPAND_STATUS_BAR</p><p>GET_PACKAGE_SIZE</p><p>INSTALL_SHORTCUT</p><p>INTERNET</p><p>KILL_BACKGROUND_PROCESSES</p><p>MODIFY_AUDIO_SETTINGS</p><p>NFC</p><p>READ_SYNC_SETTINGS</p><p>READ_SYNC_STATS</p><p>RECEIVE_BOOT_COMPLETED</p><p>REORDER_TASKS</p><p>REQUEST_INSTALL_PACKAGES</p><p>SET_ALARM</p><p>SET_TIME_ZONE</p><p>SET_WALLPAPER</p><p>SET_WALLPAPER_HINTS</p><p>TRANSMIT_IR</p><p>UNINSTALL_SHORTCUT</p><p>USE_FINGERPRINT</p><p>VIBRATE</p><p>WAKE_LOCK</p><p>WRITE_SYNC_SETTINGS</p><blockquote><p>Dangenerous Permission</p></blockquote><p>group:android.permission-group.CONTACTS<br>  permission:android.permission.WRITE_CONTACTS<br>  permission:android.permission.GET_ACCOUNTS<br>  permission:android.permission.READ_CONTACTS</p><p>group:android.permission-group.PHONE<br>  permission:android.permission.READ_CALL_LOG<br>  permission:android.permission.READ_PHONE_STATE<br>  permission:android.permission.CALL_PHONE<br>  permission:android.permission.WRITE_CALL_LOG<br>  permission:android.permission.USE_SIP<br>  permission:android.permission.PROCESS_OUTGOING_CALLS<br>  permission:com.android.voicemail.permission.ADD_VOICEMAIL</p><p>group:android.permission-group.CALENDAR<br>  permission:android.permission.READ_CALENDAR<br>  permission:android.permission.WRITE_CALENDAR</p><p>group:android.permission-group.CAMERA<br>  permission:android.permission.CAMERA</p><p>group:android.permission-group.SENSORS<br>  permission:android.permission.BODY_SENSORS</p><p>group:android.permission-group.LOCATION<br>  permission:android.permission.ACCESS_FINE_LOCATION<br>  permission:android.permission.ACCESS_COARSE_LOCATION</p><p>group:android.permission-group.STORAGE<br>  permission:android.permission.READ_EXTERNAL_STORAGE<br>  permission:android.permission.WRITE_EXTERNAL_STORAGE</p><p>group:android.permission-group.MICROPHONE<br>  permission:android.permission.RECORD_AUDIO</p><p>group:android.permission-group.SMS<br>  permission:android.permission.READ_SMS<br>  permission:android.permission.RECEIVE_WAP_PUSH<br>  permission:android.permission.RECEIVE_MMS<br>  permission:android.permission.RECEIVE_SMS<br>  permission:android.permission.SEND_SMS<br>  permission:android.permission.READ_CELL_BROADCASTS</p><p>###参考链接</p><ul><li>1、<a href="https://source.android.com/source/build-numbers" target="_blank" rel="noopener">https://source.android.com/source/build-numbers</a> </li><li>2、<a href="https://www.jianshu.com/p/06e55a322f6f" target="_blank" rel="noopener">https://www.jianshu.com/p/06e55a322f6f</a></li><li>3、<a href="https://developer.android.com/about/versions/marshmallow/android-6.0-changes?hl=zh-cn" target="_blank" rel="noopener">Android 6.0变更</a></li><li>4、<a href="https://developer.android.com/about/versions/marshmallow/android-6.0-changes?hl=zh-cn#behavior-runtime-permissions" target="_blank" rel="noopener">运行时权限</a> </li><li>5、<a href="developer.android.com/intl/zh-cn/training/permissions/best-practices.html#testing">Permissions Best Practices</a></li><li>6、<a href="developer.android.com/intl/zh-cn/training/permissions/index.html">Working with System Permissions</a></li><li>7、<a href="https://blog.csdn.net/andrexpert/article/details/53331836" target="_blank" rel="noopener">探讨Android 6.0及以上新权限系统的检测与处理</a></li><li>8、<a href="https://mp.weixin.qq.com/s/ye7RTgPuIbBS4RCH-jDWAA" target="_blank" rel="noopener">Android 权限机制与适配经验</a></li><li>9、<a href="https://blog.csdn.net/dzsw0117/article/details/51212612" target="_blank" rel="noopener">Android 6.0权限管理，sdk&gt;=23请求权限</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;权限系列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://xsfelvis.github.io/2018/04/06/%E5%8A%A8%E6%80%81%E6%
      
    
    </summary>
    
      <category term="Android" scheme="https://xsfelvis.github.io/categories/Android/"/>
    
    
      <category term="权限" scheme="https://xsfelvis.github.io/tags/%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
</feed>
